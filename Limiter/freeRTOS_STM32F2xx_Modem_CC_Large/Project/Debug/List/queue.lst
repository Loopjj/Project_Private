###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:18
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\queue.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\queue.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\queue.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\queue.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\queue.c
      1          /*
      2              FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          #include <stdlib.h>
     67          #include <string.h>
     68          
     69          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     70          all the API functions to use the MPU wrappers.  That should only be done when
     71          task.h is included from an application file. */
     72          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     73          
     74          #include "FreeRTOS.h"
     75          #include "task.h"
     76          #include "queue.h"
     77          
     78          #if ( configUSE_CO_ROUTINES == 1 )
     79          	#include "croutine.h"
     80          #endif
     81          
     82          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     83          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     84          header files above, but not in this file, in order to generate the correct
     85          privileged Vs unprivileged linkage and placement. */
     86          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     87          
     88          
     89          /* Constants used with the cRxLock and xTxLock structure members. */
     90          #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
     91          #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
     92          
     93          /* When the xQUEUE structure is used to represent a base queue its pcHead and
     94          pcTail members are used as pointers into the queue storage area.  When the
     95          xQUEUE structure is used to represent a mutex pcHead and pcTail pointers are
     96          not necessary, and the pcHead pointer is set to NULL to indicate that the
     97          pcTail pointer actually points to the mutex holder (if any).  Map alternative
     98          names to the pcHead and pcTail structure members to ensure the readability of
     99          the code is maintained despite this dual use of two structure members.  An
    100          alternative implementation would be to use a union, but use of a union is
    101          against the coding standard (although an exception to the standard has been
    102          permitted where the dual use also significantly changes the type of the
    103          structure member). */
    104          #define pxMutexHolder					pcTail
    105          #define uxQueueType						pcHead
    106          #define queueQUEUE_IS_MUTEX				NULL
    107          
    108          /* Semaphores do not actually store or copy data, so have an item size of
    109          zero. */
    110          #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
    111          #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
    112          
    113          #if( configUSE_PREEMPTION == 0 )
    114          	/* If the cooperative scheduler is being used then a yield should not be
    115          	performed just because a higher priority task has been woken. */
    116          	#define queueYIELD_IF_USING_PREEMPTION()
    117          #else
    118          	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    119          #endif
    120          
    121          /*
    122           * Definition of the queue used by the scheduler.
    123           * Items are queued by copy, not reference.
    124           */
    125          typedef struct QueueDefinition
    126          {
    127          	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
    128          	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
    129          
    130          	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
    131          
    132          	union									/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
    133          	{
    134          		signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
    135          		unsigned portBASE_TYPE uxRecursiveCallCount;/*< Maintains a count of the numebr of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
    136          	} u;
    137          
    138          	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
    139          	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
    140          
    141          	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. */
    142          	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
    143          	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
    144          
    145          	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    146          	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    147          
    148          	#if ( configUSE_TRACE_FACILITY == 1 )
    149          		unsigned char ucQueueNumber;
    150          		unsigned char ucQueueType;
    151          	#endif
    152          
    153          	#if ( configUSE_QUEUE_SETS == 1 )
    154          		struct QueueDefinition *pxQueueSetContainer;
    155          	#endif
    156          
    157          } xQUEUE;
    158          /*-----------------------------------------------------------*/
    159          
    160          /*
    161           * The queue registry is just a means for kernel aware debuggers to locate
    162           * queue structures.  It has no other purpose so is an optional component.
    163           */
    164          #if ( configQUEUE_REGISTRY_SIZE > 0 )
    165          
    166          	/* The type stored within the queue registry array.  This allows a name
    167          	to be assigned to each queue making kernel aware debugging a little
    168          	more user friendly. */
    169          	typedef struct QUEUE_REGISTRY_ITEM
    170          	{
    171          		signed char *pcQueueName;
    172          		xQueueHandle xHandle;
    173          	} xQueueRegistryItem;
    174          
    175          	/* The queue registry is simply an array of xQueueRegistryItem structures.
    176          	The pcQueueName member of a structure being NULL is indicative of the
    177          	array position being vacant. */
    178          	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
    179          
    180          #endif /* configQUEUE_REGISTRY_SIZE */
    181          
    182          /*
    183           * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
    184           * prevent an ISR from adding or removing items to the queue, but does prevent
    185           * an ISR from removing tasks from the queue event lists.  If an ISR finds a
    186           * queue is locked it will instead increment the appropriate queue lock count
    187           * to indicate that a task may require unblocking.  When the queue in unlocked
    188           * these lock counts are inspected, and the appropriate action taken.
    189           */
    190          static void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
    191          
    192          /*
    193           * Uses a critical section to determine if there is any data in a queue.
    194           *
    195           * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
    196           */
    197          static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
    198          
    199          /*
    200           * Uses a critical section to determine if there is any space in a queue.
    201           *
    202           * @return pdTRUE if there is no space, otherwise pdFALSE;
    203           */
    204          static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
    205          
    206          /*
    207           * Copies an item into the queue, either at the front of the queue or the
    208           * back of the queue.
    209           */
    210          static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition ) PRIVILEGED_FUNCTION;
    211          
    212          /*
    213           * Copies an item out of a queue.
    214           */
    215          static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
    216          
    217          #if ( configUSE_QUEUE_SETS == 1 )
    218          	/*
    219          	 * Checks to see if a queue is a member of a queue set, and if so, notifies
    220          	 * the queue set that the queue contains data.
    221          	 */
    222          	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
    223          #endif
    224          
    225          /*-----------------------------------------------------------*/
    226          
    227          /*
    228           * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
    229           * accessing the queue event lists.
    230           */
    231          #define prvLockQueue( pxQueue )								\
    232          	taskENTER_CRITICAL();									\
    233          	{														\
    234          		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
    235          		{													\
    236          			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
    237          		}													\
    238          		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
    239          		{													\
    240          			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
    241          		}													\
    242          	}														\
    243          	taskEXIT_CRITICAL()
    244          /*-----------------------------------------------------------*/
    245          

   \                                 In section .text, align 2, keep-with-next
    246          portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
    247          {
   \                     xQueueGenericReset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    248          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    249          
    250          	configASSERT( pxQueue );
    251          
    252          	taskENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
    253          	{
    254          		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6BE1             LDR      R1,[R4, #+60]
   \   0000000E   0x6C22             LDR      R2,[R4, #+64]
   \   00000010   0x4351             MULS     R1,R2,R1
   \   00000012   0x4408             ADD      R0,R0,R1
   \   00000014   0x6060             STR      R0,[R4, #+4]
    255          		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x63A0             STR      R0,[R4, #+56]
    256          		pxQueue->pcWriteTo = pxQueue->pcHead;
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
    257          		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6BE1             LDR      R1,[R4, #+60]
   \   00000022   0x1E49             SUBS     R1,R1,#+1
   \   00000024   0x6C22             LDR      R2,[R4, #+64]
   \   00000026   0x4351             MULS     R1,R2,R1
   \   00000028   0x4408             ADD      R0,R0,R1
   \   0000002A   0x60E0             STR      R0,[R4, #+12]
    258          		pxQueue->xRxLock = queueUNLOCKED;
   \   0000002C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000030   0x6460             STR      R0,[R4, #+68]
    259          		pxQueue->xTxLock = queueUNLOCKED;
   \   00000032   0x64A0             STR      R0,[R4, #+72]
    260          
    261          		if( xNewQueue == pdFALSE )
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD10B             BNE.N    ??xQueueGenericReset_0
    262          		{
    263          			/* If there are tasks blocked waiting to read from the queue, then
    264          			the tasks will remain blocked as after this function exits the queue
    265          			will still be empty.  If there are tasks blocked waiting to write to
    266          			the queue, then one should be unblocked as after this function exits
    267          			it will be possible to write to it. */
    268          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD010             BEQ.N    ??xQueueGenericReset_1
    269          			{
    270          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   \   0000003E   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000042   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD10A             BNE.N    ??xQueueGenericReset_1
    271          				{
    272          					queueYIELD_IF_USING_PREEMPTION();
   \   0000004A   0x.... 0x....      BL       vPortYield
   \   0000004E   0xE007             B.N      ??xQueueGenericReset_1
    273          				}
    274          			}
    275          		}
    276          		else
    277          		{
    278          			/* Ensure the event queues start in the correct state. */
    279          			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   \                     ??xQueueGenericReset_0: (+1)
   \   00000050   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000054   0x.... 0x....      BL       vListInitialise
    280          			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   \   00000058   0xF104 0x0024      ADD      R0,R4,#+36
   \   0000005C   0x.... 0x....      BL       vListInitialise
    281          		}
    282          	}
    283          	taskEXIT_CRITICAL();
   \                     ??xQueueGenericReset_1: (+1)
   \   00000060   0x.... 0x....      BL       vPortExitCritical
    284          
    285          	/* A value is returned for calling semantic consistency with previous
    286          	versions. */
    287          	return pdPASS;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    288          }
    289          /*-----------------------------------------------------------*/
    290          

   \                                 In section .text, align 2, keep-with-next
    291          xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
    292          {
   \                     xQueueGenericCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    293          xQUEUE *pxNewQueue;
    294          size_t xQueueSizeInBytes;
    295          xQueueHandle xReturn = NULL;
   \   0000000A   0x2700             MOVS     R7,#+0
    296          
    297          	/* Remove compiler warnings about unused parameters should
    298          	configUSE_TRACE_FACILITY not be set to 1. */
    299          	( void ) ucQueueType;
    300          
    301          	/* Allocate the new queue structure. */
    302          	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD01E             BEQ.N    ??xQueueGenericCreate_0
    303          	{
    304          		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   \   00000010   0x2050             MOVS     R0,#+80
   \   00000012   0x.... 0x....      BL       pvPortMalloc
   \   00000016   0x4680             MOV      R8,R0
    305          		if( pxNewQueue != NULL )
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD017             BEQ.N    ??xQueueGenericCreate_0
    306          		{
    307          			/* Create the list of pointers to queue items.  The queue is one byte
    308          			longer than asked for to make wrap checking easier/faster. */
    309          			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    310          
    311          			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
   \   0000001E   0xFB05 0xF004      MUL      R0,R5,R4
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x.... 0x....      BL       pvPortMalloc
   \   00000028   0xF8C8 0x0000      STR      R0,[R8, #+0]
    312          			if( pxNewQueue->pcHead != NULL )
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00B             BEQ.N    ??xQueueGenericCreate_1
    313          			{
    314          				/* Initialise the queue members as described above where the
    315          				queue type is defined. */
    316          				pxNewQueue->uxLength = uxQueueLength;
   \   00000030   0xF8C8 0x403C      STR      R4,[R8, #+60]
    317          				pxNewQueue->uxItemSize = uxItemSize;
   \   00000034   0xF8C8 0x5040      STR      R5,[R8, #+64]
    318          				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       xQueueGenericReset
    319          
    320          				#if ( configUSE_TRACE_FACILITY == 1 )
    321          				{
    322          					pxNewQueue->ucQueueType = ucQueueType;
   \   00000040   0xF888 0x604D      STRB     R6,[R8, #+77]
    323          				}
    324          				#endif /* configUSE_TRACE_FACILITY */
    325          
    326          				#if( configUSE_QUEUE_SETS == 1 )
    327          				{
    328          					pxNewQueue->pxQueueSetContainer = NULL;
    329          				}
    330          				#endif /* configUSE_QUEUE_SETS */
    331          
    332          				traceQUEUE_CREATE( pxNewQueue );
    333          				xReturn = pxNewQueue;
   \   00000044   0x4647             MOV      R7,R8
   \   00000046   0xE002             B.N      ??xQueueGenericCreate_0
    334          			}
    335          			else
    336          			{
    337          				traceQUEUE_CREATE_FAILED( ucQueueType );
    338          				vPortFree( pxNewQueue );
   \                     ??xQueueGenericCreate_1: (+1)
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       vPortFree
    339          			}
    340          		}
    341          	}
    342          
    343          	configASSERT( xReturn );
    344          
    345          	return xReturn;
   \                     ??xQueueGenericCreate_0: (+1)
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    346          }
    347          /*-----------------------------------------------------------*/
    348          
    349          #if ( configUSE_MUTEXES == 1 )
    350          

   \                                 In section .text, align 2, keep-with-next
    351          	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
    352          	{
   \                     xQueueCreateMutex: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    353          	xQUEUE *pxNewQueue;
    354          
    355          		/* Prevent compiler warnings about unused parameters if
    356          		configUSE_TRACE_FACILITY does not equal 1. */
    357          		( void ) ucQueueType;
    358          
    359          		/* Allocate the new queue structure. */
    360          		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       pvPortMalloc
   \   0000000A   0x0005             MOVS     R5,R0
    361          		if( pxNewQueue != NULL )
   \   0000000C   0xD01D             BEQ.N    ??xQueueCreateMutex_0
    362          		{
    363          			/* Information required for priority inheritance. */
    364          			pxNewQueue->pxMutexHolder = NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6068             STR      R0,[R5, #+4]
    365          			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   \   00000012   0x6028             STR      R0,[R5, #+0]
    366          
    367          			/* Queues used as a mutex no data is actually copied into or out
    368          			of the queue. */
    369          			pxNewQueue->pcWriteTo = NULL;
   \   00000014   0x60A8             STR      R0,[R5, #+8]
    370          			pxNewQueue->u.pcReadFrom = NULL;
   \   00000016   0x60E8             STR      R0,[R5, #+12]
    371          
    372          			/* Each mutex has a length of 1 (like a binary semaphore) and
    373          			an item size of 0 as nothing is actually copied into or out
    374          			of the mutex. */
    375          			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   \   00000018   0x63A8             STR      R0,[R5, #+56]
    376          			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x63E8             STR      R0,[R5, #+60]
    377          			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6428             STR      R0,[R5, #+64]
    378          			pxNewQueue->xRxLock = queueUNLOCKED;
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0x6468             STR      R0,[R5, #+68]
    379          			pxNewQueue->xTxLock = queueUNLOCKED;
   \   00000028   0x64A8             STR      R0,[R5, #+72]
    380          
    381          			#if ( configUSE_TRACE_FACILITY == 1 )
    382          			{
    383          				pxNewQueue->ucQueueType = ucQueueType;
   \   0000002A   0xF885 0x404D      STRB     R4,[R5, #+77]
    384          			}
    385          			#endif
    386          
    387          			#if ( configUSE_QUEUE_SETS == 1 )
    388          			{
    389          				pxNewQueue->pxQueueSetContainer = NULL;
    390          			}
    391          			#endif
    392          
    393          			/* Ensure the event queues start with the correct state. */
    394          			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
   \   0000002E   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000032   0x.... 0x....      BL       vListInitialise
    395          			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
   \   00000036   0xF105 0x0024      ADD      R0,R5,#+36
   \   0000003A   0x.... 0x....      BL       vListInitialise
    396          
    397          			traceCREATE_MUTEX( pxNewQueue );
    398          
    399          			/* Start with the semaphore in the expected state. */
    400          			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x461A             MOV      R2,R3
   \   00000042   0x4611             MOV      R1,R2
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       xQueueGenericSend
    401          		}
    402          		else
    403          		{
    404          			traceCREATE_MUTEX_FAILED();
    405          		}
    406          
    407          		configASSERT( pxNewQueue );
    408          		return pxNewQueue;
   \                     ??xQueueCreateMutex_0: (+1)
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    409          	}
    410          
    411          #endif /* configUSE_MUTEXES */
    412          /*-----------------------------------------------------------*/
    413          
    414          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    415          
    416          	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
    417          	{
    418          	void *pxReturn;
    419          
    420          		/* This function is called by xSemaphoreGetMutexHolder(), and should not
    421          		be called directly.  Note:  This is is a good way of determining if the
    422          		calling task is the mutex holder, but not a good way of determining the
    423          		identity of the mutex holder, as the holder may change between the
    424          		following critical section exiting and the function returning. */
    425          		taskENTER_CRITICAL();
    426          		{
    427          			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
    428          			{
    429          				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
    430          			}
    431          			else
    432          			{
    433          				pxReturn = NULL;
    434          			}
    435          		}
    436          		taskEXIT_CRITICAL();
    437          
    438          		return pxReturn;
    439          	}
    440          
    441          #endif
    442          /*-----------------------------------------------------------*/
    443          
    444          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    445          

   \                                 In section .text, align 2, keep-with-next
    446          	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
    447          	{
   \                     xQueueGiveMutexRecursive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    448          	portBASE_TYPE xReturn;
    449          	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
    450          
    451          		configASSERT( pxMutex );
    452          
    453          		/* If this is the task that holds the mutex then pxMutexHolder will not
    454          		change outside of this task.  If this task does not hold the mutex then
    455          		pxMutexHolder can never coincidentally equal the tasks handle, and as
    456          		this is the only condition we are interested in it does not matter if
    457          		pxMutexHolder is accessed simultaneously by another task.  Therefore no
    458          		mutual exclusion is required to test the pxMutexHolder variable. */
    459          		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as xTaskHandle is a typedef. */
   \   00000004   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   00000008   0x6861             LDR      R1,[R4, #+4]
   \   0000000A   0x4281             CMP      R1,R0
   \   0000000C   0xD10B             BNE.N    ??xQueueGiveMutexRecursive_0
    460          		{
    461          			traceGIVE_MUTEX_RECURSIVE( pxMutex );
    462          
    463          			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
    464          			the task handle, therefore no underflow check is required.  Also,
    465          			uxRecursiveCallCount is only modified by the mutex holder, and as
    466          			there can only be one, no mutual exclusion is required to modify the
    467          			uxRecursiveCallCount member. */
    468          			( pxMutex->u.uxRecursiveCallCount )--;
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x60E0             STR      R0,[R4, #+12]
    469          
    470          			/* Have we unwound the call count? */
    471          			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
   \   00000014   0xD105             BNE.N    ??xQueueGiveMutexRecursive_1
    472          			{
    473          				/* Return the mutex.  This will automatically unblock any other
    474          				task that might be waiting to access the mutex. */
    475          				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x461A             MOV      R2,R3
   \   0000001A   0x4611             MOV      R1,R2
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       xQueueGenericSend
    476          			}
    477          
    478          			xReturn = pdPASS;
   \                     ??xQueueGiveMutexRecursive_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBD10             POP      {R4,PC}
    479          		}
    480          		else
    481          		{
    482          			/* We cannot give the mutex because we are not the holder. */
    483          			xReturn = pdFAIL;
   \                     ??xQueueGiveMutexRecursive_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
    484          
    485          			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
    486          		}
    487          
    488          		return xReturn;
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    489          	}
    490          
    491          #endif /* configUSE_RECURSIVE_MUTEXES */
    492          /*-----------------------------------------------------------*/
    493          
    494          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    495          

   \                                 In section .text, align 2, keep-with-next
    496          	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
    497          	{
   \                     xQueueTakeMutexRecursive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    498          	portBASE_TYPE xReturn;
    499          	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
    500          
    501          		configASSERT( pxMutex );
    502          
    503          		/* Comments regarding mutual exclusion as per those within
    504          		xQueueGiveMutexRecursive(). */
    505          
    506          		traceTAKE_MUTEX_RECURSIVE( pxMutex );
    507          
    508          		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
   \   00000006   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xD104             BNE.N    ??xQueueTakeMutexRecursive_0
    509          		{
    510          			( pxMutex->u.uxRecursiveCallCount )++;
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x60E0             STR      R0,[R4, #+12]
    511          			xReturn = pdPASS;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    512          		}
    513          		else
    514          		{
    515          			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
   \                     ??xQueueTakeMutexRecursive_0: (+1)
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0x4619             MOV      R1,R3
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       xQueueGenericReceive
    516          
    517          			/* pdPASS will only be returned if we successfully obtained the mutex,
    518          			we may have blocked to reach here. */
    519          			if( xReturn == pdPASS )
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD102             BNE.N    ??xQueueTakeMutexRecursive_1
    520          			{
    521          				( pxMutex->u.uxRecursiveCallCount )++;
   \   0000002A   0x68E1             LDR      R1,[R4, #+12]
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x60E1             STR      R1,[R4, #+12]
    522          			}
    523          			else
    524          			{
    525          				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
    526          			}
    527          		}
    528          
    529          		return xReturn;
   \                     ??xQueueTakeMutexRecursive_1: (+1)
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    530          	}
    531          
    532          #endif /* configUSE_RECURSIVE_MUTEXES */
    533          /*-----------------------------------------------------------*/
    534          
    535          #if ( configUSE_COUNTING_SEMAPHORES == 1 )
    536          

   \                                 In section .text, align 2, keep-with-next
    537          	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxMaxCount, unsigned portBASE_TYPE uxInitialCount )
    538          	{
   \                     xQueueCreateCountingSemaphore: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    539          	xQueueHandle xHandle;
    540          
    541          		configASSERT( uxMaxCount != 0 );
    542          		configASSERT( uxInitialCount <= uxMaxCount );
    543          
    544          		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   \   00000004   0x2202             MOVS     R2,#+2
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       xQueueGenericCreate
    545          
    546          		if( xHandle != NULL )
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD000             BEQ.N    ??xQueueCreateCountingSemaphore_0
    547          		{
    548          			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   \   00000010   0x6384             STR      R4,[R0, #+56]
    549          
    550          			traceCREATE_COUNTING_SEMAPHORE();
    551          		}
    552          		else
    553          		{
    554          			traceCREATE_COUNTING_SEMAPHORE_FAILED();
    555          		}
    556          
    557          		configASSERT( xHandle );
    558          		return xHandle;
   \                     ??xQueueCreateCountingSemaphore_0: (+1)
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    559          	}
    560          
    561          #endif /* configUSE_COUNTING_SEMAPHORES */
    562          /*-----------------------------------------------------------*/
    563          

   \                                 In section .text, align 2, keep-with-next
    564          signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
    565          {
   \                     xQueueGenericSend: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x461E             MOV      R6,R3
    566          signed portBASE_TYPE xEntryTimeSet = pdFALSE;
   \   00000008   0x2700             MOVS     R7,#+0
    567          xTimeOutType xTimeOut;
    568          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   \   0000000A   0xE004             B.N      ??xQueueGenericSend_0
    569          
    570          	configASSERT( pxQueue );
    571          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
    572          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    573          
    574          	/* This function relaxes the coding standard somewhat to allow return
    575          	statements within the function itself.  This is done in the interest
    576          	of execution time efficiency. */
    577          	for( ;; )
    578          	{
    579          		taskENTER_CRITICAL();
    580          		{
    581          			/* Is there room on the queue now?  The running task must be
    582          			the highest priority task wanting to access the queue.  If
    583          			the head item in the queue is to be overwritten then it does
    584          			not matter if the queue is full. */
    585          			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    586          			{
    587          				traceQUEUE_SEND( pxQueue );
    588          				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    589          
    590          				#if ( configUSE_QUEUE_SETS == 1 )
    591          				{
    592          					if( pxQueue->pxQueueSetContainer != NULL )
    593          					{
    594          						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    595          						{
    596          							/* The queue is a member of a queue set, and posting
    597          							to the queue set caused a higher priority task to
    598          							unblock. A context switch is required. */
    599          							queueYIELD_IF_USING_PREEMPTION();
    600          						}
    601          					}
    602          					else
    603          					{
    604          						/* If there was a task waiting for data to arrive on the
    605          						queue then unblock it now. */
    606          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    607          						{
    608          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    609          							{
    610          								/* The unblocked task has a priority higher than
    611          								our own so yield immediately.  Yes it is ok to
    612          								do this from within the critical section - the
    613          								kernel takes care of that. */
    614          								queueYIELD_IF_USING_PREEMPTION();
    615          							}
    616          						}
    617          					}
    618          				}
    619          				#else /* configUSE_QUEUE_SETS */
    620          				{
    621          					/* If there was a task waiting for data to arrive on the
    622          					queue then unblock it now. */
    623          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    624          					{
    625          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    626          						{
    627          							/* The unblocked task has a priority higher than
    628          							our own so yield immediately.  Yes it is ok to do
    629          							this from within the critical section - the kernel
    630          							takes care of that. */
    631          							queueYIELD_IF_USING_PREEMPTION();
    632          						}
    633          					}
    634          				}
    635          				#endif /* configUSE_QUEUE_SETS */
    636          
    637          				taskEXIT_CRITICAL();
    638          
    639          				/* Return to the original privilege level before exiting the
    640          				function. */
    641          				return pdPASS;
    642          			}
    643          			else
    644          			{
    645          				if( xTicksToWait == ( portTickType ) 0 )
    646          				{
    647          					/* The queue was full and no block time is specified (or
    648          					the block time has expired) so leave now. */
    649          					taskEXIT_CRITICAL();
    650          
    651          					/* Return to the original privilege level before exiting
    652          					the function. */
    653          					traceQUEUE_SEND_FAILED( pxQueue );
    654          					return errQUEUE_FULL;
    655          				}
    656          				else if( xEntryTimeSet == pdFALSE )
    657          				{
    658          					/* The queue was full and a block time was specified so
    659          					configure the timeout structure. */
    660          					vTaskSetTimeOutState( &xTimeOut );
    661          					xEntryTimeSet = pdTRUE;
    662          				}
    663          				else
    664          				{
    665          					/* Entry time was already set. */
    666          				}
    667          			}
    668          		}
    669          		taskEXIT_CRITICAL();
    670          
    671          		/* Interrupts and other tasks can send to and receive from the queue
    672          		now the critical section has been exited. */
    673          
    674          		vTaskSuspendAll();
    675          		prvLockQueue( pxQueue );
    676          
    677          		/* Update the timeout state to see if it has expired yet. */
    678          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    679          		{
    680          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    681          			{
    682          				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    683          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    684          
    685          				/* Unlocking the queue means queue events can effect the
    686          				event list.  It is possible	that interrupts occurring now
    687          				remove this task from the event	list again - but as the
    688          				scheduler is suspended the task will go onto the pending
    689          				ready last instead of the actual ready list. */
    690          				prvUnlockQueue( pxQueue );
    691          
    692          				/* Resuming the scheduler will move tasks from the pending
    693          				ready list into the ready list - so it is feasible that this
    694          				task is already in a ready list before it yields - in which
    695          				case the yield will not cause a context switch unless there
    696          				is also a higher priority task in the pending ready list. */
    697          				if( xTaskResumeAll() == pdFALSE )
    698          				{
    699          					portYIELD_WITHIN_API();
    700          				}
    701          			}
    702          			else
    703          			{
    704          				/* Try again. */
    705          				prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_1: (+1)
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       prvUnlockQueue
    706          				( void ) xTaskResumeAll();
   \   00000012   0x.... 0x....      BL       xTaskResumeAll
    707          			}
   \                     ??xQueueGenericSend_0: (+1)
   \   00000016   0x.... 0x....      BL       vPortEnterCritical
   \   0000001A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000001C   0x6BE1             LDR      R1,[R4, #+60]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD301             BCC.N    ??xQueueGenericSend_2
   \   00000022   0x2E02             CMP      R6,#+2
   \   00000024   0xD113             BNE.N    ??xQueueGenericSend_3
   \                     ??xQueueGenericSend_2: (+1)
   \   00000026   0x4632             MOV      R2,R6
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       prvCopyDataToQueue
   \   00000030   0x6A60             LDR      R0,[R4, #+36]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD007             BEQ.N    ??xQueueGenericSend_4
   \   00000036   0xF104 0x0024      ADD      R0,R4,#+36
   \   0000003A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD101             BNE.N    ??xQueueGenericSend_4
   \   00000042   0x.... 0x....      BL       vPortYield
   \                     ??xQueueGenericSend_4: (+1)
   \   00000046   0x.... 0x....      BL       vPortExitCritical
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueGenericSend_3: (+1)
   \   0000004E   0x9802             LDR      R0,[SP, #+8]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD103             BNE.N    ??xQueueGenericSend_5
   \   00000054   0x.... 0x....      BL       vPortExitCritical
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueGenericSend_5: (+1)
   \   0000005C   0x2F00             CMP      R7,#+0
   \   0000005E   0xD103             BNE.N    ??xQueueGenericSend_6
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0x.... 0x....      BL       vTaskSetTimeOutState
   \   00000066   0x2701             MOVS     R7,#+1
   \                     ??xQueueGenericSend_6: (+1)
   \   00000068   0x.... 0x....      BL       vPortExitCritical
   \   0000006C   0x.... 0x....      BL       vTaskSuspendAll
   \   00000070   0x.... 0x....      BL       vPortEnterCritical
   \   00000074   0x6C60             LDR      R0,[R4, #+68]
   \   00000076   0xF110 0x0F01      CMN      R0,#+1
   \   0000007A   0xD101             BNE.N    ??xQueueGenericSend_7
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericSend_7: (+1)
   \   00000080   0x6CA0             LDR      R0,[R4, #+72]
   \   00000082   0xF110 0x0F01      CMN      R0,#+1
   \   00000086   0xD101             BNE.N    ??xQueueGenericSend_8
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericSend_8: (+1)
   \   0000008C   0x.... 0x....      BL       vPortExitCritical
   \   00000090   0xA902             ADD      R1,SP,#+8
   \   00000092   0x4668             MOV      R0,SP
   \   00000094   0x.... 0x....      BL       xTaskCheckForTimeOut
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0xD112             BNE.N    ??xQueueGenericSend_9
   \   0000009E   0x.... 0x....      BL       prvIsQueueFull
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD0B2             BEQ.N    ??xQueueGenericSend_1
   \   000000A6   0x9902             LDR      R1,[SP, #+8]
   \   000000A8   0xF104 0x0010      ADD      R0,R4,#+16
   \   000000AC   0x.... 0x....      BL       vTaskPlaceOnEventList
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       prvUnlockQueue
   \   000000B6   0x.... 0x....      BL       xTaskResumeAll
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD1AB             BNE.N    ??xQueueGenericSend_0
   \   000000BE   0x.... 0x....      BL       vPortYield
   \   000000C2   0xE7A8             B.N      ??xQueueGenericSend_0
    708          		}
    709          		else
    710          		{
    711          			/* The timeout has expired. */
    712          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_9: (+1)
   \   000000C4   0x.... 0x....      BL       prvUnlockQueue
    713          			( void ) xTaskResumeAll();
   \   000000C8   0x.... 0x....      BL       xTaskResumeAll
    714          
    715          			/* Return to the original privilege level before exiting the
    716          			function. */
    717          			traceQUEUE_SEND_FAILED( pxQueue );
    718          			return errQUEUE_FULL;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xBDFE             POP      {R1-R7,PC}       ;; return
    719          		}
    720          	}
    721          }
    722          /*-----------------------------------------------------------*/
    723          
    724          #if ( configUSE_ALTERNATIVE_API == 1 )
    725          
    726          	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
    727          	{
    728          	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    729          	xTimeOutType xTimeOut;
    730          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    731          
    732          		configASSERT( pxQueue );
    733          		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
    734          
    735          		for( ;; )
    736          		{
    737          			taskENTER_CRITICAL();
    738          			{
    739          				/* Is there room on the queue now?  To be running we must be
    740          				the highest priority task wanting to access the queue. */
    741          				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    742          				{
    743          					traceQUEUE_SEND( pxQueue );
    744          					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    745          
    746          					/* If there was a task waiting for data to arrive on the
    747          					queue then unblock it now. */
    748          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    749          					{
    750          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    751          						{
    752          							/* The unblocked task has a priority higher than
    753          							our own so yield immediately. */
    754          							portYIELD_WITHIN_API();
    755          						}
    756          					}
    757          
    758          					taskEXIT_CRITICAL();
    759          					return pdPASS;
    760          				}
    761          				else
    762          				{
    763          					if( xTicksToWait == ( portTickType ) 0 )
    764          					{
    765          						taskEXIT_CRITICAL();
    766          						return errQUEUE_FULL;
    767          					}
    768          					else if( xEntryTimeSet == pdFALSE )
    769          					{
    770          						vTaskSetTimeOutState( &xTimeOut );
    771          						xEntryTimeSet = pdTRUE;
    772          					}
    773          				}
    774          			}
    775          			taskEXIT_CRITICAL();
    776          
    777          			taskENTER_CRITICAL();
    778          			{
    779          				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    780          				{
    781          					if( prvIsQueueFull( pxQueue ) != pdFALSE )
    782          					{
    783          						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    784          						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    785          						portYIELD_WITHIN_API();
    786          					}
    787          				}
    788          				else
    789          				{
    790          					taskEXIT_CRITICAL();
    791          					traceQUEUE_SEND_FAILED( pxQueue );
    792          					return errQUEUE_FULL;
    793          				}
    794          			}
    795          			taskEXIT_CRITICAL();
    796          		}
    797          	}
    798          
    799          #endif /* configUSE_ALTERNATIVE_API */
    800          /*-----------------------------------------------------------*/
    801          
    802          #if ( configUSE_ALTERNATIVE_API == 1 )
    803          
    804          	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
    805          	{
    806          	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    807          	xTimeOutType xTimeOut;
    808          	signed char *pcOriginalReadPosition;
    809          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    810          
    811          		configASSERT( pxQueue );
    812          		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
    813          
    814          		for( ;; )
    815          		{
    816          			taskENTER_CRITICAL();
    817          			{
    818          				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    819          				{
    820          					/* Remember our read position in case we are just peeking. */
    821          					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    822          
    823          					prvCopyDataFromQueue( pxQueue, pvBuffer );
    824          
    825          					if( xJustPeeking == pdFALSE )
    826          					{
    827          						traceQUEUE_RECEIVE( pxQueue );
    828          
    829          						/* Data is actually being removed (not just peeked). */
    830          						--( pxQueue->uxMessagesWaiting );
    831          
    832          						#if ( configUSE_MUTEXES == 1 )
    833          						{
    834          							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    835          							{
    836          								/* Record the information required to implement
    837          								priority inheritance should it become necessary. */
    838          								pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle();
    839          							}
    840          						}
    841          						#endif
    842          
    843          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    844          						{
    845          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    846          							{
    847          								portYIELD_WITHIN_API();
    848          							}
    849          						}
    850          					}
    851          					else
    852          					{
    853          						traceQUEUE_PEEK( pxQueue );
    854          
    855          						/* We are not removing the data, so reset our read
    856          						pointer. */
    857          						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    858          
    859          						/* The data is being left in the queue, so see if there are
    860          						any other tasks waiting for the data. */
    861          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    862          						{
    863          							/* Tasks that are removed from the event list will get added to
    864          							the pending ready list as the scheduler is still suspended. */
    865          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    866          							{
    867          								/* The task waiting has a higher priority than this task. */
    868          								portYIELD_WITHIN_API();
    869          							}
    870          						}
    871          
    872          					}
    873          
    874          					taskEXIT_CRITICAL();
    875          					return pdPASS;
    876          				}
    877          				else
    878          				{
    879          					if( xTicksToWait == ( portTickType ) 0 )
    880          					{
    881          						taskEXIT_CRITICAL();
    882          						traceQUEUE_RECEIVE_FAILED( pxQueue );
    883          						return errQUEUE_EMPTY;
    884          					}
    885          					else if( xEntryTimeSet == pdFALSE )
    886          					{
    887          						vTaskSetTimeOutState( &xTimeOut );
    888          						xEntryTimeSet = pdTRUE;
    889          					}
    890          				}
    891          			}
    892          			taskEXIT_CRITICAL();
    893          
    894          			taskENTER_CRITICAL();
    895          			{
    896          				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    897          				{
    898          					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    899          					{
    900          						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
    901          
    902          						#if ( configUSE_MUTEXES == 1 )
    903          						{
    904          							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    905          							{
    906          								portENTER_CRITICAL();
    907          								{
    908          									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    909          								}
    910          								portEXIT_CRITICAL();
    911          							}
    912          						}
    913          						#endif
    914          
    915          						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    916          						portYIELD_WITHIN_API();
    917          					}
    918          				}
    919          				else
    920          				{
    921          					taskEXIT_CRITICAL();
    922          					traceQUEUE_RECEIVE_FAILED( pxQueue );
    923          					return errQUEUE_EMPTY;
    924          				}
    925          			}
    926          			taskEXIT_CRITICAL();
    927          		}
    928          	}
    929          
    930          
    931          #endif /* configUSE_ALTERNATIVE_API */
    932          /*-----------------------------------------------------------*/
    933          

   \                                 In section .text, align 2, keep-with-next
    934          signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
    935          {
   \                     xQueueGenericSendFromISR: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
    936          signed portBASE_TYPE xReturn;
    937          unsigned portBASE_TYPE uxSavedInterruptStatus;
    938          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
    939          
    940          	configASSERT( pxQueue );
    941          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
    942          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    943          
    944          	/* RTOS ports that support interrupt nesting have the concept of a maximum
    945          	system call (or maximum API call) interrupt priority.  Interrupts that are
    946          	above the maximum system call priority are keep permanently enabled, even
    947          	when the RTOS kernel is in a critical section, but cannot make any calls to
    948          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
    949          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    950          	failure if a FreeRTOS API function is called from an interrupt that has been
    951          	assigned a priority above the configured maximum system call priority.
    952          	Only FreeRTOS functions that end in FromISR can be called from interrupts
    953          	that have been assigned a priority at or (logically) below the maximum
    954          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
    955          	safe API to ensure interrupt entry is as fast and as simple as possible.
    956          	More information (albeit Cortex-M specific) is provided on the following
    957          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    958          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    959          
    960          	/* Similar to xQueueGenericSend, except we don't block if there is no room
    961          	in the queue.  Also we don't directly wake a task that was blocked on a
    962          	queue read, instead we return a flag to say whether a context switch is
    963          	required or not (i.e. has a task with a higher priority than us been woken
    964          	by this	post). */
    965          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   0000000C   0x.... 0x....      BL       ulPortSetInterruptMask
   \   00000010   0x4604             MOV      R4,R0
    966          	{
    967          		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   \   00000012   0x6BA8             LDR      R0,[R5, #+56]
   \   00000014   0x6BE9             LDR      R1,[R5, #+60]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD302             BCC.N    ??xQueueGenericSendFromISR_0
   \   0000001A   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000001E   0xD11B             BNE.N    ??xQueueGenericSendFromISR_1
    968          		{
    969          			traceQUEUE_SEND_FROM_ISR( pxQueue );
    970          
    971          			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \                     ??xQueueGenericSendFromISR_0: (+1)
   \   00000020   0x4642             MOV      R2,R8
   \   00000022   0x4639             MOV      R1,R7
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       prvCopyDataToQueue
    972          
    973          			/* If the queue is locked we do not alter the event list.  This will
    974          			be done when the queue is unlocked later. */
    975          			if( pxQueue->xTxLock == queueUNLOCKED )
   \   0000002A   0x6CA8             LDR      R0,[R5, #+72]
   \   0000002C   0xF110 0x0F01      CMN      R0,#+1
   \   00000030   0xD10D             BNE.N    ??xQueueGenericSendFromISR_2
    976          			{
    977          				#if ( configUSE_QUEUE_SETS == 1 )
    978          				{
    979          					if( pxQueue->pxQueueSetContainer != NULL )
    980          					{
    981          						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    982          						{
    983          							/* The queue is a member of a queue set, and posting
    984          							to the queue set caused a higher priority task to
    985          							unblock.  A context switch is required. */
    986          							if( pxHigherPriorityTaskWoken != NULL )
    987          							{
    988          								*pxHigherPriorityTaskWoken = pdTRUE;
    989          							}
    990          						}
    991          					}
    992          					else
    993          					{
    994          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    995          						{
    996          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    997          							{
    998          								/* The task waiting has a higher priority so record that a
    999          								context	switch is required. */
   1000          								if( pxHigherPriorityTaskWoken != NULL )
   1001          								{
   1002          									*pxHigherPriorityTaskWoken = pdTRUE;
   1003          								}
   1004          							}
   1005          						}
   1006          					}
   1007          				}
   1008          				#else /* configUSE_QUEUE_SETS */
   1009          				{
   1010          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \   00000032   0x6A68             LDR      R0,[R5, #+36]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00D             BEQ.N    ??xQueueGenericSendFromISR_3
   1011          					{
   1012          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \   00000038   0xF105 0x0024      ADD      R0,R5,#+36
   \   0000003C   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD007             BEQ.N    ??xQueueGenericSendFromISR_3
   1013          						{
   1014          							/* The task waiting has a higher priority so record that a
   1015          							context	switch is required. */
   1016          							if( pxHigherPriorityTaskWoken != NULL )
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD005             BEQ.N    ??xQueueGenericSendFromISR_3
   1017          							{
   1018          								*pxHigherPriorityTaskWoken = pdTRUE;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x6030             STR      R0,[R6, #+0]
   \   0000004C   0xE002             B.N      ??xQueueGenericSendFromISR_3
   1019          							}
   1020          						}
   1021          					}
   1022          				}
   1023          				#endif /* configUSE_QUEUE_SETS */
   1024          			}
   1025          			else
   1026          			{
   1027          				/* Increment the lock count so the task that unlocks the queue
   1028          				knows that data was posted while it was locked. */
   1029          				++( pxQueue->xTxLock );
   \                     ??xQueueGenericSendFromISR_2: (+1)
   \   0000004E   0x6CA8             LDR      R0,[R5, #+72]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x64A8             STR      R0,[R5, #+72]
   1030          			}
   1031          
   1032          			xReturn = pdPASS;
   \                     ??xQueueGenericSendFromISR_3: (+1)
   \   00000054   0x2501             MOVS     R5,#+1
   \   00000056   0xE000             B.N      ??xQueueGenericSendFromISR_4
   1033          		}
   1034          		else
   1035          		{
   1036          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1037          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGenericSendFromISR_1: (+1)
   \   00000058   0x2500             MOVS     R5,#+0
   1038          		}
   1039          	}
   1040          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGenericSendFromISR_4: (+1)
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       vPortClearInterruptMask
   1041          
   1042          	return xReturn;
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1043          }
   1044          /*-----------------------------------------------------------*/
   1045          

   \                                 In section .text, align 2, keep-with-next
   1046          signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
   1047          {
   \                     xQueueGenericReceive: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x461E             MOV      R6,R3
   1048          signed portBASE_TYPE xEntryTimeSet = pdFALSE;
   \   00000008   0x2700             MOVS     R7,#+0
   1049          xTimeOutType xTimeOut;
   1050          signed char *pcOriginalReadPosition;
   1051          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   \   0000000A   0xE004             B.N      ??xQueueGenericReceive_0
   1052          
   1053          	configASSERT( pxQueue );
   1054          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   1055          
   1056          	/* This function relaxes the coding standard somewhat to allow return
   1057          	statements within the function itself.  This is done in the interest
   1058          	of execution time efficiency. */
   1059          
   1060          	for( ;; )
   1061          	{
   1062          		taskENTER_CRITICAL();
   1063          		{
   1064          			/* Is there data in the queue now?  To be running we must be
   1065          			the highest priority task wanting to access the queue. */
   1066          			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   1067          			{
   1068          				/* Remember the read position in case the queue is only being
   1069          				peeked. */
   1070          				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   1071          
   1072          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1073          
   1074          				if( xJustPeeking == pdFALSE )
   1075          				{
   1076          					traceQUEUE_RECEIVE( pxQueue );
   1077          
   1078          					/* Actually removing data, not just peeking. */
   1079          					--( pxQueue->uxMessagesWaiting );
   1080          
   1081          					#if ( configUSE_MUTEXES == 1 )
   1082          					{
   1083          						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1084          						{
   1085          							/* Record the information required to implement
   1086          							priority inheritance should it become necessary. */
   1087          							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
   1088          						}
   1089          					}
   1090          					#endif
   1091          
   1092          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1093          					{
   1094          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   1095          						{
   1096          							queueYIELD_IF_USING_PREEMPTION();
   1097          						}
   1098          					}
   1099          				}
   1100          				else
   1101          				{
   1102          					traceQUEUE_PEEK( pxQueue );
   1103          
   1104          					/* The data is not being removed, so reset the read
   1105          					pointer. */
   1106          					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   1107          
   1108          					/* The data is being left in the queue, so see if there are
   1109          					any other tasks waiting for the data. */
   1110          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1111          					{
   1112          						/* Tasks that are removed from the event list will get added to
   1113          						the pending ready list as the scheduler is still suspended. */
   1114          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1115          						{
   1116          							/* The task waiting has a higher priority than this task. */
   1117          							queueYIELD_IF_USING_PREEMPTION();
   1118          						}
   1119          					}
   1120          				}
   1121          
   1122          				taskEXIT_CRITICAL();
   1123          				return pdPASS;
   1124          			}
   1125          			else
   1126          			{
   1127          				if( xTicksToWait == ( portTickType ) 0 )
   1128          				{
   1129          					/* The queue was empty and no block time is specified (or
   1130          					the block time has expired) so leave now. */
   1131          					taskEXIT_CRITICAL();
   1132          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1133          					return errQUEUE_EMPTY;
   1134          				}
   1135          				else if( xEntryTimeSet == pdFALSE )
   1136          				{
   1137          					/* The queue was empty and a block time was specified so
   1138          					configure the timeout structure. */
   1139          					vTaskSetTimeOutState( &xTimeOut );
   1140          					xEntryTimeSet = pdTRUE;
   1141          				}
   1142          				else
   1143          				{
   1144          					/* Entry time was already set. */
   1145          				}
   1146          			}
   1147          		}
   1148          		taskEXIT_CRITICAL();
   1149          
   1150          		/* Interrupts and other tasks can send to and receive from the queue
   1151          		now the critical section has been exited. */
   1152          
   1153          		vTaskSuspendAll();
   1154          		prvLockQueue( pxQueue );
   1155          
   1156          		/* Update the timeout state to see if it has expired yet. */
   1157          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1158          		{
   1159          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1160          			{
   1161          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1162          
   1163          				#if ( configUSE_MUTEXES == 1 )
   1164          				{
   1165          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1166          					{
   1167          						portENTER_CRITICAL();
   1168          						{
   1169          							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   1170          						}
   1171          						portEXIT_CRITICAL();
   1172          					}
   1173          				}
   1174          				#endif
   1175          
   1176          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1177          				prvUnlockQueue( pxQueue );
   1178          				if( xTaskResumeAll() == pdFALSE )
   1179          				{
   1180          					portYIELD_WITHIN_API();
   1181          				}
   1182          			}
   1183          			else
   1184          			{
   1185          				/* Try again. */
   1186          				prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericReceive_1: (+1)
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       prvUnlockQueue
   1187          				( void ) xTaskResumeAll();
   \   00000012   0x.... 0x....      BL       xTaskResumeAll
   1188          			}
   \                     ??xQueueGenericReceive_0: (+1)
   \   00000016   0x.... 0x....      BL       vPortEnterCritical
   \   0000001A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD02B             BEQ.N    ??xQueueGenericReceive_2
   \   00000020   0x68E7             LDR      R7,[R4, #+12]
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       prvCopyDataFromQueue
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD114             BNE.N    ??xQueueGenericReceive_3
   \   0000002E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x63A0             STR      R0,[R4, #+56]
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD102             BNE.N    ??xQueueGenericReceive_4
   \   0000003A   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   0000003E   0x6060             STR      R0,[R4, #+4]
   \                     ??xQueueGenericReceive_4: (+1)
   \   00000040   0x6920             LDR      R0,[R4, #+16]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD014             BEQ.N    ??xQueueGenericReceive_5
   \   00000046   0xF104 0x0010      ADD      R0,R4,#+16
   \   0000004A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD10E             BNE.N    ??xQueueGenericReceive_5
   \   00000052   0x.... 0x....      BL       vPortYield
   \   00000056   0xE00B             B.N      ??xQueueGenericReceive_5
   \                     ??xQueueGenericReceive_3: (+1)
   \   00000058   0x60E7             STR      R7,[R4, #+12]
   \   0000005A   0x6A60             LDR      R0,[R4, #+36]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD007             BEQ.N    ??xQueueGenericReceive_5
   \   00000060   0xF104 0x0024      ADD      R0,R4,#+36
   \   00000064   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD001             BEQ.N    ??xQueueGenericReceive_5
   \   0000006C   0x.... 0x....      BL       vPortYield
   \                     ??xQueueGenericReceive_5: (+1)
   \   00000070   0x.... 0x....      BL       vPortExitCritical
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueGenericReceive_2: (+1)
   \   00000078   0x9802             LDR      R0,[SP, #+8]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD103             BNE.N    ??xQueueGenericReceive_6
   \   0000007E   0x.... 0x....      BL       vPortExitCritical
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xBDFE             POP      {R1-R7,PC}
   \                     ??xQueueGenericReceive_6: (+1)
   \   00000086   0x2F00             CMP      R7,#+0
   \   00000088   0xD103             BNE.N    ??xQueueGenericReceive_7
   \   0000008A   0x4668             MOV      R0,SP
   \   0000008C   0x.... 0x....      BL       vTaskSetTimeOutState
   \   00000090   0x2701             MOVS     R7,#+1
   \                     ??xQueueGenericReceive_7: (+1)
   \   00000092   0x.... 0x....      BL       vPortExitCritical
   \   00000096   0x.... 0x....      BL       vTaskSuspendAll
   \   0000009A   0x.... 0x....      BL       vPortEnterCritical
   \   0000009E   0x6C60             LDR      R0,[R4, #+68]
   \   000000A0   0xF110 0x0F01      CMN      R0,#+1
   \   000000A4   0xD101             BNE.N    ??xQueueGenericReceive_8
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericReceive_8: (+1)
   \   000000AA   0x6CA0             LDR      R0,[R4, #+72]
   \   000000AC   0xF110 0x0F01      CMN      R0,#+1
   \   000000B0   0xD101             BNE.N    ??xQueueGenericReceive_9
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericReceive_9: (+1)
   \   000000B6   0x.... 0x....      BL       vPortExitCritical
   \   000000BA   0xA902             ADD      R1,SP,#+8
   \   000000BC   0x4668             MOV      R0,SP
   \   000000BE   0x.... 0x....      BL       xTaskCheckForTimeOut
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0xD11C             BNE.N    ??xQueueGenericReceive_10
   \   000000C8   0x.... 0x....      BL       prvIsQueueEmpty
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD09D             BEQ.N    ??xQueueGenericReceive_1
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD106             BNE.N    ??xQueueGenericReceive_11
   \   000000D6   0x.... 0x....      BL       vPortEnterCritical
   \   000000DA   0x6860             LDR      R0,[R4, #+4]
   \   000000DC   0x.... 0x....      BL       vTaskPriorityInherit
   \   000000E0   0x.... 0x....      BL       vPortExitCritical
   \                     ??xQueueGenericReceive_11: (+1)
   \   000000E4   0x9902             LDR      R1,[SP, #+8]
   \   000000E6   0xF104 0x0024      ADD      R0,R4,#+36
   \   000000EA   0x.... 0x....      BL       vTaskPlaceOnEventList
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       prvUnlockQueue
   \   000000F4   0x.... 0x....      BL       xTaskResumeAll
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD18C             BNE.N    ??xQueueGenericReceive_0
   \   000000FC   0x.... 0x....      BL       vPortYield
   \   00000100   0xE789             B.N      ??xQueueGenericReceive_0
   1189          		}
   1190          		else
   1191          		{
   1192          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericReceive_10: (+1)
   \   00000102   0x.... 0x....      BL       prvUnlockQueue
   1193          			( void ) xTaskResumeAll();
   \   00000106   0x.... 0x....      BL       xTaskResumeAll
   1194          			traceQUEUE_RECEIVE_FAILED( pxQueue );
   1195          			return errQUEUE_EMPTY;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xBDFE             POP      {R1-R7,PC}       ;; return
   1196          		}
   1197          	}
   1198          }
   1199          /*-----------------------------------------------------------*/
   1200          

   \                                 In section .text, align 2, keep-with-next
   1201          signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
   1202          {
   \                     xQueueReceiveFromISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
   1203          signed portBASE_TYPE xReturn;
   1204          unsigned portBASE_TYPE uxSavedInterruptStatus;
   1205          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1206          
   1207          	configASSERT( pxQueue );
   1208          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   1209          
   1210          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1211          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1212          	above the maximum system call priority are keep permanently enabled, even
   1213          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1214          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1215          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1216          	failure if a FreeRTOS API function is called from an interrupt that has been
   1217          	assigned a priority above the configured maximum system call priority.
   1218          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1219          	that have been assigned a priority at or (logically) below the maximum
   1220          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1221          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1222          	More information (albeit Cortex-M specific) is provided on the following
   1223          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1224          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1225          
   1226          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000008   0x.... 0x....      BL       ulPortSetInterruptMask
   \   0000000C   0x4604             MOV      R4,R0
   1227          	{
   1228          		/* Cannot block in an ISR, so check there is data available. */
   1229          		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   \   0000000E   0x6BA8             LDR      R0,[R5, #+56]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01D             BEQ.N    ??xQueueReceiveFromISR_0
   1230          		{
   1231          			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
   1232          
   1233          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \   00000014   0x4639             MOV      R1,R7
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       prvCopyDataFromQueue
   1234          			--( pxQueue->uxMessagesWaiting );
   \   0000001C   0x6BA8             LDR      R0,[R5, #+56]
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x63A8             STR      R0,[R5, #+56]
   1235          
   1236          			/* If the queue is locked the event list will not be modified.
   1237          			Instead update the lock count so the task that unlocks the queue
   1238          			will know that an ISR has removed data while the queue was
   1239          			locked. */
   1240          			if( pxQueue->xRxLock == queueUNLOCKED )
   \   00000022   0x6C68             LDR      R0,[R5, #+68]
   \   00000024   0xF110 0x0F01      CMN      R0,#+1
   \   00000028   0xD10D             BNE.N    ??xQueueReceiveFromISR_1
   1241          			{
   1242          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \   0000002A   0x6928             LDR      R0,[R5, #+16]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00D             BEQ.N    ??xQueueReceiveFromISR_2
   1243          				{
   1244          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \   00000030   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000034   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD007             BEQ.N    ??xQueueReceiveFromISR_2
   1245          					{
   1246          						/* The task waiting has a higher priority than us so
   1247          						force a context switch. */
   1248          						if( pxHigherPriorityTaskWoken != NULL )
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD005             BEQ.N    ??xQueueReceiveFromISR_2
   1249          						{
   1250          							*pxHigherPriorityTaskWoken = pdTRUE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x6030             STR      R0,[R6, #+0]
   \   00000044   0xE002             B.N      ??xQueueReceiveFromISR_2
   1251          						}
   1252          					}
   1253          				}
   1254          			}
   1255          			else
   1256          			{
   1257          				/* Increment the lock count so the task that unlocks the queue
   1258          				knows that data was removed while it was locked. */
   1259          				++( pxQueue->xRxLock );
   \                     ??xQueueReceiveFromISR_1: (+1)
   \   00000046   0x6C68             LDR      R0,[R5, #+68]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x6468             STR      R0,[R5, #+68]
   1260          			}
   1261          
   1262          			xReturn = pdPASS;
   \                     ??xQueueReceiveFromISR_2: (+1)
   \   0000004C   0x2501             MOVS     R5,#+1
   \   0000004E   0xE000             B.N      ??xQueueReceiveFromISR_3
   1263          		}
   1264          		else
   1265          		{
   1266          			xReturn = pdFAIL;
   \                     ??xQueueReceiveFromISR_0: (+1)
   \   00000050   0x2500             MOVS     R5,#+0
   1267          			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
   1268          		}
   1269          	}
   1270          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueReceiveFromISR_3: (+1)
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       vPortClearInterruptMask
   1271          
   1272          	return xReturn;
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1273          }
   1274          /*-----------------------------------------------------------*/
   1275          

   \                                 In section .text, align 2, keep-with-next
   1276          signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue,  void * const pvBuffer )
   1277          {
   \                     xQueuePeekFromISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1278          signed portBASE_TYPE xReturn;
   1279          unsigned portBASE_TYPE uxSavedInterruptStatus;
   1280          signed char *pcOriginalReadPosition;
   1281          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1282          
   1283          	configASSERT( pxQueue );
   1284          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   1285          
   1286          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1287          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1288          	above the maximum system call priority are keep permanently enabled, even
   1289          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1290          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1291          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1292          	failure if a FreeRTOS API function is called from an interrupt that has been
   1293          	assigned a priority above the configured maximum system call priority.
   1294          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1295          	that have been assigned a priority at or (logically) below the maximum
   1296          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1297          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1298          	More information (albeit Cortex-M specific) is provided on the following
   1299          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1300          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1301          
   1302          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000006   0x.... 0x....      BL       ulPortSetInterruptMask
   \   0000000A   0x4606             MOV      R6,R0
   1303          	{
   1304          		/* Cannot block in an ISR, so check there is data available. */
   1305          		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   \   0000000C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD007             BEQ.N    ??xQueuePeekFromISR_0
   1306          		{
   1307          			traceQUEUE_PEEK_FROM_ISR( pxQueue );
   1308          
   1309          			/* Remember the read position so it can be reset as nothing is
   1310          			actually being removed from the queue. */
   1311          			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   \   00000012   0x68E7             LDR      R7,[R4, #+12]
   1312          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       prvCopyDataFromQueue
   1313          			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   \   0000001C   0x60E7             STR      R7,[R4, #+12]
   1314          
   1315          			xReturn = pdPASS;
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0xE000             B.N      ??xQueuePeekFromISR_1
   1316          		}
   1317          		else
   1318          		{
   1319          			xReturn = pdFAIL;
   \                     ??xQueuePeekFromISR_0: (+1)
   \   00000022   0x2400             MOVS     R4,#+0
   1320          			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
   1321          		}
   1322          	}
   1323          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueuePeekFromISR_1: (+1)
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       vPortClearInterruptMask
   1324          
   1325          	return xReturn;
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1326          }
   1327          /*-----------------------------------------------------------*/
   1328          

   \                                 In section .text, align 2, keep-with-next
   1329          unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
   1330          {
   \                     uxQueueMessagesWaiting: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1331          unsigned portBASE_TYPE uxReturn;
   1332          
   1333          	configASSERT( xQueue );
   1334          
   1335          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1336          		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
   \   00000008   0x6BA4             LDR      R4,[R4, #+56]
   1337          	taskEXIT_CRITICAL();
   \   0000000A   0x.... 0x....      BL       vPortExitCritical
   1338          
   1339          	return uxReturn;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1340          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1341          /*-----------------------------------------------------------*/
   1342          

   \                                 In section .text, align 2, keep-with-next
   1343          unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
   1344          {
   \                     uxQueueSpacesAvailable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1345          unsigned portBASE_TYPE uxReturn;
   1346          xQUEUE *pxQueue;
   1347          
   1348          	pxQueue = ( xQUEUE * ) xQueue;
   1349          	configASSERT( pxQueue );
   1350          
   1351          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1352          		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   \   00000008   0x6BE0             LDR      R0,[R4, #+60]
   \   0000000A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000000C   0x1A44             SUBS     R4,R0,R1
   1353          	taskEXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       vPortExitCritical
   1354          
   1355          	return uxReturn;
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1356          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1357          /*-----------------------------------------------------------*/
   1358          

   \                                 In section .text, align 2, keep-with-next
   1359          unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
   1360          {
   1361          unsigned portBASE_TYPE uxReturn;
   1362          
   1363          	configASSERT( xQueue );
   1364          
   1365          	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
   \                     uxQueueMessagesWaitingFromISR: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   1366          
   1367          	return uxReturn;
   \   00000002   0x4770             BX       LR               ;; return
   1368          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1369          /*-----------------------------------------------------------*/
   1370          

   \                                 In section .text, align 2, keep-with-next
   1371          void vQueueDelete( xQueueHandle xQueue )
   1372          {
   \                     vQueueDelete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1373          xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1374          
   1375          	configASSERT( pxQueue );
   1376          
   1377          	traceQUEUE_DELETE( pxQueue );
   1378          	#if ( configQUEUE_REGISTRY_SIZE > 0 )
   1379          	{
   1380          		vQueueUnregisterQueue( pxQueue );
   1381          	}
   1382          	#endif
   1383          	vPortFree( pxQueue->pcHead );
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       vPortFree
   1384          	vPortFree( pxQueue );
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      vPortFree
   1385          }
   1386          /*-----------------------------------------------------------*/
   1387          
   1388          #if ( configUSE_TRACE_FACILITY == 1 )
   1389          

   \                                 In section .text, align 2, keep-with-next
   1390          	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
   1391          	{
   1392          		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
   \                     ucQueueGetQueueNumber: (+1)
   \   00000000   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   00000004   0x4770             BX       LR               ;; return
   1393          	}
   1394          
   1395          #endif /* configUSE_TRACE_FACILITY */
   1396          /*-----------------------------------------------------------*/
   1397          
   1398          #if ( configUSE_TRACE_FACILITY == 1 )
   1399          

   \                                 In section .text, align 2, keep-with-next
   1400          	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
   1401          	{
   1402          		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
   \                     vQueueSetQueueNumber: (+1)
   \   00000000   0xF880 0x104C      STRB     R1,[R0, #+76]
   1403          	}
   \   00000004   0x4770             BX       LR               ;; return
   1404          
   1405          #endif /* configUSE_TRACE_FACILITY */
   1406          /*-----------------------------------------------------------*/
   1407          
   1408          #if ( configUSE_TRACE_FACILITY == 1 )
   1409          

   \                                 In section .text, align 2, keep-with-next
   1410          	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
   1411          	{
   1412          		return ( ( xQUEUE * ) xQueue )->ucQueueType;
   \                     ucQueueGetQueueType: (+1)
   \   00000000   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   00000004   0x4770             BX       LR               ;; return
   1413          	}
   1414          
   1415          #endif /* configUSE_TRACE_FACILITY */
   1416          /*-----------------------------------------------------------*/
   1417          

   \                                 In section .text, align 2, keep-with-next
   1418          static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
   1419          {
   \                     prvCopyDataToQueue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   1420          	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
   \   00000006   0x6C22             LDR      R2,[R4, #+64]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??prvCopyDataToQueue_0
   1421          	{
   1422          		#if ( configUSE_MUTEXES == 1 )
   1423          		{
   1424          			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD12C             BNE.N    ??prvCopyDataToQueue_1
   1425          			{
   1426          				/* The mutex is no longer being held. */
   1427          				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x.... 0x....      BL       vTaskPriorityDisinherit
   1428          				pxQueue->pxMutexHolder = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6060             STR      R0,[R4, #+4]
   \   0000001C   0xE026             B.N      ??prvCopyDataToQueue_1
   1429          			}
   1430          		}
   1431          		#endif /* configUSE_MUTEXES */
   1432          	}
   1433          	else if( xPosition == queueSEND_TO_BACK )
   \                     ??prvCopyDataToQueue_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD10C             BNE.N    ??prvCopyDataToQueue_2
   1434          	{
   1435          		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy
   1436          		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x6C21             LDR      R1,[R4, #+64]
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x60A0             STR      R0,[R4, #+8]
   1437          		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \   00000030   0x6861             LDR      R1,[R4, #+4]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD31A             BCC.N    ??prvCopyDataToQueue_1
   1438          		{
   1439          			pxQueue->pcWriteTo = pxQueue->pcHead;
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x60A0             STR      R0,[R4, #+8]
   \   0000003A   0xE017             B.N      ??prvCopyDataToQueue_1
   1440          		}
   1441          	}
   1442          	else
   1443          	{
   1444          		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??prvCopyDataToQueue_2: (+1)
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0x.... 0x....      BL       __aeabi_memcpy
   1445          		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   \   00000042   0x68E0             LDR      R0,[R4, #+12]
   \   00000044   0x6C21             LDR      R1,[R4, #+64]
   \   00000046   0x4249             RSBS     R1,R1,#+0
   \   00000048   0x4408             ADD      R0,R0,R1
   \   0000004A   0x60E0             STR      R0,[R4, #+12]
   1446          		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD204             BCS.N    ??prvCopyDataToQueue_3
   1447          		{
   1448          			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0x6C21             LDR      R1,[R4, #+64]
   \   00000056   0x4249             RSBS     R1,R1,#+0
   \   00000058   0x4408             ADD      R0,R0,R1
   \   0000005A   0x60E0             STR      R0,[R4, #+12]
   1449          		}
   1450          
   1451          		if( xPosition == queueOVERWRITE )
   \                     ??prvCopyDataToQueue_3: (+1)
   \   0000005C   0x2D02             CMP      R5,#+2
   \   0000005E   0xD105             BNE.N    ??prvCopyDataToQueue_1
   1452          		{
   1453          			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   \   00000060   0x6BA0             LDR      R0,[R4, #+56]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ.N    ??prvCopyDataToQueue_1
   1454          			{
   1455          				/* An item is not being added but overwritten, so subtract
   1456          				one from the recorded number of items in the queue so when
   1457          				one is added again below the number of recorded items remains
   1458          				correct. */
   1459          				--( pxQueue->uxMessagesWaiting );
   \   00000066   0x6BA0             LDR      R0,[R4, #+56]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x63A0             STR      R0,[R4, #+56]
   1460          			}
   1461          		}
   1462          	}
   1463          
   1464          	++( pxQueue->uxMessagesWaiting );
   \                     ??prvCopyDataToQueue_1: (+1)
   \   0000006C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x63A0             STR      R0,[R4, #+56]
   1465          }
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1466          /*-----------------------------------------------------------*/
   1467          

   \                                 In section .text, align 2, keep-with-next
   1468          static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
   1469          {
   \                     prvCopyDataFromQueue: (+1)
   \   00000000   0x4603             MOV      R3,R0
   \   00000002   0x4608             MOV      R0,R1
   1470          	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
   \   00000004   0x6819             LDR      R1,[R3, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD00C             BEQ.N    ??prvCopyDataFromQueue_0
   1471          	{
   1472          		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   \   0000000A   0x68D9             LDR      R1,[R3, #+12]
   \   0000000C   0x6C1A             LDR      R2,[R3, #+64]
   \   0000000E   0x4411             ADD      R1,R1,R2
   \   00000010   0x60D9             STR      R1,[R3, #+12]
   1473          		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   \   00000012   0x685A             LDR      R2,[R3, #+4]
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD301             BCC.N    ??prvCopyDataFromQueue_1
   1474          		{
   1475          			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   \   00000018   0x6819             LDR      R1,[R3, #+0]
   \   0000001A   0x60D9             STR      R1,[R3, #+12]
   1476          		}
   1477          		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   \                     ??prvCopyDataFromQueue_1: (+1)
   \   0000001C   0x6C1A             LDR      R2,[R3, #+64]
   \   0000001E   0x68D9             LDR      R1,[R3, #+12]
   \   00000020   0x.... 0x....      B.W      __aeabi_memcpy
   1478          	}
   1479          }
   \                     ??prvCopyDataFromQueue_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
   1480          /*-----------------------------------------------------------*/
   1481          

   \                                 In section .text, align 2, keep-with-next
   1482          static void prvUnlockQueue( xQUEUE *pxQueue )
   1483          {
   \                     prvUnlockQueue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1484          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
   1485          
   1486          	/* The lock counts contains the number of extra data items placed or
   1487          	removed from the queue while the queue was locked.  When a queue is
   1488          	locked items can be added or removed, but the event lists cannot be
   1489          	updated. */
   1490          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   \   00000008   0xE00A             B.N      ??prvUnlockQueue_0
   1491          	{
   1492          		/* See if data was added to the queue while it was locked. */
   1493          		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   1494          		{
   1495          			/* Data was posted while the queue was locked.  Are any tasks
   1496          			blocked waiting for data to become available? */
   1497          			#if ( configUSE_QUEUE_SETS == 1 )
   1498          			{
   1499          				if( pxQueue->pxQueueSetContainer != NULL )
   1500          				{
   1501          					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
   1502          					{
   1503          						/* The queue is a member of a queue set, and posting to
   1504          						the queue set caused a higher priority task to unblock.
   1505          						A context switch is required. */
   1506          						vTaskMissedYield();
   1507          					}
   1508          				}
   1509          				else
   1510          				{
   1511          					/* Tasks that are removed from the event list will get added to
   1512          					the pending ready list as the scheduler is still suspended. */
   1513          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1514          					{
   1515          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1516          						{
   1517          							/* The task waiting has a higher priority so record that a
   1518          							context	switch is required. */
   1519          							vTaskMissedYield();
   1520          						}
   1521          					}
   1522          					else
   1523          					{
   1524          						break;
   1525          					}
   1526          				}
   1527          			}
   1528          			#else /* configUSE_QUEUE_SETS */
   1529          			{
   1530          				/* Tasks that are removed from the event list will get added to
   1531          				the pending ready list as the scheduler is still suspended. */
   1532          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1533          				{
   1534          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \                     ??prvUnlockQueue_1: (+1)
   \   0000000A   0xF104 0x0024      ADD      R0,R4,#+36
   \   0000000E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??prvUnlockQueue_2
   1535          					{
   1536          						/* The task waiting has a higher priority so record that a
   1537          						context	switch is required. */
   1538          						vTaskMissedYield();
   \   00000016   0x.... 0x....      BL       vTaskMissedYield
   1539          					}
   1540          				}
   1541          				else
   1542          				{
   1543          					break;
   1544          				}
   1545          			}
   1546          			#endif /* configUSE_QUEUE_SETS */
   1547          
   1548          			--( pxQueue->xTxLock );
   \                     ??prvUnlockQueue_2: (+1)
   \   0000001A   0x6CA0             LDR      R0,[R4, #+72]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x64A0             STR      R0,[R4, #+72]
   \                     ??prvUnlockQueue_0: (+1)
   \   00000020   0x6CA0             LDR      R0,[R4, #+72]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xDB02             BLT.N    ??prvUnlockQueue_3
   \   00000026   0x6A60             LDR      R0,[R4, #+36]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1EE             BNE.N    ??prvUnlockQueue_1
   1549          		}
   1550          
   1551          		pxQueue->xTxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_3: (+1)
   \   0000002C   0xF04F 0x35FF      MOV      R5,#-1
   \   00000030   0x64A5             STR      R5,[R4, #+72]
   1552          	}
   1553          	taskEXIT_CRITICAL();
   \   00000032   0x.... 0x....      BL       vPortExitCritical
   1554          
   1555          	/* Do the same for the Rx lock. */
   1556          	taskENTER_CRITICAL();
   \   00000036   0x.... 0x....      BL       vPortEnterCritical
   \   0000003A   0xE00A             B.N      ??prvUnlockQueue_4
   1557          	{
   1558          		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   1559          		{
   1560          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1561          			{
   1562          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \                     ??prvUnlockQueue_5: (+1)
   \   0000003C   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000040   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ.N    ??prvUnlockQueue_6
   1563          				{
   1564          					vTaskMissedYield();
   \   00000048   0x.... 0x....      BL       vTaskMissedYield
   1565          				}
   1566          
   1567          				--( pxQueue->xRxLock );
   \                     ??prvUnlockQueue_6: (+1)
   \   0000004C   0x6C60             LDR      R0,[R4, #+68]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x6460             STR      R0,[R4, #+68]
   1568          			}
   \                     ??prvUnlockQueue_4: (+1)
   \   00000052   0x6C60             LDR      R0,[R4, #+68]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xDB02             BLT.N    ??prvUnlockQueue_7
   \   00000058   0x6920             LDR      R0,[R4, #+16]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1EE             BNE.N    ??prvUnlockQueue_5
   1569          			else
   1570          			{
   1571          				break;
   1572          			}
   1573          		}
   1574          
   1575          		pxQueue->xRxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_7: (+1)
   \   0000005E   0x6465             STR      R5,[R4, #+68]
   1576          	}
   1577          	taskEXIT_CRITICAL();
   \   00000060   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000064   0x.... 0x....      B.W      vPortExitCritical
   1578          }
   1579          /*-----------------------------------------------------------*/
   1580          

   \                                 In section .text, align 2, keep-with-next
   1581          static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
   1582          {
   \                     prvIsQueueEmpty: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1583          signed portBASE_TYPE xReturn;
   1584          
   1585          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1586          	{
   1587          		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
   \   00000008   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000A   0x1E44             SUBS     R4,R0,#+1
   \   0000000C   0x41A4             SBCS     R4,R4,R4
   \   0000000E   0x0FE4             LSRS     R4,R4,#+31
   1588          		{
   1589          			xReturn = pdTRUE;
   1590          		}
   1591          		else
   1592          		{
   1593          			xReturn = pdFALSE;
   1594          		}
   1595          	}
   1596          	taskEXIT_CRITICAL();
   \   00000010   0x.... 0x....      BL       vPortExitCritical
   1597          
   1598          	return xReturn;
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1599          }
   1600          /*-----------------------------------------------------------*/
   1601          

   \                                 In section .text, align 2, keep-with-next
   1602          signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
   1603          {
   1604          signed portBASE_TYPE xReturn;
   1605          
   1606          	configASSERT( xQueue );
   1607          	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
   \                     xQueueIsQueueEmptyFromISR: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
   1608          	{
   1609          		xReturn = pdTRUE;
   1610          	}
   1611          	else
   1612          	{
   1613          		xReturn = pdFALSE;
   1614          	}
   1615          
   1616          	return xReturn;
   \   00000008   0x4770             BX       LR               ;; return
   1617          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   1618          /*-----------------------------------------------------------*/
   1619          

   \                                 In section .text, align 2, keep-with-next
   1620          static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
   1621          {
   \                     prvIsQueueFull: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1622          signed portBASE_TYPE xReturn;
   1623          
   1624          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1625          	{
   1626          		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   \   00000008   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000A   0x6BE1             LDR      R1,[R4, #+60]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD101             BNE.N    ??prvIsQueueFull_0
   1627          		{
   1628          			xReturn = pdTRUE;
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xE000             B.N      ??prvIsQueueFull_1
   1629          		}
   1630          		else
   1631          		{
   1632          			xReturn = pdFALSE;
   \                     ??prvIsQueueFull_0: (+1)
   \   00000014   0x2400             MOVS     R4,#+0
   1633          		}
   1634          	}
   1635          	taskEXIT_CRITICAL();
   \                     ??prvIsQueueFull_1: (+1)
   \   00000016   0x.... 0x....      BL       vPortExitCritical
   1636          
   1637          	return xReturn;
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1638          }
   1639          /*-----------------------------------------------------------*/
   1640          

   \                                 In section .text, align 2, keep-with-next
   1641          signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
   1642          {
   1643          signed portBASE_TYPE xReturn;
   1644          
   1645          	configASSERT( xQueue );
   1646          	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
   \                     xQueueIsQueueFullFromISR: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6BC0             LDR      R0,[R0, #+60]
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xD101             BNE.N    ??xQueueIsQueueFullFromISR_0
   1647          	{
   1648          		xReturn = pdTRUE;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   1649          	}
   1650          	else
   1651          	{
   1652          		xReturn = pdFALSE;
   \                     ??xQueueIsQueueFullFromISR_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   1653          	}
   1654          
   1655          	return xReturn;
   \   0000000E   0x4770             BX       LR               ;; return
   1656          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   1657          /*-----------------------------------------------------------*/
   1658          
   1659          #if ( configUSE_CO_ROUTINES == 1 )
   1660          
   1661          	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
   1662          	{
   1663          	signed portBASE_TYPE xReturn;
   1664          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1665          
   1666          		/* If the queue is already full we may have to block.  A critical section
   1667          		is required to prevent an interrupt removing something from the queue
   1668          		between the check to see if the queue is full and blocking on the queue. */
   1669          		portDISABLE_INTERRUPTS();
   1670          		{
   1671          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   1672          			{
   1673          				/* The queue is full - do we want to block or just leave without
   1674          				posting? */
   1675          				if( xTicksToWait > ( portTickType ) 0 )
   1676          				{
   1677          					/* As this is called from a coroutine we cannot block directly, but
   1678          					return indicating that we need to block. */
   1679          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
   1680          					portENABLE_INTERRUPTS();
   1681          					return errQUEUE_BLOCKED;
   1682          				}
   1683          				else
   1684          				{
   1685          					portENABLE_INTERRUPTS();
   1686          					return errQUEUE_FULL;
   1687          				}
   1688          			}
   1689          		}
   1690          		portENABLE_INTERRUPTS();
   1691          
   1692          		portDISABLE_INTERRUPTS();
   1693          		{
   1694          			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   1695          			{
   1696          				/* There is room in the queue, copy the data into the queue. */
   1697          				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   1698          				xReturn = pdPASS;
   1699          
   1700          				/* Were any co-routines waiting for data to become available? */
   1701          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1702          				{
   1703          					/* In this instance the co-routine could be placed directly
   1704          					into the ready list as we are within a critical section.
   1705          					Instead the same pending ready list mechanism is used as if
   1706          					the event were caused from within an interrupt. */
   1707          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1708          					{
   1709          						/* The co-routine waiting has a higher priority so record
   1710          						that a yield might be appropriate. */
   1711          						xReturn = errQUEUE_YIELD;
   1712          					}
   1713          				}
   1714          			}
   1715          			else
   1716          			{
   1717          				xReturn = errQUEUE_FULL;
   1718          			}
   1719          		}
   1720          		portENABLE_INTERRUPTS();
   1721          
   1722          		return xReturn;
   1723          	}
   1724          
   1725          #endif /* configUSE_CO_ROUTINES */
   1726          /*-----------------------------------------------------------*/
   1727          
   1728          #if ( configUSE_CO_ROUTINES == 1 )
   1729          
   1730          	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
   1731          	{
   1732          	signed portBASE_TYPE xReturn;
   1733          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1734          
   1735          		/* If the queue is already empty we may have to block.  A critical section
   1736          		is required to prevent an interrupt adding something to the queue
   1737          		between the check to see if the queue is empty and blocking on the queue. */
   1738          		portDISABLE_INTERRUPTS();
   1739          		{
   1740          			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
   1741          			{
   1742          				/* There are no messages in the queue, do we want to block or just
   1743          				leave with nothing? */
   1744          				if( xTicksToWait > ( portTickType ) 0 )
   1745          				{
   1746          					/* As this is a co-routine we cannot block directly, but return
   1747          					indicating that we need to block. */
   1748          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
   1749          					portENABLE_INTERRUPTS();
   1750          					return errQUEUE_BLOCKED;
   1751          				}
   1752          				else
   1753          				{
   1754          					portENABLE_INTERRUPTS();
   1755          					return errQUEUE_FULL;
   1756          				}
   1757          			}
   1758          		}
   1759          		portENABLE_INTERRUPTS();
   1760          
   1761          		portDISABLE_INTERRUPTS();
   1762          		{
   1763          			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   1764          			{
   1765          				/* Data is available from the queue. */
   1766          				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   1767          				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
   1768          				{
   1769          					pxQueue->u.pcReadFrom = pxQueue->pcHead;
   1770          				}
   1771          				--( pxQueue->uxMessagesWaiting );
   1772          				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   1773          
   1774          				xReturn = pdPASS;
   1775          
   1776          				/* Were any co-routines waiting for space to become available? */
   1777          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1778          				{
   1779          					/* In this instance the co-routine could be placed directly
   1780          					into the ready list as we are within a critical section.
   1781          					Instead the same pending ready list mechanism is used as if
   1782          					the event were caused from within an interrupt. */
   1783          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1784          					{
   1785          						xReturn = errQUEUE_YIELD;
   1786          					}
   1787          				}
   1788          			}
   1789          			else
   1790          			{
   1791          				xReturn = pdFAIL;
   1792          			}
   1793          		}
   1794          		portENABLE_INTERRUPTS();
   1795          
   1796          		return xReturn;
   1797          	}
   1798          
   1799          #endif /* configUSE_CO_ROUTINES */
   1800          /*-----------------------------------------------------------*/
   1801          
   1802          #if ( configUSE_CO_ROUTINES == 1 )
   1803          
   1804          	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
   1805          	{
   1806          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1807          
   1808          		/* Cannot block within an ISR so if there is no space on the queue then
   1809          		exit without doing anything. */
   1810          		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   1811          		{
   1812          			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   1813          
   1814          			/* We only want to wake one co-routine per ISR, so check that a
   1815          			co-routine has not already been woken. */
   1816          			if( xCoRoutinePreviouslyWoken == pdFALSE )
   1817          			{
   1818          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1819          				{
   1820          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1821          					{
   1822          						return pdTRUE;
   1823          					}
   1824          				}
   1825          			}
   1826          		}
   1827          
   1828          		return xCoRoutinePreviouslyWoken;
   1829          	}
   1830          
   1831          #endif /* configUSE_CO_ROUTINES */
   1832          /*-----------------------------------------------------------*/
   1833          
   1834          #if ( configUSE_CO_ROUTINES == 1 )
   1835          
   1836          	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
   1837          	{
   1838          	signed portBASE_TYPE xReturn;
   1839          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1840          
   1841          		/* We cannot block from an ISR, so check there is data available. If
   1842          		not then just leave without doing anything. */
   1843          		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   1844          		{
   1845          			/* Copy the data from the queue. */
   1846          			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   1847          			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
   1848          			{
   1849          				pxQueue->u.pcReadFrom = pxQueue->pcHead;
   1850          			}
   1851          			--( pxQueue->uxMessagesWaiting );
   1852          			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   1853          
   1854          			if( ( *pxCoRoutineWoken ) == pdFALSE )
   1855          			{
   1856          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1857          				{
   1858          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1859          					{
   1860          						*pxCoRoutineWoken = pdTRUE;
   1861          					}
   1862          				}
   1863          			}
   1864          
   1865          			xReturn = pdPASS;
   1866          		}
   1867          		else
   1868          		{
   1869          			xReturn = pdFAIL;
   1870          		}
   1871          
   1872          		return xReturn;
   1873          	}
   1874          
   1875          #endif /* configUSE_CO_ROUTINES */
   1876          /*-----------------------------------------------------------*/
   1877          
   1878          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   1879          
   1880          	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
   1881          	{
   1882          	unsigned portBASE_TYPE ux;
   1883          
   1884          		/* See if there is an empty space in the registry.  A NULL name denotes
   1885          		a free slot. */
   1886          		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
   1887          		{
   1888          			if( xQueueRegistry[ ux ].pcQueueName == NULL )
   1889          			{
   1890          				/* Store the information on this queue. */
   1891          				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   1892          				xQueueRegistry[ ux ].xHandle = xQueue;
   1893          				break;
   1894          			}
   1895          		}
   1896          	}
   1897          
   1898          #endif /* configQUEUE_REGISTRY_SIZE */
   1899          /*-----------------------------------------------------------*/
   1900          
   1901          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   1902          
   1903          	void vQueueUnregisterQueue( xQueueHandle xQueue )
   1904          	{
   1905          	unsigned portBASE_TYPE ux;
   1906          
   1907          		/* See if the handle of the queue being unregistered in actually in the
   1908          		registry. */
   1909          		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
   1910          		{
   1911          			if( xQueueRegistry[ ux ].xHandle == xQueue )
   1912          			{
   1913          				/* Set the name to NULL to show that this slot if free again. */
   1914          				xQueueRegistry[ ux ].pcQueueName = NULL;
   1915          				break;
   1916          			}
   1917          		}
   1918          
   1919          	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   1920          
   1921          #endif /* configQUEUE_REGISTRY_SIZE */
   1922          /*-----------------------------------------------------------*/
   1923          
   1924          #if ( configUSE_TIMERS == 1 )
   1925          

   \                                 In section .text, align 2, keep-with-next
   1926          	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
   1927          	{
   \                     vQueueWaitForMessageRestricted: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1928          	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
   1929          
   1930          		/* This function should not be called by application code hence the
   1931          		'Restricted' in its name.  It is not part of the public API.  It is
   1932          		designed for use by kernel code, and has special calling requirements.
   1933          		It can result in vListInsert() being called on a list that can only
   1934          		possibly ever have one item in it, so the list will be fast, but even
   1935          		so it should be called with the scheduler locked and not from a critical
   1936          		section. */
   1937          
   1938          		/* Only do anything if there are no messages in the queue.  This function
   1939          		will not actually cause the task to block, just place it on a blocked
   1940          		list.  It will not block until the scheduler is unlocked - at which
   1941          		time a yield will be performed.  If an item is added to the queue while
   1942          		the queue is locked, and the calling task blocks on the queue, then the
   1943          		calling task will be immediately unblocked when the queue is unlocked. */
   1944          		prvLockQueue( pxQueue );
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
   \   0000000A   0x6C60             LDR      R0,[R4, #+68]
   \   0000000C   0xF110 0x0F01      CMN      R0,#+1
   \   00000010   0xD101             BNE.N    ??vQueueWaitForMessageRestricted_0
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6460             STR      R0,[R4, #+68]
   \                     ??vQueueWaitForMessageRestricted_0: (+1)
   \   00000016   0x6CA0             LDR      R0,[R4, #+72]
   \   00000018   0xF110 0x0F01      CMN      R0,#+1
   \   0000001C   0xD101             BNE.N    ??vQueueWaitForMessageRestricted_1
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x64A0             STR      R0,[R4, #+72]
   \                     ??vQueueWaitForMessageRestricted_1: (+1)
   \   00000022   0x.... 0x....      BL       vPortExitCritical
   1945          		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
   \   00000026   0x6BA0             LDR      R0,[R4, #+56]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD104             BNE.N    ??vQueueWaitForMessageRestricted_2
   1946          		{
   1947          			/* There is nothing in the queue, block for the specified period. */
   1948          			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0xF104 0x0024      ADD      R0,R4,#+36
   \   00000032   0x.... 0x....      BL       vTaskPlaceOnEventListRestricted
   1949          		}
   1950          		prvUnlockQueue( pxQueue );
   \                     ??vQueueWaitForMessageRestricted_2: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000003C   0x....             B.N      prvUnlockQueue
   1951          	}
   1952          
   1953          #endif /* configUSE_TIMERS */
   1954          /*-----------------------------------------------------------*/
   1955          
   1956          #if ( configUSE_QUEUE_SETS == 1 )
   1957          
   1958          	xQueueSetHandle xQueueCreateSet( unsigned portBASE_TYPE uxEventQueueLength )
   1959          	{
   1960          	xQueueSetHandle pxQueue;
   1961          
   1962          		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( xQUEUE * ), queueQUEUE_TYPE_SET );
   1963          
   1964          		return pxQueue;
   1965          	}
   1966          
   1967          #endif /* configUSE_QUEUE_SETS */
   1968          /*-----------------------------------------------------------*/
   1969          
   1970          #if ( configUSE_QUEUE_SETS == 1 )
   1971          
   1972          	portBASE_TYPE xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
   1973          	{
   1974          	portBASE_TYPE xReturn;
   1975          
   1976          		if( ( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
   1977          		{
   1978          			/* Cannot add a queue/semaphore to more than one queue set. */
   1979          			xReturn = pdFAIL;
   1980          		}
   1981          		else if( ( ( xQUEUE * ) xQueueOrSemaphore )->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
   1982          		{
   1983          			/* Cannot add a queue/semaphore to a queue set if there are already
   1984          			items in the queue/semaphore. */
   1985          			xReturn = pdFAIL;
   1986          		}
   1987          		else
   1988          		{
   1989          			taskENTER_CRITICAL();
   1990          			{
   1991          				( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
   1992          			}
   1993          			taskEXIT_CRITICAL();
   1994          			xReturn = pdPASS;
   1995          		}
   1996          
   1997          		return xReturn;
   1998          	}
   1999          
   2000          #endif /* configUSE_QUEUE_SETS */
   2001          /*-----------------------------------------------------------*/
   2002          
   2003          #if ( configUSE_QUEUE_SETS == 1 )
   2004          
   2005          	portBASE_TYPE xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
   2006          	{
   2007          	portBASE_TYPE xReturn;
   2008          	xQUEUE * const pxQueueOrSemaphore = ( xQUEUE * ) xQueueOrSemaphore;
   2009          
   2010          		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
   2011          		{
   2012          			/* The queue was not a member of the set. */
   2013          			xReturn = pdFAIL;
   2014          		}
   2015          		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
   2016          		{
   2017          			/* It is dangerous to remove a queue from a set when the queue is
   2018          			not empty because the queue set will still hold pending events for
   2019          			the queue. */
   2020          			xReturn = pdFAIL;
   2021          		}
   2022          		else
   2023          		{
   2024          			taskENTER_CRITICAL();
   2025          			{
   2026          				/* The queue is no longer contained in the set. */
   2027          				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
   2028          			}
   2029          			taskEXIT_CRITICAL();
   2030          			xReturn = pdPASS;
   2031          		}
   2032          
   2033          		return xReturn;
   2034          	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
   2035          
   2036          #endif /* configUSE_QUEUE_SETS */
   2037          /*-----------------------------------------------------------*/
   2038          
   2039          #if ( configUSE_QUEUE_SETS == 1 )
   2040          
   2041          	xQueueSetMemberHandle xQueueSelectFromSet( xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks )
   2042          	{
   2043          	xQueueSetMemberHandle xReturn = NULL;
   2044          
   2045          		( void ) xQueueGenericReceive( ( xQueueHandle ) xQueueSet, &xReturn, xBlockTimeTicks, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2046          		return xReturn;
   2047          	}
   2048          
   2049          #endif /* configUSE_QUEUE_SETS */
   2050          /*-----------------------------------------------------------*/
   2051          
   2052          #if ( configUSE_QUEUE_SETS == 1 )
   2053          
   2054          	xQueueSetMemberHandle xQueueSelectFromSetFromISR( xQueueSetHandle xQueueSet )
   2055          	{
   2056          	xQueueSetMemberHandle xReturn = NULL;
   2057          
   2058          		( void ) xQueueReceiveFromISR( ( xQueueHandle ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2059          		return xReturn;
   2060          	}
   2061          
   2062          #endif /* configUSE_QUEUE_SETS */
   2063          /*-----------------------------------------------------------*/
   2064          
   2065          #if ( configUSE_QUEUE_SETS == 1 )
   2066          
   2067          	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition )
   2068          	{
   2069          	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   2070          	portBASE_TYPE xReturn = pdFALSE;
   2071          
   2072          		configASSERT( pxQueueSetContainer );
   2073          		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   2074          
   2075          		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   2076          		{
   2077          			traceQUEUE_SEND( pxQueueSetContainer );
   2078          			/* The data copies is the handle of the queue that contains data. */
   2079          			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
   2080          			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   2081          			{
   2082          				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   2083          				{
   2084          					/* The task waiting has a higher priority */
   2085          					xReturn = pdTRUE;
   2086          				}
   2087          			}
   2088          		}
   2089          
   2090          		return xReturn;
   2091          	}
   2092          
   2093          #endif /* configUSE_QUEUE_SETS */
   2094          
   2095          
   2096          
   2097          
   2098          
   2099          
   2100          
   2101          
   2102          
   2103          
   2104          
   2105          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvCopyDataFromQueue
         0   -> __aeabi_memcpy
      16   prvCopyDataToQueue
        16   -> __aeabi_memcpy
        16   -> vTaskPriorityDisinherit
       8   prvIsQueueEmpty
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   prvIsQueueFull
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   prvUnlockQueue
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vPortExitCritical
        16   -> vTaskMissedYield
        16   -> xTaskRemoveFromEventList
       0   ucQueueGetQueueNumber
       0   ucQueueGetQueueType
       8   uxQueueMessagesWaiting
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   uxQueueMessagesWaitingFromISR
       8   uxQueueSpacesAvailable
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   vQueueDelete
         0   -> vPortFree
         8   -> vPortFree
       0   vQueueSetQueueNumber
      16   vQueueWaitForMessageRestricted
         0   -> prvUnlockQueue
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskPlaceOnEventListRestricted
       8   xQueueCreateCountingSemaphore
         8   -> xQueueGenericCreate
      16   xQueueCreateMutex
        16   -> pvPortMalloc
        16   -> vListInitialise
        16   -> xQueueGenericSend
      24   xQueueGenericCreate
        24   -> pvPortMalloc
        24   -> vPortFree
        24   -> xQueueGenericReset
      32   xQueueGenericReceive
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
        32   -> vTaskPlaceOnEventList
        32   -> vTaskPriorityInherit
        32   -> vTaskSetTimeOutState
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetCurrentTaskHandle
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      16   xQueueGenericReset
        16   -> vListInitialise
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
        16   -> xTaskRemoveFromEventList
      32   xQueueGenericSend
        32   -> prvCopyDataToQueue
        32   -> prvIsQueueFull
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSetTimeOutState
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      24   xQueueGenericSendFromISR
        24   -> prvCopyDataToQueue
        24   -> ulPortSetInterruptMask
        24   -> vPortClearInterruptMask
        24   -> xTaskRemoveFromEventList
       8   xQueueGiveMutexRecursive
         8   -> xQueueGenericSend
         8   -> xTaskGetCurrentTaskHandle
       0   xQueueIsQueueEmptyFromISR
       0   xQueueIsQueueFullFromISR
      24   xQueuePeekFromISR
        24   -> prvCopyDataFromQueue
        24   -> ulPortSetInterruptMask
        24   -> vPortClearInterruptMask
      24   xQueueReceiveFromISR
        24   -> prvCopyDataFromQueue
        24   -> ulPortSetInterruptMask
        24   -> vPortClearInterruptMask
        24   -> xTaskRemoveFromEventList
      16   xQueueTakeMutexRecursive
        16   -> xQueueGenericReceive
        16   -> xTaskGetCurrentTaskHandle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  prvCopyDataFromQueue
     116  prvCopyDataToQueue
      24  prvIsQueueEmpty
      30  prvIsQueueFull
     104  prvUnlockQueue
       6  ucQueueGetQueueNumber
       6  ucQueueGetQueueType
      18  uxQueueMessagesWaiting
       4  uxQueueMessagesWaitingFromISR
      22  uxQueueSpacesAvailable
      20  vQueueDelete
       6  vQueueSetQueueNumber
      62  vQueueWaitForMessageRestricted
      20  xQueueCreateCountingSemaphore
      78  xQueueCreateMutex
      84  xQueueGenericCreate
     270  xQueueGenericReceive
     104  xQueueGenericReset
     208  xQueueGenericSend
     102  xQueueGenericSendFromISR
      42  xQueueGiveMutexRecursive
      10  xQueueIsQueueEmptyFromISR
      16  xQueueIsQueueFullFromISR
      46  xQueuePeekFromISR
      92  xQueueReceiveFromISR
      50  xQueueTakeMutexRecursive

 
 1 578 bytes in section .text
 
 1 578 bytes of CODE memory

Errors: none
Warnings: none
