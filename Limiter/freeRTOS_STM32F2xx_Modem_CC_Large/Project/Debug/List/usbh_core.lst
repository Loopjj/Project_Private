###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_core.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_core.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_core.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_core.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_core.c 
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file implements the functions for the core state machine process
      8            *          the enumeration and the control transfer process
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */ 
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "includes.h"
     30          #include "usbh_ioreq.h"
     31          #include "usb_bsp.h"
     32          #include "usbh_hcs.h"
     33          #include "usbh_stdreq.h"
     34          #include "usbh_core.h"
     35          #include "usb_hcd_int.h"
     36          
     37          
     38          uint8_t USB_RespWaitCount;
     39          /** @addtogroup USBH_LIB
     40            * @{
     41            */
     42          
     43          /** @addtogroup USBH_LIB_CORE
     44          * @{
     45          */
     46          
     47          /** @defgroup USBH_CORE 
     48            * @brief TThis file handles the basic enumaration when a device is connected 
     49            *          to the host.
     50            * @{
     51            */ 
     52          
     53          /** @defgroup USBH_CORE_Private_TypesDefinitions
     54            * @{
     55            */ 
     56          uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev); 
     57          uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev); 
     58          uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev); 
     59          

   \                                 In section .data, align 4
     60          USBH_HCD_INT_cb_TypeDef USBH_HCD_INT_cb = 
   \                     USBH_HCD_INT_cb:
   \   00000000   0x........         DC32 USBH_SOF, USBH_Connected, USBH_Disconnected
   \              0x........   
   \              0x........   
     61          {
     62            USBH_SOF,
     63            USBH_Connected, 
     64            USBH_Disconnected,    
     65          };
     66          

   \                                 In section .data, align 4
     67          USBH_HCD_INT_cb_TypeDef  *USBH_HCD_INT_fops = &USBH_HCD_INT_cb;
   \                     USBH_HCD_INT_fops:
   \   00000000   0x........         DC32 USBH_HCD_INT_cb
     68          /**
     69            * @}
     70            */ 
     71          
     72          
     73          /** @defgroup USBH_CORE_Private_Defines
     74            * @{
     75            */ 
     76          /**
     77            * @}
     78            */ 
     79          
     80          
     81          /** @defgroup USBH_CORE_Private_Macros
     82            * @{
     83            */ 
     84          /**
     85            * @}
     86            */ 
     87          
     88          
     89          /** @defgroup USBH_CORE_Private_Variables
     90            * @{
     91            */ 
     92          /**
     93            * @}
     94            */ 
     95          
     96          
     97          /** @defgroup USBH_CORE_Private_FunctionPrototypes
     98            * @{
     99            */
    100          static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost);
    101          USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost);
    102          
    103          /**
    104            * @}
    105            */ 
    106          
    107          
    108          /** @defgroup USBH_CORE_Private_Functions
    109            * @{
    110            */ 
    111          
    112          
    113          /**
    114            * @brief  USBH_Connected
    115            *         USB Connect callback function from the Interrupt. 
    116            * @param  selected device
    117            * @retval Status
    118          */

   \                                 In section .text, align 2, keep-with-next
    119          uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
    120          {
    121            pdev->host.ConnSts = 1;
   \                     USBH_Connected: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF8C0 0x1310      STR      R1,[R0, #+784]
    122            return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    123          }
    124          
    125          /**
    126          * @brief  USBH_Disconnected
    127          *         USB Disconnect callback function from the Interrupt. 
    128          * @param  selected device
    129          * @retval Status
    130          */
    131          

   \                                 In section .text, align 2, keep-with-next
    132          uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
    133          {
    134            pdev->host.ConnSts = 0;
   \                     USBH_Disconnected: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF8C0 0x1310      STR      R1,[R0, #+784]
    135            return 0;  
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    136          }
    137          
    138          /**
    139            * @brief  USBH_SOF
    140            *         USB SOF callback function from the Interrupt. 
    141            * @param  selected device
    142            * @retval Status
    143            */
    144          

   \                                 In section .text, align 2, keep-with-next
    145          uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
    146          {
    147            /* This callback could be used to implement a scheduler process */
    148            return 0;  
   \                     USBH_SOF: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    149          }
    150          /**
    151            * @brief  USBH_Init
    152            *         Host hardware and stack initializations 
    153            * @param  class_cb: Class callback structure address
    154            * @param  usr_cb: User callback structure address
    155            * @retval None
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
    158                         USB_OTG_CORE_ID_TypeDef coreID,
    159                         USBH_HOST *phost,               
    160                         USBH_Class_cb_TypeDef *class_cb, 
    161                         USBH_Usr_cb_TypeDef *usr_cb)
    162          {
   \                     USBH_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    163               
    164            /* Hardware Init */
    165            USB_OTG_BSP_Init(pdev);  
   \   0000000A   0x.... 0x....      BL       USB_OTG_BSP_Init
    166            
    167            /* configure GPIO pin used for switching VBUS power */
    168            USB_OTG_BSP_ConfigVBUS(0);  
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       USB_OTG_BSP_ConfigVBUS
    169            
    170            
    171            /* Host de-initializations */
    172            USBH_DeInit(pdev, phost);
   \   00000014   0x4631             MOV      R1,R6
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       USBH_DeInit
    173            
    174            /*Register class and user callbacks */
    175            phost->class_cb = class_cb;
   \   0000001C   0x67F7             STR      R7,[R6, #+124]
    176            phost->usr_cb = usr_cb;  
   \   0000001E   0x9806             LDR      R0,[SP, #+24]
   \   00000020   0xF8C6 0x0080      STR      R0,[R6, #+128]
    177              
    178            /* Start the USB OTG core */     
    179             HCD_Init(pdev , coreID);
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       HCD_Init
    180             
    181            /* Upon Init call usr call back */
    182            phost->usr_cb->Init();
   \   0000002C   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4780             BLX      R0
    183            
    184            /* Enable Interrupts */
    185            USB_OTG_BSP_EnableInterrupt(pdev);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000003A   0x.... 0x....      B.W      USB_OTG_BSP_EnableInterrupt
    186          }
    187          
    188          /**
    189            * @brief  USBH_DeInit 
    190            *         Re-Initialize Host
    191            * @param  None 
    192            * @retval status: USBH_Status
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    195          {
   \                     USBH_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    196            /* Software Init */
    197            
    198            phost->gState = HOST_IDLE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7028             STRB     R0,[R5, #+0]
    199            phost->gStateBkp = HOST_IDLE; 
   \   0000000A   0x7068             STRB     R0,[R5, #+1]
    200            phost->EnumState = ENUM_IDLE;
   \   0000000C   0x70A8             STRB     R0,[R5, #+2]
    201            phost->RequestState = CMD_SEND;  
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x70E8             STRB     R0,[R5, #+3]
    202            
    203            phost->Control.state = CTRL_SETUP;
   \   00000012   0x7728             STRB     R0,[R5, #+28]
    204            phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x71A8             STRB     R0,[R5, #+6]
    205            
    206            phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF885 0x0020      STRB     R0,[R5, #+32]
    207            phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF885 0x0021      STRB     R0,[R5, #+33]
    208            
    209            USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
   \   00000024   0x7929             LDRB     R1,[R5, #+4]
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       USBH_Free_Channel
    210            USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
   \   0000002C   0x7969             LDRB     R1,[R5, #+5]
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       USBH_Free_Channel
    211            return USBH_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    212          }
    213          
    214          

   \                                 In section .text, align 2, keep-with-next
    215          void TM_DELAY_Init(void)
    216          {
    217          	TmrStop(TMR_USBINTERVAL);
   \                     TM_DELAY_Init: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0x.... 0x....      B.W      TmrStop
    218          }

   \                                 In section .text, align 2, keep-with-next
    219          void TM_DELAY_SetTime(uint32_t interval)
    220          {
   \                     TM_DELAY_SetTime: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    221          	TmrStop(TMR_USBINTERVAL);
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       TmrStop
    222          	TmrSetT(TMR_USBINTERVAL, interval);
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x.... 0x....      BL       TmrSetT
    223          	TmrStart(TMR_USBINTERVAL);
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      TmrStart
    224          }

   \                                 In section .text, align 2, keep-with-next
    225          uint32_t TM_DELAY_Time(void)
    226          {
    227          	return TmrChk(TMR_USBINTERVAL);
   \                     TM_DELAY_Time: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0x.... 0x....      B.W      TmrChk
    228          }
    229          
    230          /**
    231          * @brief  USBH_Process
    232          *         USB Host core main state machine process
    233          * @param  None 
    234          * @retval None
    235          */

   \                                 In section .text, align 4, keep-with-next
    236          void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
    237          {
   \                     USBH_Process: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    238          	//
    239          	static uint8_t nWaitTime=0;
    240          	//
    241            volatile USBH_Status status = USBH_FAIL;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    242            
    243            
    244            /* check for Host port events */
    245            if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD106             BNE.N    ??USBH_Process_1
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0xD003             BEQ.N    ??USBH_Process_1
    246            {
    247              if(phost->gState != HOST_DEV_DISCONNECTED) 
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD001             BEQ.N    ??USBH_Process_1
    248              {
    249                phost->gState = HOST_DEV_DISCONNECTED;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7020             STRB     R0,[R4, #+0]
    250              }
    251            }
    252          
    253              
    254            switch (phost->gState)
   \                     ??USBH_Process_1: (+1)
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x280A             CMP      R0,#+10
   \   00000028   0xF200 0x80D0      BHI.W    ??USBH_Process_2
   \   0000002C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_Process_0:
   \   00000030   0x06 0x23          DC8      0x6,0x23,0xB7,0xCE
   \              0xB7 0xCE    
   \   00000034   0x60 0x7F          DC8      0x60,0x7F,0x93,0xA0
   \              0x93 0xA0    
   \   00000038   0x6E 0xCE          DC8      0x6E,0xCE,0xA5,0x0
   \              0xA5 0x00    
    255            {
    256            
    257            case HOST_IDLE :
    258              if(nWaitTime == 0)
   \                     ??USBH_Process_3: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R6,??DataTable3_1
   \   00000040   0x7830             LDRB     R0,[R6, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD10D             BNE.N    ??USBH_Process_4
    259          	{
    260          		if (HCD_IsDeviceConnected(pdev))  
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD005             BEQ.N    ??USBH_Process_5
    261          		{
    262          			TM_DELAY_SetTime(200);
   \   00000050   0x20C8             MOVS     R0,#+200
   \   00000052   0x.... 0x....      BL       TM_DELAY_SetTime
    263          			nWaitTime = 1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x7030             STRB     R0,[R6, #+0]
   \   0000005A   0xBD73             POP      {R0,R1,R4-R6,PC}
    264          		}
    265          		else
    266          			nWaitTime = 0;
   \                     ??USBH_Process_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x7030             STRB     R0,[R6, #+0]
   \   00000060   0xBD73             POP      {R0,R1,R4-R6,PC}
    267          	}
    268          	else
    269          	{
    270          		if(TM_DELAY_Time() == 0)
   \                     ??USBH_Process_4: (+1)
   \   00000062   0x.... 0x....      BL       TM_DELAY_Time
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xF040 0x80B0      BNE.W    ??USBH_Process_2
    271          		{
    272          			phost->gState = HOST_DEV_ATTACHED;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
    273          			nWaitTime = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7030             STRB     R0,[R6, #+0]
   \   00000074   0xBD73             POP      {R0,R1,R4-R6,PC}
    274          		}
    275          	}
    276          
    277              //if (HCD_IsDeviceConnected(pdev))  
    278              //{
    279              //  phost->gState = HOST_DEV_ATTACHED;
    280              //  USB_OTG_BSP_mDelay(100);
    281              //}
    282              break;
    283             
    284            case HOST_DEV_ATTACHED :
    285              //USB_OTG_BSP_mDelay(100);
    286              phost->usr_cb->DeviceAttached();
   \                     ??USBH_Process_6: (+1)
   \   00000076   0xF104 0x067C      ADD      R6,R4,#+124
   \   0000007A   0x6870             LDR      R0,[R6, #+4]
   \   0000007C   0x6880             LDR      R0,[R0, #+8]
   \   0000007E   0x4780             BLX      R0
    287              phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       USBH_Alloc_Channel
   \   00000088   0x7160             STRB     R0,[R4, #+5]
    288              phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
   \   0000008A   0x2180             MOVS     R1,#+128
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       USBH_Alloc_Channel
   \   00000092   0x7120             STRB     R0,[R4, #+4]
    289            
    290              /* Reset USB Device */
    291              if ( HCD_ResetPort(pdev) == 0)
   \   00000094   0x4628             MOV      R0,R5
   \   00000096   0x.... 0x....      BL       HCD_ResetPort
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xF040 0x8096      BNE.W    ??USBH_Process_2
    292              {
    293                phost->usr_cb->ResetDevice();
   \   000000A0   0x6870             LDR      R0,[R6, #+4]
   \   000000A2   0x68C0             LDR      R0,[R0, #+12]
   \   000000A4   0x4780             BLX      R0
    294                /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
    295                Host is Now ready to start the Enumeration 
    296                */
    297                
    298                phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0x.... 0x....      BL       HCD_GetCurrentSpeed
   \   000000AC   0xF884 0x0021      STRB     R0,[R4, #+33]
    299                
    300                phost->gState = HOST_ENUMERATION;
   \   000000B0   0x2004             MOVS     R0,#+4
   \   000000B2   0x7020             STRB     R0,[R4, #+0]
    301                phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
   \   000000B4   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \   000000B8   0x6871             LDR      R1,[R6, #+4]
   \   000000BA   0x6989             LDR      R1,[R1, #+24]
   \   000000BC   0x4788             BLX      R1
    302                  
    303                /* Open Control pipes */
    304                USBH_Open_Channel (pdev,
    305                                     phost->Control.hc_num_in,
    306                                     phost->device_prop.address,
    307                                     phost->device_prop.speed,
    308                                     EP_TYPE_CTRL,
    309                                     phost->Control.ep0size); 
   \   000000BE   0x79A0             LDRB     R0,[R4, #+6]
   \   000000C0   0x9001             STR      R0,[SP, #+4]
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0xF894 0x3021      LDRB     R3,[R4, #+33]
   \   000000CA   0xF894 0x2020      LDRB     R2,[R4, #+32]
   \   000000CE   0x7921             LDRB     R1,[R4, #+4]
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0x.... 0x....      BL       USBH_Open_Channel
    310                
    311                /* Open Control pipes */
    312                USBH_Open_Channel (pdev,
    313                                     phost->Control.hc_num_out,
    314                                     phost->device_prop.address,
    315                                     phost->device_prop.speed,
    316                                     EP_TYPE_CTRL,
    317                                     phost->Control.ep0size);          
   \   000000D6   0x79A0             LDRB     R0,[R4, #+6]
   \   000000D8   0x9001             STR      R0,[SP, #+4]
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \   000000DE   0xF894 0x3021      LDRB     R3,[R4, #+33]
   \   000000E2   0xF894 0x2020      LDRB     R2,[R4, #+32]
   \   000000E6   0x7961             LDRB     R1,[R4, #+5]
   \   000000E8   0x4628             MOV      R0,R5
   \   000000EA   0x.... 0x....      BL       USBH_Open_Channel
   \   000000EE   0xBD73             POP      {R0,R1,R4-R6,PC}
    318             }
    319              break;
    320              
    321            case HOST_ENUMERATION:     
    322              /* Check for enumeration status */  
    323              if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
   \                     ??USBH_Process_7: (+1)
   \   000000F0   0x4621             MOV      R1,R4
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x.... 0x....      BL       USBH_HandleEnum
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD167             BNE.N    ??USBH_Process_2
    324              { 
    325                /* The function shall return USBH_OK when full enumeration is complete */
    326                
    327                /* user callback for end of device basic enumeration */
    328                phost->usr_cb->EnumerationDone();
   \   000000FC   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000100   0x6840             LDR      R0,[R0, #+4]
   \   00000102   0x6B40             LDR      R0,[R0, #+52]
   \   00000104   0x4780             BLX      R0
    329                
    330                phost->gState  = HOST_USR_INPUT;    
   \   00000106   0x2008             MOVS     R0,#+8
   \   00000108   0x7020             STRB     R0,[R4, #+0]
   \   0000010A   0xBD73             POP      {R0,R1,R4-R6,PC}
    331              }
    332              break;
    333              
    334            case HOST_USR_INPUT:    
    335              /*The function should return user response true to move to class state */
    336              if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
   \                     ??USBH_Process_8: (+1)
   \   0000010C   0xF104 0x067C      ADD      R6,R4,#+124
   \   00000110   0x6870             LDR      R0,[R6, #+4]
   \   00000112   0x6B80             LDR      R0,[R0, #+56]
   \   00000114   0x4780             BLX      R0
   \   00000116   0x2801             CMP      R0,#+1
   \   00000118   0xD158             BNE.N    ??USBH_Process_2
    337              {
    338                if((phost->class_cb->Init(pdev, phost))\
    339                  == USBH_OK)
   \   0000011A   0x4621             MOV      R1,R4
   \   0000011C   0x4628             MOV      R0,R5
   \   0000011E   0x6832             LDR      R2,[R6, #+0]
   \   00000120   0x6812             LDR      R2,[R2, #+0]
   \   00000122   0x4790             BLX      R2
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD151             BNE.N    ??USBH_Process_2
    340                {
    341                  phost->gState  = HOST_CLASS_REQUEST;     
   \   00000128   0x2005             MOVS     R0,#+5
   \   0000012A   0x7020             STRB     R0,[R4, #+0]
   \   0000012C   0xBD73             POP      {R0,R1,R4-R6,PC}
    342                }     
    343              }   
    344              break;
    345           
    346          
    347            case HOST_CLASS_REQUEST:  
    348              /* process class standard contol requests state machine */ 
    349              status = phost->class_cb->Requests(pdev, phost);
   \                     ??USBH_Process_9: (+1)
   \   0000012E   0x4621             MOV      R1,R4
   \   00000130   0x4628             MOV      R0,R5
   \   00000132   0x6FE2             LDR      R2,[R4, #+124]
   \   00000134   0x6892             LDR      R2,[R2, #+8]
   \   00000136   0x4790             BLX      R2
   \   00000138   0xF88D 0x0000      STRB     R0,[SP, #+0]
    350              
    351               if(status == USBH_OK)
   \   0000013C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD102             BNE.N    ??USBH_Process_10
    352               {
    353                 phost->gState  = HOST_CLASS;
   \   00000144   0x2006             MOVS     R0,#+6
   \   00000146   0x7020             STRB     R0,[R4, #+0]
   \   00000148   0xBD73             POP      {R0,R1,R4-R6,PC}
    354               }  
    355               
    356               else
    357               {
    358                 USBH_ErrorHandle(phost, status);
   \                     ??USBH_Process_10: (+1)
   \   0000014A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   00000154   0x....             B.N      USBH_ErrorHandle
    359               }
    360           
    361              
    362              break;    
    363            case HOST_CLASS:   
    364              /* process class state machine */
    365              status = phost->class_cb->Machine(pdev, phost);
   \                     ??USBH_Process_11: (+1)
   \   00000156   0x4621             MOV      R1,R4
   \   00000158   0x4628             MOV      R0,R5
   \   0000015A   0x6FE2             LDR      R2,[R4, #+124]
   \   0000015C   0x68D2             LDR      R2,[R2, #+12]
   \   0000015E   0x4790             BLX      R2
   \   00000160   0xF88D 0x0000      STRB     R0,[SP, #+0]
    366              USBH_ErrorHandle(phost, status);
   \   00000164   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   0000016E   0x....             B.N      USBH_ErrorHandle
    367              break;       
    368              
    369            case HOST_CTRL_XFER:
    370              /* process control transfer state machine */
    371              USBH_HandleControl(pdev, phost);    
   \                     ??USBH_Process_12: (+1)
   \   00000170   0x4621             MOV      R1,R4
   \   00000172   0x4628             MOV      R0,R5
   \   00000174   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   00000178   0x....             B.N      USBH_HandleControl
    372              break;
    373              
    374            case HOST_SUSPENDED:
    375              break;
    376            
    377            case HOST_ERROR_STATE:
    378              /* Re-Initilaize Host for new Enumeration */
    379              USBH_DeInit(pdev, phost);
   \                     ??USBH_Process_13: (+1)
   \   0000017A   0x4621             MOV      R1,R4
   \   0000017C   0x4628             MOV      R0,R5
   \   0000017E   0x.... 0x....      BL       USBH_DeInit
    380              phost->usr_cb->DeInit();
   \   00000182   0xF104 0x067C      ADD      R6,R4,#+124
   \   00000186   0x6870             LDR      R0,[R6, #+4]
   \   00000188   0x6840             LDR      R0,[R0, #+4]
   \   0000018A   0x4780             BLX      R0
    381              phost->class_cb->DeInit(pdev, &phost->device_prop);
   \   0000018C   0xF104 0x0120      ADD      R1,R4,#+32
   \   00000190   0x4628             MOV      R0,R5
   \   00000192   0x6832             LDR      R2,[R6, #+0]
   \   00000194   0x6852             LDR      R2,[R2, #+4]
   \   00000196   0xB002             ADD      SP,SP,#+8
   \   00000198   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000019C   0x4710             BX       R2
    382              break;
    383              
    384            case HOST_DEV_DISCONNECTED :
    385              
    386              /* Manage User disconnect operations*/
    387              phost->usr_cb->DeviceDisconnected();
   \                     ??USBH_Process_14: (+1)
   \   0000019E   0xF104 0x067C      ADD      R6,R4,#+124
   \   000001A2   0x6870             LDR      R0,[R6, #+4]
   \   000001A4   0x6900             LDR      R0,[R0, #+16]
   \   000001A6   0x4780             BLX      R0
    388              
    389              /* Re-Initilaize Host for new Enumeration */
    390              USBH_DeInit(pdev, phost);
   \   000001A8   0x4621             MOV      R1,R4
   \   000001AA   0x4628             MOV      R0,R5
   \   000001AC   0x.... 0x....      BL       USBH_DeInit
    391              phost->usr_cb->DeInit();
   \   000001B0   0x6870             LDR      R0,[R6, #+4]
   \   000001B2   0x6840             LDR      R0,[R0, #+4]
   \   000001B4   0x4780             BLX      R0
    392              phost->class_cb->DeInit(pdev, &phost->device_prop); 
   \   000001B6   0xF104 0x0120      ADD      R1,R4,#+32
   \   000001BA   0x4628             MOV      R0,R5
   \   000001BC   0x6832             LDR      R2,[R6, #+0]
   \   000001BE   0x6852             LDR      R2,[R2, #+4]
   \   000001C0   0x4790             BLX      R2
    393              USBH_DeAllocate_AllChannel(pdev);  
   \   000001C2   0x4628             MOV      R0,R5
   \   000001C4   0x.... 0x....      BL       USBH_DeAllocate_AllChannel
    394              phost->gState = HOST_IDLE;
   \   000001C8   0x2000             MOVS     R0,#+0
   \   000001CA   0x7020             STRB     R0,[R4, #+0]
    395              
    396              break;
    397              
    398            default :
    399              break;
    400            }
    401          
    402          }
   \                     ??USBH_Process_2: (+1)
   \   000001CC   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    403          
    404          
    405          /**
    406            * @brief  USBH_ErrorHandle 
    407            *         This function handles the Error on Host side.
    408            * @param  errType : Type of Error or Busy/OK state
    409            * @retval None
    410            */

   \                                 In section .text, align 2, keep-with-next
    411          void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
    412          {
   \                     USBH_ErrorHandle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    413            /* Error unrecovered or not supported device speed */
    414            if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
    415                 (errType == USBH_UNRECOVERED_ERROR) )
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xD001             BEQ.N    ??USBH_ErrorHandle_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD106             BNE.N    ??USBH_ErrorHandle_1
    416            {
    417              phost->usr_cb->UnrecoveredError(); 
   \                     ??USBH_ErrorHandle_0: (+1)
   \   0000000C   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   00000010   0x6C40             LDR      R0,[R0, #+68]
   \   00000012   0x4780             BLX      R0
    418              phost->gState = HOST_ERROR_STATE;   
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   \   00000018   0xBD10             POP      {R4,PC}
    419            }  
    420            /* USB host restart requested from application layer */
    421            else if(errType == USBH_APPLY_DEINIT)
   \                     ??USBH_ErrorHandle_1: (+1)
   \   0000001A   0x2906             CMP      R1,#+6
   \   0000001C   0xD107             BNE.N    ??USBH_ErrorHandle_2
    422            {
    423              phost->gState = HOST_ERROR_STATE;  
   \   0000001E   0x200A             MOVS     R0,#+10
   \   00000020   0x7020             STRB     R0,[R4, #+0]
    424              /* user callback for initalization */
    425              phost->usr_cb->Init();
   \   00000022   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C   0x4700             BX       R0
    426            } 
    427          }
   \                     ??USBH_ErrorHandle_2: (+1)
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    428          
    429          
    430          /**
    431            * @brief  USBH_HandleEnum 
    432            *         This function includes the complete enumeration process
    433            * @param  pdev: Selected device
    434            * @retval USBH_Status
    435            */

   \                                 In section .text, align 4, keep-with-next
    436          static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    437          {
   \                     USBH_HandleEnum: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    438            USBH_Status Status = USBH_BUSY;  
   \   00000008   0x2601             MOVS     R6,#+1
    439            uint8_t Local_Buffer[64];
    440            
    441            switch (phost->EnumState)
   \   0000000A   0x1CAF             ADDS     R7,R5,#+2
   \   0000000C   0x7838             LDRB     R0,[R7, #+0]
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xF200 0x80DF      BHI.W    ??USBH_HandleEnum_1
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_HandleEnum_0:
   \   00000018   0x05 0x29          DC8      0x5,0x29,0x39,0x5E
   \              0x39 0x5E    
   \   0000001C   0x67 0x7A          DC8      0x67,0x7A,0x97,0xB4
   \              0x97 0xB4    
   \   00000020   0xD1 0xDC          DC8      0xD1,0xDC
    442            {
    443            case ENUM_IDLE:  
    444              /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    445              if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
   \                     ??USBH_HandleEnum_2: (+1)
   \   00000022   0x2208             MOVS     R2,#+8
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USBH_Get_DevDesc
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF040 0x80D1      BNE.W    ??USBH_HandleEnum_1
    446              {
    447                phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
   \   00000030   0xF895 0x0029      LDRB     R0,[R5, #+41]
   \   00000034   0x7138             STRB     R0,[R7, #+4]
    448                
    449                /* Issue Reset  */
    450                HCD_ResetPort(pdev);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       HCD_ResetPort
    451                phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x7038             STRB     R0,[R7, #+0]
    452                
    453                /* modify control channels configuration for MaxPacket size */
    454                USBH_Modify_Channel (pdev,
    455                                     phost->Control.hc_num_out,
    456                                     0,
    457                                     0,
    458                                     0,
    459                                     phost->Control.ep0size);
   \   00000040   0x7938             LDRB     R0,[R7, #+4]
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x4603             MOV      R3,R0
   \   0000004A   0x4602             MOV      R2,R0
   \   0000004C   0x78F9             LDRB     R1,[R7, #+3]
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       USBH_Modify_Channel
    460                
    461                USBH_Modify_Channel (pdev,
    462                                     phost->Control.hc_num_in,
    463                                     0,
    464                                     0,
    465                                     0,
    466                                     phost->Control.ep0size);      
   \   00000054   0x7938             LDRB     R0,[R7, #+4]
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x4603             MOV      R3,R0
   \   0000005E   0x4602             MOV      R2,R0
   \   00000060   0x78B9             LDRB     R1,[R7, #+2]
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       USBH_Modify_Channel
   \   00000068   0xE0B3             B.N      ??USBH_HandleEnum_1
    467              }
    468              break;
    469              
    470            case ENUM_GET_FULL_DEV_DESC:  
    471              /* Get FULL Device Desc  */
    472              if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
    473                == USBH_OK)
   \                     ??USBH_HandleEnum_3: (+1)
   \   0000006A   0x2212             MOVS     R2,#+18
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       USBH_Get_DevDesc
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xF040 0x80AD      BNE.W    ??USBH_HandleEnum_1
    474              {
    475                /* user callback for device descriptor available */
    476                phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
   \   00000078   0xF105 0x0022      ADD      R0,R5,#+34
   \   0000007C   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   00000080   0x69C9             LDR      R1,[R1, #+28]
   \   00000082   0x4788             BLX      R1
    477                phost->EnumState = ENUM_SET_ADDR;
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x7038             STRB     R0,[R7, #+0]
   \   00000088   0xE0A3             B.N      ??USBH_HandleEnum_1
    478              }
    479              break;
    480             
    481            case ENUM_SET_ADDR: 
    482              /* set address */
    483              if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
   \                     ??USBH_HandleEnum_4: (+1)
   \   0000008A   0x4632             MOV      R2,R6
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       USBH_SetAddress
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xF040 0x809D      BNE.W    ??USBH_HandleEnum_1
    484              {
    485                USB_OTG_BSP_mDelay(2);
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x.... 0x....      BL       USB_OTG_BSP_mDelay
    486                phost->device_prop.address = USBH_DEVICE_ADDRESS;
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0x77B8             STRB     R0,[R7, #+30]
    487                
    488                /* user callback for device address assigned */
    489                phost->usr_cb->DeviceAddressAssigned();
   \   000000A2   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \   000000A6   0x6A00             LDR      R0,[R0, #+32]
   \   000000A8   0x4780             BLX      R0
    490                phost->EnumState = ENUM_GET_CFG_DESC;
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0x7038             STRB     R0,[R7, #+0]
    491                
    492                /* modify control channels to update device address */
    493                USBH_Modify_Channel (pdev,
    494                                     phost->Control.hc_num_in,
    495                                     phost->device_prop.address,
    496                                     0,
    497                                     0,
    498                                     0);
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x9001             STR      R0,[SP, #+4]
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x4603             MOV      R3,R0
   \   000000B6   0x7FBA             LDRB     R2,[R7, #+30]
   \   000000B8   0x78B9             LDRB     R1,[R7, #+2]
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       USBH_Modify_Channel
    499                
    500                USBH_Modify_Channel (pdev,
    501                                     phost->Control.hc_num_out,
    502                                     phost->device_prop.address,
    503                                     0,
    504                                     0,
    505                                     0);         
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x9001             STR      R0,[SP, #+4]
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0x4603             MOV      R3,R0
   \   000000C8   0x7FBA             LDRB     R2,[R7, #+30]
   \   000000CA   0x78F9             LDRB     R1,[R7, #+3]
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       USBH_Modify_Channel
   \   000000D2   0xE07E             B.N      ??USBH_HandleEnum_1
    506              }
    507              break;
    508              
    509            case ENUM_GET_CFG_DESC:  
    510              /* get standard configuration descriptor */
    511              if ( USBH_Get_CfgDesc(pdev, 
    512                                    phost,
    513                                    USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
   \                     ??USBH_HandleEnum_5: (+1)
   \   000000D4   0x2209             MOVS     R2,#+9
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD178             BNE.N    ??USBH_HandleEnum_1
    514              {
    515                phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   \   000000E0   0x2004             MOVS     R0,#+4
   \   000000E2   0x7038             STRB     R0,[R7, #+0]
   \   000000E4   0xE075             B.N      ??USBH_HandleEnum_1
    516              }
    517              break;
    518              
    519            case ENUM_GET_FULL_CFG_DESC:  
    520              /* get FULL config descriptor (config, interface, endpoints) */
    521              if (USBH_Get_CfgDesc(pdev, 
    522                                   phost,
    523                                   phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
   \                     ??USBH_HandleEnum_6: (+1)
   \   000000E6   0x8EEA             LDRH     R2,[R5, #+54]
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD16F             BNE.N    ??USBH_HandleEnum_1
    524              {
    525                /* User callback for configuration descriptors available */
    526                phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
    527                                                                phost->device_prop.Itf_Desc,
    528                                                                phost->device_prop.Ep_Desc[0]);
   \   000000F2   0xF105 0x0250      ADD      R2,R5,#+80
   \   000000F6   0xF105 0x013E      ADD      R1,R5,#+62
   \   000000FA   0xF105 0x0034      ADD      R0,R5,#+52
   \   000000FE   0xF8D5 0x3080      LDR      R3,[R5, #+128]
   \   00000102   0x6A5B             LDR      R3,[R3, #+36]
   \   00000104   0x4798             BLX      R3
    529                
    530                phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   \   00000106   0x2005             MOVS     R0,#+5
   \   00000108   0x7038             STRB     R0,[R7, #+0]
   \   0000010A   0xE062             B.N      ??USBH_HandleEnum_1
    531              }
    532              break;
    533              
    534            case ENUM_GET_MFC_STRING_DESC:  
    535              if (phost->device_prop.Dev_Desc.iManufacturer != 0)
   \                     ??USBH_HandleEnum_7: (+1)
   \   0000010C   0xF105 0x0029      ADD      R0,R5,#+41
   \   00000110   0x79C2             LDRB     R2,[R0, #+7]
   \   00000112   0x0010             MOVS     R0,R2
   \   00000114   0xD00F             BEQ.N    ??USBH_HandleEnum_8
    536              { /* Check that Manufacturer String is available */
    537                
    538                if ( USBH_Get_StringDesc(pdev,
    539                                         phost,
    540                                         phost->device_prop.Dev_Desc.iManufacturer, 
    541                                         Local_Buffer , 
    542                                         0xff) == USBH_OK)
   \   00000116   0x20FF             MOVS     R0,#+255
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0xAB02             ADD      R3,SP,#+8
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD155             BNE.N    ??USBH_HandleEnum_1
    543                {
    544                  /* User callback for Manufacturing string */
    545                  phost->usr_cb->ManufacturerString(Local_Buffer);
   \   00000126   0xA802             ADD      R0,SP,#+8
   \   00000128   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   0000012C   0x6A89             LDR      R1,[R1, #+40]
   \   0000012E   0x4788             BLX      R1
    546                  phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   00000130   0x2006             MOVS     R0,#+6
   \   00000132   0x7038             STRB     R0,[R7, #+0]
   \   00000134   0xE04D             B.N      ??USBH_HandleEnum_1
    547                }
    548              }
    549              else
    550              {
    551                phost->usr_cb->ManufacturerString("N/A");      
   \                     ??USBH_HandleEnum_8: (+1)
   \   00000136   0x....             ADR.N    R0,??DataTable3  ;; "N/A"
   \   00000138   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   0000013C   0x6A89             LDR      R1,[R1, #+40]
   \   0000013E   0x4788             BLX      R1
    552                phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   00000140   0x2006             MOVS     R0,#+6
   \   00000142   0x7038             STRB     R0,[R7, #+0]
   \   00000144   0xE045             B.N      ??USBH_HandleEnum_1
    553              }
    554              break;
    555              
    556            case ENUM_GET_PRODUCT_STRING_DESC:   
    557              if (phost->device_prop.Dev_Desc.iProduct != 0)
   \                     ??USBH_HandleEnum_9: (+1)
   \   00000146   0xF105 0x0029      ADD      R0,R5,#+41
   \   0000014A   0x7A02             LDRB     R2,[R0, #+8]
   \   0000014C   0x0010             MOVS     R0,R2
   \   0000014E   0xD00F             BEQ.N    ??USBH_HandleEnum_10
    558              { /* Check that Product string is available */
    559                if ( USBH_Get_StringDesc(pdev,
    560                                         phost,
    561                                         phost->device_prop.Dev_Desc.iProduct, 
    562                                         Local_Buffer, 
    563                                         0xff) == USBH_OK)
   \   00000150   0x20FF             MOVS     R0,#+255
   \   00000152   0x9000             STR      R0,[SP, #+0]
   \   00000154   0xAB02             ADD      R3,SP,#+8
   \   00000156   0x4620             MOV      R0,R4
   \   00000158   0x.... 0x....      BL       USBH_Get_StringDesc
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD138             BNE.N    ??USBH_HandleEnum_1
    564                {
    565                  /* User callback for Product string */
    566                  phost->usr_cb->ProductString(Local_Buffer);
   \   00000160   0xA802             ADD      R0,SP,#+8
   \   00000162   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   00000166   0x6AC9             LDR      R1,[R1, #+44]
   \   00000168   0x4788             BLX      R1
    567                  phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   \   0000016A   0x2007             MOVS     R0,#+7
   \   0000016C   0x7038             STRB     R0,[R7, #+0]
   \   0000016E   0xE030             B.N      ??USBH_HandleEnum_1
    568                }
    569              }
    570              else
    571              {
    572                phost->usr_cb->ProductString("N/A");
   \                     ??USBH_HandleEnum_10: (+1)
   \   00000170   0x....             ADR.N    R0,??DataTable3  ;; "N/A"
   \   00000172   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   00000176   0x6AC9             LDR      R1,[R1, #+44]
   \   00000178   0x4788             BLX      R1
    573                phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   \   0000017A   0x2007             MOVS     R0,#+7
   \   0000017C   0x7038             STRB     R0,[R7, #+0]
   \   0000017E   0xE028             B.N      ??USBH_HandleEnum_1
    574              } 
    575              break;
    576              
    577            case ENUM_GET_SERIALNUM_STRING_DESC:   
    578              if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
   \                     ??USBH_HandleEnum_11: (+1)
   \   00000180   0xF105 0x0029      ADD      R0,R5,#+41
   \   00000184   0x7A42             LDRB     R2,[R0, #+9]
   \   00000186   0x0010             MOVS     R0,R2
   \   00000188   0xD00F             BEQ.N    ??USBH_HandleEnum_12
    579              { /* Check that Serial number string is available */    
    580                if ( USBH_Get_StringDesc(pdev, 
    581                                         phost,
    582                                         phost->device_prop.Dev_Desc.iSerialNumber, 
    583                                         Local_Buffer, 
    584                                         0xff) == USBH_OK)
   \   0000018A   0x20FF             MOVS     R0,#+255
   \   0000018C   0x9000             STR      R0,[SP, #+0]
   \   0000018E   0xAB02             ADD      R3,SP,#+8
   \   00000190   0x4620             MOV      R0,R4
   \   00000192   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD11B             BNE.N    ??USBH_HandleEnum_1
    585                {
    586                  /* User callback for Serial number string */
    587                  phost->usr_cb->SerialNumString(Local_Buffer);
   \   0000019A   0xA802             ADD      R0,SP,#+8
   \   0000019C   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   000001A0   0x6B09             LDR      R1,[R1, #+48]
   \   000001A2   0x4788             BLX      R1
    588                  phost->EnumState = ENUM_SET_CONFIGURATION;
   \   000001A4   0x2008             MOVS     R0,#+8
   \   000001A6   0x7038             STRB     R0,[R7, #+0]
   \   000001A8   0xE013             B.N      ??USBH_HandleEnum_1
    589                }
    590              }
    591              else
    592              {
    593                phost->usr_cb->SerialNumString("N/A");      
   \                     ??USBH_HandleEnum_12: (+1)
   \   000001AA   0x....             ADR.N    R0,??DataTable3  ;; "N/A"
   \   000001AC   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \   000001B0   0x6B09             LDR      R1,[R1, #+48]
   \   000001B2   0x4788             BLX      R1
    594                phost->EnumState = ENUM_SET_CONFIGURATION;
   \   000001B4   0x2008             MOVS     R0,#+8
   \   000001B6   0x7038             STRB     R0,[R7, #+0]
   \   000001B8   0xE00B             B.N      ??USBH_HandleEnum_1
    595              }  
    596              break;
    597                
    598            case ENUM_SET_CONFIGURATION:
    599              /* set configuration  (default config) */
    600              if (USBH_SetCfg(pdev, 
    601                              phost,
    602                              phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
   \                     ??USBH_HandleEnum_13: (+1)
   \   000001BA   0xF105 0x0036      ADD      R0,R5,#+54
   \   000001BE   0x78C2             LDRB     R2,[R0, #+3]
   \   000001C0   0x4620             MOV      R0,R4
   \   000001C2   0x.... 0x....      BL       USBH_SetCfg
   \   000001C6   0x2800             CMP      R0,#+0
   \   000001C8   0xD103             BNE.N    ??USBH_HandleEnum_1
    603              {
    604                phost->EnumState = ENUM_DEV_CONFIGURED;
   \   000001CA   0x2009             MOVS     R0,#+9
   \   000001CC   0x7038             STRB     R0,[R7, #+0]
   \   000001CE   0xE000             B.N      ??USBH_HandleEnum_1
    605              }
    606              break;
    607          
    608              
    609            case ENUM_DEV_CONFIGURED:
    610              /* user callback for enumeration done */
    611              Status = USBH_OK;
   \                     ??USBH_HandleEnum_14: (+1)
   \   000001D0   0x2600             MOVS     R6,#+0
    612              break;
    613              
    614            default:
    615              break;
    616            }  
    617            return Status;
   \                     ??USBH_HandleEnum_1: (+1)
   \   000001D2   0x4630             MOV      R0,R6
   \   000001D4   0xB013             ADD      SP,SP,#+76
   \   000001D6   0xBDF0             POP      {R4-R7,PC}       ;; return
    618          }
    619          
    620          
    621          /**
    622            * @brief  USBH_HandleControl
    623            *         Handles the USB control transfer state machine
    624            * @param  pdev: Selected device
    625            * @retval Status
    626            */

   \                                 In section .text, align 4, keep-with-next
    627          USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    628          {
   \                     USBH_HandleControl: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
    629            uint8_t direction;  
    630            static uint16_t timeout = 0;
    631            USBH_Status status = USBH_OK;
   \   00000006   0x2400             MOVS     R4,#+0
    632            URB_STATE URB_Status = URB_IDLE;
    633            
    634            phost->Control.status = CTRL_START;
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x74A8             STRB     R0,[R5, #+18]
    635          
    636            
    637            switch (phost->Control.state)
   \   0000000C   0x7F28             LDRB     R0,[R5, #+28]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x280A             CMP      R0,#+10
   \   00000012   0xF200 0x8105      BHI.W    ??USBH_HandleControl_1
   \   00000016   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??USBH_HandleControl_0:
   \   0000001A   0x000B 0x0017      DC16     0xB,0x17,0x51,0x5A
   \              0x0051 0x005A
   \   00000022   0x007A 0x0089      DC16     0x7A,0x89,0xA4,0xAD
   \              0x00A4 0x00AD
   \   0000002A   0x00CD 0x00DF      DC16     0xCD,0xDF,0xF5
   \              0x00F5       
    638            {
    639            case CTRL_SETUP:
    640              /* send a SETUP packet */
    641              USBH_CtlSendSetup     (pdev, 
    642          	                   phost->Control.setup.d8 , 
    643          	                   phost->Control.hc_num_out);  
   \                     ??USBH_HandleControl_2: (+1)
   \   00000030   0x796A             LDRB     R2,[R5, #+5]
   \   00000032   0xF105 0x0114      ADD      R1,R5,#+20
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       USBH_CtlSendSetup
    644              phost->Control.state = CTRL_SETUP_WAIT;  
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x7728             STRB     R0,[R5, #+28]
    645              USB_RespWaitCount = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable3_2
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    646              break; 
   \   00000046   0xE0EB             B.N      ??USBH_HandleControl_1
    647              
    648            case CTRL_SETUP_WAIT:
    649              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
   \                     ??USBH_HandleControl_3: (+1)
   \   00000048   0x7969             LDRB     R1,[R5, #+5]
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       HCD_GetURB_State
   \   00000050   0x0007             MOVS     R7,R0
    650              if(URB_Status != URB_IDLE) USB_RespWaitCount = 0;
   \   00000052   0x....             LDR.N    R0,??DataTable3_2
   \   00000054   0xD002             BEQ.N    ??USBH_HandleControl_4
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0x7001             STRB     R1,[R0, #+0]
   \   0000005A   0xE006             B.N      ??USBH_HandleControl_5
    651              else if(USB_RespWaitCount > 100) {  // 1 sec
   \                     ??USBH_HandleControl_4: (+1)
   \   0000005C   0x7801             LDRB     R1,[R0, #+0]
   \   0000005E   0x2965             CMP      R1,#+101
   \   00000060   0xDB03             BLT.N    ??USBH_HandleControl_5
    652                phost->gState = HOST_ERROR_STATE;
   \   00000062   0x210A             MOVS     R1,#+10
   \   00000064   0x7029             STRB     R1,[R5, #+0]
    653                USB_RespWaitCount = 0;
   \   00000066   0x4621             MOV      R1,R4
   \   00000068   0x7001             STRB     R1,[R0, #+0]
    654              }      
    655          
    656          
    657              /* case SETUP packet sent successfully */
    658              if(URB_Status == URB_DONE)
   \                     ??USBH_HandleControl_5: (+1)
   \   0000006A   0x2F01             CMP      R7,#+1
   \   0000006C   0xD11E             BNE.N    ??USBH_HandleControl_6
    659              { 
    660                direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
   \   0000006E   0x7D29             LDRB     R1,[R5, #+20]
   \   00000070   0xF001 0x0180      AND      R1,R1,#0x80
    661                
    662                /* check if there is a data stage */
    663                if (phost->Control.setup.b.wLength.w != 0 )
   \   00000074   0x8B6A             LDRH     R2,[R5, #+26]
   \   00000076   0x2A00             CMP      R2,#+0
   \   00000078   0xD00A             BEQ.N    ??USBH_HandleControl_7
    664                {        
    665                  timeout = DATA_STAGE_TIMEOUT;
   \   0000007A   0xF241 0x3288      MOVW     R2,#+5000
   \   0000007E   0x8042             STRH     R2,[R0, #+2]
    666                  if (direction == USB_D2H)
   \   00000080   0x2980             CMP      R1,#+128
   \   00000082   0xD102             BNE.N    ??USBH_HandleControl_8
    667                  {
    668                    /* Data Direction is IN */
    669                    phost->Control.state = CTRL_DATA_IN;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x7728             STRB     R0,[R5, #+28]
   \   00000088   0xE00B             B.N      ??USBH_HandleControl_9
    670                  }
    671                  else
    672                  {
    673                    /* Data Direction is OUT */
    674                    phost->Control.state = CTRL_DATA_OUT;
   \                     ??USBH_HandleControl_8: (+1)
   \   0000008A   0x2005             MOVS     R0,#+5
   \   0000008C   0x7728             STRB     R0,[R5, #+28]
   \   0000008E   0xE008             B.N      ??USBH_HandleControl_9
    675                  } 
    676                }
    677                /* No DATA stage */
    678                else
    679                {
    680                  timeout = NODATA_STAGE_TIMEOUT;
   \                     ??USBH_HandleControl_7: (+1)
   \   00000090   0x2232             MOVS     R2,#+50
   \   00000092   0x8042             STRH     R2,[R0, #+2]
    681                  
    682                  /* If there is No Data Transfer Stage */
    683                  if (direction == USB_D2H)
   \   00000094   0x2980             CMP      R1,#+128
   \   00000096   0xD102             BNE.N    ??USBH_HandleControl_10
    684                  {
    685                    /* Data Direction is IN */
    686                    phost->Control.state = CTRL_STATUS_OUT;
   \   00000098   0x2009             MOVS     R0,#+9
   \   0000009A   0x7728             STRB     R0,[R5, #+28]
   \   0000009C   0xE001             B.N      ??USBH_HandleControl_9
    687                  }
    688                  else
    689                  {
    690                    /* Data Direction is OUT */
    691                    phost->Control.state = CTRL_STATUS_IN;
   \                     ??USBH_HandleControl_10: (+1)
   \   0000009E   0x2007             MOVS     R0,#+7
   \   000000A0   0x7728             STRB     R0,[R5, #+28]
    692                  } 
    693                }          
    694                /* Set the delay timer to enable timeout for data stage completion */
    695                phost->Control.timer = HCD_GetCurrentFrame(pdev);
   \                     ??USBH_HandleControl_9: (+1)
   \   000000A2   0x4630             MOV      R0,R6
   \   000000A4   0x.... 0x....      BL       HCD_GetCurrentFrame
   \   000000A8   0x8228             STRH     R0,[R5, #+16]
   \   000000AA   0xE0B9             B.N      ??USBH_HandleControl_1
    696              }
    697              else if(URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_6: (+1)
   \   000000AC   0x2F03             CMP      R7,#+3
   \   000000AE   0xF040 0x80B7      BNE.W    ??USBH_HandleControl_1
    698              {
    699                phost->Control.state = CTRL_ERROR;     
   \   000000B2   0x200B             MOVS     R0,#+11
   \   000000B4   0x7728             STRB     R0,[R5, #+28]
    700                phost->Control.status = CTRL_XACTERR;
   \   000000B6   0x2005             MOVS     R0,#+5
   \   000000B8   0x74A8             STRB     R0,[R5, #+18]
   \   000000BA   0xE0B1             B.N      ??USBH_HandleControl_1
    701              }    
    702              break;
    703              
    704            case CTRL_DATA_IN:  
    705              /* Issue an IN token */ 
    706              USBH_CtlReceiveData(pdev,
    707                                  phost->Control.buff, 
    708                                  phost->Control.length,
    709                                  phost->Control.hc_num_in);
   \                     ??USBH_HandleControl_11: (+1)
   \   000000BC   0x792B             LDRB     R3,[R5, #+4]
   \   000000BE   0x89AA             LDRH     R2,[R5, #+12]
   \   000000C0   0x68A9             LDR      R1,[R5, #+8]
   \   000000C2   0x4630             MOV      R0,R6
   \   000000C4   0x.... 0x....      BL       USBH_CtlReceiveData
    710           
    711              phost->Control.state = CTRL_DATA_IN_WAIT;
   \   000000C8   0x2004             MOVS     R0,#+4
   \   000000CA   0x7728             STRB     R0,[R5, #+28]
    712          
    713              break;    
   \   000000CC   0xE0A8             B.N      ??USBH_HandleControl_1
    714              
    715            case CTRL_DATA_IN_WAIT:
    716              
    717              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
   \                     ??USBH_HandleControl_12: (+1)
   \   000000CE   0x7929             LDRB     R1,[R5, #+4]
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       HCD_GetURB_State
   \   000000D6   0x4607             MOV      R7,R0
    718              
    719              /* check is DATA packet transfered successfully */
    720              if  (URB_Status == URB_DONE)
   \   000000D8   0x2F01             CMP      R7,#+1
   \   000000DA   0xD101             BNE.N    ??USBH_HandleControl_13
    721              { 
    722                phost->Control.state = CTRL_STATUS_OUT;
   \   000000DC   0x2009             MOVS     R0,#+9
   \   000000DE   0x7728             STRB     R0,[R5, #+28]
    723              }
    724             
    725              /* manage error cases*/
    726              if  (URB_Status == URB_STALL) 
   \                     ??USBH_HandleControl_13: (+1)
   \   000000E0   0x2F04             CMP      R7,#+4
   \   000000E2   0xD102             BNE.N    ??USBH_HandleControl_14
    727              { 
    728                /* In stall case, return to previous machine state*/
    729                phost->gState =   phost->gStateBkp;
   \   000000E4   0x7868             LDRB     R0,[R5, #+1]
   \   000000E6   0x7028             STRB     R0,[R5, #+0]
   \   000000E8   0xE09A             B.N      ??USBH_HandleControl_1
    730              }   
    731              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_14: (+1)
   \   000000EA   0x2F03             CMP      R7,#+3
   \   000000EC   0xD102             BNE.N    ??USBH_HandleControl_15
    732              {
    733                /* Device error */
    734                phost->Control.state = CTRL_ERROR;    
   \   000000EE   0x200B             MOVS     R0,#+11
   \   000000F0   0x7728             STRB     R0,[R5, #+28]
   \   000000F2   0xE095             B.N      ??USBH_HandleControl_1
    735              }
    736              else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
   \                     ??USBH_HandleControl_15: (+1)
   \   000000F4   0x4630             MOV      R0,R6
   \   000000F6   0x.... 0x....      BL       HCD_GetCurrentFrame
   \   000000FA   0x....             LDR.N    R1,??DataTable3_2
   \   000000FC   0x8849             LDRH     R1,[R1, #+2]
   \   000000FE   0x8A2A             LDRH     R2,[R5, #+16]
   \   00000100   0x1A80             SUBS     R0,R0,R2
   \   00000102   0x4281             CMP      R1,R0
   \   00000104   0xF080 0x808C      BCS.W    ??USBH_HandleControl_1
    737              {
    738                /* timeout for IN transfer */
    739                phost->Control.state = CTRL_ERROR; 
   \   00000108   0x200B             MOVS     R0,#+11
   \   0000010A   0x7728             STRB     R0,[R5, #+28]
   \   0000010C   0xE088             B.N      ??USBH_HandleControl_1
    740              }   
    741              break;
    742              
    743            case CTRL_DATA_OUT:
    744              /* Start DATA out transfer (only one DATA packet)*/
    745              pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
   \                     ??USBH_HandleControl_16: (+1)
   \   0000010E   0x7968             LDRB     R0,[R5, #+5]
   \   00000110   0xEB06 0x1040      ADD      R0,R6,R0, LSL #+5
   \   00000114   0x2101             MOVS     R1,#+1
   \   00000116   0xF880 0x13C5      STRB     R1,[R0, #+965]
    746                  
    747              USBH_CtlSendData (pdev,
    748                                phost->Control.buff, 
    749                                phost->Control.length , 
    750                                phost->Control.hc_num_out);
   \   0000011A   0x796B             LDRB     R3,[R5, #+5]
   \   0000011C   0x89AA             LDRH     R2,[R5, #+12]
   \   0000011E   0x68A9             LDR      R1,[R5, #+8]
   \   00000120   0x4630             MOV      R0,R6
   \   00000122   0x.... 0x....      BL       USBH_CtlSendData
    751              
    752          
    753          
    754          
    755              
    756              phost->Control.state = CTRL_DATA_OUT_WAIT;
   \   00000126   0x2006             MOVS     R0,#+6
   \   00000128   0x7728             STRB     R0,[R5, #+28]
    757              break;
   \   0000012A   0xE079             B.N      ??USBH_HandleControl_1
    758              
    759            case CTRL_DATA_OUT_WAIT:
    760              
    761              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
   \                     ??USBH_HandleControl_17: (+1)
   \   0000012C   0x7969             LDRB     R1,[R5, #+5]
   \   0000012E   0x4630             MOV      R0,R6
   \   00000130   0x.... 0x....      BL       HCD_GetURB_State
   \   00000134   0x4607             MOV      R7,R0
    762              if  (URB_Status == URB_DONE)
   \   00000136   0x2F01             CMP      R7,#+1
   \   00000138   0xD102             BNE.N    ??USBH_HandleControl_18
    763              { /* If the Setup Pkt is sent successful, then change the state */
    764                phost->Control.state = CTRL_STATUS_IN;
   \   0000013A   0x2007             MOVS     R0,#+7
   \   0000013C   0x7728             STRB     R0,[R5, #+28]
   \   0000013E   0xE06F             B.N      ??USBH_HandleControl_1
    765              }
    766              
    767              /* handle error cases */
    768              else if  (URB_Status == URB_STALL) 
   \                     ??USBH_HandleControl_18: (+1)
   \   00000140   0x2F04             CMP      R7,#+4
   \   00000142   0xD104             BNE.N    ??USBH_HandleControl_19
    769              { 
    770                /* In stall case, return to previous machine state*/
    771                phost->gState =   phost->gStateBkp;
   \   00000144   0x7868             LDRB     R0,[R5, #+1]
   \   00000146   0x7028             STRB     R0,[R5, #+0]
    772                phost->Control.state = CTRL_STALLED;  
   \   00000148   0x200C             MOVS     R0,#+12
   \   0000014A   0x7728             STRB     R0,[R5, #+28]
   \   0000014C   0xE068             B.N      ??USBH_HandleControl_1
    773              } 
    774              else if  (URB_Status == URB_NOTREADY)
   \                     ??USBH_HandleControl_19: (+1)
   \   0000014E   0x2F02             CMP      R7,#+2
   \   00000150   0xD102             BNE.N    ??USBH_HandleControl_20
    775              { 
    776                /* Nack received from device */
    777                phost->Control.state = CTRL_DATA_OUT;
   \   00000152   0x2005             MOVS     R0,#+5
   \   00000154   0x7728             STRB     R0,[R5, #+28]
   \   00000156   0xE063             B.N      ??USBH_HandleControl_1
    778              }    
    779              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_20: (+1)
   \   00000158   0x2F03             CMP      R7,#+3
   \   0000015A   0xD161             BNE.N    ??USBH_HandleControl_1
    780              {
    781                /* device error */
    782                phost->Control.state = CTRL_ERROR;      
   \   0000015C   0x200B             MOVS     R0,#+11
   \   0000015E   0x7728             STRB     R0,[R5, #+28]
   \   00000160   0xE05E             B.N      ??USBH_HandleControl_1
    783              } 
    784              break;
    785              
    786              
    787            case CTRL_STATUS_IN:
    788              /* Send 0 bytes out packet */
    789              USBH_CtlReceiveData (pdev,
    790                                   0,
    791                                   0,
    792                                   phost->Control.hc_num_in);
   \                     ??USBH_HandleControl_21: (+1)
   \   00000162   0x792B             LDRB     R3,[R5, #+4]
   \   00000164   0x4622             MOV      R2,R4
   \   00000166   0x4611             MOV      R1,R2
   \   00000168   0x4630             MOV      R0,R6
   \   0000016A   0x.... 0x....      BL       USBH_CtlReceiveData
    793              
    794              phost->Control.state = CTRL_STATUS_IN_WAIT;
   \   0000016E   0x2008             MOVS     R0,#+8
   \   00000170   0x7728             STRB     R0,[R5, #+28]
    795              
    796              break;
   \   00000172   0xE055             B.N      ??USBH_HandleControl_1
    797              
    798            case CTRL_STATUS_IN_WAIT:
    799              
    800              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
   \                     ??USBH_HandleControl_22: (+1)
   \   00000174   0x7929             LDRB     R1,[R5, #+4]
   \   00000176   0x4630             MOV      R0,R6
   \   00000178   0x.... 0x....      BL       HCD_GetURB_State
   \   0000017C   0x4607             MOV      R7,R0
    801              
    802              if  ( URB_Status == URB_DONE)
   \   0000017E   0x2F01             CMP      R7,#+1
   \   00000180   0xD031             BEQ.N    ??USBH_HandleControl_23
    803              { /* Control transfers completed, Exit the State Machine */
    804                phost->gState =   phost->gStateBkp;
    805                phost->Control.state = CTRL_COMPLETE;
    806              }
    807              
    808              else if (URB_Status == URB_ERROR)
   \   00000182   0x2F03             CMP      R7,#+3
   \   00000184   0xD102             BNE.N    ??USBH_HandleControl_24
    809              {
    810                phost->Control.state = CTRL_ERROR;  
   \   00000186   0x200B             MOVS     R0,#+11
   \   00000188   0x7728             STRB     R0,[R5, #+28]
   \   0000018A   0xE049             B.N      ??USBH_HandleControl_1
    811              }
    812              
    813              else if((HCD_GetCurrentFrame(pdev)\
    814                - phost->Control.timer) > timeout)
   \                     ??USBH_HandleControl_24: (+1)
   \   0000018C   0x4630             MOV      R0,R6
   \   0000018E   0x.... 0x....      BL       HCD_GetCurrentFrame
   \   00000192   0x....             LDR.N    R1,??DataTable3_2
   \   00000194   0x8849             LDRH     R1,[R1, #+2]
   \   00000196   0x8A2A             LDRH     R2,[R5, #+16]
   \   00000198   0x1A80             SUBS     R0,R0,R2
   \   0000019A   0x4281             CMP      R1,R0
   \   0000019C   0xD202             BCS.N    ??USBH_HandleControl_25
    815              {
    816                phost->Control.state = CTRL_ERROR; 
   \   0000019E   0x200B             MOVS     R0,#+11
   \   000001A0   0x7728             STRB     R0,[R5, #+28]
   \   000001A2   0xE03D             B.N      ??USBH_HandleControl_1
    817              }
    818               else if(URB_Status == URB_STALL)
   \                     ??USBH_HandleControl_25: (+1)
   \   000001A4   0x2F04             CMP      R7,#+4
   \   000001A6   0xD13B             BNE.N    ??USBH_HandleControl_1
    819              {
    820                /* Control transfers completed, Exit the State Machine */
    821                phost->gState =   phost->gStateBkp;
   \   000001A8   0x7868             LDRB     R0,[R5, #+1]
   \   000001AA   0x7028             STRB     R0,[R5, #+0]
    822                phost->Control.status = CTRL_STALL;
   \   000001AC   0x2004             MOVS     R0,#+4
   \   000001AE   0x74A8             STRB     R0,[R5, #+18]
    823                status = USBH_NOT_SUPPORTED;
   \   000001B0   0x2403             MOVS     R4,#+3
   \   000001B2   0xE035             B.N      ??USBH_HandleControl_1
    824              }
   \                     ??USBH_HandleControl_26: (+1)
   \   000001B4   0x7968             LDRB     R0,[R5, #+5]
   \   000001B6   0xEB06 0x1040      ADD      R0,R6,R0, LSL #+5
   \   000001BA   0xF890 0x13C5      LDRB     R1,[R0, #+965]
   \   000001BE   0xF081 0x0101      EOR      R1,R1,#0x1
   \   000001C2   0xF880 0x13C5      STRB     R1,[R0, #+965]
    825              break;
    826              
    827            case CTRL_STATUS_OUT:
    828              pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
    829              USBH_CtlSendData (pdev,
    830                                0,
    831                                0,
    832                                phost->Control.hc_num_out);
   \   000001C6   0x796B             LDRB     R3,[R5, #+5]
   \   000001C8   0x4622             MOV      R2,R4
   \   000001CA   0x4611             MOV      R1,R2
   \   000001CC   0x4630             MOV      R0,R6
   \   000001CE   0x.... 0x....      BL       USBH_CtlSendData
    833              
    834              phost->Control.state = CTRL_STATUS_OUT_WAIT;
   \   000001D2   0x200A             MOVS     R0,#+10
   \   000001D4   0x7728             STRB     R0,[R5, #+28]
    835              break;
   \   000001D6   0xE023             B.N      ??USBH_HandleControl_1
    836              
    837            case CTRL_STATUS_OUT_WAIT: 
    838              
    839              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
   \                     ??USBH_HandleControl_27: (+1)
   \   000001D8   0x7969             LDRB     R1,[R5, #+5]
   \   000001DA   0x4630             MOV      R0,R6
   \   000001DC   0x.... 0x....      BL       HCD_GetURB_State
   \   000001E0   0x4607             MOV      R7,R0
    840              if  (URB_Status == URB_DONE)
   \   000001E2   0x2F01             CMP      R7,#+1
   \   000001E4   0xD104             BNE.N    ??USBH_HandleControl_28
    841              { 
    842                phost->gState =   phost->gStateBkp; 
   \                     ??USBH_HandleControl_23: (+1)
   \   000001E6   0x7868             LDRB     R0,[R5, #+1]
   \   000001E8   0x7028             STRB     R0,[R5, #+0]
    843                phost->Control.state = CTRL_COMPLETE; 
   \   000001EA   0x200D             MOVS     R0,#+13
   \   000001EC   0x7728             STRB     R0,[R5, #+28]
   \   000001EE   0xE017             B.N      ??USBH_HandleControl_1
    844              }
    845              else if  (URB_Status == URB_NOTREADY)
   \                     ??USBH_HandleControl_28: (+1)
   \   000001F0   0x2F02             CMP      R7,#+2
   \   000001F2   0xD102             BNE.N    ??USBH_HandleControl_29
    846              { 
    847                phost->Control.state = CTRL_STATUS_OUT;
   \   000001F4   0x2009             MOVS     R0,#+9
   \   000001F6   0x7728             STRB     R0,[R5, #+28]
   \   000001F8   0xE012             B.N      ??USBH_HandleControl_1
    848              }      
    849              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_29: (+1)
   \   000001FA   0x2F03             CMP      R7,#+3
   \   000001FC   0xD110             BNE.N    ??USBH_HandleControl_1
    850              {
    851                phost->Control.state = CTRL_ERROR;      
   \   000001FE   0x200B             MOVS     R0,#+11
   \   00000200   0x7728             STRB     R0,[R5, #+28]
   \   00000202   0xE00D             B.N      ??USBH_HandleControl_1
    852              }
    853              break;
    854              
    855            case CTRL_ERROR:
    856              /* 
    857              After a halt condition is encountered or an error is detected by the 
    858              host, a control endpoint is allowed to recover by accepting the next Setup 
    859              PID; i.e., recovery actions via some other pipe are not required for control
    860              endpoints. For the Default Control Pipe, a device reset will ultimately be 
    861              required to clear the halt or error condition if the next Setup PID is not 
    862              accepted.
    863              */
    864              if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   \                     ??USBH_HandleControl_30: (+1)
   \   00000204   0x7BA8             LDRB     R0,[R5, #+14]
   \   00000206   0x1C40             ADDS     R0,R0,#+1
   \   00000208   0x73A8             STRB     R0,[R5, #+14]
   \   0000020A   0xB2C0             UXTB     R0,R0
   \   0000020C   0x2803             CMP      R0,#+3
   \   0000020E   0xDA02             BGE.N    ??USBH_HandleControl_31
    865              {
    866                /* Do the transmission again, starting from SETUP Packet */
    867                phost->Control.state = CTRL_SETUP; 
   \   00000210   0x2001             MOVS     R0,#+1
   \   00000212   0x7728             STRB     R0,[R5, #+28]
   \   00000214   0xE004             B.N      ??USBH_HandleControl_1
    868              }
    869              else
    870              {
    871                phost->Control.status = CTRL_FAIL;
   \                     ??USBH_HandleControl_31: (+1)
   \   00000216   0x2008             MOVS     R0,#+8
   \   00000218   0x74A8             STRB     R0,[R5, #+18]
    872                phost->gState =   phost->gStateBkp;
   \   0000021A   0x7868             LDRB     R0,[R5, #+1]
   \   0000021C   0x7028             STRB     R0,[R5, #+0]
    873                
    874                status = USBH_FAIL;
   \   0000021E   0x2402             MOVS     R4,#+2
    875              }
    876              break;
    877              
    878            default:
    879              break;
    880            }
    881            return status;
   \                     ??USBH_HandleControl_1: (+1)
   \   00000220   0x4620             MOV      R0,R4
   \   00000222   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    882          }

   \                                 In section .bss, align 2
   \                     USB_RespWaitCount:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2

   \                                 In section .bss, align 1
   \                     `USBH_Process::nWaitTime`:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4E 0x2F          DC8      "N/A"
   \              0x41 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     `USBH_Process::nWaitTime`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     USB_RespWaitCount

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x4E 0x2F          DC8 "N/A"
   \              0x41 0x00    
    883          
    884          
    885          /**
    886          * @}
    887          */ 
    888          
    889          /**
    890          * @}
    891          */ 
    892          
    893          /**
    894          * @}
    895          */
    896          
    897          /**
    898          * @}
    899          */ 
    900          
    901          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    902          
    903          
    904          
    905          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TM_DELAY_Init
         0   -> TmrStop
       8   TM_DELAY_SetTime
         8   -> TmrSetT
         0   -> TmrStart
         8   -> TmrStop
       0   TM_DELAY_Time
         0   -> TmrChk
       0   USBH_Connected
      16   USBH_DeInit
        16   -> USBH_Free_Channel
       0   USBH_Disconnected
       8   USBH_ErrorHandle
         0   -- Indirect call
         8   -- Indirect call
      24   USBH_HandleControl
        24   -> HCD_GetCurrentFrame
        24   -> HCD_GetURB_State
        24   -> USBH_CtlReceiveData
        24   -> USBH_CtlSendData
        24   -> USBH_CtlSendSetup
      96   USBH_HandleEnum
        96   -- Indirect call
        96   -> HCD_ResetPort
        96   -> USBH_Get_CfgDesc
        96   -> USBH_Get_DevDesc
        96   -> USBH_Get_StringDesc
        96   -> USBH_Modify_Channel
        96   -> USBH_SetAddress
        96   -> USBH_SetCfg
        96   -> USB_OTG_BSP_mDelay
      24   USBH_Init
        24   -- Indirect call
        24   -> HCD_Init
        24   -> USBH_DeInit
        24   -> USB_OTG_BSP_ConfigVBUS
         0   -> USB_OTG_BSP_EnableInterrupt
        24   -> USB_OTG_BSP_Init
      24   USBH_Process
         0   -- Indirect call
        24   -- Indirect call
        24   -> HCD_GetCurrentSpeed
        24   -> HCD_IsDeviceConnected
        24   -> HCD_ResetPort
        24   -> TM_DELAY_SetTime
        24   -> TM_DELAY_Time
        24   -> USBH_Alloc_Channel
        24   -> USBH_DeAllocate_AllChannel
        24   -> USBH_DeInit
         0   -> USBH_ErrorHandle
         0   -> USBH_HandleControl
        24   -> USBH_HandleEnum
        24   -> USBH_Open_Channel
       0   USBH_SOF


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ?_0
       6  TM_DELAY_Init
      28  TM_DELAY_SetTime
       6  TM_DELAY_Time
      10  USBH_Connected
      56  USBH_DeInit
      10  USBH_Disconnected
      48  USBH_ErrorHandle
      12  USBH_HCD_INT_cb
       4  USBH_HCD_INT_fops
     548  USBH_HandleControl
     472  USBH_HandleEnum
      62  USBH_Init
     462  USBH_Process
       4  USBH_SOF
       4  USB_RespWaitCount
          timeout
       1  nWaitTime

 
     5 bytes in section .bss
    16 bytes in section .data
     4 bytes in section .rodata
 1 724 bytes in section .text
 
 1 724 bytes of CODE  memory
     4 bytes of CONST memory
    21 bytes of DATA  memory

Errors: none
Warnings: none
