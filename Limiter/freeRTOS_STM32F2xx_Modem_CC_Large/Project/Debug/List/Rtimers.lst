###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:18
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\Rtimers.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\Rtimers.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\Rtimers.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\Rtimers.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\Rtimers.c
      1          /*
      2              FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd. 
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          /* Standard includes. */
     67          #include <stdlib.h>
     68          
     69          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     70          all the API functions to use the MPU wrappers.  That should only be done when
     71          task.h is included from an application file. */
     72          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     73          
     74          #include "FreeRTOS.h"
     75          #include "task.h"
     76          #include "queue.h"
     77          #include "Rtimers.h"
     78          
     79          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     80          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     81          header files above, but not in this file, in order to generate the correct
     82          privileged Vs unprivileged linkage and placement. */
     83          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     84          
     85          
     86          /* This entire source file will be skipped if the application is not configured
     87          to include software timer functionality.  This #if is closed at the very bottom
     88          of this file.  If you want to include software timer functionality then ensure
     89          configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
     90          #if ( configUSE_TIMERS == 1 )
     91          
     92          /* Misc definitions. */
     93          #define tmrNO_DELAY		( portTickType ) 0U
     94          
     95          /* The definition of the timers themselves. */
     96          typedef struct tmrTimerControl
     97          {
     98          	const signed char		*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */
     99          	xListItem				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
    100          	portTickType			xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
    101          	unsigned portBASE_TYPE	uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one shot timer. */
    102          	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
    103          	tmrTIMER_CALLBACK		pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
    104          } xTIMER;
    105          
    106          /* The definition of messages that can be sent and received on the timer
    107          queue. */
    108          typedef struct tmrTimerQueueMessage
    109          {
    110          	portBASE_TYPE			xMessageID;			/*<< The command being sent to the timer service task. */
    111          	portTickType			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
    112          	xTIMER *				pxTimer;			/*<< The timer to which the command will be applied. */
    113          } xTIMER_MESSAGE;
    114          
    115          /*lint -e956 A manual analysis and inspection has been used to determine which
    116          static variables must be declared volatile. */
    117          
    118          /* The list in which active timers are stored.  Timers are referenced in expire
    119          time order, with the nearest expiry time at the front of the list.  Only the
    120          timer service task is allowed to access xActiveTimerList. */

   \                                 In section .bss, align 4
    121          PRIVILEGED_DATA static xList xActiveTimerList1;
    122          PRIVILEGED_DATA static xList xActiveTimerList2;
    123          PRIVILEGED_DATA static xList *pxCurrentTimerList;
   \                     pxCurrentTimerList:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   \   0000000C                      DS8 20
   \   00000020                      DS8 20
    124          PRIVILEGED_DATA static xList *pxOverflowTimerList;
    125          
    126          /* A queue that is used to send commands to the timer service task. */
    127          PRIVILEGED_DATA static xQueueHandle xTimerQueue = NULL;
    128          
    129          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    130          
    131          	PRIVILEGED_DATA static xTaskHandle xTimerTaskHandle = NULL;
    132          
    133          #endif
    134          
    135          /*lint +e956 */
    136          
    137          /*-----------------------------------------------------------*/
    138          
    139          /*
    140           * Initialise the infrastructure used by the timer service task if it has not
    141           * been initialised already.
    142           */
    143          static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
    144          
    145          /*
    146           * The timer service task (daemon).  Timer functionality is controlled by this
    147           * task.  Other tasks communicate with the timer service task using the
    148           * xTimerQueue queue.
    149           */
    150          static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
    151          
    152          /*
    153           * Called by the timer service task to interpret and process a command it
    154           * received on the timer queue.
    155           */
    156          static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
    157          
    158          /*
    159           * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
    160           * depending on if the expire time causes a timer counter overflow.
    161           */
    162          static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime ) PRIVILEGED_FUNCTION;
    163          
    164          /*
    165           * An active timer has reached its expire time.  Reload the timer if it is an
    166           * auto reload timer, then call its callback.
    167           */
    168          static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow ) PRIVILEGED_FUNCTION;
    169          
    170          /*
    171           * The tick count has overflowed.  Switch the timer lists after ensuring the
    172           * current timer list does not still reference some timers.
    173           */
    174          static void prvSwitchTimerLists( portTickType xLastTime ) PRIVILEGED_FUNCTION;
    175          
    176          /*
    177           * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
    178           * if a tick count overflow occurred since prvSampleTimeNow() was last called.
    179           */
    180          static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
    181          
    182          /*
    183           * If the timer list contains any active timers then return the expire time of
    184           * the timer that will expire first and set *pxListWasEmpty to false.  If the
    185           * timer list does not contain any timers then return 0 and set *pxListWasEmpty
    186           * to pdTRUE.
    187           */
    188          static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty ) PRIVILEGED_FUNCTION;
    189          
    190          /*
    191           * If a timer has expired, process it.  Otherwise, block the timer service task
    192           * until either a timer does expire or a command is received.
    193           */
    194          static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;
    195          
    196          /*-----------------------------------------------------------*/
    197          

   \                                 In section .text, align 2, keep-with-next
    198          portBASE_TYPE xTimerCreateTimerTask( void )
    199          {
   \                     xTimerCreateTimerTask: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    200          portBASE_TYPE xReturn = pdFAIL;
   \   00000002   0x2400             MOVS     R4,#+0
    201          
    202          	/* This function is called when the scheduler is started if
    203          	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
    204          	timer service task has been created/initialised.  If timers have already
    205          	been created then the initialisation will already have been performed. */
    206          	prvCheckForValidListAndQueue();
   \   00000004   0x.... 0x....      BL       prvCheckForValidListAndQueue
    207          
    208          	if( xTimerQueue != NULL )
   \   00000008   0x....             LDR.N    R0,??DataTable10
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00F             BEQ.N    ??xTimerCreateTimerTask_0
    209          	{
    210          		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    211          		{
    212          			/* Create the timer task, storing its handle in xTimerTaskHandle so
    213          			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
    214          			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
    215          		}
    216          		#else
    217          		{
    218          			/* Create the timer task without storing its handle. */
    219          			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x9003             STR      R0,[SP, #+12]
   \   00000014   0x9002             STR      R0,[SP, #+8]
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x4623             MOV      R3,R4
   \   0000001E   0xF44F 0x7280      MOV      R2,#+256
   \   00000022   0x.... 0x....      ADR.W    R1,?_0
   \   00000026   0x.... 0x....      ADR.W    R0,prvTimerTask
   \   0000002A   0x.... 0x....      BL       xTaskGenericCreate
   \   0000002E   0x4604             MOV      R4,R0
    220          		}
    221          		#endif
    222          	}
    223          
    224          	configASSERT( xReturn );
    225          	return xReturn;
   \                     ??xTimerCreateTimerTask_0: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xB004             ADD      SP,SP,#+16
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    226          }
    227          /*-----------------------------------------------------------*/
    228          

   \                                 In section .text, align 2, keep-with-next
    229          xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
    230          {
   \                     xTimerCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    231          xTIMER *pxNewTimer;
    232          
    233          	/* Allocate the timer structure. */
    234          	if( xTimerPeriodInTicks == ( portTickType ) 0U )
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD102             BNE.N    ??xTimerCreate_0
    235          	{
    236          		pxNewTimer = NULL;
   \   00000010   0xF04F 0x0800      MOV      R8,#+0
   \   00000014   0xE017             B.N      ??xTimerCreate_1
    237          	}
    238          	else
    239          	{
    240          		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
   \                     ??xTimerCreate_0: (+1)
   \   00000016   0x2028             MOVS     R0,#+40
   \   00000018   0x.... 0x....      BL       pvPortMalloc
   \   0000001C   0x4680             MOV      R8,R0
    241          		if( pxNewTimer != NULL )
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD010             BEQ.N    ??xTimerCreate_1
    242          		{
    243          			/* Ensure the infrastructure used by the timer service task has been
    244          			created/initialised. */
    245          			prvCheckForValidListAndQueue();
   \   00000024   0x.... 0x....      BL       prvCheckForValidListAndQueue
    246          
    247          			/* Initialise the timer structure members using the function parameters. */
    248          			pxNewTimer->pcTimerName = pcTimerName;
   \   00000028   0xF8C8 0x4000      STR      R4,[R8, #+0]
    249          			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   \   0000002C   0xF8C8 0x5018      STR      R5,[R8, #+24]
    250          			pxNewTimer->uxAutoReload = uxAutoReload;
   \   00000030   0xF8C8 0x601C      STR      R6,[R8, #+28]
    251          			pxNewTimer->pvTimerID = pvTimerID;
   \   00000034   0xF8C8 0x7020      STR      R7,[R8, #+32]
    252          			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   \   00000038   0x9806             LDR      R0,[SP, #+24]
   \   0000003A   0xF8C8 0x0024      STR      R0,[R8, #+36]
    253          			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   \   0000003E   0xF108 0x0004      ADD      R0,R8,#+4
   \   00000042   0x.... 0x....      BL       vListInitialiseItem
    254          
    255          			traceTIMER_CREATE( pxNewTimer );
    256          		}
    257          		else
    258          		{
    259          			traceTIMER_CREATE_FAILED();
    260          		}
    261          	}
    262          
    263          	/* 0 is not a valid value for xTimerPeriodInTicks. */
    264          	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    265          
    266          	return ( xTimerHandle ) pxNewTimer;
   \                     ??xTimerCreate_1: (+1)
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    267          }
    268          /*-----------------------------------------------------------*/
    269          

   \                                 In section .text, align 2, keep-with-next
    270          portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
    271          {
   \                     xTimerGenericCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461D             MOV      R5,R3
    272          portBASE_TYPE xReturn = pdFAIL;
   \   00000008   0x2300             MOVS     R3,#+0
    273          xTIMER_MESSAGE xMessage;
    274          
    275          	/* Send a message to the timer service task to perform a particular action
    276          	on a particular timer definition. */
    277          	if( xTimerQueue != NULL )
   \   0000000A   0x....             LDR.N    R6,??DataTable10
   \   0000000C   0x68B0             LDR      R0,[R6, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01D             BEQ.N    ??xTimerGenericCommand_0
    278          	{
    279          		/* Send a command to the timer service task to start the xTimer timer. */
    280          		xMessage.xMessageID = xCommandID;
   \   00000012   0x9100             STR      R1,[SP, #+0]
    281          		xMessage.xMessageValue = xOptionalValue;
   \   00000014   0x9201             STR      R2,[SP, #+4]
    282          		xMessage.pxTimer = ( xTIMER * ) xTimer;
   \   00000016   0x9402             STR      R4,[SP, #+8]
    283          
    284          		if( pxHigherPriorityTaskWoken == NULL )
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD113             BNE.N    ??xTimerGenericCommand_1
    285          		{
    286          			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   \   0000001C   0x.... 0x....      BL       xTaskGetSchedulerState
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD107             BNE.N    ??xTimerGenericCommand_2
    287          			{
    288          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x9A08             LDR      R2,[SP, #+32]
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x68B0             LDR      R0,[R6, #+8]
   \   0000002C   0x.... 0x....      BL       xQueueGenericSend
   \   00000030   0x4603             MOV      R3,R0
   \   00000032   0xE00C             B.N      ??xTimerGenericCommand_0
    289          			}
    290          			else
    291          			{
    292          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   \                     ??xTimerGenericCommand_2: (+1)
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x461A             MOV      R2,R3
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x68B0             LDR      R0,[R6, #+8]
   \   0000003C   0x.... 0x....      BL       xQueueGenericSend
   \   00000040   0x4603             MOV      R3,R0
   \   00000042   0xE004             B.N      ??xTimerGenericCommand_0
    293          			}
    294          		}
    295          		else
    296          		{
    297          			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   \                     ??xTimerGenericCommand_1: (+1)
   \   00000044   0x462A             MOV      R2,R5
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x.... 0x....      BL       xQueueGenericSendFromISR
   \   0000004C   0x4603             MOV      R3,R0
    298          		}
    299          
    300          		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
    301          	}
    302          
    303          	return xReturn;
   \                     ??xTimerGenericCommand_0: (+1)
   \   0000004E   0x4618             MOV      R0,R3
   \   00000050   0xB004             ADD      SP,SP,#+16
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    304          }
    305          /*-----------------------------------------------------------*/
    306          
    307          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    308          
    309          	xTaskHandle xTimerGetTimerDaemonTaskHandle( void )
    310          	{
    311          		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
    312          		started, then xTimerTaskHandle will be NULL. */
    313          		configASSERT( ( xTimerTaskHandle != NULL ) );
    314          		return xTimerTaskHandle;
    315          	}
    316          
    317          #endif
    318          /*-----------------------------------------------------------*/
    319          

   \                                 In section .text, align 2, keep-with-next
    320          static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
    321          {
   \                     prvProcessExpiredTimer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    322          xTIMER *pxTimer;
    323          portBASE_TYPE xResult;
    324          
    325          	/* Remove the timer from the list of active timers.  A check has already
    326          	been performed to ensure the list is not empty. */
    327          	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   \   00000008   0x....             LDR.N    R0,??DataTable10
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x68C6             LDR      R6,[R0, #+12]
    328          	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   \   00000010   0x1D30             ADDS     R0,R6,#+4
   \   00000012   0x.... 0x....      BL       uxListRemove
    329          	traceTIMER_EXPIRED( pxTimer );
    330          
    331          	/* If the timer is an auto reload timer then calculate the next
    332          	expiry time and re-insert the timer in the list of active timers. */
    333          	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   \   00000016   0x69F0             LDR      R0,[R6, #+28]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD110             BNE.N    ??prvProcessExpiredTimer_0
    334          	{
    335          		/* This is the only time a timer is inserted into a list using
    336          		a time relative to anything other than the current time.  It
    337          		will therefore be inserted into the correct list relative to
    338          		the time this task thinks it is now, even if a command to
    339          		switch lists due to a tick count overflow is already waiting in
    340          		the timer queue. */
    341          		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   \   0000001C   0x4623             MOV      R3,R4
   \   0000001E   0x462A             MOV      R2,R5
   \   00000020   0x69B0             LDR      R0,[R6, #+24]
   \   00000022   0x1901             ADDS     R1,R0,R4
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       prvInsertTimerInActiveList
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD107             BNE.N    ??prvProcessExpiredTimer_0
    342          		{
    343          			/* The timer expired before it was added to the active timer
    344          			list.  Reload it now.  */
    345          			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x4603             MOV      R3,R0
   \   00000034   0x4622             MOV      R2,R4
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       xTimerGenericCommand
    346          			configASSERT( xResult );
    347          			( void ) xResult;
    348          		}
    349          	}
    350          
    351          	/* Call the timer callback. */
    352          	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   \                     ??prvProcessExpiredTimer_0: (+1)
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x6A71             LDR      R1,[R6, #+36]
   \   00000042   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   00000046   0x4708             BX       R1
    353          }
    354          /*-----------------------------------------------------------*/
    355          

   \                                 In section .text, align 4, keep-with-next
    356          static void prvTimerTask( void *pvParameters )
    357          {
   \                     prvTimerTask: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    358          portTickType xNextExpireTime;
    359          portBASE_TYPE xListWasEmpty;
    360          
    361          	/* Just to avoid compiler warnings. */
    362          	( void ) pvParameters;
    363          
    364          	for( ;; )
    365          	{
    366          		/* Query the timers list to see if it contains any timers, and if so,
    367          		obtain the time at which the next timer will expire. */
    368          		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   \                     ??prvTimerTask_0: (+1)
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x.... 0x....      BL       prvGetNextExpireTime
    369          
    370          		/* If a timer has expired, process it.  Otherwise, block this task
    371          		until either a timer does expire, or a command is received. */
    372          		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   \   00000008   0x9900             LDR      R1,[SP, #+0]
   \   0000000A   0x.... 0x....      BL       prvProcessTimerOrBlockTask
    373          
    374          		/* Empty the command queue. */
    375          		prvProcessReceivedCommands();
   \   0000000E   0x.... 0x....      BL       prvProcessReceivedCommands
   \   00000012   0xE7F6             B.N      ??prvTimerTask_0
    376          	}
    377          }
    378          /*-----------------------------------------------------------*/
    379          

   \                                 In section .text, align 2, keep-with-next
    380          static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
    381          {
   \                     prvProcessTimerOrBlockTask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    382          portTickType xTimeNow;
    383          portBASE_TYPE xTimerListsWereSwitched;
    384          
    385          	vTaskSuspendAll();
   \   00000008   0x.... 0x....      BL       vTaskSuspendAll
    386          	{
    387          		/* Obtain the time now to make an assessment as to whether the timer
    388          		has expired or not.  If obtaining the time causes the lists to switch
    389          		then don't process this timer as any timers that remained in the list
    390          		when the lists were switched will have been processed within the
    391          		prvSampelTimeNow() function. */
    392          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       prvSampleTimeNow
   \   00000012   0x4606             MOV      R6,R0
    393          		if( xTimerListsWereSwitched == pdFALSE )
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD116             BNE.N    ??prvProcessTimerOrBlockTask_0
    394          		{
    395          			/* The tick count has not overflowed, has the timer expired? */
    396          			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD108             BNE.N    ??prvProcessTimerOrBlockTask_1
   \   0000001E   0x42A6             CMP      R6,R4
   \   00000020   0xD306             BCC.N    ??prvProcessTimerOrBlockTask_1
    397          			{
    398          				( void ) xTaskResumeAll();
   \   00000022   0x.... 0x....      BL       xTaskResumeAll
    399          				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   \   00000026   0x4631             MOV      R1,R6
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       prvProcessExpiredTimer
   \   0000002E   0xBD73             POP      {R0,R1,R4-R6,PC}
    400          			}
    401          			else
    402          			{
    403          				/* The tick count has not overflowed, and the next expire
    404          				time has not been reached yet.  This task should therefore
    405          				block to wait for the next expire time or a command to be
    406          				received - whichever comes first.  The following line cannot
    407          				be reached unless xNextExpireTime > xTimeNow, except in the
    408          				case when the current timer list is empty. */
    409          				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
   \                     ??prvProcessTimerOrBlockTask_1: (+1)
   \   00000030   0x1BA1             SUBS     R1,R4,R6
   \   00000032   0x....             LDR.N    R0,??DataTable10
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0x.... 0x....      BL       vQueueWaitForMessageRestricted
    410          
    411          				if( xTaskResumeAll() == pdFALSE )
   \   0000003A   0x.... 0x....      BL       xTaskResumeAll
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD104             BNE.N    ??prvProcessTimerOrBlockTask_2
    412          				{
    413          					/* Yield to wait for either a command to arrive, or the block time
    414          					to expire.  If a command arrived between the critical section being
    415          					exited and this yield then the yield will not cause the task
    416          					to block. */
    417          					portYIELD_WITHIN_API();
   \   00000042   0x.... 0x....      BL       vPortYield
   \   00000046   0xBD73             POP      {R0,R1,R4-R6,PC}
    418          				}
    419          			}
    420          		}
    421          		else
    422          		{
    423          			( void ) xTaskResumeAll();
   \                     ??prvProcessTimerOrBlockTask_0: (+1)
   \   00000048   0x.... 0x....      BL       xTaskResumeAll
    424          		}
    425          	}
    426          }
   \                     ??prvProcessTimerOrBlockTask_2: (+1)
   \   0000004C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    427          /*-----------------------------------------------------------*/
    428          

   \                                 In section .text, align 2, keep-with-next
    429          static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
    430          {
    431          portTickType xNextExpireTime;
    432          
    433          	/* Timers are listed in expiry time order, with the head of the list
    434          	referencing the task that will expire first.  Obtain the time at which
    435          	the timer with the nearest expiry time will expire.  If there are no
    436          	active timers then just set the next expire time to 0.  That will cause
    437          	this task to unblock when the tick count overflows, at which point the
    438          	timer lists will be switched and the next expiry time can be
    439          	re-assessed.  */
    440          	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   \                     prvGetNextExpireTime: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x1E52             SUBS     R2,R2,#+1
   \   00000008   0x4192             SBCS     R2,R2,R2
   \   0000000A   0x0FD2             LSRS     R2,R2,#+31
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    441          	if( *pxListWasEmpty == pdFALSE )
   \   0000000E   0xD102             BNE.N    ??prvGetNextExpireTime_0
    442          	{
    443          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   \   00000010   0x68C8             LDR      R0,[R1, #+12]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x4770             BX       LR
    444          	}
    445          	else
    446          	{
    447          		/* Ensure the task unblocks when the tick count rolls over. */
    448          		xNextExpireTime = ( portTickType ) 0U;
   \                     ??prvGetNextExpireTime_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
    449          	}
    450          
    451          	return xNextExpireTime;
   \   00000018   0x4770             BX       LR               ;; return
    452          }
    453          /*-----------------------------------------------------------*/
    454          

   \                                 In section .text, align 2, keep-with-next
    455          static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
    456          {
   \                     prvSampleTimeNow: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    457          portTickType xTimeNow;
    458          PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */
    459          
    460          	xTimeNow = xTaskGetTickCount();
   \   00000004   0x.... 0x....      BL       xTaskGetTickCount
   \   00000008   0x4605             MOV      R5,R0
    461          
    462          	if( xTimeNow < xLastTime )
   \   0000000A   0x....             LDR.N    R6,??DataTable10_1
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD204             BCS.N    ??prvSampleTimeNow_0
    463          	{
    464          		prvSwitchTimerLists( xLastTime );
   \   00000012   0x.... 0x....      BL       prvSwitchTimerLists
    465          		*pxTimerListsWereSwitched = pdTRUE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x6020             STR      R0,[R4, #+0]
   \   0000001A   0xE001             B.N      ??prvSampleTimeNow_1
    466          	}
    467          	else
    468          	{
    469          		*pxTimerListsWereSwitched = pdFALSE;
   \                     ??prvSampleTimeNow_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6020             STR      R0,[R4, #+0]
    470          	}
    471          
    472          	xLastTime = xTimeNow;
   \                     ??prvSampleTimeNow_1: (+1)
   \   00000020   0x6035             STR      R5,[R6, #+0]
    473          
    474          	return xTimeNow;
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    475          }

   \                                 In section .bss, align 4
   \                     `prvSampleTimeNow::xLastTime`:
   \   00000000                      DS8 4
    476          /*-----------------------------------------------------------*/
    477          

   \                                 In section .text, align 2, keep-with-next
    478          static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
    479          {
   \                     prvInsertTimerInActiveList: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    480          portBASE_TYPE xProcessTimerNow = pdFALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    481          
    482          	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   \   00000004   0x6041             STR      R1,[R0, #+4]
    483          	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   \   00000006   0x6100             STR      R0,[R0, #+16]
    484          
    485          	if( xNextExpiryTime <= xTimeNow )
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xD30B             BCC.N    ??prvInsertTimerInActiveList_0
    486          	{
    487          		/* Has the expiry time elapsed between the command to start/reset a
    488          		timer was issued, and the time the command was processed? */
    489          		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
   \   0000000C   0x1AD1             SUBS     R1,R2,R3
   \   0000000E   0x6982             LDR      R2,[R0, #+24]
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xD301             BCC.N    ??prvInsertTimerInActiveList_1
    490          		{
    491          			/* The time between a command being issued and the command being
    492          			processed actually exceeds the timers period.  */
    493          			xProcessTimerNow = pdTRUE;
   \   00000014   0x2401             MOVS     R4,#+1
   \   00000016   0xE010             B.N      ??prvInsertTimerInActiveList_2
    494          		}
    495          		else
    496          		{
    497          			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   \                     ??prvInsertTimerInActiveList_1: (+1)
   \   00000018   0x1D01             ADDS     R1,R0,#+4
   \   0000001A   0x....             LDR.N    R0,??DataTable10
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x.... 0x....      BL       vListInsert
   \   00000022   0xE00A             B.N      ??prvInsertTimerInActiveList_2
    498          		}
    499          	}
    500          	else
    501          	{
    502          		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   \                     ??prvInsertTimerInActiveList_0: (+1)
   \   00000024   0x429A             CMP      R2,R3
   \   00000026   0xD203             BCS.N    ??prvInsertTimerInActiveList_3
   \   00000028   0x4299             CMP      R1,R3
   \   0000002A   0xD301             BCC.N    ??prvInsertTimerInActiveList_3
    503          		{
    504          			/* If, since the command was issued, the tick count has overflowed
    505          			but the expiry time has not, then the timer must have already passed
    506          			its expiry time and should be processed immediately. */
    507          			xProcessTimerNow = pdTRUE;
   \   0000002C   0x2401             MOVS     R4,#+1
   \   0000002E   0xE004             B.N      ??prvInsertTimerInActiveList_2
    508          		}
    509          		else
    510          		{
    511          			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   \                     ??prvInsertTimerInActiveList_3: (+1)
   \   00000030   0x1D01             ADDS     R1,R0,#+4
   \   00000032   0x....             LDR.N    R0,??DataTable10
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x.... 0x....      BL       vListInsert
    512          		}
    513          	}
    514          
    515          	return xProcessTimerNow;
   \                     ??prvInsertTimerInActiveList_2: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    516          }
    517          /*-----------------------------------------------------------*/
    518          

   \                                 In section .text, align 2, keep-with-next
    519          static void	prvProcessReceivedCommands( void )
    520          {
   \                     prvProcessReceivedCommands: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0xE006             B.N      ??prvProcessReceivedCommands_0
    521          xTIMER_MESSAGE xMessage;
    522          xTIMER *pxTimer;
    523          portBASE_TYPE xTimerListsWereSwitched, xResult;
    524          portTickType xTimeNow;
    525          
    526          	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    527          	{
    528          		pxTimer = xMessage.pxTimer;
    529          
    530          		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    531          		{
    532          			/* The timer is in a list, remove it. */
    533          			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    534          		}
    535          
    536          		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
    537          
    538          		/* In this case the xTimerListsWereSwitched parameter is not used, but 
    539          		it must be present in the function call.  prvSampleTimeNow() must be 
    540          		called after the message is received from xTimerQueue so there is no 
    541          		possibility of a higher priority task adding a message to the message
    542          		queue with a time that is ahead of the timer daemon task (because it
    543          		pre-empted the timer daemon task after the xTimeNow value was set). */
    544          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    545          
    546          		switch( xMessage.xMessageID )
    547          		{
    548          			case tmrCOMMAND_START :
    549          				/* Start or restart a timer. */
    550          				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    551          				{
    552          					/* The timer expired before it was added to the active timer
    553          					list.  Process it now. */
    554          					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    555          
    556          					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    557          					{
    558          						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    559          						configASSERT( xResult );
    560          						( void ) xResult;
    561          					}
    562          				}
    563          				break;
    564          
    565          			case tmrCOMMAND_STOP :
    566          				/* The timer has already been removed from the active list.
    567          				There is nothing to do here. */
    568          				break;
    569          
    570          			case tmrCOMMAND_CHANGE_PERIOD :
    571          				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
   \                     ??prvProcessReceivedCommands_1: (+1)
   \   00000006   0x9803             LDR      R0,[SP, #+12]
   \   00000008   0x61A0             STR      R0,[R4, #+24]
    572          				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    573          
    574          				/* The new period does not really have a reference, and can be
    575          				longer or shorter than the old one.  The command time is 
    576          				therefore set to the current time, and as the period cannot be
    577          				zero the next expiry time can only be in the future, meaning
    578          				(unlike for the xTimerStart() case above) there is no fail case
    579          				that needs to be handled here. */
    580          				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   \   0000000A   0x4613             MOV      R3,R2
   \   0000000C   0x1881             ADDS     R1,R0,R2
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       prvInsertTimerInActiveList
    581          				break;
   \                     ??prvProcessReceivedCommands_0: (+1)
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x461A             MOV      R2,R3
   \   00000018   0xA902             ADD      R1,SP,#+8
   \   0000001A   0x....             LDR.N    R0,??DataTable10
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x.... 0x....      BL       xQueueGenericReceive
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD030             BEQ.N    ??prvProcessReceivedCommands_2
   \   00000026   0x9C04             LDR      R4,[SP, #+16]
   \   00000028   0x6960             LDR      R0,[R4, #+20]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD002             BEQ.N    ??prvProcessReceivedCommands_3
   \   0000002E   0x1D20             ADDS     R0,R4,#+4
   \   00000030   0x.... 0x....      BL       uxListRemove
   \                     ??prvProcessReceivedCommands_3: (+1)
   \   00000034   0xA801             ADD      R0,SP,#+4
   \   00000036   0x.... 0x....      BL       prvSampleTimeNow
   \   0000003A   0x4602             MOV      R2,R0
   \   0000003C   0x9802             LDR      R0,[SP, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD004             BEQ.N    ??prvProcessReceivedCommands_4
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD0DF             BEQ.N    ??prvProcessReceivedCommands_1
   \   00000046   0x2803             CMP      R0,#+3
   \   00000048   0xD01A             BEQ.N    ??prvProcessReceivedCommands_5
   \   0000004A   0xE7E3             B.N      ??prvProcessReceivedCommands_0
   \                     ??prvProcessReceivedCommands_4: (+1)
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0x4603             MOV      R3,R0
   \   00000050   0x69A1             LDR      R1,[R4, #+24]
   \   00000052   0x1809             ADDS     R1,R1,R0
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       prvInsertTimerInActiveList
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD1DA             BNE.N    ??prvProcessReceivedCommands_0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x6A61             LDR      R1,[R4, #+36]
   \   00000062   0x4788             BLX      R1
   \   00000064   0x69E0             LDR      R0,[R4, #+28]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD1D4             BNE.N    ??prvProcessReceivedCommands_0
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0x4603             MOV      R3,R0
   \   00000070   0x9803             LDR      R0,[SP, #+12]
   \   00000072   0x69A1             LDR      R1,[R4, #+24]
   \   00000074   0x180A             ADDS     R2,R1,R0
   \   00000076   0x4619             MOV      R1,R3
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       xTimerGenericCommand
   \   0000007E   0xE7C9             B.N      ??prvProcessReceivedCommands_0
    582          
    583          			case tmrCOMMAND_DELETE :
    584          				/* The timer has already been removed from the active list,
    585          				just free up the memory. */
    586          				vPortFree( pxTimer );
   \                     ??prvProcessReceivedCommands_5: (+1)
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       vPortFree
    587          				break;
   \   00000086   0xE7C5             B.N      ??prvProcessReceivedCommands_0
    588          
    589          			default	:
    590          				/* Don't expect to get here. */
    591          				break;
    592          		}
    593          	}
    594          }
   \                     ??prvProcessReceivedCommands_2: (+1)
   \   00000088   0xB006             ADD      SP,SP,#+24
   \   0000008A   0xBD10             POP      {R4,PC}          ;; return
    595          /*-----------------------------------------------------------*/
    596          

   \                                 In section .text, align 2, keep-with-next
    597          static void prvSwitchTimerLists( portTickType xLastTime )
    598          {
   \                     prvSwitchTimerLists: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    599          portTickType xNextExpireTime, xReloadTime;
    600          xList *pxTemp;
    601          xTIMER *pxTimer;
    602          portBASE_TYPE xResult;
    603          
    604          	/* Remove compiler warnings if configASSERT() is not defined. */
    605          	( void ) xLastTime;
   \   00000004   0x....             LDR.N    R4,??DataTable10
   \   00000006   0xE005             B.N      ??prvSwitchTimerLists_0
    606          
    607          	/* The tick count has overflowed.  The timer lists must be switched.
    608          	If there are any timers still referenced from the current timer list
    609          	then they must have expired and should be processed before the lists
    610          	are switched. */
    611          	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    612          	{
    613          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    614          
    615          		/* Remove the timer from the list. */
    616          		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    617          		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    618          
    619          		/* Execute its callback, then send a command to restart the timer if
    620          		it is an auto-reload timer.  It cannot be restarted here as the lists
    621          		have not yet been switched. */
    622          		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    623          
    624          		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    625          		{
    626          			/* Calculate the reload value, and if the reload value results in
    627          			the timer going into the same timer list then it has already expired
    628          			and the timer should be re-inserted into the current list so it is
    629          			processed again within this loop.  Otherwise a command should be sent
    630          			to restart the timer to ensure it is only inserted into a list after
    631          			the lists have been swapped. */
    632          			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    633          			if( xReloadTime > xNextExpireTime )
    634          			{
    635          				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   \                     ??prvSwitchTimerLists_1: (+1)
   \   00000008   0x6070             STR      R0,[R6, #+4]
    636          				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   \   0000000A   0x6136             STR      R6,[R6, #+16]
    637          				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   \   0000000C   0x1D31             ADDS     R1,R6,#+4
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       vListInsert
    638          			}
   \                     ??prvSwitchTimerLists_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD018             BEQ.N    ??prvSwitchTimerLists_2
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0x6805             LDR      R5,[R0, #+0]
   \   00000020   0x68C6             LDR      R6,[R0, #+12]
   \   00000022   0x1D30             ADDS     R0,R6,#+4
   \   00000024   0x.... 0x....      BL       uxListRemove
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x6A71             LDR      R1,[R6, #+36]
   \   0000002C   0x4788             BLX      R1
   \   0000002E   0x69F0             LDR      R0,[R6, #+28]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD1EF             BNE.N    ??prvSwitchTimerLists_0
   \   00000034   0x69B0             LDR      R0,[R6, #+24]
   \   00000036   0x1940             ADDS     R0,R0,R5
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD3E5             BCC.N    ??prvSwitchTimerLists_1
    639          			else
    640          			{
    641          				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x4603             MOV      R3,R0
   \   00000042   0x462A             MOV      R2,R5
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       xTimerGenericCommand
    642          				configASSERT( xResult );
    643          				( void ) xResult;
   \   0000004C   0xE7E2             B.N      ??prvSwitchTimerLists_0
    644          			}
    645          		}
    646          	}
    647          
    648          	pxTemp = pxCurrentTimerList;
    649          	pxCurrentTimerList = pxOverflowTimerList;
   \                     ??prvSwitchTimerLists_2: (+1)
   \   0000004E   0x6861             LDR      R1,[R4, #+4]
   \   00000050   0x6021             STR      R1,[R4, #+0]
    650          	pxOverflowTimerList = pxTemp;
   \   00000052   0x6060             STR      R0,[R4, #+4]
    651          }
   \   00000054   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    652          /*-----------------------------------------------------------*/
    653          

   \                                 In section .text, align 2, keep-with-next
    654          static void prvCheckForValidListAndQueue( void )
    655          {
   \                     prvCheckForValidListAndQueue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    656          	/* Check that the list from which active timers are referenced, and the
    657          	queue used to communicate with the timer service, have been
    658          	initialised. */
    659          	taskENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       vPortEnterCritical
    660          	{
    661          		if( xTimerQueue == NULL )
   \   00000006   0x....             LDR.N    R4,??DataTable10
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD113             BNE.N    ??prvCheckForValidListAndQueue_0
    662          		{
    663          			vListInitialise( &xActiveTimerList1 );
   \   0000000E   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000012   0x.... 0x....      BL       vListInitialise
    664          			vListInitialise( &xActiveTimerList2 );
   \   00000016   0xF104 0x0020      ADD      R0,R4,#+32
   \   0000001A   0x.... 0x....      BL       vListInitialise
    665          			pxCurrentTimerList = &xActiveTimerList1;
   \   0000001E   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000022   0x6020             STR      R0,[R4, #+0]
    666          			pxOverflowTimerList = &xActiveTimerList2;
   \   00000024   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000028   0x6060             STR      R0,[R4, #+4]
    667          			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x210C             MOVS     R1,#+12
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0x.... 0x....      BL       xQueueGenericCreate
   \   00000034   0x60A0             STR      R0,[R4, #+8]
    668          		}
    669          	}
    670          	taskEXIT_CRITICAL();
   \                     ??prvCheckForValidListAndQueue_0: (+1)
   \   00000036   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003A   0x.... 0x....      B.W      vPortExitCritical
    671          }
    672          /*-----------------------------------------------------------*/
    673          

   \                                 In section .text, align 2, keep-with-next
    674          portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
    675          {
   \                     xTimerIsTimerActive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    676          portBASE_TYPE xTimerIsInActiveList;
    677          xTIMER *pxTimer = ( xTIMER * ) xTimer;
    678          
    679          	/* Is the timer in the list of active timers? */
    680          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    681          	{
    682          		/* Checking to see if it is in the NULL list in effect checks to see if
    683          		it is referenced from either the current or the overflow timer lists in
    684          		one go, but the logic has to be reversed, hence the '!'. */
    685          		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??xTimerIsTimerActive_0
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xE000             B.N      ??xTimerIsTimerActive_1
   \                     ??xTimerIsTimerActive_0: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
    686          	}
    687          	taskEXIT_CRITICAL();
   \                     ??xTimerIsTimerActive_1: (+1)
   \   00000014   0x.... 0x....      BL       vPortExitCritical
    688          
    689          	return xTimerIsInActiveList;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    690          }
    691          /*-----------------------------------------------------------*/
    692          

   \                                 In section .text, align 2, keep-with-next
    693          void *pvTimerGetTimerID( xTimerHandle xTimer )
    694          {
    695          xTIMER *pxTimer = ( xTIMER * ) xTimer;
    696          
    697          	return pxTimer->pvTimerID;
   \                     pvTimerGetTimerID: (+1)
   \   00000000   0x6A00             LDR      R0,[R0, #+32]
   \   00000002   0x4770             BX       LR               ;; return
    698          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pxCurrentTimerList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     `prvSampleTimeNow::xLastTime`

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x54 0x6D          DC8 "Tmr Svc"
   \              0x72 0x20    
   \              0x53 0x76    
   \              0x63 0x00    
    699          /*-----------------------------------------------------------*/
    700          
    701          /* This entire source file will be skipped if the application is not configured
    702          to include software timer functionality.  If you want to include software timer
    703          functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
    704          #endif /* configUSE_TIMERS == 1 */
    705          
    706          
    707          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   prvCheckForValidListAndQueue
         8   -> vListInitialise
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
         8   -> xQueueGenericCreate
       0   prvGetNextExpireTime
       8   prvInsertTimerInActiveList
         8   -> vListInsert
      24   prvProcessExpiredTimer
         0   -- Indirect call
        24   -> prvInsertTimerInActiveList
        24   -> uxListRemove
        24   -> xTimerGenericCommand
      32   prvProcessReceivedCommands
        32   -- Indirect call
        32   -> prvInsertTimerInActiveList
        32   -> prvSampleTimeNow
        32   -> uxListRemove
        32   -> vPortFree
        32   -> xQueueGenericReceive
        32   -> xTimerGenericCommand
      24   prvProcessTimerOrBlockTask
        24   -> prvProcessExpiredTimer
        24   -> prvSampleTimeNow
        24   -> vPortYield
        24   -> vQueueWaitForMessageRestricted
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
      16   prvSampleTimeNow
        16   -> prvSwitchTimerLists
        16   -> xTaskGetTickCount
      24   prvSwitchTimerLists
        24   -- Indirect call
        24   -> uxListRemove
        24   -> vListInsert
        24   -> xTimerGenericCommand
       8   prvTimerTask
         8   -> prvGetNextExpireTime
         8   -> prvProcessReceivedCommands
         8   -> prvProcessTimerOrBlockTask
       0   pvTimerGetTimerID
      24   xTimerCreate
        24   -> prvCheckForValidListAndQueue
        24   -> pvPortMalloc
        24   -> vListInitialiseItem
      24   xTimerCreateTimerTask
        24   -> prvCheckForValidListAndQueue
        24   -> xTaskGenericCreate
      32   xTimerGenericCommand
        32   -> xQueueGenericSend
        32   -> xQueueGenericSendFromISR
        32   -> xTaskGetSchedulerState
       8   xTimerIsTimerActive
         8   -> vPortEnterCritical
         8   -> vPortExitCritical


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       8  ?_0
      62  prvCheckForValidListAndQueue
      26  prvGetNextExpireTime
      62  prvInsertTimerInActiveList
      72  prvProcessExpiredTimer
     140  prvProcessReceivedCommands
      78  prvProcessTimerOrBlockTask
      38  prvSampleTimeNow
      86  prvSwitchTimerLists
      20  prvTimerTask
       4  pvTimerGetTimerID
      52  pxCurrentTimerList
          pxOverflowTimerList
          xTimerQueue
          xActiveTimerList1
          xActiveTimerList2
       4  xLastTime
      76  xTimerCreate
      54  xTimerCreateTimerTask
      84  xTimerGenericCommand
      28  xTimerIsTimerActive

 
  56 bytes in section .bss
 846 bytes in section .text
 
 846 bytes of CODE memory
  56 bytes of DATA memory

Errors: none
Warnings: none
