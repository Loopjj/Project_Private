###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\drivers\fatfs_sd_sdio.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\drivers\fatfs_sd_sdio.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\fatfs_sd_sdio.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\fatfs_sd_sdio.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\drivers\fatfs_sd_sdio.c
      1          /**
      2           ******************************************************************************
      3           * @file    stm324x9i_eval_sdio_sd.c
      4           * @author  MCD Application Team
      5           * @version V1.0.3
      6           * @date    13-November-2013
      7           * @brief   This file provides a set of functions needed to manage the SDIO SD
      8           *          Card memory mounted on STM324x9I-EVAL evaluation board.
      9           *
     10           *
     11           *  @verbatim
     12           *
     13           *          ===================================================================
     14           *                                   How to use this driver
     15           *          ===================================================================
     16           *          It implements a high level communication layer for read and write
     17           *          from/to this memory. The needed STM32 hardware resources (SDIO and
     18           *          GPIO) are defined in stm324x9i_eval.h file, and the initialization is
     19           *          performed in SD_LowLevel_Init() function declared in stm324x9i_eval.c
     20           *          file.
     21           *          You can easily tailor this driver to any other development board,
     22           *          by just adapting the defines for hardware resources and
     23           *          SD_LowLevel_Init() function.
     24           *
     25           *          A - SD Card Initialization and configuration
     26           *          ============================================
     27           *            - To initialize the SD Card, use the SD_Init() function.  It
     28           *              Initializes the SD Card and put it into StandBy State (Ready
     29           *              for data transfer). This function provides the following operations:
     30           *
     31           *              1 - Apply the SD Card initialization process at 400KHz and check
     32           *                  the SD Card type (Standard Capacity or High Capacity). You
     33           *                  can change or adapt this frequency by adjusting the
     34           *                  "SDIO_INIT_CLK_DIV" define inside the stm324x9i_eval.h file.
     35           *                  The SD Card frequency (SDIO_CK) is computed as follows:
     36           *
     37           *                     +---------------------------------------------+
     38           *                     | SDIO_CK = SDIOCLK / (SDIO_INIT_CLK_DIV + 2) |
     39           *                     +---------------------------------------------+
     40           *
     41           *                  In initialization mode and according to the SD Card standard,
     42           *                  make sure that the SDIO_CK frequency doesn't exceed 400KHz.
     43           *
     44           *              2 - Get the SD CID and CSD data. All these information are
     45           *                  managed by the SDCardInfo structure. This structure provides
     46           *                  also ready computed SD Card capacity and Block size.
     47           *
     48           *              3 - Configure the SD Card Data transfer frequency. By Default,
     49           *                  the card transfer frequency is set to 24MHz. You can change
     50           *                  or adapt this frequency by adjusting the "SDIO_TRANSFER_CLK_DIV"
     51           *                  define inside the stm324x9i_eval.h file.
     52           *                  The SD Card frequency (SDIO_CK) is computed as follows:
     53           *
     54           *                     +---------------------------------------------+
     55           *                     | SDIO_CK = SDIOCLK / (SDIO_INIT_CLK_DIV + 2) |
     56           *                     +---------------------------------------------+
     57           *
     58           *                  In transfer mode and according to the SD Card standard,
     59           *                  make sure that the SDIO_CK frequency doesn't exceed 25MHz
     60           *                  and 50MHz in High-speed mode switch.
     61           *                  To be able to use a frequency higher than 24MHz, you should
     62           *                  use the SDIO peripheral in bypass mode. Refer to the
     63           *                  corresponding reference manual for more details.
     64           *
     65           *              4 -  Select the corresponding SD Card according to the address
     66           *                   read with the step 2.
     67           *
     68           *              5 -  Configure the SD Card in wide bus mode: 4-bits data.
     69           *
     70           *          B - SD Card Read operation
     71           *          ==========================
     72           *           - You can read SD card by using two functions : SD_ReadBlock() and
     73           *             SD_ReadMultiBlocks() functions. These functions support only
     74           *             512-byte block length.
     75           *           - The SD_ReadBlock() function reads only one block (512-byte). This
     76           *             function can transfer the data using DMA controller or using
     77           *             polling mode. To select between DMA or polling mode refer to
     78           *             "SD_DMA_MODE" or "SD_POLLING_MODE" inside the stm324x9i_eval_sdio_sd.h
     79           *             file and uncomment the corresponding line. By default the SD DMA
     80           *             mode is selected
     81           *           - The SD_ReadMultiBlocks() function reads only mutli blocks (multiple
     82           *             of 512-byte).
     83           *           - Any read operation should be followed by two functions to check
     84           *             if the DMA Controller and SD Card status.
     85           *              - SD_ReadWaitOperation(): this function insure that the DMA
     86           *                controller has finished all data transfer.
     87           *              - SD_GetStatus(): to check that the SD Card has finished the
     88           *                data transfer and it is ready for data.
     89           *
     90           *           - The DMA transfer is finished by the SDIO Data End interrupt.
     91           *             User has to call the SD_ProcessIRQ() function inside the SDIO_IRQHandler()
     92           *             and SD_ProcessDMAIRQ() function inside the DMA2_Streamx_IRQHandler().
     93           *             Don't forget to enable the SDIO_IRQn and DMA2_Stream3_IRQn or
     94           *             DMA2_Stream6_IRQn interrupts using the NVIC controller.
     95           *
     96           *          C - SD Card Write operation
     97           *          ===========================
     98           *           - You can write SD card by using two function: SD_WriteBlock() and
     99           *             SD_WriteMultiBlocks() functions. These functions support only
    100           *             512-byte block length.
    101           *           - The SD_WriteBlock() function write only one block (512-byte). This
    102           *             function can transfer the data using DMA controller or using
    103           *             polling mode. To select between DMA or polling mode refer to
    104           *             "SD_DMA_MODE" or "SD_POLLING_MODE" inside the stm324x9i_eval_sdio_sd.h
    105           *             file and uncomment the corresponding line. By default the SD DMA
    106           *             mode is selected
    107           *           - The SD_WriteMultiBlocks() function write only mutli blocks (multiple
    108           *             of 512-byte).
    109           *           - Any write operation should be followed by two functions to check
    110           *             if the DMA Controller and SD Card status.
    111           *              - SD_ReadWaitOperation(): this function insure that the DMA
    112           *                controller has finished all data transfer.
    113           *              - SD_GetStatus(): to check that the SD Card has finished the
    114           *                data transfer and it is ready for data.
    115           *
    116           *           - The DMA transfer is finished by the SDIO Data End interrupt.
    117           *             User has to call the SD_ProcessIRQ() function inside the SDIO_IRQHandler()
    118           *             and SD_ProcessDMAIRQ() function inside the DMA2_Streamx_IRQHandler().
    119           *             Don't forget to enable the SDIO_IRQn and DMA2_Stream3_IRQn or
    120           *             DMA2_Stream6_IRQn interrupts using the NVIC controller.
    121           *
    122           *
    123           *          D - SD card status
    124           *          ==================
    125           *           - At any time, you can check the SD Card status and get the SD card
    126           *             state by using the SD_GetStatus() function. This function checks
    127           *             first if the SD card is still connected and then get the internal
    128           *             SD Card transfer state.
    129           *           - You can also get the SD card SD Status register by using the
    130           *             SD_SendSDStatus() function.
    131           *
    132           *          E - Programming Model (Selecting DMA for SDIO data Transfer)
    133           *          ============================================================
    134           *             Status = SD_Init(); // Initialization Step as described in section A
    135           *
    136           *             // SDIO Interrupt ENABLE
    137           *             NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
    138           *             NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    139           *             NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    140           *             NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    141           *             NVIC_Init(&NVIC_InitStructure);
    142           *             // DMA2 STREAMx Interrupt ENABLE
    143           *             NVIC_InitStructure.NVIC_IRQChannel = SD_SDIO_DMA_IRQn;
    144           *             NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    145           *             NVIC_Init(&NVIC_InitStructure);
    146           *
    147           *             // Write operation as described in Section C
    148           *             Status = SD_WriteBlock(buffer, address, 512);
    149           *             Status = SD_WaitWriteOperation();
    150           *             while(SD_GetStatus() != SD_TRANSFER_OK);
    151           *
    152           *             Status = SD_WriteMultiBlocks(buffer, address, 512, NUMBEROFBLOCKS);
    153           *             Status = SD_WaitWriteOperation();
    154           *             while(SD_GetStatus() != SD_TRANSFER_OK);
    155           *
    156           *             // Read operation as described in Section B
    157           *             Status = SD_ReadBlock(buffer, address, 512);
    158           *             Status = SD_WaitReadOperation();
    159           *             while(SD_GetStatus() != SD_TRANSFER_OK);
    160           *
    161           *             Status = SD_ReadMultiBlocks(buffer, address, 512, NUMBEROFBLOCKS);
    162           *             Status = SD_WaitReadOperation();
    163           *             while(SD_GetStatus() != SD_TRANSFER_OK);
    164           *
    165           *             - Add the SDIO and DMA2 StreamX (3 or 6) IRQ Handlers:
    166           *                 void SDIO_IRQHandler(void)
    167           *                 {
    168           *                   SD_ProcessIRQ();
    169           *                 }
    170           *                 void SD_SDIO_DMA_IRQHANDLER(void)
    171           *                 {
    172           *                   SD_ProcessDMAIRQ();
    173           *                 }
    174           *
    175           *          F - Programming Model (Selecting Polling for SDIO data Transfer)
    176           *          ================================================================
    177           *            //Only SD Card Single Block operation are managed.
    178           *            Status = SD_Init(); // Initialization Step as described in section
    179           *
    180           *            // Write operation as described in Section C
    181           *            Status = SD_WriteBlock(buffer, address, 512);
    182           *
    183           *            // Read operation as described in Section B
    184           *            Status = SD_ReadBlock(buffer, address, 512);
    185           *
    186           *          STM32 SDIO Pin assignment
    187           *          =========================
    188           *          +-----------------------------------------------------------+
    189           *          |                     Pin assignment                        |
    190           *          +-----------------------------+---------------+-------------+
    191           *          |  STM32 SDIO Pins            |     SD        |    Pin      |
    192           *          +-----------------------------+---------------+-------------+
    193           *          |      SDIO D2                |   D2          |    1        |
    194           *          |      SDIO D3                |   D3          |    2        |
    195           *          |      SDIO CMD               |   CMD         |    3        |
    196           *          |                             |   VCC         |    4 (3.3 V)|
    197           *          |      SDIO CLK               |   CLK         |    5        |
    198           *          |                             |   GND         |    6 (0 V)  |
    199           *          |      SDIO D0                |   D0          |    7        |
    200           *          |      SDIO D1                |   D1          |    8        |
    201           *          +-----------------------------+---------------+-------------+
    202           *
    203           *  @endverbatim
    204           *
    205           ******************************************************************************
    206           * @attention
    207           *
    208           * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
    209           *
    210           * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    211           * You may not use this file except in compliance with the License.
    212           * You may obtain a copy of the License at:
    213           *
    214           *        http://www.st.com/software_license_agreement_liberty_v2
    215           *
    216           * Unless required by applicable law or agreed to in writing, software
    217           * distributed under the License is distributed on an "AS IS" BASIS,
    218           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    219           * See the License for the specific language governing permissions and
    220           * limitations under the License.
    221           *
    222           ******************************************************************************
    223           */
    224          
    225          /* Includes ------------------------------------------------------------------*/
    226          
    227          //#include "stm32f2xx.h"
    228          //#include "fatfs_sd_sdio.h"
    229          //#include <string.h>
    230          #include "includes.h"
    231          
    232          #define logf(x)
    233          
    234          

   \                                 In section .bss, align 4
    235          static uint32_t CardType = SDIO_STD_CAPACITY_SD_CARD_V1_1;
    236          static uint32_t CSD_Tab[4], CID_Tab[4], RCA = 0;
    237          static uint8_t SDSTATUS_Tab[16];
    238          __IO uint32_t StopCondition = 0;
    239          __IO SD_Error TransferError = SD_OK;
    240          __IO uint32_t TransferEnd = 0, DMAEndOfTransfer = 0;
    241          SD_CardInfo SDCardInfo;
    242          
    243          SDIO_InitTypeDef SDIO_InitStructure;
   \                     SDIO_InitStructure:
   \   00000000                      DS8 24
   \                     TransferError:
   \   00000018                      DS8 1
   \   00000019                      DS8 3
    244          SDIO_CmdInitTypeDef SDIO_CmdInitStructure;
    245          SDIO_DataInitTypeDef SDIO_DataInitStructure;
   \                     SDIO_DataInitStructure:
   \   0000001C                      DS8 24
   \                     SDIO_CmdInitStructure:
   \   00000034                      DS8 20
   \   00000048                      DS8 16
   \   00000058                      DS8 16
   \   00000068                      DS8 4
   \   0000006C                      DS8 4
   \                     StopCondition:
   \   00000070                      DS8 4
   \                     TransferEnd:
   \   00000074                      DS8 4
   \                     DMAEndOfTransfer:
   \   00000078                      DS8 4

   \                                 In section .bss, align 4
   \                     SDSTATUS_Tab:
   \   00000000                      DS8 16

   \                                 In section .bss, align 8
   \                     SDCardInfo:
   \   00000000                      DS8 88
    246          /**
    247           * @}
    248           */
    249          
    250          /** @defgroup STM324x9I_EVAL_SDIO_SD_Private_Function_Prototypes
    251           * @{
    252           */
    253          static SD_Error CmdError (void);
    254          static SD_Error CmdResp1Error (uint8_t cmd);
    255          static SD_Error CmdResp7Error (void);
    256          static SD_Error CmdResp3Error (void);
    257          static SD_Error CmdResp2Error (void);
    258          static SD_Error CmdResp6Error (uint8_t cmd, uint16_t *prca);
    259          static SD_Error SDEnWideBus (FunctionalState NewState);
    260          static SD_Error IsCardProgramming (uint8_t *pstatus);
    261          static SD_Error FindSCR (uint16_t rca, uint32_t *pscr);
    262          uint8_t convert_from_bytes_to_power_of_two (uint16_t NumberOfBytes);
    263          
    264          

   \                                 In section .data, align 1
    265          static volatile DSTATUS TM_FATFS_SD_SDIO_Stat = STA_NOINIT;	/* Physical drive status */
   \                     TM_FATFS_SD_SDIO_Stat:
   \   00000000   0x01               DC8 1
    266          
    267          

   \                                 In section .text, align 2, keep-with-next
    268          uint8_t TM_FATFS_SDIO_WriteEnabled(void) {
    269          	return 1;
   \                     TM_FATFS_SDIO_WriteEnabled: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    270          }
    271          

   \                                 In section .text, align 2, keep-with-next
    272          DSTATUS TM_FATFS_SD_SDIO_disk_initialize(void)
    273          {
   \                     TM_FATFS_SD_SDIO_disk_initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    274          
    275          	
    276          	SD_LowLevel_DeInit();
   \   00000002   0x.... 0x....      BL       SD_LowLevel_DeInit
    277          	SD_LowLevel_Init();
   \   00000006   0x.... 0x....      BL       SD_LowLevel_Init
    278          	
    279          	//Check disk initialized
    280          	if (SD_Init() == SD_OK) {
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable20
   \   0000000E   0x.... 0x....      BL       SD_Init
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0xD103             BNE.N    ??TM_FATFS_SD_SDIO_disk_initialize_0
    281          		TM_FATFS_SD_SDIO_Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
   \   00000018   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   \   0000001E   0xE002             B.N      ??TM_FATFS_SD_SDIO_disk_initialize_1
    282          	} else {
    283          		TM_FATFS_SD_SDIO_Stat |= STA_NOINIT;
   \                     ??TM_FATFS_SD_SDIO_disk_initialize_0: (+1)
   \   00000020   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    284          	}
    285          	//Check write protected
    286          	if (!TM_FATFS_SDIO_WriteEnabled()) {
   \                     ??TM_FATFS_SD_SDIO_disk_initialize_1: (+1)
   \   00000026   0x.... 0x....      BL       TM_FATFS_SDIO_WriteEnabled
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0xD103             BNE.N    ??TM_FATFS_SD_SDIO_disk_initialize_2
    287          		TM_FATFS_SD_SDIO_Stat |= STA_PROTECT;
   \   00000030   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0xE002             B.N      ??TM_FATFS_SD_SDIO_disk_initialize_3
    288          	} else {
    289          		TM_FATFS_SD_SDIO_Stat &= ~STA_PROTECT;
   \                     ??TM_FATFS_SD_SDIO_disk_initialize_2: (+1)
   \   00000038   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   0000003C   0x7020             STRB     R0,[R4, #+0]
    290          	}
    291          	
    292          	return TM_FATFS_SD_SDIO_Stat;
   \                     ??TM_FATFS_SD_SDIO_disk_initialize_3: (+1)
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    293          }
    294          

   \                                 In section .text, align 2, keep-with-next
    295          DSTATUS TM_FATFS_SD_SDIO_disk_status(void) {
   \                     TM_FATFS_SD_SDIO_disk_status: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    296          	if (SD_Detect() != SD_PRESENT) {
   \   00000002   0x.... 0x....      BL       SD_Detect
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD001             BEQ.N    ??TM_FATFS_SD_SDIO_disk_status_0
    297          		return STA_NOINIT;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD10             POP      {R4,PC}
    298          	}
    299          	
    300          	if (!TM_FATFS_SDIO_WriteEnabled()) {
   \                     ??TM_FATFS_SD_SDIO_disk_status_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable20
   \   00000012   0x.... 0x....      BL       TM_FATFS_SDIO_WriteEnabled
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0xD103             BNE.N    ??TM_FATFS_SD_SDIO_disk_status_1
    301          		TM_FATFS_SD_SDIO_Stat |= STA_PROTECT;
   \   0000001C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000020   0x7020             STRB     R0,[R4, #+0]
   \   00000022   0xE002             B.N      ??TM_FATFS_SD_SDIO_disk_status_2
    302          	} else {
    303          		TM_FATFS_SD_SDIO_Stat &= ~STA_PROTECT;
   \                     ??TM_FATFS_SD_SDIO_disk_status_1: (+1)
   \   00000024   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   00000028   0x7020             STRB     R0,[R4, #+0]
    304          	}
    305          	
    306          	return TM_FATFS_SD_SDIO_Stat;
   \                     ??TM_FATFS_SD_SDIO_disk_status_2: (+1)
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    307          }
    308          
    309          #define BLOCK_SIZE            512
    310          

   \                                 In section .text, align 2, keep-with-next
    311          DRESULT TM_FATFS_SD_SDIO_disk_read(BYTE *buff, DWORD sector, UINT count) {
   \                     TM_FATFS_SD_SDIO_disk_read: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    312          	SD_Error Status = SD_OK;
    313          
    314          	if ((TM_FATFS_SD_SDIO_Stat & STA_NOINIT)) {
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable20
   \   00000006   0x781B             LDRB     R3,[R3, #+0]
   \   00000008   0x07DB             LSLS     R3,R3,#+31
   \   0000000A   0xD501             BPL.N    ??TM_FATFS_SD_SDIO_disk_read_0
    315          		return RES_NOTRDY;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xBD16             POP      {R1,R2,R4,PC}
    316          	}
    317          
    318          	SD_ReadMultiBlocks(buff, sector << 9, 512, count);
   \                     ??TM_FATFS_SD_SDIO_disk_read_0: (+1)
   \   00000010   0x9201             STR      R2,[SP, #+4]
   \   00000012   0xF44F 0x7200      MOV      R2,#+512
   \   00000016   0x9200             STR      R2,[SP, #+0]
   \   00000018   0x024A             LSLS     R2,R1,#+9
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x.... 0x....      BL       SD_ReadMultiBlocks
    319          
    320          	//Check if the Transfer is finished
    321          	Status =  SD_WaitReadOperation();
   \   00000020   0x.... 0x....      BL       SD_WaitReadOperation
   \   00000024   0x4604             MOV      R4,R0
    322          	while(SD_GetStatus() != SD_TRANSFER_OK);
   \                     ??TM_FATFS_SD_SDIO_disk_read_1: (+1)
   \   00000026   0x.... 0x....      BL       SD_GetStatus
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1FB             BNE.N    ??TM_FATFS_SD_SDIO_disk_read_1
    323          
    324          	if (Status == SD_OK) {
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x4180             SBCS     R0,R0,R0
   \   00000034   0x43C0             MVNS     R0,R0
   \   00000036   0x0FC0             LSRS     R0,R0,#+31
    325          		return RES_OK;
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    326          	}
    327          	return RES_ERROR;
    328          /*
    329          	if ((DWORD)buff & 3) {
    330          		DRESULT res = RES_OK;
    331          		DWORD scratch[BLOCK_SIZE / 4];
    332          
    333          		while (count--) {
    334          			res = TM_FATFS_SD_SDIO_disk_read((void *)scratch, sector++, 1);
    335          
    336          			if (res != RES_OK) {
    337          				break;
    338          			}
    339          
    340          			memcpy(buff, scratch, BLOCK_SIZE);
    341          
    342          			buff += BLOCK_SIZE;
    343          		}
    344          
    345          		return res;
    346          	}
    347          
    348          	Status = SD_ReadMultiBlocksFIXED(buff, sector, BLOCK_SIZE, count);
    349          
    350          	if (Status == SD_OK) {
    351          		SDTransferState State;
    352          
    353          		Status = SD_WaitReadOperation();
    354          
    355          		while ((State = SD_GetStatus()) == SD_TRANSFER_BUSY);
    356          
    357          		if ((State == SD_TRANSFER_ERROR) || (Status != SD_OK)) {
    358          			return RES_ERROR;
    359          		} else {
    360          			return RES_OK;
    361          		}			
    362          	} else {
    363          		return RES_ERROR;
    364          	}
    365          */
    366          }
    367          

   \                                 In section .text, align 2, keep-with-next
    368          DRESULT TM_FATFS_SD_SDIO_disk_write(BYTE *buff, DWORD sector, UINT count) {
   \                     TM_FATFS_SD_SDIO_disk_write: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    369          	SD_Error Status = SD_OK;
    370          
    371          	if (!TM_FATFS_SDIO_WriteEnabled()) {
   \   00000008   0x.... 0x....      BL       TM_FATFS_SDIO_WriteEnabled
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??TM_FATFS_SD_SDIO_disk_write_0
    372          		return RES_WRPRT;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD76             POP      {R1,R2,R4-R6,PC}
    373          	}
    374          
    375          	if (SD_Detect() != SD_PRESENT) {
   \                     ??TM_FATFS_SD_SDIO_disk_write_0: (+1)
   \   00000014   0x.... 0x....      BL       SD_Detect
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD001             BEQ.N    ??TM_FATFS_SD_SDIO_disk_write_1
    376          		return RES_NOTRDY;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xBD76             POP      {R1,R2,R4-R6,PC}
    377          	}
    378          	
    379          	SD_WriteMultiBlocks((BYTE *)buff, sector << 9, 512, count);
   \                     ??TM_FATFS_SD_SDIO_disk_write_1: (+1)
   \   00000020   0x9601             STR      R6,[SP, #+4]
   \   00000022   0xF44F 0x7000      MOV      R0,#+512
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x026A             LSLS     R2,R5,#+9
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       SD_WriteMultiBlocks
    380          
    381          	//Check if the Transfer is finished
    382          	Status = SD_WaitWriteOperation();
   \   00000032   0x.... 0x....      BL       SD_WaitWriteOperation
   \   00000036   0x4604             MOV      R4,R0
    383          	while(SD_GetStatus() != SD_TRANSFER_OK);     
   \                     ??TM_FATFS_SD_SDIO_disk_write_2: (+1)
   \   00000038   0x.... 0x....      BL       SD_GetStatus
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1FB             BNE.N    ??TM_FATFS_SD_SDIO_disk_write_2
    384          
    385          	if (Status == SD_OK) {
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x4180             SBCS     R0,R0,R0
   \   00000046   0x43C0             MVNS     R0,R0
   \   00000048   0x0FC0             LSRS     R0,R0,#+31
    386          		return RES_OK;
   \   0000004A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    387          	}
    388          	return RES_ERROR;
    389          	
    390          /*
    391          	if ((DWORD)buff & 3) {
    392          		DRESULT res = RES_OK;
    393          		DWORD scratch[BLOCK_SIZE / 4];
    394          
    395          		while (count--) {
    396          			memcpy(scratch, buff, BLOCK_SIZE);
    397          			res = TM_FATFS_SD_SDIO_disk_write((void *)scratch, sector++, 1);
    398          
    399          			if (res != RES_OK) {
    400          				break;
    401          			}
    402          
    403          			buff += BLOCK_SIZE;
    404          		}
    405          
    406          		return(res);
    407          	}
    408          
    409          	Status = SD_WriteMultiBlocksFIXED((uint8_t *)buff, sector, BLOCK_SIZE, count); // 4GB Compliant
    410          
    411          	if (Status == SD_OK) {
    412          		SDTransferState State;
    413          
    414          		Status = SD_WaitWriteOperation(); // Check if the Transfer is finished
    415          
    416          		while((State = SD_GetStatus()) == SD_TRANSFER_BUSY); // BUSY, OK (DONE), ERROR (FAIL)
    417          
    418          		if ((State == SD_TRANSFER_ERROR) || (Status != SD_OK)) {
    419          			return RES_ERROR;
    420          		} else {
    421          			return RES_OK;
    422          		}
    423          	} else {
    424          		return RES_ERROR;
    425          	}
    426          */
    427          }
    428          

   \                                 In section .text, align 2, keep-with-next
    429          DRESULT TM_FATFS_SD_SDIO_disk_ioctl(BYTE cmd, char *buff) {
    430          	switch (cmd) {
   \                     TM_FATFS_SD_SDIO_disk_ioctl: (+1)
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xD002             BEQ.N    ??TM_FATFS_SD_SDIO_disk_ioctl_0
   \   00000004   0x2803             CMP      R0,#+3
   \   00000006   0xD004             BEQ.N    ??TM_FATFS_SD_SDIO_disk_ioctl_1
   \   00000008   0xE005             B.N      ??TM_FATFS_SD_SDIO_disk_ioctl_2
    431          		case GET_SECTOR_SIZE :     // Get R/W sector size (WORD) 
    432          			*(WORD * )buff = 512;
   \                     ??TM_FATFS_SD_SDIO_disk_ioctl_0: (+1)
   \   0000000A   0xF44F 0x7000      MOV      R0,#+512
   \   0000000E   0x8008             STRH     R0,[R1, #+0]
    433          		break;
   \   00000010   0xE001             B.N      ??TM_FATFS_SD_SDIO_disk_ioctl_2
    434          		case GET_BLOCK_SIZE :      // Get erase block size in unit of sector (DWORD)
    435          			*(DWORD * )buff = 32;
   \                     ??TM_FATFS_SD_SDIO_disk_ioctl_1: (+1)
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0x6008             STR      R0,[R1, #+0]
    436          		break;
    437          		case CTRL_SYNC :
    438          		case CTRL_ERASE_SECTOR :
    439          		break;
    440          	}
    441          
    442          	return RES_OK;
   \                     ??TM_FATFS_SD_SDIO_disk_ioctl_2: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    443          }
    444          
    445          
    446          
    447          
    448          
    449          
    450          
    451          
    452          
    453          
    454          
    455          
    456          
    457          
    458          
    459          /**
    460           * @}
    461           */
    462          
    463          /** @defgroup STM324x9I_EVAL_SDIO_SD_Private_Functions
    464           * @{
    465           */
    466          
    467          /**
    468           * @brief  DeInitializes the SDIO interface.
    469           * @param  None
    470           * @retval None
    471           */

   \                                 In section .text, align 2, keep-with-next
    472          void SD_DeInit (void)
    473          {
    474                  SD_LowLevel_DeInit ();
   \                     SD_DeInit: (+1)
   \   00000000   0x.... 0x....      B.W      SD_LowLevel_DeInit
    475          }
    476          
    477          /**
    478           * @brief  Initializes the SD Card and put it into StandBy State (Ready for data
    479           *         transfer).
    480           * @param  None
    481           * @retval SD_Error: SD Card Error code.
    482           */

   \                                 In section .text, align 2, keep-with-next
    483          SD_Error SD_Init (void)
    484          {
   \                     SD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    485          	__IO SD_Error errorstatus = SD_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    486          
    487          	/* SDIO Peripheral Low Level Init */
    488          	//SD_LowLevel_Init();
    489          	SDIO_DeInit ();
   \   0000000A   0x.... 0x....      BL       SDIO_DeInit
    490          	errorstatus = SD_PowerON ();
   \   0000000E   0x.... 0x....      BL       SD_PowerON
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    491          
    492          	if (errorstatus != SD_OK) {
   \   00000016   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??SD_Init_0
    493          		logf("SD_PowerON failed\r\n");
    494          		/*!< CMD Response TimeOut (wait for CMDSENT flag) */
    495          		return (errorstatus);
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xBD16             POP      {R1,R2,R4,PC}
    496          	}
    497          
    498          	logf("SD_PowerON OK\r\n");
    499          
    500          	errorstatus = SD_InitializeCards ();
   \                     ??SD_Init_0: (+1)
   \   00000024   0x.... 0x....      BL       SD_InitializeCards
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
    501          
    502          	if (errorstatus != SD_OK) {
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??SD_Init_1
    503          		logf("SD_InitializeCards failed\r\n");
    504          		/*!< CMD Response TimeOut (wait for CMDSENT flag) */
    505          		return (errorstatus);
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}
    506          	}
    507          
    508          	logf("SD_InitializeCards OK\r\n");
    509          
    510          	/*!< Configure the SDIO peripheral */
    511          	/*!< SDIO_CK = SDIOCLK / (SDIO_TRANSFER_CLK_DIV + 2) */
    512          	/*!< on STM32F4xx devices, SDIOCLK is fixed to 48MHz */
    513          	SDIO_InitStructure.SDIO_ClockDiv = SDIO_TRANSFER_CLK_DIV;
   \                     ??SD_Init_1: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x7501             STRB     R1,[R0, #+20]
    514          	SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6001             STR      R1,[R0, #+0]
    515          	SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
   \   00000046   0x6041             STR      R1,[R0, #+4]
    516          	SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
   \   00000048   0x6081             STR      R1,[R0, #+8]
    517          	SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
   \   0000004A   0x60C1             STR      R1,[R0, #+12]
    518          	SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
   \   0000004C   0x6101             STR      R1,[R0, #+16]
    519          	SDIO_Init (&SDIO_InitStructure);
   \   0000004E   0x.... 0x....      BL       SDIO_Init
    520          
    521          	/*----------------- Read CSD/CID MSD registers ------------------*/
    522          	errorstatus = SD_GetCardInfo (&SDCardInfo);
   \   00000052   0x.... 0x....      LDR.W    R4,??DataTable21_1
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       SD_GetCardInfo
   \   0000005C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    523          
    524          	if (errorstatus == SD_OK) {
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD107             BNE.N    ??SD_Init_2
    525          		/*----------------- Select Card --------------------------------*/
    526          		logf("SD_GetCardInfo OK\r\n");
    527          		errorstatus = SD_SelectDeselect ((uint32_t) (SDCardInfo.RCA << 16));
   \   00000068   0xF8B4 0x0054      LDRH     R0,[R4, #+84]
   \   0000006C   0x0400             LSLS     R0,R0,#+16
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x.... 0x....      BL       SD_SelectDeselect
   \   00000074   0xF88D 0x0000      STRB     R0,[SP, #+0]
    528          	}
    529          	else {
    530          		logf("SD_SelectDeselect failed\r\n");
    531          	}
    532          
    533          	if (errorstatus == SD_OK) {
   \                     ??SD_Init_2: (+1)
   \   00000078   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD105             BNE.N    ??SD_Init_3
    534          		logf("SD_SelectDeselect OK\r\n");
    535          #if FATFS_SDIO_4BIT == 1
    536          		//4 bit mode
    537          		errorstatus = SD_EnableWideBusOperation (SDIO_BusWide_4b);
   \   00000080   0xF44F 0x6000      MOV      R0,#+2048
   \   00000084   0x.... 0x....      BL       SD_EnableWideBusOperation
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
    538          		logf("SD_EnableWideBusOperation init 4bit \r\n");
    539          #else
    540          		//1 bit mode
    541          		errorstatus = SD_EnableWideBusOperation (SDIO_BusWide_1b);
    542          		logf("SD_EnableWideBusOperation init 1bit\r\n");
    543          #endif
    544          	}
    545          	else {
    546          		logf("SD_EnableWideBusOperation failed\r\n");
    547          	}
    548          
    549          	if (errorstatus == SD_OK) {
   \                     ??SD_Init_3: (+1)
   \   0000008C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
    550          		logf("SD_EnableWideBusOperation OK\r\n");
    551          	}
    552          
    553          	return (errorstatus);
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    554          }
    555          
    556          /**
    557           * @brief  Gets the cuurent sd card data transfer status.
    558           * @param  None
    559           * @retval SDTransferState: Data Transfer state.
    560           *   This value can be:
    561           *        - SD_TRANSFER_OK: No data transfer is acting
    562           *        - SD_TRANSFER_BUSY: Data transfer is acting
    563           */

   \                                 In section .text, align 2, keep-with-next
    564          SDTransferState SD_GetStatus (void)
    565          {
   \                     SD_GetStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    566                  SDCardState cardstate = SD_CARD_TRANSFER;
    567          
    568                  cardstate = SD_GetState ();
   \   00000002   0x.... 0x....      BL       SD_GetState
    569          
    570                  if (cardstate == SD_CARD_TRANSFER) {
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xD101             BNE.N    ??SD_GetStatus_0
    571                          return (SD_TRANSFER_OK);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}
    572                  }
    573                  else if (cardstate == SD_CARD_ERROR) {
   \                     ??SD_GetStatus_0: (+1)
   \   0000000E   0x28FF             CMP      R0,#+255
   \   00000010   0xD101             BNE.N    ??SD_GetStatus_1
    574                          return (SD_TRANSFER_ERROR);
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBD02             POP      {R1,PC}
    575                  }
    576                  else {
    577                          return (SD_TRANSFER_BUSY);
   \                     ??SD_GetStatus_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    578                  }
    579          }
    580          
    581          /**
    582           * @brief  Returns the current card's state.
    583           * @param  None
    584           * @retval SDCardState: SD Card Error or SD Card Current State.
    585           */

   \                                 In section .text, align 2, keep-with-next
    586          SDCardState SD_GetState(void) {
   \                     SD_GetState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    587          	uint32_t resp1 = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    588          
    589          	if (SD_Detect () == SD_PRESENT ) {
   \   00000006   0x.... 0x....      BL       SD_Detect
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD10B             BNE.N    ??SD_GetState_0
    590          		if (SD_SendStatus (&resp1) != SD_OK) {
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       SD_SendStatus
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??SD_GetState_1
    591          			return SD_CARD_ERROR;
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0xBD02             POP      {R1,PC}
    592          		} else {
    593          			return (SDCardState) ((resp1 >> 9) & 0x0F);
   \                     ??SD_GetState_1: (+1)
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
   \   0000001E   0x0A40             LSRS     R0,R0,#+9
   \   00000020   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000024   0xBD02             POP      {R1,PC}
    594          		}
    595          	}
    596          	
    597          	return SD_CARD_ERROR;
   \                     ??SD_GetState_0: (+1)
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    598          }
    599          
    600          /**
    601           * @brief  Detect if SD card is correctly plugged in the memory slot.
    602           * @param  None
    603           * @retval Return if SD is detected or not
    604           */

   \                                 In section .text, align 2, keep-with-next
    605          uint8_t SD_Detect (void)
    606          {
   \                     SD_Detect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    607          	__IO uint8_t status = SD_PRESENT;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    608          
    609          	if( SDCARD_DETECT() != 0)
   \   00000008   0x2108             MOVS     R1,#+8
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40021000
   \   0000000E   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??SD_Detect_0
    610          	{
    611          		status = SD_NOT_PRESENT;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    612          	}
    613          
    614          	return status;
   \                     ??SD_Detect_0: (+1)
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    615          }
    616          
    617          /**
    618           * @brief  Enquires cards about their operating voltage and configures
    619           *   clock controls.
    620           * @param  None
    621           * @retval SD_Error: SD Card Error code.
    622           */

   \                                 In section .text, align 2, keep-with-next
    623          SD_Error SD_PowerON (void)
    624          {
   \                     SD_PowerON: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    625                  __IO SD_Error errorstatus = SD_OK;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    626                  uint32_t response = 0, count = 0, validvoltage = 0;
   \   0000000A   0x4680             MOV      R8,R0
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x4681             MOV      R9,R0
    627                  uint32_t SDType = SD_STD_CAPACITY;
   \   00000010   0x4605             MOV      R5,R0
    628          
    629                  /*!< Power ON Sequence -----------------------------------------------------*/
    630                  /*!< Configure the SDIO peripheral */
    631                  /*!< SDIO_CK = SDIOCLK / (SDIO_INIT_CLK_DIV + 2) */
    632                  /*!< on STM32F4xx devices, SDIOCLK is fixed to 48MHz */
    633                  /*!< SDIO_CK for initialization should not exceed 400 KHz */
    634                  SDIO_InitStructure.SDIO_ClockDiv = SDIO_INIT_CLK_DIV;
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable21
   \   00000016   0x2076             MOVS     R0,#+118
   \   00000018   0x7530             STRB     R0,[R6, #+20]
    635                  SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x6030             STR      R0,[R6, #+0]
    636                  SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
   \   0000001E   0x6070             STR      R0,[R6, #+4]
    637                  SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
   \   00000020   0x60B0             STR      R0,[R6, #+8]
    638                  SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
   \   00000022   0x60F0             STR      R0,[R6, #+12]
    639                  SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
   \   00000024   0x6130             STR      R0,[R6, #+16]
    640                  SDIO_Init (&SDIO_InitStructure);
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       SDIO_Init
    641          
    642                  /*!< Set Power State to ON */
    643                  SDIO_SetPowerState (SDIO_PowerState_ON);
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x.... 0x....      BL       SDIO_SetPowerState
    644          
    645                  /*!< Enable SDIO Clock */
    646                  SDIO_ClockCmd (ENABLE);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       SDIO_ClockCmd
    647          
    648                  /*!< CMD0: GO_IDLE_STATE ---------------------------------------------------*/
    649                  /*!< No CMD response required */
    650                  SDIO_CmdInitStructure.SDIO_Argument = 0x0;
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x6370             STR      R0,[R6, #+52]
    651                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_GO_IDLE_STATE;
   \   0000003C   0x63B0             STR      R0,[R6, #+56]
    652                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_No;
   \   0000003E   0x63F0             STR      R0,[R6, #+60]
    653                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000040   0x6430             STR      R0,[R6, #+64]
    654                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000042   0xF44F 0x6780      MOV      R7,#+1024
   \   00000046   0x6477             STR      R7,[R6, #+68]
    655                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000048   0xF106 0x0034      ADD      R0,R6,#+52
   \   0000004C   0x.... 0x....      BL       SDIO_SendCommand
    656          
    657                  errorstatus = CmdError ();
   \   00000050   0x.... 0x....      BL       CmdError
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    658          
    659                  if (errorstatus != SD_OK) {
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??SD_PowerON_0
    660                          /*!< CMD Response TimeOut (wait for CMDSENT flag) */
    661                          return (errorstatus);
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE093             B.N      ??SD_PowerON_1
    662                  }
    663          
    664                  /*!< CMD8: SEND_IF_COND ----------------------------------------------------*/
    665                  /*!< Send CMD8 to verify SD card interface operating condition */
    666                  /*!< Argument: - [31:12]: Reserved (shall be set to '0')
    667                   - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
    668                   - [7:0]: Check Pattern (recommended 0xAA) */
    669                  /*!< CMD Response: R7 */
    670                  SDIO_CmdInitStructure.SDIO_Argument = SD_CHECK_PATTERN;
   \                     ??SD_PowerON_0: (+1)
   \   00000066   0xF44F 0x70D5      MOV      R0,#+426
   \   0000006A   0x6370             STR      R0,[R6, #+52]
    671                  SDIO_CmdInitStructure.SDIO_CmdIndex = SDIO_SEND_IF_COND;
   \   0000006C   0x2008             MOVS     R0,#+8
   \   0000006E   0x63B0             STR      R0,[R6, #+56]
    672                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000070   0x2040             MOVS     R0,#+64
   \   00000072   0x63F0             STR      R0,[R6, #+60]
    673                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x6430             STR      R0,[R6, #+64]
    674                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000078   0x6477             STR      R7,[R6, #+68]
    675                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000007A   0xF106 0x0034      ADD      R0,R6,#+52
   \   0000007E   0x.... 0x....      BL       SDIO_SendCommand
    676          
    677                  errorstatus = CmdResp7Error ();
   \   00000082   0x.... 0x....      BL       CmdResp7Error
   \   00000086   0xF88D 0x0000      STRB     R0,[SP, #+0]
    678          
    679                  if (errorstatus == SD_OK) {
   \   0000008A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD104             BNE.N    ??SD_PowerON_2
    680                          CardType = SDIO_STD_CAPACITY_SD_CARD_V2_0; /*!< SD Card 2.0 */
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x66B0             STR      R0,[R6, #+104]
    681                          SDType = SD_HIGH_CAPACITY;
   \   00000096   0xF04F 0x4580      MOV      R5,#+1073741824
   \   0000009A   0xE011             B.N      ??SD_PowerON_3
    682                  }
    683                  else {
    684                          /*!< CMD55 */
    685                          SDIO_CmdInitStructure.SDIO_Argument = 0x00;
   \                     ??SD_PowerON_2: (+1)
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x6370             STR      R0,[R6, #+52]
    686                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   000000A0   0x2037             MOVS     R0,#+55
   \   000000A2   0x63B0             STR      R0,[R6, #+56]
    687                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000A4   0x2040             MOVS     R0,#+64
   \   000000A6   0x63F0             STR      R0,[R6, #+60]
    688                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x6430             STR      R0,[R6, #+64]
    689                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000AC   0x6477             STR      R7,[R6, #+68]
    690                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000AE   0xF106 0x0034      ADD      R0,R6,#+52
   \   000000B2   0x.... 0x....      BL       SDIO_SendCommand
    691                          errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   000000B6   0x2037             MOVS     R0,#+55
   \   000000B8   0x.... 0x....      BL       CmdResp1Error
   \   000000BC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    692                  }
    693                  /*!< CMD55 */
    694                  SDIO_CmdInitStructure.SDIO_Argument = 0x00;
   \                     ??SD_PowerON_3: (+1)
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x6370             STR      R0,[R6, #+52]
    695                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   000000C4   0x2037             MOVS     R0,#+55
   \   000000C6   0x63B0             STR      R0,[R6, #+56]
    696                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000C8   0x2040             MOVS     R0,#+64
   \   000000CA   0x63F0             STR      R0,[R6, #+60]
    697                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x6430             STR      R0,[R6, #+64]
    698                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000D0   0x6477             STR      R7,[R6, #+68]
    699                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000D2   0xF106 0x0034      ADD      R0,R6,#+52
   \   000000D6   0x.... 0x....      BL       SDIO_SendCommand
    700                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   000000DA   0x2037             MOVS     R0,#+55
   \   000000DC   0x.... 0x....      BL       CmdResp1Error
   \   000000E0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    701          
    702                  /*!< If errorstatus is Command TimeOut, it is a MMC card */
    703                  /*!< If errorstatus is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
    704                   or SD card 1.x */
    705                  if (errorstatus == SD_OK) {
   \   000000E4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD14E             BNE.N    ??SD_PowerON_4
   \   000000EC   0xE006             B.N      ??SD_PowerON_5
    706                          /*!< SD CARD */
    707                          /*!< Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    708                          while ((!validvoltage) && (count < SD_MAX_VOLT_TRIAL )) {
    709          
    710                                  /*!< SEND CMD55 APP_CMD with RCA as 0 */
    711                                  SDIO_CmdInitStructure.SDIO_Argument = 0x00;
    712                                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
    713                                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
    714                                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
    715                                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
    716                                  SDIO_SendCommand (&SDIO_CmdInitStructure);
    717          
    718                                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
    719          
    720                                  if (errorstatus != SD_OK) {
    721                                          return (errorstatus);
    722                                  }
    723                                  SDIO_CmdInitStructure.SDIO_Argument = SD_VOLTAGE_WINDOW_SD | SDType;
    724                                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SD_APP_OP_COND;
    725                                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
    726                                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
    727                                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
    728                                  SDIO_SendCommand (&SDIO_CmdInitStructure);
    729          
    730                                  errorstatus = CmdResp3Error ();
    731                                  if (errorstatus != SD_OK) {
    732                                          return (errorstatus);
    733                                  }
    734          
    735                                  response = SDIO_GetResponse (SDIO_RESP1);
   \                     ??SD_PowerON_6: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x.... 0x....      BL       SDIO_GetResponse
   \   000000F4   0x4680             MOV      R8,R0
    736                                  validvoltage = (((response >> 31) == 1) ? 1 : 0);
   \   000000F6   0xEA4F 0x79D8      LSR      R9,R8,#+31
    737                                  count++;
   \   000000FA   0x1C64             ADDS     R4,R4,#+1
   \                     ??SD_PowerON_5: (+1)
   \   000000FC   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000100   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000104   0xD134             BNE.N    ??SD_PowerON_7
   \   00000106   0x4284             CMP      R4,R0
   \   00000108   0xD232             BCS.N    ??SD_PowerON_7
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x6370             STR      R0,[R6, #+52]
   \   0000010E   0x2037             MOVS     R0,#+55
   \   00000110   0x63B0             STR      R0,[R6, #+56]
   \   00000112   0x2040             MOVS     R0,#+64
   \   00000114   0x63F0             STR      R0,[R6, #+60]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x6430             STR      R0,[R6, #+64]
   \   0000011A   0x6477             STR      R7,[R6, #+68]
   \   0000011C   0xF106 0x0034      ADD      R0,R6,#+52
   \   00000120   0x.... 0x....      BL       SDIO_SendCommand
   \   00000124   0x2037             MOVS     R0,#+55
   \   00000126   0x.... 0x....      BL       CmdResp1Error
   \   0000012A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000012E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD002             BEQ.N    ??SD_PowerON_8
   \   00000136   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000013A   0xE028             B.N      ??SD_PowerON_1
   \                     ??SD_PowerON_8: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x80100000
   \   00000140   0x4328             ORRS     R0,R0,R5
   \   00000142   0x6370             STR      R0,[R6, #+52]
   \   00000144   0x2029             MOVS     R0,#+41
   \   00000146   0x63B0             STR      R0,[R6, #+56]
   \   00000148   0x2040             MOVS     R0,#+64
   \   0000014A   0x63F0             STR      R0,[R6, #+60]
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x6430             STR      R0,[R6, #+64]
   \   00000150   0x6477             STR      R7,[R6, #+68]
   \   00000152   0xF106 0x0034      ADD      R0,R6,#+52
   \   00000156   0x.... 0x....      BL       SDIO_SendCommand
   \   0000015A   0x.... 0x....      BL       CmdResp3Error
   \   0000015E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000162   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD0C1             BEQ.N    ??SD_PowerON_6
   \   0000016A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000016E   0xE00E             B.N      ??SD_PowerON_1
    738                          }
    739                          if (count >= SD_MAX_VOLT_TRIAL ) {
   \                     ??SD_PowerON_7: (+1)
   \   00000170   0x4284             CMP      R4,R0
   \   00000172   0xD305             BCC.N    ??SD_PowerON_9
    740                                  errorstatus = SD_INVALID_VOLTRANGE;
   \   00000174   0x201B             MOVS     R0,#+27
   \   00000176   0xF88D 0x0000      STRB     R0,[SP, #+0]
    741                                  return (errorstatus);
   \   0000017A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000017E   0xE006             B.N      ??SD_PowerON_1
    742                          }
    743          
    744                          if (response &= SD_HIGH_CAPACITY ) {
   \                     ??SD_PowerON_9: (+1)
   \   00000180   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   00000184   0xD501             BPL.N    ??SD_PowerON_4
    745                                  CardType = SDIO_HIGH_CAPACITY_SD_CARD;
   \   00000186   0x2002             MOVS     R0,#+2
   \   00000188   0x66B0             STR      R0,[R6, #+104]
    746                          }
    747          
    748                  }/*!< else MMC Card */
    749          
    750                  return (errorstatus);
   \                     ??SD_PowerON_4: (+1)
   \   0000018A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \                     ??SD_PowerON_1: (+1)
   \   0000018E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    751          }
    752          
    753          /**
    754           * @brief  Turns the SDIO output signals off.
    755           * @param  None
    756           * @retval SD_Error: SD Card Error code.
    757           */

   \                                 In section .text, align 2, keep-with-next
    758          SD_Error SD_PowerOFF (void)
    759          {
   \                     SD_PowerOFF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    760                  SD_Error errorstatus = SD_OK;
    761          
    762                  /*!< Set Power State to OFF */
    763                  SDIO_SetPowerState (SDIO_PowerState_OFF);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       SDIO_SetPowerState
    764          
    765                  return (errorstatus);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    766          }
    767          
    768          /**
    769           * @brief  Intialises all cards or single card as the case may be Card(s) come
    770           *         into standby state.
    771           * @param  None
    772           * @retval SD_Error: SD Card Error code.
    773           */

   \                                 In section .text, align 2, keep-with-next
    774          SD_Error SD_InitializeCards (void)
    775          {
   \                     SD_InitializeCards: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    776                  SD_Error errorstatus = SD_OK;
    777                  uint16_t rca = 0x01;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    778          
    779                  if (SDIO_GetPowerState () == SDIO_PowerState_OFF) {
   \   0000000A   0x.... 0x....      BL       SDIO_GetPowerState
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??SD_InitializeCards_0
    780                          errorstatus = SD_REQUEST_NOT_APPLICABLE;
    781                          return (errorstatus);
   \   00000012   0x2025             MOVS     R0,#+37
   \   00000014   0xBD16             POP      {R1,R2,R4,PC}
    782                  }
    783          
    784                  if (SDIO_SECURE_DIGITAL_IO_CARD != CardType) {
   \                     ??SD_InitializeCards_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R4,??DataTable21
   \   0000001A   0x6EA0             LDR      R0,[R4, #+104]
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xD022             BEQ.N    ??SD_InitializeCards_1
    785                          /*!< Send CMD2 ALL_SEND_CID */
    786                          SDIO_CmdInitStructure.SDIO_Argument = 0x0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6360             STR      R0,[R4, #+52]
    787                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_ALL_SEND_CID;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x63A0             STR      R0,[R4, #+56]
    788                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Long;
   \   00000028   0x20C0             MOVS     R0,#+192
   \   0000002A   0x63E0             STR      R0,[R4, #+60]
    789                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6420             STR      R0,[R4, #+64]
    790                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000030   0xF44F 0x6080      MOV      R0,#+1024
   \   00000034   0x6460             STR      R0,[R4, #+68]
    791                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000036   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000003A   0x.... 0x....      BL       SDIO_SendCommand
    792          
    793                          errorstatus = CmdResp2Error ();
   \   0000003E   0x.... 0x....      BL       CmdResp2Error
    794          
    795                          if (SD_OK != errorstatus) {
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0xD159             BNE.N    ??SD_InitializeCards_2
    796                                  return (errorstatus);
    797                          }
    798          
    799                          CID_Tab[0] = SDIO_GetResponse (SDIO_RESP1);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      BL       SDIO_GetResponse
   \   0000004C   0x65A0             STR      R0,[R4, #+88]
    800                          CID_Tab[1] = SDIO_GetResponse (SDIO_RESP2);
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x.... 0x....      BL       SDIO_GetResponse
   \   00000054   0x65E0             STR      R0,[R4, #+92]
    801                          CID_Tab[2] = SDIO_GetResponse (SDIO_RESP3);
   \   00000056   0x2008             MOVS     R0,#+8
   \   00000058   0x.... 0x....      BL       SDIO_GetResponse
   \   0000005C   0x6620             STR      R0,[R4, #+96]
    802                          CID_Tab[3] = SDIO_GetResponse (SDIO_RESP4);
   \   0000005E   0x200C             MOVS     R0,#+12
   \   00000060   0x.... 0x....      BL       SDIO_GetResponse
   \   00000064   0x6660             STR      R0,[R4, #+100]
    803                  }
    804                  if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_SECURE_DIGITAL_IO_COMBO_CARD == CardType)
    805                                  || (SDIO_HIGH_CAPACITY_SD_CARD == CardType)) {
   \                     ??SD_InitializeCards_1: (+1)
   \   00000066   0x6EA0             LDR      R0,[R4, #+104]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD005             BEQ.N    ??SD_InitializeCards_3
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD003             BEQ.N    ??SD_InitializeCards_3
   \   00000070   0x2806             CMP      R0,#+6
   \   00000072   0xD001             BEQ.N    ??SD_InitializeCards_3
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD114             BNE.N    ??SD_InitializeCards_4
    806                          /*!< Send CMD3 SET_REL_ADDR with argument 0 */
    807                          /*!< SD Card publishes its RCA. */
    808                          SDIO_CmdInitStructure.SDIO_Argument = 0x00;
   \                     ??SD_InitializeCards_3: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x6360             STR      R0,[R4, #+52]
    809                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_REL_ADDR;
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0x63A0             STR      R0,[R4, #+56]
    810                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000080   0x2040             MOVS     R0,#+64
   \   00000082   0x63E0             STR      R0,[R4, #+60]
    811                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x6420             STR      R0,[R4, #+64]
    812                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000088   0xF44F 0x6080      MOV      R0,#+1024
   \   0000008C   0x6460             STR      R0,[R4, #+68]
    813                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000008E   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000092   0x.... 0x....      BL       SDIO_SendCommand
    814          
    815                          errorstatus = CmdResp6Error (SD_CMD_SET_REL_ADDR, &rca);
   \   00000096   0x4669             MOV      R1,SP
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0x.... 0x....      BL       CmdResp6Error
    816          
    817                          if (SD_OK != errorstatus) {
   \   0000009E   0x0001             MOVS     R1,R0
   \   000000A0   0xD12B             BNE.N    ??SD_InitializeCards_2
    818                                  return (errorstatus);
    819                          }
    820                  }
    821          
    822                  if (SDIO_SECURE_DIGITAL_IO_CARD != CardType) {
   \                     ??SD_InitializeCards_4: (+1)
   \   000000A2   0x6EA0             LDR      R0,[R4, #+104]
   \   000000A4   0x2804             CMP      R0,#+4
   \   000000A6   0xD027             BEQ.N    ??SD_InitializeCards_5
    823                          RCA = rca;
   \   000000A8   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000AC   0x66E0             STR      R0,[R4, #+108]
    824          
    825                          /*!< Send CMD9 SEND_CSD with argument as card's RCA */
    826                          SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (rca << 16);
   \   000000AE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B2   0x0400             LSLS     R0,R0,#+16
   \   000000B4   0x6360             STR      R0,[R4, #+52]
    827                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SEND_CSD;
   \   000000B6   0x2009             MOVS     R0,#+9
   \   000000B8   0x63A0             STR      R0,[R4, #+56]
    828                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Long;
   \   000000BA   0x20C0             MOVS     R0,#+192
   \   000000BC   0x63E0             STR      R0,[R4, #+60]
    829                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x6420             STR      R0,[R4, #+64]
    830                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000C2   0xF44F 0x6080      MOV      R0,#+1024
   \   000000C6   0x6460             STR      R0,[R4, #+68]
    831                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000C8   0xF104 0x0034      ADD      R0,R4,#+52
   \   000000CC   0x.... 0x....      BL       SDIO_SendCommand
    832          
    833                          errorstatus = CmdResp2Error ();
   \   000000D0   0x.... 0x....      BL       CmdResp2Error
    834          
    835                          if (SD_OK != errorstatus) {
   \   000000D4   0x0001             MOVS     R1,R0
   \   000000D6   0xD110             BNE.N    ??SD_InitializeCards_2
    836                                  return (errorstatus);
    837                          }
    838          
    839                          CSD_Tab[0] = SDIO_GetResponse (SDIO_RESP1);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x.... 0x....      BL       SDIO_GetResponse
   \   000000DE   0x64A0             STR      R0,[R4, #+72]
    840                          CSD_Tab[1] = SDIO_GetResponse (SDIO_RESP2);
   \   000000E0   0x2004             MOVS     R0,#+4
   \   000000E2   0x.... 0x....      BL       SDIO_GetResponse
   \   000000E6   0x64E0             STR      R0,[R4, #+76]
    841                          CSD_Tab[2] = SDIO_GetResponse (SDIO_RESP3);
   \   000000E8   0x2008             MOVS     R0,#+8
   \   000000EA   0x.... 0x....      BL       SDIO_GetResponse
   \   000000EE   0x6520             STR      R0,[R4, #+80]
    842                          CSD_Tab[3] = SDIO_GetResponse (SDIO_RESP4);
   \   000000F0   0x200C             MOVS     R0,#+12
   \   000000F2   0x.... 0x....      BL       SDIO_GetResponse
   \   000000F6   0x6560             STR      R0,[R4, #+84]
    843                  }
    844          
    845                  errorstatus = SD_OK; /*!< All cards get intialized */
    846          
    847                  return (errorstatus);
   \                     ??SD_InitializeCards_5: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \                     ??SD_InitializeCards_2: (+1)
   \   000000FA   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    848          }
    849          
    850          /**
    851           * @brief  Returns information about specific card.
    852           * @param  cardinfo: pointer to a SD_CardInfo structure that contains all SD card
    853           *         information.
    854           * @retval SD_Error: SD Card Error code.
    855           */

   \                                 In section .text, align 2, keep-with-next
    856          SD_Error SD_GetCardInfo (SD_CardInfo *cardinfo)
    857          {
   \                     SD_GetCardInfo: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
    858                  SD_Error errorstatus = SD_OK;
    859                  uint8_t tmp = 0;
    860          
    861                  cardinfo->CardType = (uint8_t) CardType;
   \   00000006   0x.... 0x....      LDR.W    R7,??DataTable21
   \   0000000A   0x6EB8             LDR      R0,[R7, #+104]
   \   0000000C   0xF886 0x0056      STRB     R0,[R6, #+86]
    862                  cardinfo->RCA = (uint16_t) RCA;
   \   00000010   0xF106 0x0C30      ADD      R12,R6,#+48
   \   00000014   0x6EF9             LDR      R1,[R7, #+108]
   \   00000016   0xF8AC 0x1024      STRH     R1,[R12, #+36]
    863          
    864                  /*!< Byte 0 */
    865                  tmp = (uint8_t) ((CSD_Tab[0] & 0xFF000000) >> 24);
   \   0000001A   0x6CB9             LDR      R1,[R7, #+72]
   \   0000001C   0x0E09             LSRS     R1,R1,#+24
    866                  cardinfo->SD_csd.CSDStruct = (tmp & 0xC0) >> 6;
   \   0000001E   0x118A             ASRS     R2,R1,#+6
   \   00000020   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000024   0x7032             STRB     R2,[R6, #+0]
    867                  cardinfo->SD_csd.SysSpecVersion = (tmp & 0x3C) >> 2;
   \   00000026   0x108A             ASRS     R2,R1,#+2
   \   00000028   0xF002 0x020F      AND      R2,R2,#0xF
   \   0000002C   0x7072             STRB     R2,[R6, #+1]
    868                  cardinfo->SD_csd.Reserved1 = tmp & 0x03;
   \   0000002E   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000032   0x70B1             STRB     R1,[R6, #+2]
    869          
    870                  /*!< Byte 1 */
    871                  tmp = (uint8_t) ((CSD_Tab[0] & 0x00FF0000) >> 16);
    872                  cardinfo->SD_csd.TAAC = tmp;
   \   00000034   0x6CB9             LDR      R1,[R7, #+72]
   \   00000036   0x0C09             LSRS     R1,R1,#+16
   \   00000038   0x70F1             STRB     R1,[R6, #+3]
    873          
    874                  /*!< Byte 2 */
    875                  tmp = (uint8_t) ((CSD_Tab[0] & 0x0000FF00) >> 8);
    876                  cardinfo->SD_csd.NSAC = tmp;
   \   0000003A   0x6CB9             LDR      R1,[R7, #+72]
   \   0000003C   0x0A09             LSRS     R1,R1,#+8
   \   0000003E   0x7131             STRB     R1,[R6, #+4]
    877          
    878                  /*!< Byte 3 */
    879                  tmp = (uint8_t) (CSD_Tab[0] & 0x000000FF);
    880                  cardinfo->SD_csd.MaxBusClkFrec = tmp;
   \   00000040   0x6CB9             LDR      R1,[R7, #+72]
   \   00000042   0x7171             STRB     R1,[R6, #+5]
    881          
    882                  /*!< Byte 4 */
    883                  tmp = (uint8_t) ((CSD_Tab[1] & 0xFF000000) >> 24);
    884                  cardinfo->SD_csd.CardComdClasses = tmp << 4;
   \   00000044   0x6CF9             LDR      R1,[R7, #+76]
   \   00000046   0x0E09             LSRS     R1,R1,#+24
   \   00000048   0x0109             LSLS     R1,R1,#+4
   \   0000004A   0x80F1             STRH     R1,[R6, #+6]
    885          
    886                  /*!< Byte 5 */
    887                  tmp = (uint8_t) ((CSD_Tab[1] & 0x00FF0000) >> 16);
   \   0000004C   0x6CF9             LDR      R1,[R7, #+76]
   \   0000004E   0xF3C1 0x4107      UBFX     R1,R1,#+16,#+8
    888                  cardinfo->SD_csd.CardComdClasses |= (tmp & 0xF0) >> 4;
   \   00000052   0x88F2             LDRH     R2,[R6, #+6]
   \   00000054   0x460B             MOV      R3,R1
   \   00000056   0xEA52 0x1213      ORRS     R2,R2,R3, LSR #+4
   \   0000005A   0x80F2             STRH     R2,[R6, #+6]
    889                  cardinfo->SD_csd.RdBlockLen = tmp & 0x0F;
   \   0000005C   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000060   0x7231             STRB     R1,[R6, #+8]
    890          
    891                  /*!< Byte 6 */
    892                  tmp = (uint8_t) ((CSD_Tab[1] & 0x0000FF00) >> 8);
   \   00000062   0x6CF9             LDR      R1,[R7, #+76]
   \   00000064   0xEA4F 0x2E11      LSR      LR,R1,#+8
   \   00000068   0xFA5F 0xFE8E      UXTB     LR,LR
    893                  cardinfo->SD_csd.PartBlockRead = (tmp & 0x80) >> 7;
   \   0000006C   0xEA4F 0x11EE      ASR      R1,LR,#+7
   \   00000070   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000074   0x7271             STRB     R1,[R6, #+9]
    894                  cardinfo->SD_csd.WrBlockMisalign = (tmp & 0x40) >> 6;
   \   00000076   0xEA4F 0x11AE      ASR      R1,LR,#+6
   \   0000007A   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000007E   0x72B1             STRB     R1,[R6, #+10]
    895                  cardinfo->SD_csd.RdBlockMisalign = (tmp & 0x20) >> 5;
   \   00000080   0xEA4F 0x116E      ASR      R1,LR,#+5
   \   00000084   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000088   0x72F1             STRB     R1,[R6, #+11]
    896                  cardinfo->SD_csd.DSRImpl = (tmp & 0x10) >> 4;
   \   0000008A   0xEA4F 0x112E      ASR      R1,LR,#+4
   \   0000008E   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000092   0x7331             STRB     R1,[R6, #+12]
    897                  cardinfo->SD_csd.Reserved2 = 0; /*!< Reserved */
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x7371             STRB     R1,[R6, #+13]
    898          
    899                  if ((CardType == SDIO_STD_CAPACITY_SD_CARD_V1_1 )|| (CardType == SDIO_STD_CAPACITY_SD_CARD_V2_0)){
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD001             BEQ.N    ??SD_GetCardInfo_0
   \   0000009C   0x2801             CMP      R0,#+1
   \   0000009E   0xD155             BNE.N    ??SD_GetCardInfo_1
    900                  cardinfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;
   \                     ??SD_GetCardInfo_0: (+1)
   \   000000A0   0xEA4F 0x208E      LSL      R0,LR,#+10
   \   000000A4   0xF400 0x6040      AND      R0,R0,#0xC00
   \   000000A8   0x6130             STR      R0,[R6, #+16]
    901          
    902                  /*!< Byte 7 */
    903                  tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
    904                  cardinfo->SD_csd.DeviceSize |= (tmp) << 2;
   \   000000AA   0x6930             LDR      R0,[R6, #+16]
   \   000000AC   0xF897 0x104C      LDRB     R1,[R7, #+76]
   \   000000B0   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   000000B4   0x6130             STR      R0,[R6, #+16]
    905          
    906                  /*!< Byte 8 */
    907                  tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
   \   000000B6   0x6D38             LDR      R0,[R7, #+80]
   \   000000B8   0x0E00             LSRS     R0,R0,#+24
    908                  cardinfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;
   \   000000BA   0x6931             LDR      R1,[R6, #+16]
   \   000000BC   0x1182             ASRS     R2,R0,#+6
   \   000000BE   0xF002 0x0203      AND      R2,R2,#0x3
   \   000000C2   0x4311             ORRS     R1,R2,R1
   \   000000C4   0x6131             STR      R1,[R6, #+16]
    909          
    910                  cardinfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
   \   000000C6   0x10C1             ASRS     R1,R0,#+3
   \   000000C8   0xF001 0x0107      AND      R1,R1,#0x7
   \   000000CC   0x7531             STRB     R1,[R6, #+20]
    911                  cardinfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);
   \   000000CE   0xF000 0x0007      AND      R0,R0,#0x7
   \   000000D2   0x7570             STRB     R0,[R6, #+21]
    912          
    913                  /*!< Byte 9 */
    914                  tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
   \   000000D4   0x6D38             LDR      R0,[R7, #+80]
   \   000000D6   0x0C00             LSRS     R0,R0,#+16
   \   000000D8   0xB2C0             UXTB     R0,R0
    915                  cardinfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
   \   000000DA   0x1141             ASRS     R1,R0,#+5
   \   000000DC   0xF001 0x0107      AND      R1,R1,#0x7
   \   000000E0   0x75B1             STRB     R1,[R6, #+22]
    916                  cardinfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
   \   000000E2   0x1081             ASRS     R1,R0,#+2
   \   000000E4   0xF001 0x0107      AND      R1,R1,#0x7
   \   000000E8   0x75F1             STRB     R1,[R6, #+23]
    917                  cardinfo->SD_csd.DeviceSizeMul = (tmp & 0x03) << 1;
   \   000000EA   0x0040             LSLS     R0,R0,#+1
   \   000000EC   0xF000 0x0006      AND      R0,R0,#0x6
   \   000000F0   0x7630             STRB     R0,[R6, #+24]
    918                  /*!< Byte 10 */
    919                  tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
   \   000000F2   0x6D38             LDR      R0,[R7, #+80]
   \   000000F4   0xEA4F 0x2E10      LSR      LR,R0,#+8
   \   000000F8   0xFA5F 0xFE8E      UXTB     LR,LR
    920                  cardinfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;
   \   000000FC   0x7E30             LDRB     R0,[R6, #+24]
   \   000000FE   0xEA4F 0x11EE      ASR      R1,LR,#+7
   \   00000102   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000106   0x4308             ORRS     R0,R1,R0
   \   00000108   0x7630             STRB     R0,[R6, #+24]
    921          
    922                  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1);
   \   0000010A   0x6930             LDR      R0,[R6, #+16]
   \   0000010C   0x1C44             ADDS     R4,R0,#+1
   \   0000010E   0x2500             MOVS     R5,#+0
   \   00000110   0xE9CC 0x4506      STRD     R4,R5,[R12, #+24]
    923                  cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
   \   00000114   0xF04F 0x0801      MOV      R8,#+1
   \   00000118   0x7E30             LDRB     R0,[R6, #+24]
   \   0000011A   0x1C80             ADDS     R0,R0,#+2
   \   0000011C   0xFA08 0xF000      LSL      R0,R8,R0
   \   00000120   0x17C1             ASRS     R1,R0,#+31
   \   00000122   0xFBA0 0x2304      UMULL    R2,R3,R0,R4
   \   00000126   0xFB01 0x3304      MLA      R3,R1,R4,R3
   \   0000012A   0xE9CC 0x2306      STRD     R2,R3,[R12, #+24]
    924                  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
   \   0000012E   0xF996 0x0008      LDRSB    R0,[R6, #+8]
   \   00000132   0xFA08 0xF000      LSL      R0,R8,R0
   \   00000136   0xF8CC 0x0020      STR      R0,[R12, #+32]
    925                  cardinfo->CardCapacity *= cardinfo->CardBlockSize;
   \   0000013A   0xE9DC 0x2306      LDRD     R2,R3,[R12, #+24]
   \   0000013E   0xFBA0 0x4502      UMULL    R4,R5,R0,R2
   \   00000142   0xFB00 0x5503      MLA      R5,R0,R3,R5
   \   00000146   0xE9CC 0x4506      STRD     R4,R5,[R12, #+24]
   \   0000014A   0xE024             B.N      ??SD_GetCardInfo_2
    926          }
    927          else if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
   \                     ??SD_GetCardInfo_1: (+1)
   \   0000014C   0x2802             CMP      R0,#+2
   \   0000014E   0xD122             BNE.N    ??SD_GetCardInfo_2
    928          {
    929                  /*!< Byte 7 */
    930                  tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
    931                  cardinfo->SD_csd.DeviceSize = (tmp & 0x3F) << 16;
   \   00000150   0x6CF8             LDR      R0,[R7, #+76]
   \   00000152   0x0400             LSLS     R0,R0,#+16
   \   00000154   0xF400 0x107C      AND      R0,R0,#0x3F0000
   \   00000158   0x6130             STR      R0,[R6, #+16]
    932          
    933                  /*!< Byte 8 */
    934                  tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
    935          
    936                  cardinfo->SD_csd.DeviceSize |= (tmp << 8);
   \   0000015A   0x6930             LDR      R0,[R6, #+16]
   \   0000015C   0x6D39             LDR      R1,[R7, #+80]
   \   0000015E   0x0E09             LSRS     R1,R1,#+24
   \   00000160   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000164   0x6130             STR      R0,[R6, #+16]
    937          
    938                  /*!< Byte 9 */
    939                  tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
    940          
    941                  cardinfo->SD_csd.DeviceSize |= (tmp);
   \   00000166   0x6930             LDR      R0,[R6, #+16]
   \   00000168   0x6D39             LDR      R1,[R7, #+80]
   \   0000016A   0x0C09             LSRS     R1,R1,#+16
   \   0000016C   0xB2C9             UXTB     R1,R1
   \   0000016E   0x4308             ORRS     R0,R1,R0
   \   00000170   0x6130             STR      R0,[R6, #+16]
    942          
    943                  /*!< Byte 10 */
    944                  tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
   \   00000172   0x6D38             LDR      R0,[R7, #+80]
   \   00000174   0xF3C0 0x2E07      UBFX     LR,R0,#+8,#+8
    945          
    946                  cardinfo->CardCapacity = ((uint64_t)cardinfo->SD_csd.DeviceSize + 1) * 512 * 1024;
   \   00000178   0x6930             LDR      R0,[R6, #+16]
   \   0000017A   0x2100             MOVS     R1,#+0
   \   0000017C   0x1C40             ADDS     R0,R0,#+1
   \   0000017E   0xF161 0x31FF      SBC      R1,R1,#-1
   \   00000182   0x04C9             LSLS     R1,R1,#+19
   \   00000184   0xEA41 0x3150      ORR      R1,R1,R0, LSR #+13
   \   00000188   0x04C0             LSLS     R0,R0,#+19
   \   0000018A   0xE9CC 0x0106      STRD     R0,R1,[R12, #+24]
    947                  cardinfo->CardBlockSize = 512;
   \   0000018E   0xF44F 0x7000      MOV      R0,#+512
   \   00000192   0xF8CC 0x0020      STR      R0,[R12, #+32]
    948          }
    949          
    950                  cardinfo->SD_csd.EraseGrSize = (tmp & 0x40) >> 6;
   \                     ??SD_GetCardInfo_2: (+1)
   \   00000196   0xEA4F 0x10AE      ASR      R0,LR,#+6
   \   0000019A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000019E   0x7670             STRB     R0,[R6, #+25]
    951                  cardinfo->SD_csd.EraseGrMul = (tmp & 0x3F) << 1;
   \   000001A0   0xEA4F 0x004E      LSL      R0,LR,#+1
   \   000001A4   0xF000 0x007E      AND      R0,R0,#0x7E
   \   000001A8   0x76B0             STRB     R0,[R6, #+26]
    952          
    953                  /*!< Byte 11 */
    954                  tmp = (uint8_t) (CSD_Tab[2] & 0x000000FF);
   \   000001AA   0xF897 0x0050      LDRB     R0,[R7, #+80]
    955                  cardinfo->SD_csd.EraseGrMul |= (tmp & 0x80) >> 7;
   \   000001AE   0x7EB1             LDRB     R1,[R6, #+26]
   \   000001B0   0x4602             MOV      R2,R0
   \   000001B2   0xEA41 0x11D2      ORR      R1,R1,R2, LSR #+7
   \   000001B6   0x76B1             STRB     R1,[R6, #+26]
    956                  cardinfo->SD_csd.WrProtectGrSize = (tmp & 0x7F);
   \   000001B8   0xF000 0x007F      AND      R0,R0,#0x7F
   \   000001BC   0x76F0             STRB     R0,[R6, #+27]
    957          
    958                  /*!< Byte 12 */
    959                  tmp = (uint8_t) ((CSD_Tab[3] & 0xFF000000) >> 24);
   \   000001BE   0x6D78             LDR      R0,[R7, #+84]
   \   000001C0   0x0E00             LSRS     R0,R0,#+24
    960                  cardinfo->SD_csd.WrProtectGrEnable = (tmp & 0x80) >> 7;
   \   000001C2   0x11C1             ASRS     R1,R0,#+7
   \   000001C4   0xF001 0x0101      AND      R1,R1,#0x1
   \   000001C8   0x7731             STRB     R1,[R6, #+28]
    961                  cardinfo->SD_csd.ManDeflECC = (tmp & 0x60) >> 5;
   \   000001CA   0x1141             ASRS     R1,R0,#+5
   \   000001CC   0xF001 0x0103      AND      R1,R1,#0x3
   \   000001D0   0x7771             STRB     R1,[R6, #+29]
    962                  cardinfo->SD_csd.WrSpeedFact = (tmp & 0x1C) >> 2;
   \   000001D2   0x1081             ASRS     R1,R0,#+2
   \   000001D4   0xF001 0x0107      AND      R1,R1,#0x7
   \   000001D8   0x77B1             STRB     R1,[R6, #+30]
    963                  cardinfo->SD_csd.MaxWrBlockLen = (tmp & 0x03) << 2;
   \   000001DA   0x0080             LSLS     R0,R0,#+2
   \   000001DC   0xF000 0x000C      AND      R0,R0,#0xC
   \   000001E0   0x77F0             STRB     R0,[R6, #+31]
    964          
    965                  /*!< Byte 13 */
    966                  tmp = (uint8_t) ((CSD_Tab[3] & 0x00FF0000) >> 16);
   \   000001E2   0x6D78             LDR      R0,[R7, #+84]
   \   000001E4   0x0C01             LSRS     R1,R0,#+16
   \   000001E6   0xB2C9             UXTB     R1,R1
    967                  cardinfo->SD_csd.MaxWrBlockLen |= (tmp & 0xC0) >> 6;
   \   000001E8   0x7FF0             LDRB     R0,[R6, #+31]
   \   000001EA   0x118A             ASRS     R2,R1,#+6
   \   000001EC   0xF002 0x0203      AND      R2,R2,#0x3
   \   000001F0   0x4310             ORRS     R0,R2,R0
   \   000001F2   0x77F0             STRB     R0,[R6, #+31]
    968                  cardinfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20) >> 5;
   \   000001F4   0x1148             ASRS     R0,R1,#+5
   \   000001F6   0xF000 0x0001      AND      R0,R0,#0x1
   \   000001FA   0xF886 0x0020      STRB     R0,[R6, #+32]
    969                  cardinfo->SD_csd.Reserved3 = 0;
   \   000001FE   0xF106 0x0021      ADD      R0,R6,#+33
   \   00000202   0x2200             MOVS     R2,#+0
   \   00000204   0x7002             STRB     R2,[R0, #+0]
    970                  cardinfo->SD_csd.ContentProtectAppli = (tmp & 0x01);
   \   00000206   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000020A   0x7041             STRB     R1,[R0, #+1]
    971          
    972                  /*!< Byte 14 */
    973                  tmp = (uint8_t) ((CSD_Tab[3] & 0x0000FF00) >> 8);
   \   0000020C   0x6D79             LDR      R1,[R7, #+84]
   \   0000020E   0x0A09             LSRS     R1,R1,#+8
   \   00000210   0xB2C9             UXTB     R1,R1
    974                  cardinfo->SD_csd.FileFormatGrouop = (tmp & 0x80) >> 7;
   \   00000212   0x11CA             ASRS     R2,R1,#+7
   \   00000214   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000218   0x7082             STRB     R2,[R0, #+2]
    975                  cardinfo->SD_csd.CopyFlag = (tmp & 0x40) >> 6;
   \   0000021A   0x118A             ASRS     R2,R1,#+6
   \   0000021C   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000220   0x70C2             STRB     R2,[R0, #+3]
    976                  cardinfo->SD_csd.PermWrProtect = (tmp & 0x20) >> 5;
   \   00000222   0x114A             ASRS     R2,R1,#+5
   \   00000224   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000228   0x7102             STRB     R2,[R0, #+4]
    977                  cardinfo->SD_csd.TempWrProtect = (tmp & 0x10) >> 4;
   \   0000022A   0x110A             ASRS     R2,R1,#+4
   \   0000022C   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000230   0x7142             STRB     R2,[R0, #+5]
    978                  cardinfo->SD_csd.FileFormat = (tmp & 0x0C) >> 2;
   \   00000232   0x108A             ASRS     R2,R1,#+2
   \   00000234   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000238   0x7182             STRB     R2,[R0, #+6]
    979                  cardinfo->SD_csd.ECC = (tmp & 0x03);
   \   0000023A   0xF001 0x0103      AND      R1,R1,#0x3
   \   0000023E   0x71C1             STRB     R1,[R0, #+7]
    980          
    981                  /*!< Byte 15 */
    982                  tmp = (uint8_t) (CSD_Tab[3] & 0x000000FF);
    983                  cardinfo->SD_csd.CSD_CRC = (tmp & 0xFE) >> 1;
   \   00000240   0x6D79             LDR      R1,[R7, #+84]
   \   00000242   0xB2C9             UXTB     R1,R1
   \   00000244   0x0849             LSRS     R1,R1,#+1
   \   00000246   0x7201             STRB     R1,[R0, #+8]
    984                  cardinfo->SD_csd.Reserved4 = 1;
   \   00000248   0x2101             MOVS     R1,#+1
   \   0000024A   0x7241             STRB     R1,[R0, #+9]
    985          
    986                  /*!< Byte 0 */
    987                  tmp = (uint8_t) ((CID_Tab[0] & 0xFF000000) >> 24);
    988                  cardinfo->SD_cid.ManufacturerID = tmp;
   \   0000024C   0x6DB9             LDR      R1,[R7, #+88]
   \   0000024E   0x0E09             LSRS     R1,R1,#+24
   \   00000250   0x72C1             STRB     R1,[R0, #+11]
    989          
    990                  /*!< Byte 1 */
    991                  tmp = (uint8_t) ((CID_Tab[0] & 0x00FF0000) >> 16);
    992                  cardinfo->SD_cid.OEM_AppliID = tmp << 8;
   \   00000252   0x6DB8             LDR      R0,[R7, #+88]
   \   00000254   0x0C00             LSRS     R0,R0,#+16
   \   00000256   0xB2C0             UXTB     R0,R0
   \   00000258   0x0200             LSLS     R0,R0,#+8
   \   0000025A   0x85F0             STRH     R0,[R6, #+46]
    993          
    994                  /*!< Byte 2 */
    995                  tmp = (uint8_t) ((CID_Tab[0] & 0x000000FF00) >> 8);
    996                  cardinfo->SD_cid.OEM_AppliID |= tmp;
   \   0000025C   0x8DF0             LDRH     R0,[R6, #+46]
   \   0000025E   0x6DB9             LDR      R1,[R7, #+88]
   \   00000260   0x0A09             LSRS     R1,R1,#+8
   \   00000262   0xB2C9             UXTB     R1,R1
   \   00000264   0x4308             ORRS     R0,R1,R0
   \   00000266   0x85F0             STRH     R0,[R6, #+46]
    997          
    998                  /*!< Byte 3 */
    999                  tmp = (uint8_t) (CID_Tab[0] & 0x000000FF);
   1000                  cardinfo->SD_cid.ProdName1 = tmp << 24;
   \   00000268   0xF897 0x0058      LDRB     R0,[R7, #+88]
   \   0000026C   0x0600             LSLS     R0,R0,#+24
   \   0000026E   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1001          
   1002                  /*!< Byte 4 */
   1003                  tmp = (uint8_t) ((CID_Tab[1] & 0xFF000000) >> 24);
   1004                  cardinfo->SD_cid.ProdName1 |= tmp << 16;
   \   00000272   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \   00000276   0x6DF9             LDR      R1,[R7, #+92]
   \   00000278   0x0E09             LSRS     R1,R1,#+24
   \   0000027A   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000027E   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1005          
   1006                  /*!< Byte 5 */
   1007                  tmp = (uint8_t) ((CID_Tab[1] & 0x00FF0000) >> 16);
   1008                  cardinfo->SD_cid.ProdName1 |= tmp << 8;
   \   00000282   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \   00000286   0x6DF9             LDR      R1,[R7, #+92]
   \   00000288   0x0C09             LSRS     R1,R1,#+16
   \   0000028A   0xB2C9             UXTB     R1,R1
   \   0000028C   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000290   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1009          
   1010                  /*!< Byte 6 */
   1011                  tmp = (uint8_t) ((CID_Tab[1] & 0x0000FF00) >> 8);
   1012                  cardinfo->SD_cid.ProdName1 |= tmp;
   \   00000294   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \   00000298   0x6DF9             LDR      R1,[R7, #+92]
   \   0000029A   0x0A09             LSRS     R1,R1,#+8
   \   0000029C   0xB2C9             UXTB     R1,R1
   \   0000029E   0x4308             ORRS     R0,R1,R0
   \   000002A0   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1013          
   1014                  /*!< Byte 7 */
   1015                  tmp = (uint8_t) (CID_Tab[1] & 0x000000FF);
   1016                  cardinfo->SD_cid.ProdName2 = tmp;
   \   000002A4   0x6DF8             LDR      R0,[R7, #+92]
   \   000002A6   0xF88C 0x0004      STRB     R0,[R12, #+4]
   1017          
   1018                  /*!< Byte 8 */
   1019                  tmp = (uint8_t) ((CID_Tab[2] & 0xFF000000) >> 24);
   1020                  cardinfo->SD_cid.ProdRev = tmp;
   \   000002AA   0x6E38             LDR      R0,[R7, #+96]
   \   000002AC   0x0E00             LSRS     R0,R0,#+24
   \   000002AE   0xF88C 0x0005      STRB     R0,[R12, #+5]
   1021          
   1022                  /*!< Byte 9 */
   1023                  tmp = (uint8_t) ((CID_Tab[2] & 0x00FF0000) >> 16);
   1024                  cardinfo->SD_cid.ProdSN = tmp << 24;
   \   000002B2   0x6E38             LDR      R0,[R7, #+96]
   \   000002B4   0x0C00             LSRS     R0,R0,#+16
   \   000002B6   0xB2C0             UXTB     R0,R0
   \   000002B8   0x0600             LSLS     R0,R0,#+24
   \   000002BA   0xF8CC 0x0008      STR      R0,[R12, #+8]
   1025          
   1026                  /*!< Byte 10 */
   1027                  tmp = (uint8_t) ((CID_Tab[2] & 0x0000FF00) >> 8);
   1028                  cardinfo->SD_cid.ProdSN |= tmp << 16;
   \   000002BE   0xF8DC 0x0008      LDR      R0,[R12, #+8]
   \   000002C2   0x6E39             LDR      R1,[R7, #+96]
   \   000002C4   0x0A09             LSRS     R1,R1,#+8
   \   000002C6   0xB2C9             UXTB     R1,R1
   \   000002C8   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000002CC   0xF8CC 0x0008      STR      R0,[R12, #+8]
   1029          
   1030                  /*!< Byte 11 */
   1031                  tmp = (uint8_t) (CID_Tab[2] & 0x000000FF);
   1032                  cardinfo->SD_cid.ProdSN |= tmp << 8;
   \   000002D0   0xF8DC 0x0008      LDR      R0,[R12, #+8]
   \   000002D4   0xF897 0x1060      LDRB     R1,[R7, #+96]
   \   000002D8   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000002DC   0xF8CC 0x0008      STR      R0,[R12, #+8]
   1033          
   1034                  /*!< Byte 12 */
   1035                  tmp = (uint8_t) ((CID_Tab[3] & 0xFF000000) >> 24);
   1036                  cardinfo->SD_cid.ProdSN |= tmp;
   \   000002E0   0xF8DC 0x0008      LDR      R0,[R12, #+8]
   \   000002E4   0x6E79             LDR      R1,[R7, #+100]
   \   000002E6   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   000002EA   0xF8CC 0x0008      STR      R0,[R12, #+8]
   1037          
   1038                  /*!< Byte 13 */
   1039                  tmp = (uint8_t) ((CID_Tab[3] & 0x00FF0000) >> 16);
   \   000002EE   0x6E78             LDR      R0,[R7, #+100]
   \   000002F0   0x0C00             LSRS     R0,R0,#+16
   \   000002F2   0xB2C0             UXTB     R0,R0
   1040                  cardinfo->SD_cid.Reserved1 |= (tmp & 0xF0) >> 4;
   \   000002F4   0xF89C 0x100C      LDRB     R1,[R12, #+12]
   \   000002F8   0x1102             ASRS     R2,R0,#+4
   \   000002FA   0xF002 0x020F      AND      R2,R2,#0xF
   \   000002FE   0x4311             ORRS     R1,R2,R1
   \   00000300   0xF88C 0x100C      STRB     R1,[R12, #+12]
   1041                  cardinfo->SD_cid.ManufactDate = (tmp & 0x0F) << 8;
   \   00000304   0x0200             LSLS     R0,R0,#+8
   \   00000306   0xF400 0x6070      AND      R0,R0,#0xF00
   \   0000030A   0xF8AC 0x000E      STRH     R0,[R12, #+14]
   1042          
   1043                  /*!< Byte 14 */
   1044                  tmp = (uint8_t) ((CID_Tab[3] & 0x0000FF00) >> 8);
   1045                  cardinfo->SD_cid.ManufactDate |= tmp;
   \   0000030E   0xF8BC 0x000E      LDRH     R0,[R12, #+14]
   \   00000312   0x6E79             LDR      R1,[R7, #+100]
   \   00000314   0x0A09             LSRS     R1,R1,#+8
   \   00000316   0xB2C9             UXTB     R1,R1
   \   00000318   0x4308             ORRS     R0,R1,R0
   \   0000031A   0xF8AC 0x000E      STRH     R0,[R12, #+14]
   1046          
   1047                  /*!< Byte 15 */
   1048                  tmp = (uint8_t) (CID_Tab[3] & 0x000000FF);
   1049                  cardinfo->SD_cid.CID_CRC = (tmp & 0xFE) >> 1;
   \   0000031E   0x6E78             LDR      R0,[R7, #+100]
   \   00000320   0xB2C0             UXTB     R0,R0
   \   00000322   0x0840             LSRS     R0,R0,#+1
   \   00000324   0xF88C 0x0010      STRB     R0,[R12, #+16]
   1050                  cardinfo->SD_cid.Reserved2 = 1;
   \   00000328   0x2001             MOVS     R0,#+1
   \   0000032A   0xF88C 0x0011      STRB     R0,[R12, #+17]
   1051          
   1052                  return (errorstatus);
   \   0000032E   0x2000             MOVS     R0,#+0
   \   00000330   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1053          }
   1054          
   1055          /**
   1056           * @brief  Enables wide bus opeartion for the requeseted card if supported by
   1057           *         card.
   1058           * @param  WideMode: Specifies the SD card wide bus mode.
   1059           *   This parameter can be one of the following values:
   1060           *     @arg SDIO_BusWide_8b: 8-bit data transfer (Only for MMC)
   1061           *     @arg SDIO_BusWide_4b: 4-bit data transfer
   1062           *     @arg SDIO_BusWide_1b: 1-bit data transfer
   1063           * @retval SD_Error: SD Card Error code.
   1064           */

   \                                 In section .text, align 2, keep-with-next
   1065          SD_Error SD_GetCardStatus (SD_CardStatus *cardstatus)
   1066          {
   \                     SD_GetCardStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1067                  SD_Error errorstatus = SD_OK;
   1068                  uint8_t tmp = 0;
   1069          
   1070                  errorstatus = SD_SendSDStatus ((uint32_t *) SDSTATUS_Tab);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable32
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SD_SendSDStatus
   1071          
   1072                  if (errorstatus != SD_OK) {
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD134             BNE.N    ??SD_GetCardStatus_0
   1073                          return (errorstatus);
   1074                  }
   1075          
   1076                  /*!< Byte 0 */
   1077                  tmp = (uint8_t) ((SDSTATUS_Tab[0] & 0xC0) >> 6);
   1078                  cardstatus->DAT_BUS_WIDTH = tmp;
   \   00000012   0x7828             LDRB     R0,[R5, #+0]
   \   00000014   0x0980             LSRS     R0,R0,#+6
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   1079          
   1080                  /*!< Byte 0 */
   1081                  tmp = (uint8_t) ((SDSTATUS_Tab[0] & 0x20) >> 5);
   1082                  cardstatus->SECURED_MODE = tmp;
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   0000001E   0x7060             STRB     R0,[R4, #+1]
   1083          
   1084                  /*!< Byte 2 */
   1085                  tmp = (uint8_t) ((SDSTATUS_Tab[2] & 0xFF));
   1086                  cardstatus->SD_CARD_TYPE = tmp << 8;
   \   00000020   0x78A8             LDRB     R0,[R5, #+2]
   \   00000022   0x0200             LSLS     R0,R0,#+8
   \   00000024   0x8060             STRH     R0,[R4, #+2]
   1087          
   1088                  /*!< Byte 3 */
   1089                  tmp = (uint8_t) ((SDSTATUS_Tab[3] & 0xFF));
   1090                  cardstatus->SD_CARD_TYPE |= tmp;
   \   00000026   0x8860             LDRH     R0,[R4, #+2]
   \   00000028   0x78E9             LDRB     R1,[R5, #+3]
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x8060             STRH     R0,[R4, #+2]
   1091          
   1092                  /*!< Byte 4 */
   1093                  tmp = (uint8_t) (SDSTATUS_Tab[4] & 0xFF);
   1094                  cardstatus->SIZE_OF_PROTECTED_AREA = tmp << 24;
   \   0000002E   0x7928             LDRB     R0,[R5, #+4]
   \   00000030   0x0600             LSLS     R0,R0,#+24
   \   00000032   0x6060             STR      R0,[R4, #+4]
   1095          
   1096                  /*!< Byte 5 */
   1097                  tmp = (uint8_t) (SDSTATUS_Tab[5] & 0xFF);
   1098                  cardstatus->SIZE_OF_PROTECTED_AREA |= tmp << 16;
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x7969             LDRB     R1,[R5, #+5]
   \   00000038   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000003C   0x6060             STR      R0,[R4, #+4]
   1099          
   1100                  /*!< Byte 6 */
   1101                  tmp = (uint8_t) (SDSTATUS_Tab[6] & 0xFF);
   1102                  cardstatus->SIZE_OF_PROTECTED_AREA |= tmp << 8;
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x79A9             LDRB     R1,[R5, #+6]
   \   00000042   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000046   0x6060             STR      R0,[R4, #+4]
   1103          
   1104                  /*!< Byte 7 */
   1105                  tmp = (uint8_t) (SDSTATUS_Tab[7] & 0xFF);
   1106                  cardstatus->SIZE_OF_PROTECTED_AREA |= tmp;
   \   00000048   0x6860             LDR      R0,[R4, #+4]
   \   0000004A   0x79E9             LDRB     R1,[R5, #+7]
   \   0000004C   0x4308             ORRS     R0,R1,R0
   \   0000004E   0x6060             STR      R0,[R4, #+4]
   1107          
   1108                  /*!< Byte 8 */
   1109                  tmp = (uint8_t) ((SDSTATUS_Tab[8] & 0xFF));
   1110                  cardstatus->SPEED_CLASS = tmp;
   \   00000050   0x7A28             LDRB     R0,[R5, #+8]
   \   00000052   0x7220             STRB     R0,[R4, #+8]
   1111          
   1112                  /*!< Byte 9 */
   1113                  tmp = (uint8_t) ((SDSTATUS_Tab[9] & 0xFF));
   1114                  cardstatus->PERFORMANCE_MOVE = tmp;
   \   00000054   0x7A68             LDRB     R0,[R5, #+9]
   \   00000056   0x7260             STRB     R0,[R4, #+9]
   1115          
   1116                  /*!< Byte 10 */
   1117                  tmp = (uint8_t) ((SDSTATUS_Tab[10] & 0xF0) >> 4);
   1118                  cardstatus->AU_SIZE = tmp;
   \   00000058   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000005A   0x0900             LSRS     R0,R0,#+4
   \   0000005C   0x72A0             STRB     R0,[R4, #+10]
   1119          
   1120                  /*!< Byte 11 */
   1121                  tmp = (uint8_t) (SDSTATUS_Tab[11] & 0xFF);
   1122                  cardstatus->ERASE_SIZE = tmp << 8;
   \   0000005E   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000060   0x0200             LSLS     R0,R0,#+8
   \   00000062   0x81A0             STRH     R0,[R4, #+12]
   1123          
   1124                  /*!< Byte 12 */
   1125                  tmp = (uint8_t) (SDSTATUS_Tab[12] & 0xFF);
   1126                  cardstatus->ERASE_SIZE |= tmp;
   \   00000064   0x89A0             LDRH     R0,[R4, #+12]
   \   00000066   0x7B29             LDRB     R1,[R5, #+12]
   \   00000068   0x4308             ORRS     R0,R1,R0
   \   0000006A   0x81A0             STRH     R0,[R4, #+12]
   1127          
   1128                  /*!< Byte 13 */
   1129                  tmp = (uint8_t) ((SDSTATUS_Tab[13] & 0xFC) >> 2);
   1130                  cardstatus->ERASE_TIMEOUT = tmp;
   \   0000006C   0x7B68             LDRB     R0,[R5, #+13]
   \   0000006E   0x0880             LSRS     R0,R0,#+2
   \   00000070   0x73A0             STRB     R0,[R4, #+14]
   1131          
   1132                  /*!< Byte 13 */
   1133                  tmp = (uint8_t) ((SDSTATUS_Tab[13] & 0x3));
   1134                  cardstatus->ERASE_OFFSET = tmp;
   \   00000072   0x7B68             LDRB     R0,[R5, #+13]
   \   00000074   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000078   0x73E0             STRB     R0,[R4, #+15]
   1135          
   1136                  return (errorstatus);
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??SD_GetCardStatus_0: (+1)
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1137          }
   1138          
   1139          /**
   1140           * @brief  Enables wide bus opeartion for the requeseted card if supported by
   1141           *         card.
   1142           * @param  WideMode: Specifies the SD card wide bus mode.
   1143           *   This parameter can be one of the following values:
   1144           *     @arg SDIO_BusWide_8b: 8-bit data transfer (Only for MMC)
   1145           *     @arg SDIO_BusWide_4b: 4-bit data transfer
   1146           *     @arg SDIO_BusWide_1b: 1-bit data transfer
   1147           * @retval SD_Error: SD Card Error code.
   1148           */

   \                                 In section .text, align 2, keep-with-next
   1149          SD_Error SD_EnableWideBusOperation (uint32_t WideMode)
   1150          {
   \                     SD_EnableWideBusOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1151                  SD_Error errorstatus = SD_OK;
   \   00000002   0x2500             MOVS     R5,#+0
   1152          
   1153                  /*!< MMC Card doesn't support this feature */
   1154                  if (SDIO_MULTIMEDIA_CARD == CardType) {
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable21
   \   00000008   0x6EA1             LDR      R1,[R4, #+104]
   \   0000000A   0x2903             CMP      R1,#+3
   \   0000000C   0xD008             BEQ.N    ??SD_EnableWideBusOperation_0
   1155                          errorstatus = SD_UNSUPPORTED_FEATURE;
   1156                          return (errorstatus);
   1157                  }
   1158                  else if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType)) {
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD003             BEQ.N    ??SD_EnableWideBusOperation_1
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD001             BEQ.N    ??SD_EnableWideBusOperation_1
   \   00000016   0x2902             CMP      R1,#+2
   \   00000018   0xD12B             BNE.N    ??SD_EnableWideBusOperation_2
   1159                          if (SDIO_BusWide_8b == WideMode) {
   \                     ??SD_EnableWideBusOperation_1: (+1)
   \   0000001A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001E   0xD101             BNE.N    ??SD_EnableWideBusOperation_3
   1160                                  errorstatus = SD_UNSUPPORTED_FEATURE;
   1161                                  return (errorstatus);
   \                     ??SD_EnableWideBusOperation_0: (+1)
   \   00000020   0x2027             MOVS     R0,#+39
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
   1162                          }
   1163                          else if (SDIO_BusWide_4b == WideMode) {
   \                     ??SD_EnableWideBusOperation_3: (+1)
   \   00000024   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000028   0xD113             BNE.N    ??SD_EnableWideBusOperation_4
   1164                                  errorstatus = SDEnWideBus (ENABLE);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      BL       SDEnWideBus
   \   00000030   0x0005             MOVS     R5,R0
   1165          
   1166                                  if (SD_OK == errorstatus) {
   \   00000032   0xD11E             BNE.N    ??SD_EnableWideBusOperation_2
   1167                                          /*!< Configure the SDIO peripheral */
   1168                                          SDIO_InitStructure.SDIO_ClockDiv = SDIO_TRANSFER_CLK_DIV;
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0x7520             STRB     R0,[R4, #+20]
   1169                                          SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6020             STR      R0,[R4, #+0]
   1170                                          SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
   \   0000003C   0x6060             STR      R0,[R4, #+4]
   1171                                          SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   1172                                          SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_4b;
   \   00000040   0xF44F 0x6000      MOV      R0,#+2048
   \   00000044   0x60E0             STR      R0,[R4, #+12]
   1173                                          SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6120             STR      R0,[R4, #+16]
   1174                                          SDIO_Init (&SDIO_InitStructure);
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       SDIO_Init
   \   00000050   0xE00F             B.N      ??SD_EnableWideBusOperation_2
   1175                                  }
   1176                          }
   1177                          else {
   1178                                  errorstatus = SDEnWideBus (DISABLE);
   \                     ??SD_EnableWideBusOperation_4: (+1)
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       SDEnWideBus
   \   00000058   0x0005             MOVS     R5,R0
   1179          
   1180                                  if (SD_OK == errorstatus) {
   \   0000005A   0xD10A             BNE.N    ??SD_EnableWideBusOperation_2
   1181                                          /*!< Configure the SDIO peripheral */
   1182                                          SDIO_InitStructure.SDIO_ClockDiv = SDIO_TRANSFER_CLK_DIV;
   \   0000005C   0x2004             MOVS     R0,#+4
   \   0000005E   0x7520             STRB     R0,[R4, #+20]
   1183                                          SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6020             STR      R0,[R4, #+0]
   1184                                          SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
   \   00000064   0x6060             STR      R0,[R4, #+4]
   1185                                          SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
   \   00000066   0x60A0             STR      R0,[R4, #+8]
   1186                                          SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
   \   00000068   0x60E0             STR      R0,[R4, #+12]
   1187                                          SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
   \   0000006A   0x6120             STR      R0,[R4, #+16]
   1188                                          SDIO_Init (&SDIO_InitStructure);
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       SDIO_Init
   1189                                  }
   1190                          }
   1191                  }
   1192          
   1193                  return (errorstatus);
   \                     ??SD_EnableWideBusOperation_2: (+1)
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1194          }
   1195          
   1196          /**
   1197           * @brief  Selects od Deselects the corresponding card.
   1198           * @param  addr: Address of the Card to be selected.
   1199           * @retval SD_Error: SD Card Error code.
   1200           */

   \                                 In section .text, align 2, keep-with-next
   1201          SD_Error SD_SelectDeselect (uint64_t addr)
   1202          {
   \                     SD_SelectDeselect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1203                  SD_Error errorstatus = SD_OK;
   1204          
   1205                  /*!< Send CMD7 SDIO_SEL_DESEL_CARD */
   1206                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) addr;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000006   0x6350             STR      R0,[R2, #+52]
   1207                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SEL_DESEL_CARD;
   \   00000008   0x2007             MOVS     R0,#+7
   \   0000000A   0x6390             STR      R0,[R2, #+56]
   1208                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000000C   0x2040             MOVS     R0,#+64
   \   0000000E   0x63D0             STR      R0,[R2, #+60]
   1209                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6410             STR      R0,[R2, #+64]
   1210                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000014   0xF44F 0x6080      MOV      R0,#+1024
   \   00000018   0x6450             STR      R0,[R2, #+68]
   1211                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000001A   0xF102 0x0034      ADD      R0,R2,#+52
   \   0000001E   0x.... 0x....      BL       SDIO_SendCommand
   1212          
   1213                  errorstatus = CmdResp1Error (SD_CMD_SEL_DESEL_CARD );
   1214          
   1215                  return (errorstatus);
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0xE8BD 0x4002      POP      {R1,LR}
   \   00000028   0x.... 0x....      B.W      CmdResp1Error
   1216          }
   1217          
   1218          /**
   1219           * @brief  Allows to read one block from a specified address in a card. The Data
   1220           *         transfer can be managed by DMA mode or Polling mode.
   1221           * @note   This operation should be followed by two functions to check if the
   1222           *         DMA Controller and SD Card status.
   1223           *          - SD_ReadWaitOperation(): this function insure that the DMA
   1224           *            controller has finished all data transfer.
   1225           *          - SD_GetStatus(): to check that the SD Card has finished the
   1226           *            data transfer and it is ready for data.
   1227           * @param  readbuff: pointer to the buffer that will contain the received data
   1228           * @param  ReadAddr: Address from where data are to be read.
   1229           * @param  BlockSize: the SD card Data block size. The Block size should be 512.
   1230           * @retval SD_Error: SD Card Error code.
   1231           */

   \                                 In section .text, align 2, keep-with-next
   1232          SD_Error SD_ReadBlock (uint8_t *readbuff, uint64_t ReadAddr, uint16_t BlockSize)
   1233          {
   \                     SD_ReadBlock: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
   1234                  SD_Error errorstatus = SD_OK;
   1235          #if defined (SD_POLLING_MODE) 
   1236                  uint32_t count = 0, *tempbuff = (uint32_t *)readbuff;
   1237          #endif
   1238          
   1239                  TransferError = SD_OK;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable21
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF888 0x0018      STRB     R0,[R8, #+24]
   1240                  TransferEnd = 0;
   \   00000014   0xF8C8 0x0074      STR      R0,[R8, #+116]
   1241                  StopCondition = 0;
   \   00000018   0xF8C8 0x0070      STR      R0,[R8, #+112]
   1242          
   1243                  SDIO ->DCTRL = 0x0;
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x40012c2c
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1244          
   1245          #if defined (SD_DMA_MODE)
   1246                  SDIO_ITConfig (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF240 0x302A      MOVW     R0,#+810
   \   00000028   0x.... 0x....      BL       SDIO_ITConfig
   1247                  SDIO_DMACmd (ENABLE);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       SDIO_DMACmd
   \   00000032   0x9E06             LDR      R6,[SP, #+24]
   1248                  SD_LowLevel_DMA_RxConfig ((uint32_t *) readbuff, BlockSize);
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       SD_LowLevel_DMA_RxConfig
   1249          #endif
   1250          
   1251                  if (CardType == SDIO_HIGH_CAPACITY_SD_CARD ) {
   \   0000003C   0xF8D8 0x0068      LDR      R0,[R8, #+104]
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xD104             BNE.N    ??SD_ReadBlock_0
   1252                          BlockSize = 512;
   \   00000044   0xF44F 0x7600      MOV      R6,#+512
   1253                          ReadAddr /= 512;
   \   00000048   0x0A64             LSRS     R4,R4,#+9
   \   0000004A   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1254                  }
   1255          
   1256                  /* Set Block Size for Card */
   1257                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
   \                     ??SD_ReadBlock_0: (+1)
   \   0000004E   0xF8C8 0x6034      STR      R6,[R8, #+52]
   1258                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   00000052   0x2010             MOVS     R0,#+16
   \   00000054   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1259                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000058   0x2040             MOVS     R0,#+64
   \   0000005A   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1260                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1261                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000064   0xF44F 0x6780      MOV      R7,#+1024
   \   00000068   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1262                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000006C   0xF108 0x0034      ADD      R0,R8,#+52
   \   00000070   0x.... 0x....      BL       SDIO_SendCommand
   1263          
   1264                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   00000074   0x2010             MOVS     R0,#+16
   \   00000076   0x.... 0x....      BL       CmdResp1Error
   1265          
   1266                  if (SD_OK != errorstatus) {
   \   0000007A   0x0001             MOVS     R1,R0
   \   0000007C   0xD12C             BNE.N    ??SD_ReadBlock_1
   1267                          return (errorstatus);
   1268                  }
   1269          
   1270                  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   0000007E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000082   0xF8C8 0x001C      STR      R0,[R8, #+28]
   1271                  SDIO_DataInitStructure.SDIO_DataLength = BlockSize;
   \   00000086   0xF8C8 0x6020      STR      R6,[R8, #+32]
   1272                  SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) 9 << 4;
   \   0000008A   0x2090             MOVS     R0,#+144
   \   0000008C   0xF8C8 0x0024      STR      R0,[R8, #+36]
   1273                  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xF8C8 0x0028      STR      R0,[R8, #+40]
   1274                  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF8C8 0x002C      STR      R0,[R8, #+44]
   1275                  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xF8C8 0x0030      STR      R0,[R8, #+48]
   1276                  SDIO_DataConfig (&SDIO_DataInitStructure);
   \   000000A2   0xF108 0x001C      ADD      R0,R8,#+28
   \   000000A6   0x.... 0x....      BL       SDIO_DataConfig
   1277          
   1278                  /*!< Send CMD17 READ_SINGLE_BLOCK */
   1279                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) ReadAddr;
   \   000000AA   0xF8C8 0x4034      STR      R4,[R8, #+52]
   1280                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_READ_SINGLE_BLOCK;
   \   000000AE   0x2011             MOVS     R0,#+17
   \   000000B0   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1281                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000B4   0x2040             MOVS     R0,#+64
   \   000000B6   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1282                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1283                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000C0   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1284                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000C4   0xF108 0x0034      ADD      R0,R8,#+52
   \   000000C8   0x.... 0x....      BL       SDIO_SendCommand
   1285          
   1286                  errorstatus = CmdResp1Error (SD_CMD_READ_SINGLE_BLOCK );
   \   000000CC   0x2011             MOVS     R0,#+17
   \   000000CE   0x.... 0x....      BL       CmdResp1Error
   1287          
   1288                  if (errorstatus != SD_OK) {
   \   000000D2   0x0001             MOVS     R1,R0
   \   000000D4   0xD100             BNE.N    ??SD_ReadBlock_1
   1289                          return (errorstatus);
   1290                  }
   1291          
   1292          #if defined (SD_POLLING_MODE)  
   1293                  /*!< In case of single block transfer, no need of stop transfer at all.*/
   1294                  /*!< Polling mode */
   1295                  while (!(SDIO->STA &(SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR)))
   1296                  {
   1297                          if (SDIO_GetFlagStatus(SDIO_FLAG_RXFIFOHF) != RESET)
   1298                          {
   1299                                  for (count = 0; count < 8; count++)
   1300                                  {
   1301                                          *(tempbuff + count) = SDIO_ReadData();
   1302                                  }
   1303                                  tempbuff += 8;
   1304                          }
   1305                  }
   1306          
   1307                  if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
   1308                  {
   1309                          SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
   1310                          errorstatus = SD_DATA_TIMEOUT;
   1311                          return(errorstatus);
   1312                  }
   1313                  else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
   1314                  {
   1315                          SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
   1316                          errorstatus = SD_DATA_CRC_FAIL;
   1317                          return(errorstatus);
   1318                  }
   1319                  else if (SDIO_GetFlagStatus(SDIO_FLAG_RXOVERR) != RESET)
   1320                  {
   1321                          SDIO_ClearFlag(SDIO_FLAG_RXOVERR);
   1322                          errorstatus = SD_RX_OVERRUN;
   1323                          return(errorstatus);
   1324                  }
   1325                  else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
   1326                  {
   1327                          SDIO_ClearFlag(SDIO_FLAG_STBITERR);
   1328                          errorstatus = SD_START_BIT_ERR;
   1329                          return(errorstatus);
   1330                  }
   1331                  count = SD_DATATIMEOUT;
   1332                  while ((SDIO_GetFlagStatus(SDIO_FLAG_RXDAVL) != RESET) && (count > 0))
   1333                  {
   1334                          *tempbuff = SDIO_ReadData();
   1335                          tempbuff++;
   1336                          count--;
   1337                  }
   1338          
   1339                  /*!< Clear all the static flags */
   1340                  SDIO_ClearFlag(SDIO_STATIC_FLAGS);
   1341          
   1342          #endif
   1343          
   1344                  return (errorstatus);
   \   000000D6   0x2000             MOVS     R0,#+0
   \                     ??SD_ReadBlock_1: (+1)
   \   000000D8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1345          }
   1346          
   1347          /**
   1348           * @brief  Allows to read blocks from a specified address  in a card.  The Data
   1349           *         transfer can be managed by DMA mode or Polling mode.
   1350           * @note   This operation should be followed by two functions to check if the
   1351           *         DMA Controller and SD Card status.
   1352           *          - SD_ReadWaitOperation(): this function insure that the DMA
   1353           *            controller has finished all data transfer.
   1354           *          - SD_GetStatus(): to check that the SD Card has finished the
   1355           *            data transfer and it is ready for data.
   1356           * @param  readbuff: pointer to the buffer that will contain the received data.
   1357           * @param  ReadAddr: Address from where data are to be read.
   1358           * @param  BlockSize: the SD card Data block size. The Block size should be 512.
   1359           * @param  NumberOfBlocks: number of blocks to be read.
   1360           * @retval SD_Error: SD Card Error code.
   1361           */

   \                                 In section .text, align 2, keep-with-next
   1362          SD_Error SD_ReadMultiBlocks (uint8_t *readbuff, uint64_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
   1363          {
   \                     SD_ReadMultiBlocks: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
   1364                  SD_Error errorstatus = SD_OK;
   1365                  TransferError = SD_OK;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable21
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF888 0x0018      STRB     R0,[R8, #+24]
   1366                  TransferEnd = 0;
   \   00000014   0xF8C8 0x0074      STR      R0,[R8, #+116]
   1367                  StopCondition = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF8C8 0x0070      STR      R0,[R8, #+112]
   1368          
   1369                  SDIO ->DCTRL = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x40012c2c
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1370          
   1371          #if defined (SD_DMA_MODE)
   1372                  SDIO_ITConfig (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF240 0x302A      MOVW     R0,#+810
   \   0000002C   0x.... 0x....      BL       SDIO_ITConfig
   \   00000030   0x9E08             LDR      R6,[SP, #+32]
   \   00000032   0xF8DD 0x9024      LDR      R9,[SP, #+36]
   1373                  SD_LowLevel_DMA_RxConfig ((uint32_t *) readbuff, (NumberOfBlocks * BlockSize));
   \   00000036   0xFB06 0xF109      MUL      R1,R6,R9
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       SD_LowLevel_DMA_RxConfig
   1374                  SDIO_DMACmd (ENABLE);
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       SDIO_DMACmd
   1375          #endif
   1376          
   1377                  if (CardType == SDIO_HIGH_CAPACITY_SD_CARD ) {
   \   00000046   0xF8D8 0x0068      LDR      R0,[R8, #+104]
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD104             BNE.N    ??SD_ReadMultiBlocks_0
   1378                          BlockSize = 512;
   \   0000004E   0xF44F 0x7600      MOV      R6,#+512
   1379                          ReadAddr /= 512;
   \   00000052   0x0A64             LSRS     R4,R4,#+9
   \   00000054   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1380                  }
   1381          
   1382                  /*!< Set Block Size for Card */
   1383                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
   \                     ??SD_ReadMultiBlocks_0: (+1)
   \   00000058   0xF8C8 0x6034      STR      R6,[R8, #+52]
   1384                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1385                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000062   0x2040             MOVS     R0,#+64
   \   00000064   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1386                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1387                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   0000006E   0xF44F 0x6780      MOV      R7,#+1024
   \   00000072   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1388                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000076   0xF108 0x0034      ADD      R0,R8,#+52
   \   0000007A   0x.... 0x....      BL       SDIO_SendCommand
   1389          
   1390                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   0000007E   0x2010             MOVS     R0,#+16
   \   00000080   0x.... 0x....      BL       CmdResp1Error
   1391          
   1392                  if (SD_OK != errorstatus) {
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0xD12E             BNE.N    ??SD_ReadMultiBlocks_1
   1393                          return (errorstatus);
   1394                  }
   1395          
   1396                  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   00000088   0xF04F 0x30FF      MOV      R0,#-1
   \   0000008C   0xF8C8 0x001C      STR      R0,[R8, #+28]
   1397                  SDIO_DataInitStructure.SDIO_DataLength = NumberOfBlocks * BlockSize;
   \   00000090   0xFB06 0xF009      MUL      R0,R6,R9
   \   00000094   0xF8C8 0x0020      STR      R0,[R8, #+32]
   1398                  SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) 9 << 4;
   \   00000098   0x2090             MOVS     R0,#+144
   \   0000009A   0xF8C8 0x0024      STR      R0,[R8, #+36]
   1399                  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0xF8C8 0x0028      STR      R0,[R8, #+40]
   1400                  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF8C8 0x002C      STR      R0,[R8, #+44]
   1401                  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF8C8 0x0030      STR      R0,[R8, #+48]
   1402                  SDIO_DataConfig (&SDIO_DataInitStructure);
   \   000000B0   0xF108 0x001C      ADD      R0,R8,#+28
   \   000000B4   0x.... 0x....      BL       SDIO_DataConfig
   1403          
   1404                  /*!< Send CMD18 READ_MULT_BLOCK with argument data address */
   1405                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) ReadAddr;
   \   000000B8   0xF8C8 0x4034      STR      R4,[R8, #+52]
   1406                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_READ_MULT_BLOCK;
   \   000000BC   0x2012             MOVS     R0,#+18
   \   000000BE   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1407                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000C2   0x2040             MOVS     R0,#+64
   \   000000C4   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1408                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1409                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000CE   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1410                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000D2   0xF108 0x0034      ADD      R0,R8,#+52
   \   000000D6   0x.... 0x....      BL       SDIO_SendCommand
   1411          
   1412                  errorstatus = CmdResp1Error (SD_CMD_READ_MULT_BLOCK );
   \   000000DA   0x2012             MOVS     R0,#+18
   \   000000DC   0x.... 0x....      BL       CmdResp1Error
   1413          
   1414                  if (errorstatus != SD_OK) {
   \   000000E0   0x0001             MOVS     R1,R0
   \   000000E2   0xD100             BNE.N    ??SD_ReadMultiBlocks_1
   1415                          return (errorstatus);
   1416                  }
   1417          
   1418                  return (errorstatus);
   \   000000E4   0x2000             MOVS     R0,#+0
   \                     ??SD_ReadMultiBlocks_1: (+1)
   \   000000E6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1419          }
   1420          

   \                                 In section .text, align 2, keep-with-next
   1421          SD_Error SD_ReadMultiBlocksFIXED(uint8_t *readbuff, uint64_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks) {
   \                     SD_ReadMultiBlocksFIXED: (+1)
   \   00000000   0xE92D 0x43DC      PUSH     {R2-R4,R6-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4614             MOV      R4,R2
   1422            SD_Error errorstatus = SD_OK;
   1423            TransferError = SD_OK;
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable21
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF889 0x0018      STRB     R0,[R9, #+24]
   1424            TransferEnd = 0;
   \   00000012   0xF8C9 0x0074      STR      R0,[R9, #+116]
   1425            StopCondition = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF8C9 0x0070      STR      R0,[R9, #+112]
   1426          
   1427            SDIO->DCTRL = 0x0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x40012c2c
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0x9E08             LDR      R6,[SP, #+32]
   1428          
   1429            if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
   \   00000026   0xF8D9 0x0068      LDR      R0,[R9, #+104]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD102             BNE.N    ??SD_ReadMultiBlocksFIXED_0
   1430              BlockSize = 512;
   \   0000002E   0xF44F 0x7600      MOV      R6,#+512
   \   00000032   0xE002             B.N      ??SD_ReadMultiBlocksFIXED_1
   1431            else
   1432              ReadAddr *= BlockSize; // Convert to Bytes for NON SDHC
   \                     ??SD_ReadMultiBlocksFIXED_0: (+1)
   \   00000034   0xFBA6 0x0104      UMULL    R0,R1,R6,R4
   \   00000038   0x4604             MOV      R4,R0
   1433          
   1434            /*!< Set Block Size for Card */
   1435            SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
   \                     ??SD_ReadMultiBlocksFIXED_1: (+1)
   \   0000003A   0xF8C9 0x6034      STR      R6,[R9, #+52]
   1436            SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1437            SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000044   0x2040             MOVS     R0,#+64
   \   00000046   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1438            SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1439            SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000050   0xF44F 0x6780      MOV      R7,#+1024
   \   00000054   0xF8C9 0x7044      STR      R7,[R9, #+68]
   1440            SDIO_SendCommand(&SDIO_CmdInitStructure);
   \   00000058   0xF109 0x0034      ADD      R0,R9,#+52
   \   0000005C   0x.... 0x....      BL       SDIO_SendCommand
   1441          
   1442            errorstatus = CmdResp1Error(SD_CMD_SET_BLOCKLEN);
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0x.... 0x....      BL       CmdResp1Error
   1443          
   1444            if (SD_OK != errorstatus)
   \   00000066   0x0001             MOVS     R1,R0
   \   00000068   0xD13A             BNE.N    ??SD_ReadMultiBlocksFIXED_2
   1445            {
   1446              return(errorstatus);
   1447            }
   1448          
   1449            SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   0000006A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000006E   0xF8C9 0x001C      STR      R0,[R9, #+28]
   \   00000072   0x9809             LDR      R0,[SP, #+36]
   1450            SDIO_DataInitStructure.SDIO_DataLength = NumberOfBlocks * BlockSize;
   \   00000074   0x4346             MULS     R6,R6,R0
   \   00000076   0xF8C9 0x6020      STR      R6,[R9, #+32]
   1451            SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) 9 << 4;
   \   0000007A   0x2090             MOVS     R0,#+144
   \   0000007C   0xF8C9 0x0024      STR      R0,[R9, #+36]
   1452            SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0xF8C9 0x0028      STR      R0,[R9, #+40]
   1453            SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF8C9 0x002C      STR      R0,[R9, #+44]
   1454            SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF8C9 0x0030      STR      R0,[R9, #+48]
   1455            SDIO_DataConfig(&SDIO_DataInitStructure);
   \   00000092   0xF109 0x001C      ADD      R0,R9,#+28
   \   00000096   0x.... 0x....      BL       SDIO_DataConfig
   1456          
   1457            /*!< Send CMD18 READ_MULT_BLOCK with argument data address */
   1458            SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)ReadAddr;
   \   0000009A   0xF8C9 0x4034      STR      R4,[R9, #+52]
   1459            SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_READ_MULT_BLOCK;
   \   0000009E   0x2012             MOVS     R0,#+18
   \   000000A0   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1460            SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000A4   0x2040             MOVS     R0,#+64
   \   000000A6   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1461            SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1462            SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000B0   0xF8C9 0x7044      STR      R7,[R9, #+68]
   1463            SDIO_SendCommand(&SDIO_CmdInitStructure);
   \   000000B4   0xF109 0x0034      ADD      R0,R9,#+52
   \   000000B8   0x.... 0x....      BL       SDIO_SendCommand
   1464          
   1465            errorstatus = CmdResp1Error(SD_CMD_READ_MULT_BLOCK);
   \   000000BC   0x2012             MOVS     R0,#+18
   \   000000BE   0x.... 0x....      BL       CmdResp1Error
   1466          
   1467            if (errorstatus != SD_OK)
   \   000000C2   0x0001             MOVS     R1,R0
   \   000000C4   0xD10C             BNE.N    ??SD_ReadMultiBlocksFIXED_2
   1468            {
   1469              return(errorstatus);
   1470            }
   1471          
   1472            SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
   \   000000C6   0x2101             MOVS     R1,#+1
   \   000000C8   0xF240 0x302A      MOVW     R0,#+810
   \   000000CC   0x.... 0x....      BL       SDIO_ITConfig
   1473            SDIO_DMACmd(ENABLE);
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x.... 0x....      BL       SDIO_DMACmd
   1474            SD_LowLevel_DMA_RxConfig((uint32_t *)readbuff, (NumberOfBlocks * BlockSize));
   \   000000D6   0x4631             MOV      R1,R6
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x.... 0x....      BL       SD_LowLevel_DMA_RxConfig
   1475          
   1476            return(errorstatus);
   \   000000DE   0x2000             MOVS     R0,#+0
   \                     ??SD_ReadMultiBlocksFIXED_2: (+1)
   \   000000E0   0xE8BD 0x83D6      POP      {R1,R2,R4,R6-R9,PC}  ;; return
   1477          }
   1478          
   1479          /**
   1480           * @brief  This function waits until the SDIO DMA data transfer is finished.
   1481           *         This function should be called after SDIO_ReadMultiBlocks() function
   1482           *         to insure that all data sent by the card are already transferred by
   1483           *         the DMA controller.
   1484           * @param  None.
   1485           * @retval SD_Error: SD Card Error code.
   1486           */

   \                                 In section .text, align 2, keep-with-next
   1487          SD_Error SD_WaitReadOperation (void)
   1488          {
   \                     SD_WaitReadOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1489                  SD_Error errorstatus = SD_OK;
   \   00000002   0x2400             MOVS     R4,#+0
   1490                  volatile uint32_t timeout;
   1491          
   1492                  timeout = SD_DATATIMEOUT;
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable21
   \   0000000E   0xE002             B.N      ??SD_WaitReadOperation_0
   1493          
   1494                  logf("1\r\n");
   1495                  while ((DMAEndOfTransfer == 0x00) && (TransferEnd == 0) && (TransferError == SD_OK) && (timeout > 0)) {
   1496                          timeout--;
   \                     ??SD_WaitReadOperation_1: (+1)
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0x9100             STR      R1,[SP, #+0]
   1497                  }
   \                     ??SD_WaitReadOperation_0: (+1)
   \   00000016   0x6FA9             LDR      R1,[R5, #+120]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD108             BNE.N    ??SD_WaitReadOperation_2
   \   0000001C   0x6F69             LDR      R1,[R5, #+116]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD105             BNE.N    ??SD_WaitReadOperation_2
   \   00000022   0x7E29             LDRB     R1,[R5, #+24]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD102             BNE.N    ??SD_WaitReadOperation_2
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD1F0             BNE.N    ??SD_WaitReadOperation_1
   1498          
   1499                  logf("1.5\r\n");
   1500          
   1501                  DMAEndOfTransfer = 0x00;
   \                     ??SD_WaitReadOperation_2: (+1)
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x67A9             STR      R1,[R5, #+120]
   1502          
   1503                  timeout = SD_DATATIMEOUT;
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0xE002             B.N      ??SD_WaitReadOperation_3
   1504          
   1505                  while (((SDIO ->STA & SDIO_FLAG_RXACT)) && (timeout > 0)) {
   1506                          timeout--;
   \                     ??SD_WaitReadOperation_4: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   1507                  }
   \                     ??SD_WaitReadOperation_3: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x40012c34
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x0480             LSLS     R0,R0,#+18
   \   00000044   0xD502             BPL.N    ??SD_WaitReadOperation_5
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD1F4             BNE.N    ??SD_WaitReadOperation_4
   1508          
   1509                  logf("3\r\n");
   1510          
   1511                  if (StopCondition == 1) {
   \                     ??SD_WaitReadOperation_5: (+1)
   \   0000004C   0x6F28             LDR      R0,[R5, #+112]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD104             BNE.N    ??SD_WaitReadOperation_6
   1512                          errorstatus = SD_StopTransfer ();
   \   00000052   0x.... 0x....      BL       SD_StopTransfer
   \   00000056   0x4604             MOV      R4,R0
   1513                          StopCondition = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6728             STR      R0,[R5, #+112]
   1514                  }
   1515          
   1516                  if ((timeout == 0) && (errorstatus == SD_OK)) {
   \                     ??SD_WaitReadOperation_6: (+1)
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD102             BNE.N    ??SD_WaitReadOperation_7
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xD100             BNE.N    ??SD_WaitReadOperation_7
   1517                          errorstatus = SD_DATA_TIMEOUT;
   \   00000066   0x2404             MOVS     R4,#+4
   1518                  }
   1519          
   1520                  /*!< Clear all the static flags */
   1521                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??SD_WaitReadOperation_7: (+1)
   \   00000068   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000006C   0x.... 0x....      BL       SDIO_ClearFlag
   1522          
   1523                  logf("4\r\n");
   1524          
   1525                  if (TransferError != SD_OK) {
   \   00000070   0x7E28             LDRB     R0,[R5, #+24]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD001             BEQ.N    ??SD_WaitReadOperation_8
   1526                          return (TransferError);
   \   00000076   0x7E28             LDRB     R0,[R5, #+24]
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}
   1527                  }
   1528                  else {
   1529                          return (errorstatus);
   \                     ??SD_WaitReadOperation_8: (+1)
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1530                  }
   1531          }
   1532          
   1533          /**
   1534           * @brief  Allows to write one block starting from a specified address in a card.
   1535           *         The Data transfer can be managed by DMA mode or Polling mode.
   1536           * @note   This operation should be followed by two functions to check if the
   1537           *         DMA Controller and SD Card status.
   1538           *          - SD_ReadWaitOperation(): this function insure that the DMA
   1539           *            controller has finished all data transfer.
   1540           *          - SD_GetStatus(): to check that the SD Card has finished the
   1541           *            data transfer and it is ready for data.
   1542           * @param  writebuff: pointer to the buffer that contain the data to be transferred.
   1543           * @param  WriteAddr: Address from where data are to be read.
   1544           * @param  BlockSize: the SD card Data block size. The Block size should be 512.
   1545           * @retval SD_Error: SD Card Error code.
   1546           */

   \                                 In section .text, align 2, keep-with-next
   1547          SD_Error SD_WriteBlock (uint8_t *writebuff, uint64_t WriteAddr, uint16_t BlockSize)
   1548          {
   \                     SD_WriteBlock: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
   1549                  SD_Error errorstatus = SD_OK;
   1550          
   1551          #if defined (SD_POLLING_MODE)
   1552                  uint32_t bytestransferred = 0, count = 0, restwords = 0;
   1553                  uint32_t *tempbuff = (uint32_t *)writebuff;
   1554          #endif
   1555          
   1556                  TransferError = SD_OK;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable21
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF888 0x0018      STRB     R0,[R8, #+24]
   1557                  TransferEnd = 0;
   \   00000014   0xF8C8 0x0074      STR      R0,[R8, #+116]
   1558                  StopCondition = 0;
   \   00000018   0xF8C8 0x0070      STR      R0,[R8, #+112]
   1559          
   1560                  SDIO ->DCTRL = 0x0;
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x40012c2c
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1561          
   1562          #if defined (SD_DMA_MODE)
   1563                  SDIO_ITConfig (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF240 0x302A      MOVW     R0,#+810
   \   00000028   0x.... 0x....      BL       SDIO_ITConfig
   \   0000002C   0x9E06             LDR      R6,[SP, #+24]
   1564                  SD_LowLevel_DMA_TxConfig ((uint32_t *) writebuff, BlockSize);
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       SD_LowLevel_DMA_TxConfig
   1565                  SDIO_DMACmd (ENABLE);
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       SDIO_DMACmd
   1566          #endif
   1567          
   1568                  if (CardType == SDIO_HIGH_CAPACITY_SD_CARD ) {
   \   0000003C   0xF8D8 0x0068      LDR      R0,[R8, #+104]
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xD104             BNE.N    ??SD_WriteBlock_0
   1569                          BlockSize = 512;
   \   00000044   0xF44F 0x7600      MOV      R6,#+512
   1570                          WriteAddr /= 512;
   \   00000048   0x0A64             LSRS     R4,R4,#+9
   \   0000004A   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1571                  }
   1572          
   1573                  /* Set Block Size for Card */
   1574                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
   \                     ??SD_WriteBlock_0: (+1)
   \   0000004E   0xF8C8 0x6034      STR      R6,[R8, #+52]
   1575                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   00000052   0x2010             MOVS     R0,#+16
   \   00000054   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1576                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000058   0x2040             MOVS     R0,#+64
   \   0000005A   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1577                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1578                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000064   0xF44F 0x6780      MOV      R7,#+1024
   \   00000068   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1579                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000006C   0xF108 0x0034      ADD      R0,R8,#+52
   \   00000070   0x.... 0x....      BL       SDIO_SendCommand
   1580          
   1581                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   00000074   0x2010             MOVS     R0,#+16
   \   00000076   0x.... 0x....      BL       CmdResp1Error
   1582          
   1583                  if (SD_OK != errorstatus) {
   \   0000007A   0x0001             MOVS     R1,R0
   \   0000007C   0xD12B             BNE.N    ??SD_WriteBlock_1
   1584                          return (errorstatus);
   1585                  }
   1586          
   1587                  /*!< Send CMD24 WRITE_SINGLE_BLOCK */
   1588                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) WriteAddr;
   \   0000007E   0xF8C8 0x4034      STR      R4,[R8, #+52]
   1589                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
   \   00000082   0x2018             MOVS     R0,#+24
   \   00000084   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1590                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000088   0x2040             MOVS     R0,#+64
   \   0000008A   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1591                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1592                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000094   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1593                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000098   0xF108 0x0034      ADD      R0,R8,#+52
   \   0000009C   0x.... 0x....      BL       SDIO_SendCommand
   1594          
   1595                  errorstatus = CmdResp1Error (SD_CMD_WRITE_SINGLE_BLOCK );
   \   000000A0   0x2018             MOVS     R0,#+24
   \   000000A2   0x.... 0x....      BL       CmdResp1Error
   1596          
   1597                  if (errorstatus != SD_OK) {
   \   000000A6   0x0001             MOVS     R1,R0
   \   000000A8   0xD115             BNE.N    ??SD_WriteBlock_1
   1598                          return (errorstatus);
   1599                  }
   1600          
   1601                  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   000000AA   0xF04F 0x30FF      MOV      R0,#-1
   \   000000AE   0xF8C8 0x001C      STR      R0,[R8, #+28]
   1602                  SDIO_DataInitStructure.SDIO_DataLength = BlockSize;
   \   000000B2   0xF8C8 0x6020      STR      R6,[R8, #+32]
   1603                  SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) 9 << 4;
   \   000000B6   0x2090             MOVS     R0,#+144
   \   000000B8   0xF8C8 0x0024      STR      R0,[R8, #+36]
   1604                  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF8C8 0x0028      STR      R0,[R8, #+40]
   1605                  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   000000C2   0xF8C8 0x002C      STR      R0,[R8, #+44]
   1606                  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF8C8 0x0030      STR      R0,[R8, #+48]
   1607                  SDIO_DataConfig (&SDIO_DataInitStructure);
   \   000000CC   0xF108 0x001C      ADD      R0,R8,#+28
   \   000000D0   0x.... 0x....      BL       SDIO_DataConfig
   1608          
   1609                  /*!< In case of single data block transfer no need of stop command at all */
   1610          #if defined (SD_POLLING_MODE) 
   1611                  while (!(SDIO->STA & (SDIO_FLAG_DBCKEND | SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_STBITERR)))
   1612                  {
   1613                          if (SDIO_GetFlagStatus(SDIO_FLAG_TXFIFOHE) != RESET)
   1614                          {
   1615                                  if ((512 - bytestransferred) < 32)
   1616                                  {
   1617                                          restwords = ((512 - bytestransferred) % 4 == 0) ? ((512 - bytestransferred) / 4) : (( 512 - bytestransferred) / 4 + 1);
   1618                                          for (count = 0; count < restwords; count++, tempbuff++, bytestransferred += 4)
   1619                                          {
   1620                                                  SDIO_WriteData(*tempbuff);
   1621                                          }
   1622                                  }
   1623                                  else
   1624                                  {
   1625                                          for (count = 0; count < 8; count++)
   1626                                          {
   1627                                                  SDIO_WriteData(*(tempbuff + count));
   1628                                          }
   1629                                          tempbuff += 8;
   1630                                          bytestransferred += 32;
   1631                                  }
   1632                          }
   1633                  }
   1634                  if (SDIO_GetFlagStatus(SDIO_FLAG_DTIMEOUT) != RESET)
   1635                  {
   1636                          SDIO_ClearFlag(SDIO_FLAG_DTIMEOUT);
   1637                          errorstatus = SD_DATA_TIMEOUT;
   1638                          return(errorstatus);
   1639                  }
   1640                  else if (SDIO_GetFlagStatus(SDIO_FLAG_DCRCFAIL) != RESET)
   1641                  {
   1642                          SDIO_ClearFlag(SDIO_FLAG_DCRCFAIL);
   1643                          errorstatus = SD_DATA_CRC_FAIL;
   1644                          return(errorstatus);
   1645                  }
   1646                  else if (SDIO_GetFlagStatus(SDIO_FLAG_TXUNDERR) != RESET)
   1647                  {
   1648                          SDIO_ClearFlag(SDIO_FLAG_TXUNDERR);
   1649                          errorstatus = SD_TX_UNDERRUN;
   1650                          return(errorstatus);
   1651                  }
   1652                  else if (SDIO_GetFlagStatus(SDIO_FLAG_STBITERR) != RESET)
   1653                  {
   1654                          SDIO_ClearFlag(SDIO_FLAG_STBITERR);
   1655                          errorstatus = SD_START_BIT_ERR;
   1656                          return(errorstatus);
   1657                  }
   1658          
   1659          #endif
   1660          
   1661                  return (errorstatus);
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??SD_WriteBlock_1: (+1)
   \   000000D6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1662          }
   1663          
   1664          /**
   1665           * @brief  Allows to write blocks starting from a specified address in a card.
   1666           *         The Data transfer can be managed by DMA mode only.
   1667           * @note   This operation should be followed by two functions to check if the
   1668           *         DMA Controller and SD Card status.
   1669           *          - SD_ReadWaitOperation(): this function insure that the DMA
   1670           *            controller has finished all data transfer.
   1671           *          - SD_GetStatus(): to check that the SD Card has finished the
   1672           *            data transfer and it is ready for data.
   1673           * @param  WriteAddr: Address from where data are to be read.
   1674           * @param  writebuff: pointer to the buffer that contain the data to be transferred.
   1675           * @param  BlockSize: the SD card Data block size. The Block size should be 512.
   1676           * @param  NumberOfBlocks: number of blocks to be written.
   1677           * @retval SD_Error: SD Card Error code.
   1678           */

   \                                 In section .text, align 2, keep-with-next
   1679          SD_Error SD_WriteMultiBlocks (uint8_t *writebuff, uint64_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
   1680          {
   \                     SD_WriteMultiBlocks: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
   1681                  SD_Error errorstatus = SD_OK;
   1682          
   1683                  TransferError = SD_OK;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable21
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF888 0x0018      STRB     R0,[R8, #+24]
   1684                  TransferEnd = 0;
   \   00000014   0xF8C8 0x0074      STR      R0,[R8, #+116]
   1685                  StopCondition = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF8C8 0x0070      STR      R0,[R8, #+112]
   1686                  SDIO ->DCTRL = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x40012c2c
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1687          
   1688          #if defined (SD_DMA_MODE)
   1689                  SDIO_ITConfig (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF240 0x301A      MOVW     R0,#+794
   \   0000002C   0x.... 0x....      BL       SDIO_ITConfig
   \   00000030   0x9E08             LDR      R6,[SP, #+32]
   \   00000032   0xF8DD 0x9024      LDR      R9,[SP, #+36]
   1690                  SD_LowLevel_DMA_TxConfig ((uint32_t *) writebuff, (NumberOfBlocks * BlockSize));
   \   00000036   0xFB06 0xF109      MUL      R1,R6,R9
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       SD_LowLevel_DMA_TxConfig
   1691                  SDIO_DMACmd (ENABLE);
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       SDIO_DMACmd
   1692          #endif
   1693          
   1694                  if (CardType == SDIO_HIGH_CAPACITY_SD_CARD ) {
   \   00000046   0xF8D8 0x0068      LDR      R0,[R8, #+104]
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD104             BNE.N    ??SD_WriteMultiBlocks_0
   1695                          BlockSize = 512;
   \   0000004E   0xF44F 0x7600      MOV      R6,#+512
   1696                          WriteAddr /= 512;
   \   00000052   0x0A64             LSRS     R4,R4,#+9
   \   00000054   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1697                  }
   1698          
   1699                  /* Set Block Size for Card */
   1700                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
   \                     ??SD_WriteMultiBlocks_0: (+1)
   \   00000058   0xF8C8 0x6034      STR      R6,[R8, #+52]
   1701                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1702                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000062   0x2040             MOVS     R0,#+64
   \   00000064   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1703                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1704                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   0000006E   0xF44F 0x6780      MOV      R7,#+1024
   \   00000072   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1705                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000076   0xF108 0x0034      ADD      R0,R8,#+52
   \   0000007A   0x.... 0x....      BL       SDIO_SendCommand
   1706          
   1707                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   0000007E   0x2010             MOVS     R0,#+16
   \   00000080   0x.... 0x....      BL       CmdResp1Error
   1708          
   1709                  if (SD_OK != errorstatus) {
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0xD15C             BNE.N    ??SD_WriteMultiBlocks_1
   1710                          return (errorstatus);
   1711                  }
   1712          
   1713                  /*!< To improve performance */
   1714                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (RCA << 16);
   \   00000088   0xF8D8 0x006C      LDR      R0,[R8, #+108]
   \   0000008C   0x0400             LSLS     R0,R0,#+16
   \   0000008E   0xF8C8 0x0034      STR      R0,[R8, #+52]
   1715                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   00000092   0x2037             MOVS     R0,#+55
   \   00000094   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1716                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000098   0x2040             MOVS     R0,#+64
   \   0000009A   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1717                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1718                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000A4   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1719                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000A8   0xF108 0x0034      ADD      R0,R8,#+52
   \   000000AC   0x.... 0x....      BL       SDIO_SendCommand
   1720          
   1721                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   000000B0   0x2037             MOVS     R0,#+55
   \   000000B2   0x.... 0x....      BL       CmdResp1Error
   1722          
   1723                  if (errorstatus != SD_OK) {
   \   000000B6   0x0001             MOVS     R1,R0
   \   000000B8   0xD143             BNE.N    ??SD_WriteMultiBlocks_1
   1724                          return (errorstatus);
   1725                  }
   1726                  /*!< To improve performance */
   1727                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) NumberOfBlocks;
   \   000000BA   0xF8C8 0x9034      STR      R9,[R8, #+52]
   1728                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCK_COUNT;
   \   000000BE   0x2017             MOVS     R0,#+23
   \   000000C0   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1729                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000C4   0x2040             MOVS     R0,#+64
   \   000000C6   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1730                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1731                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000D0   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1732                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000D4   0xF108 0x0034      ADD      R0,R8,#+52
   \   000000D8   0x.... 0x....      BL       SDIO_SendCommand
   1733          
   1734                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCK_COUNT );
   \   000000DC   0x2017             MOVS     R0,#+23
   \   000000DE   0x.... 0x....      BL       CmdResp1Error
   1735          
   1736                  if (errorstatus != SD_OK) {
   \   000000E2   0x0001             MOVS     R1,R0
   \   000000E4   0xD12D             BNE.N    ??SD_WriteMultiBlocks_1
   1737                          return (errorstatus);
   1738                  }
   1739          
   1740                  /*!< Send CMD25 WRITE_MULT_BLOCK with argument data address */
   1741                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) WriteAddr;
   \   000000E6   0xF8C8 0x4034      STR      R4,[R8, #+52]
   1742                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
   \   000000EA   0x2019             MOVS     R0,#+25
   \   000000EC   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1743                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000F0   0x2040             MOVS     R0,#+64
   \   000000F2   0xF8C8 0x003C      STR      R0,[R8, #+60]
   1744                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1745                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000FC   0xF8C8 0x7044      STR      R7,[R8, #+68]
   1746                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000100   0xF108 0x0034      ADD      R0,R8,#+52
   \   00000104   0x.... 0x....      BL       SDIO_SendCommand
   1747          
   1748                  errorstatus = CmdResp1Error (SD_CMD_WRITE_MULT_BLOCK );
   \   00000108   0x2019             MOVS     R0,#+25
   \   0000010A   0x.... 0x....      BL       CmdResp1Error
   1749          
   1750                  if (SD_OK != errorstatus) {
   \   0000010E   0x0001             MOVS     R1,R0
   \   00000110   0xD117             BNE.N    ??SD_WriteMultiBlocks_1
   1751                          return (errorstatus);
   1752                  }
   1753          
   1754                  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   00000112   0xF04F 0x30FF      MOV      R0,#-1
   \   00000116   0xF8C8 0x001C      STR      R0,[R8, #+28]
   1755                  SDIO_DataInitStructure.SDIO_DataLength = NumberOfBlocks * BlockSize;
   \   0000011A   0xFB06 0xF009      MUL      R0,R6,R9
   \   0000011E   0xF8C8 0x0020      STR      R0,[R8, #+32]
   1756                  SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) 9 << 4;
   \   00000122   0x2090             MOVS     R0,#+144
   \   00000124   0xF8C8 0x0024      STR      R0,[R8, #+36]
   1757                  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF8C8 0x0028      STR      R0,[R8, #+40]
   1758                  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   0000012E   0xF8C8 0x002C      STR      R0,[R8, #+44]
   1759                  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0xF8C8 0x0030      STR      R0,[R8, #+48]
   1760                  SDIO_DataConfig (&SDIO_DataInitStructure);
   \   00000138   0xF108 0x001C      ADD      R0,R8,#+28
   \   0000013C   0x.... 0x....      BL       SDIO_DataConfig
   1761          
   1762                  return (errorstatus);
   \   00000140   0x2000             MOVS     R0,#+0
   \                     ??SD_WriteMultiBlocks_1: (+1)
   \   00000142   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1763          }
   1764          
   1765          /**
   1766           * @brief  Allows to write blocks starting from a specified address in a card.
   1767           *         The Data transfer can be managed by DMA mode only.
   1768           * @note   This operation should be followed by two functions to check if the
   1769           *         DMA Controller and SD Card status.
   1770           *          - SD_ReadWaitOperation(): this function insure that the DMA
   1771           *            controller has finished all data transfer.
   1772           *          - SD_GetStatus(): to check that the SD Card has finished the
   1773           *            data transfer and it is ready for data.
   1774           * @param  WriteAddr: Address from where data are to be read.
   1775           * @param  writebuff: pointer to the buffer that contain the data to be transferred.
   1776           * @param  BlockSize: the SD card Data block size. The Block size should be 512.
   1777           * @param  NumberOfBlocks: number of blocks to be written.
   1778           * @retval SD_Error: SD Card Error code.
   1779           */

   \                                 In section .text, align 2, keep-with-next
   1780          SD_Error SD_WriteMultiBlocksFIXED (uint8_t *writebuff, uint64_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
   1781          {
   \                     SD_WriteMultiBlocksFIXED: (+1)
   \   00000000   0xE92D 0x47D8      PUSH     {R3,R4,R6-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4614             MOV      R4,R2
   1782            SD_Error errorstatus = SD_OK;
   1783          
   1784            TransferError = SD_OK;
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable21
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF889 0x0018      STRB     R0,[R9, #+24]
   1785            TransferEnd = 0;
   \   00000012   0xF8C9 0x0074      STR      R0,[R9, #+116]
   1786            StopCondition = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF8C9 0x0070      STR      R0,[R9, #+112]
   1787          
   1788            SDIO->DCTRL = 0x0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x40012c2c
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0x9E08             LDR      R6,[SP, #+32]
   1789          
   1790            if (CardType == SDIO_HIGH_CAPACITY_SD_CARD)
   \   00000026   0xF8D9 0x0068      LDR      R0,[R9, #+104]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD102             BNE.N    ??SD_WriteMultiBlocksFIXED_0
   1791              BlockSize = 512;
   \   0000002E   0xF44F 0x7600      MOV      R6,#+512
   \   00000032   0xE002             B.N      ??SD_WriteMultiBlocksFIXED_1
   1792            else
   1793              WriteAddr *= BlockSize; // Convert to Bytes for NON SDHC
   \                     ??SD_WriteMultiBlocksFIXED_0: (+1)
   \   00000034   0xFBA6 0x0104      UMULL    R0,R1,R6,R4
   \   00000038   0x4604             MOV      R4,R0
   1794          
   1795            /* Set Block Size for Card */
   1796            SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) BlockSize;
   \                     ??SD_WriteMultiBlocksFIXED_1: (+1)
   \   0000003A   0xF8C9 0x6034      STR      R6,[R9, #+52]
   1797            SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1798            SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000044   0x2040             MOVS     R0,#+64
   \   00000046   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1799            SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1800            SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000050   0xF44F 0x6780      MOV      R7,#+1024
   \   00000054   0xF8C9 0x7044      STR      R7,[R9, #+68]
   1801            SDIO_SendCommand(&SDIO_CmdInitStructure);
   \   00000058   0xF109 0x0034      ADD      R0,R9,#+52
   \   0000005C   0x.... 0x....      BL       SDIO_SendCommand
   1802          
   1803            errorstatus = CmdResp1Error(SD_CMD_SET_BLOCKLEN);
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0x.... 0x....      BL       CmdResp1Error
   1804          
   1805            if (SD_OK != errorstatus)
   \   00000066   0x0001             MOVS     R1,R0
   \   00000068   0xD16A             BNE.N    ??SD_WriteMultiBlocksFIXED_2
   1806            {
   1807              return(errorstatus);
   1808            }
   1809          
   1810            /*!< To improve performance */
   1811            SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) (RCA << 16);
   \   0000006A   0xF8D9 0x006C      LDR      R0,[R9, #+108]
   \   0000006E   0x0400             LSLS     R0,R0,#+16
   \   00000070   0xF8C9 0x0034      STR      R0,[R9, #+52]
   1812            SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   00000074   0x2037             MOVS     R0,#+55
   \   00000076   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1813            SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000007A   0x2040             MOVS     R0,#+64
   \   0000007C   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1814            SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1815            SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000086   0xF8C9 0x7044      STR      R7,[R9, #+68]
   1816            SDIO_SendCommand(&SDIO_CmdInitStructure);
   \   0000008A   0xF109 0x0034      ADD      R0,R9,#+52
   \   0000008E   0x.... 0x....      BL       SDIO_SendCommand
   1817          
   1818          
   1819            errorstatus = CmdResp1Error(SD_CMD_APP_CMD);
   \   00000092   0x2037             MOVS     R0,#+55
   \   00000094   0x.... 0x....      BL       CmdResp1Error
   1820          
   1821            if (errorstatus != SD_OK)
   \   00000098   0x0001             MOVS     R1,R0
   \   0000009A   0xD151             BNE.N    ??SD_WriteMultiBlocksFIXED_2
   \   0000009C   0xF8DD 0xA024      LDR      R10,[SP, #+36]
   1822            {
   1823              return(errorstatus);
   1824            }
   1825            /*!< To improve performance */
   1826            SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)NumberOfBlocks;
   \   000000A0   0xF8C9 0xA034      STR      R10,[R9, #+52]
   1827            SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCK_COUNT;
   \   000000A4   0x2017             MOVS     R0,#+23
   \   000000A6   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1828            SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000AA   0x2040             MOVS     R0,#+64
   \   000000AC   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1829            SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1830            SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000B6   0xF8C9 0x7044      STR      R7,[R9, #+68]
   1831            SDIO_SendCommand(&SDIO_CmdInitStructure);
   \   000000BA   0xF109 0x0034      ADD      R0,R9,#+52
   \   000000BE   0x.... 0x....      BL       SDIO_SendCommand
   1832          
   1833            errorstatus = CmdResp1Error(SD_CMD_SET_BLOCK_COUNT);
   \   000000C2   0x2017             MOVS     R0,#+23
   \   000000C4   0x.... 0x....      BL       CmdResp1Error
   1834          
   1835            if (errorstatus != SD_OK)
   \   000000C8   0x0001             MOVS     R1,R0
   \   000000CA   0xD139             BNE.N    ??SD_WriteMultiBlocksFIXED_2
   1836            {
   1837              return(errorstatus);
   1838            }
   1839          
   1840          
   1841            /*!< Send CMD25 WRITE_MULT_BLOCK with argument data address */
   1842            SDIO_CmdInitStructure.SDIO_Argument = (uint32_t)WriteAddr;
   \   000000CC   0xF8C9 0x4034      STR      R4,[R9, #+52]
   1843            SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
   \   000000D0   0x2019             MOVS     R0,#+25
   \   000000D2   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1844            SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000D6   0x2040             MOVS     R0,#+64
   \   000000D8   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1845            SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1846            SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000E2   0xF8C9 0x7044      STR      R7,[R9, #+68]
   1847            SDIO_SendCommand(&SDIO_CmdInitStructure);
   \   000000E6   0xF109 0x0034      ADD      R0,R9,#+52
   \   000000EA   0x.... 0x....      BL       SDIO_SendCommand
   1848          
   1849            errorstatus = CmdResp1Error(SD_CMD_WRITE_MULT_BLOCK);
   \   000000EE   0x2019             MOVS     R0,#+25
   \   000000F0   0x.... 0x....      BL       CmdResp1Error
   1850          
   1851            if (SD_OK != errorstatus)
   \   000000F4   0x0001             MOVS     R1,R0
   \   000000F6   0xD123             BNE.N    ??SD_WriteMultiBlocksFIXED_2
   1852            {
   1853              return(errorstatus);
   1854            }
   1855          
   1856            SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   000000F8   0xF04F 0x30FF      MOV      R0,#-1
   \   000000FC   0xF8C9 0x001C      STR      R0,[R9, #+28]
   1857            SDIO_DataInitStructure.SDIO_DataLength = NumberOfBlocks * BlockSize;
   \   00000100   0xFB06 0xF40A      MUL      R4,R6,R10
   \   00000104   0xF8C9 0x4020      STR      R4,[R9, #+32]
   1858            SDIO_DataInitStructure.SDIO_DataBlockSize = (uint32_t) 9 << 4;
   \   00000108   0x2090             MOVS     R0,#+144
   \   0000010A   0xF8C9 0x0024      STR      R0,[R9, #+36]
   1859            SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF8C9 0x0028      STR      R0,[R9, #+40]
   1860            SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   00000114   0xF8C9 0x002C      STR      R0,[R9, #+44]
   1861            SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0xF8C9 0x0030      STR      R0,[R9, #+48]
   1862            SDIO_DataConfig(&SDIO_DataInitStructure);
   \   0000011E   0xF109 0x001C      ADD      R0,R9,#+28
   \   00000122   0x.... 0x....      BL       SDIO_DataConfig
   1863          
   1864            SDIO_ITConfig(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, ENABLE);
   \   00000126   0x2101             MOVS     R1,#+1
   \   00000128   0xF240 0x302A      MOVW     R0,#+810
   \   0000012C   0x.... 0x....      BL       SDIO_ITConfig
   1865            SDIO_DMACmd(ENABLE);
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0x.... 0x....      BL       SDIO_DMACmd
   1866            SD_LowLevel_DMA_TxConfig((uint32_t *)writebuff, (NumberOfBlocks * BlockSize));
   \   00000136   0x4621             MOV      R1,R4
   \   00000138   0x4640             MOV      R0,R8
   \   0000013A   0x.... 0x....      BL       SD_LowLevel_DMA_TxConfig
   1867          
   1868            return(errorstatus);
   \   0000013E   0x2000             MOVS     R0,#+0
   \                     ??SD_WriteMultiBlocksFIXED_2: (+1)
   \   00000140   0xE8BD 0x87D2      POP      {R1,R4,R6-R10,PC}  ;; return
   1869          }
   1870          
   1871          /**
   1872           * @brief  This function waits until the SDIO DMA data transfer is finished.
   1873           *         This function should be called after SDIO_WriteBlock() and
   1874           *         SDIO_WriteMultiBlocks() function to insure that all data sent by the
   1875           *         card are already transferred by the DMA controller.
   1876           * @param  None.
   1877           * @retval SD_Error: SD Card Error code.
   1878           */

   \                                 In section .text, align 2, keep-with-next
   1879          SD_Error SD_WaitWriteOperation (void)
   1880          {
   \                     SD_WaitWriteOperation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1881                  SD_Error errorstatus = SD_OK;
   \   00000002   0x2400             MOVS     R4,#+0
   1882                  uint32_t timeout;
   1883          
   1884                  timeout = SD_DATATIMEOUT;
   \   00000004   0xF04F 0x36FF      MOV      R6,#-1
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x....             LDR.N    R5,??DataTable24_1
   \   0000000C   0xE000             B.N      ??SD_WaitWriteOperation_0
   1885          
   1886                  while ((DMAEndOfTransfer == 0x00) && (TransferEnd == 0) && (TransferError == SD_OK) && (timeout > 0)) {
   1887                          timeout--;
   \                     ??SD_WaitWriteOperation_1: (+1)
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   1888                  }
   \                     ??SD_WaitWriteOperation_0: (+1)
   \   00000010   0x6FA9             LDR      R1,[R5, #+120]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD107             BNE.N    ??SD_WaitWriteOperation_2
   \   00000016   0x6F69             LDR      R1,[R5, #+116]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD104             BNE.N    ??SD_WaitWriteOperation_2
   \   0000001C   0x7E29             LDRB     R1,[R5, #+24]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD101             BNE.N    ??SD_WaitWriteOperation_2
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F3             BNE.N    ??SD_WaitWriteOperation_1
   1889          
   1890                  DMAEndOfTransfer = 0x00;
   \                     ??SD_WaitWriteOperation_2: (+1)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x67A8             STR      R0,[R5, #+120]
   1891          
   1892                  timeout = SD_DATATIMEOUT;
   \   0000002A   0xE000             B.N      ??SD_WaitWriteOperation_3
   1893          
   1894                  while (((SDIO ->STA & SDIO_FLAG_TXACT)) && (timeout > 0)) {
   1895                          timeout--;
   \                     ??SD_WaitWriteOperation_4: (+1)
   \   0000002C   0x1E76             SUBS     R6,R6,#+1
   1896                  }
   \                     ??SD_WaitWriteOperation_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x40012c34
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x04C0             LSLS     R0,R0,#+19
   \   00000036   0xD501             BPL.N    ??SD_WaitWriteOperation_5
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD1F7             BNE.N    ??SD_WaitWriteOperation_4
   1897          
   1898                  if (StopCondition == 1) {
   \                     ??SD_WaitWriteOperation_5: (+1)
   \   0000003C   0x6F28             LDR      R0,[R5, #+112]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD104             BNE.N    ??SD_WaitWriteOperation_6
   1899                          errorstatus = SD_StopTransfer ();
   \   00000042   0x.... 0x....      BL       SD_StopTransfer
   \   00000046   0x4604             MOV      R4,R0
   1900                          StopCondition = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6728             STR      R0,[R5, #+112]
   1901                  }
   1902          
   1903                  if ((timeout == 0) && (errorstatus == SD_OK)) {
   \                     ??SD_WaitWriteOperation_6: (+1)
   \   0000004C   0x2E00             CMP      R6,#+0
   \   0000004E   0xD102             BNE.N    ??SD_WaitWriteOperation_7
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xD100             BNE.N    ??SD_WaitWriteOperation_7
   1904                          errorstatus = SD_DATA_TIMEOUT;
   \   00000054   0x2404             MOVS     R4,#+4
   1905                  }
   1906          
   1907                  /*!< Clear all the static flags */
   1908                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??SD_WaitWriteOperation_7: (+1)
   \   00000056   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000005A   0x.... 0x....      BL       SDIO_ClearFlag
   1909          
   1910                  if (TransferError != SD_OK) {
   \   0000005E   0x7E28             LDRB     R0,[R5, #+24]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD001             BEQ.N    ??SD_WaitWriteOperation_8
   1911                          return (TransferError);
   \   00000064   0x7E28             LDRB     R0,[R5, #+24]
   \   00000066   0xBD70             POP      {R4-R6,PC}
   1912                  }
   1913                  else {
   1914                          return (errorstatus);
   \                     ??SD_WaitWriteOperation_8: (+1)
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   1915                  }
   1916          }
   1917          
   1918          /**
   1919           * @brief  Gets the cuurent data transfer state.
   1920           * @param  None
   1921           * @retval SDTransferState: Data Transfer state.
   1922           *   This value can be:
   1923           *        - SD_TRANSFER_OK: No data transfer is acting
   1924           *        - SD_TRANSFER_BUSY: Data transfer is acting
   1925           */

   \                                 In section .text, align 2, keep-with-next
   1926          SDTransferState SD_GetTransferState (void)
   1927          {
   1928                  if (SDIO ->STA & (SDIO_FLAG_TXACT | SDIO_FLAG_RXACT)) {
   \                     SD_GetTransferState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x40012c34
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF400 0x5040      AND      R0,R0,#0x3000
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
   1929                          return (SD_TRANSFER_BUSY);
   1930                  }
   1931                  else {
   1932                          return (SD_TRANSFER_OK);
   \   00000012   0x4770             BX       LR               ;; return
   1933                  }
   1934          }
   1935          
   1936          /**
   1937           * @brief  Aborts an ongoing data transfer.
   1938           * @param  None
   1939           * @retval SD_Error: SD Card Error code.
   1940           */

   \                                 In section .text, align 2, keep-with-next
   1941          SD_Error SD_StopTransfer (void)
   1942          {
   \                     SD_StopTransfer: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1943                  SD_Error errorstatus = SD_OK;
   1944          
   1945                  /*!< Send CMD12 STOP_TRANSMISSION  */
   1946                  SDIO_CmdInitStructure.SDIO_Argument = 0x0;
   \   00000002   0x....             LDR.N    R0,??DataTable24_1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6341             STR      R1,[R0, #+52]
   1947                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_STOP_TRANSMISSION;
   \   00000008   0x210C             MOVS     R1,#+12
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   1948                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000000C   0x2140             MOVS     R1,#+64
   \   0000000E   0x63C1             STR      R1,[R0, #+60]
   1949                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6401             STR      R1,[R0, #+64]
   1950                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000014   0xF44F 0x6180      MOV      R1,#+1024
   \   00000018   0x6441             STR      R1,[R0, #+68]
   1951                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000001A   0x3034             ADDS     R0,R0,#+52
   \   0000001C   0x.... 0x....      BL       SDIO_SendCommand
   1952          
   1953                  errorstatus = CmdResp1Error (SD_CMD_STOP_TRANSMISSION );
   1954          
   1955                  return (errorstatus);
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0xE8BD 0x4002      POP      {R1,LR}
   \   00000026   0x....             B.N      CmdResp1Error
   1956          }
   1957          
   1958          /**
   1959           * @brief  Allows to erase memory area specified for the given card.
   1960           * @param  startaddr: the start address.
   1961           * @param  endaddr: the end address.
   1962           * @retval SD_Error: SD Card Error code.
   1963           */

   \                                 In section .text, align 2, keep-with-next
   1964          SD_Error SD_Erase (uint64_t startaddr, uint64_t endaddr)
   1965          {
   \                     SD_Erase: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   1966                  SD_Error errorstatus = SD_OK;
   1967                  uint32_t delay = 0;
   \   0000000E   0xF04F 0x0800      MOV      R8,#+0
   1968                  __IO uint32_t maxdelay = 0;
   \   00000012   0x4640             MOV      R0,R8
   \   00000014   0x9001             STR      R0,[SP, #+4]
   1969                  uint8_t cardstate = 0;
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1970          
   1971                  /*!< Check if the card coomnd class supports erase command */
   1972                  if (((CSD_Tab[1] >> 20) & SD_CCCC_ERASE )== 0){
   \   0000001A   0x.... 0x....      LDR.W    R9,??DataTable41
   \   0000001E   0xF8D9 0x004C      LDR      R0,[R9, #+76]
   \   00000022   0x0D00             LSRS     R0,R0,#+20
   \   00000024   0x0680             LSLS     R0,R0,#+26
   \   00000026   0xD401             BMI.N    ??SD_Erase_0
   1973                          errorstatus = SD_REQUEST_NOT_APPLICABLE;
   1974                          return (errorstatus);
   \   00000028   0x2025             MOVS     R0,#+37
   \   0000002A   0xE084             B.N      ??SD_Erase_1
   1975                  }
   1976          
   1977                  maxdelay = 120000 / ((SDIO ->CLKCR & 0xFF) + 2);
   \                     ??SD_Erase_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable41_1  ;; 0x1d4c0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable42  ;; 0x40012c04
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0xF001 0x01FF      AND      R1,R1,#0xFF
   \   0000003A   0x1C89             ADDS     R1,R1,#+2
   \   0000003C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000040   0x9001             STR      R0,[SP, #+4]
   1978          
   1979                  if (SDIO_GetResponse (SDIO_RESP1) & SD_CARD_LOCKED ) {
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x.... 0x....      BL       SDIO_GetResponse
   \   00000048   0x0180             LSLS     R0,R0,#+6
   \   0000004A   0xD501             BPL.N    ??SD_Erase_2
   1980                          errorstatus = SD_LOCK_UNLOCK_FAILED;
   1981                          return (errorstatus);
   \   0000004C   0x200E             MOVS     R0,#+14
   \   0000004E   0xE072             B.N      ??SD_Erase_1
   1982                  }
   1983          
   1984                  if (CardType == SDIO_HIGH_CAPACITY_SD_CARD ) {
   \                     ??SD_Erase_2: (+1)
   \   00000050   0xF8D9 0x0068      LDR      R0,[R9, #+104]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD105             BNE.N    ??SD_Erase_3
   1985                          startaddr /= 512;
   \   00000058   0x0A64             LSRS     R4,R4,#+9
   \   0000005A   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1986                          endaddr /= 512;
   \   0000005E   0x0A76             LSRS     R6,R6,#+9
   \   00000060   0xEA46 0x56C7      ORR      R6,R6,R7, LSL #+23
   1987                  }
   1988          
   1989                  /*!< According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
   1990                  if ((SDIO_STD_CAPACITY_SD_CARD_V1_1 == CardType) || (SDIO_STD_CAPACITY_SD_CARD_V2_0 == CardType) || (SDIO_HIGH_CAPACITY_SD_CARD == CardType)) {
   \                     ??SD_Erase_3: (+1)
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD003             BEQ.N    ??SD_Erase_4
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD001             BEQ.N    ??SD_Erase_4
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD12D             BNE.N    ??SD_Erase_5
   1991                          /*!< Send CMD32 SD_ERASE_GRP_START with argument as addr  */
   1992                          SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) startaddr;
   \                     ??SD_Erase_4: (+1)
   \   00000070   0xF8C9 0x4034      STR      R4,[R9, #+52]
   1993                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SD_ERASE_GRP_START;
   \   00000074   0x2020             MOVS     R0,#+32
   \   00000076   0xF8C9 0x0038      STR      R0,[R9, #+56]
   1994                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000007A   0x2040             MOVS     R0,#+64
   \   0000007C   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1995                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000080   0x4640             MOV      R0,R8
   \   00000082   0xF8C9 0x0040      STR      R0,[R9, #+64]
   1996                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000086   0xF44F 0x6480      MOV      R4,#+1024
   \   0000008A   0xF8C9 0x4044      STR      R4,[R9, #+68]
   1997                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000008E   0xF109 0x0034      ADD      R0,R9,#+52
   \   00000092   0x.... 0x....      BL       SDIO_SendCommand
   1998          
   1999                          errorstatus = CmdResp1Error (SD_CMD_SD_ERASE_GRP_START );
   \   00000096   0x2020             MOVS     R0,#+32
   \   00000098   0x.... 0x....      BL       CmdResp1Error
   2000                          if (errorstatus != SD_OK) {
   \   0000009C   0x0001             MOVS     R1,R0
   \   0000009E   0xD14A             BNE.N    ??SD_Erase_1
   2001                                  return (errorstatus);
   2002                          }
   2003          
   2004                          /*!< Send CMD33 SD_ERASE_GRP_END with argument as addr  */
   2005                          SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) endaddr;
   \   000000A0   0xF8C9 0x6034      STR      R6,[R9, #+52]
   2006                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SD_ERASE_GRP_END;
   \   000000A4   0x2021             MOVS     R0,#+33
   \   000000A6   0xF8C9 0x0038      STR      R0,[R9, #+56]
   2007                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000AA   0x2040             MOVS     R0,#+64
   \   000000AC   0xF8C9 0x003C      STR      R0,[R9, #+60]
   2008                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0xF8C9 0x0040      STR      R0,[R9, #+64]
   2009                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000B6   0xF8C9 0x4044      STR      R4,[R9, #+68]
   2010                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000BA   0xF109 0x0034      ADD      R0,R9,#+52
   \   000000BE   0x.... 0x....      BL       SDIO_SendCommand
   2011          
   2012                          errorstatus = CmdResp1Error (SD_CMD_SD_ERASE_GRP_END );
   \   000000C2   0x2021             MOVS     R0,#+33
   \   000000C4   0x.... 0x....      BL       CmdResp1Error
   2013                          if (errorstatus != SD_OK) {
   \   000000C8   0x0001             MOVS     R1,R0
   \   000000CA   0xD134             BNE.N    ??SD_Erase_1
   2014                                  return (errorstatus);
   2015                          }
   2016                  }
   2017          
   2018                  /*!< Send CMD38 ERASE */
   2019                  SDIO_CmdInitStructure.SDIO_Argument = 0;
   \                     ??SD_Erase_5: (+1)
   \   000000CC   0x4640             MOV      R0,R8
   \   000000CE   0xF8C9 0x0034      STR      R0,[R9, #+52]
   2020                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_ERASE;
   \   000000D2   0x2026             MOVS     R0,#+38
   \   000000D4   0xF8C9 0x0038      STR      R0,[R9, #+56]
   2021                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000D8   0x2040             MOVS     R0,#+64
   \   000000DA   0xF8C9 0x003C      STR      R0,[R9, #+60]
   2022                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0xF8C9 0x0040      STR      R0,[R9, #+64]
   2023                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000E4   0xF44F 0x6080      MOV      R0,#+1024
   \   000000E8   0xF8C9 0x0044      STR      R0,[R9, #+68]
   2024                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000EC   0xF109 0x0034      ADD      R0,R9,#+52
   \   000000F0   0x.... 0x....      BL       SDIO_SendCommand
   2025          
   2026                  errorstatus = CmdResp1Error (SD_CMD_ERASE );
   \   000000F4   0x2026             MOVS     R0,#+38
   \   000000F6   0x.... 0x....      BL       CmdResp1Error
   2027          
   2028                  if (errorstatus != SD_OK) {
   \   000000FA   0x0001             MOVS     R1,R0
   \   000000FC   0xD11B             BNE.N    ??SD_Erase_1
   \   000000FE   0xE001             B.N      ??SD_Erase_6
   2029                          return (errorstatus);
   2030                  }
   2031          
   2032                  for (delay = 0; delay < maxdelay; delay++) {
   \                     ??SD_Erase_7: (+1)
   \   00000100   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??SD_Erase_6: (+1)
   \   00000104   0x9801             LDR      R0,[SP, #+4]
   \   00000106   0x4580             CMP      R8,R0
   \   00000108   0xD3FA             BCC.N    ??SD_Erase_7
   2033                  }
   2034          
   2035                  /*!< Wait till the card is in programming state */
   2036                  errorstatus = IsCardProgramming (&cardstate);
   \   0000010A   0x4668             MOV      R0,SP
   \   0000010C   0x.... 0x....      BL       IsCardProgramming
   2037                  delay = SD_DATATIMEOUT;
   \   00000110   0xF04F 0x38FF      MOV      R8,#-1
   \   00000114   0xE004             B.N      ??SD_Erase_8
   2038                  while ((delay > 0) && (errorstatus == SD_OK) && ((SD_CARD_PROGRAMMING == cardstate) || (SD_CARD_RECEIVING == cardstate))) {
   2039                          errorstatus = IsCardProgramming (&cardstate);
   \                     ??SD_Erase_9: (+1)
   \   00000116   0x4668             MOV      R0,SP
   \   00000118   0x.... 0x....      BL       IsCardProgramming
   2040                          delay--;
   \   0000011C   0xF1A8 0x0801      SUB      R8,R8,#+1
   2041                  }
   \                     ??SD_Erase_8: (+1)
   \   00000120   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000124   0xD007             BEQ.N    ??SD_Erase_1
   \   00000126   0x0001             MOVS     R1,R0
   \   00000128   0xD105             BNE.N    ??SD_Erase_1
   \   0000012A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000012E   0x2907             CMP      R1,#+7
   \   00000130   0xD0F1             BEQ.N    ??SD_Erase_9
   \   00000132   0x2906             CMP      R1,#+6
   \   00000134   0xD0EF             BEQ.N    ??SD_Erase_9
   2042          
   2043                  return (errorstatus);
   \                     ??SD_Erase_1: (+1)
   \   00000136   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   2044          }
   2045          
   2046          /**
   2047           * @brief  Returns the current card's status.
   2048           * @param  pcardstatus: pointer to the buffer that will contain the SD card
   2049           *         status (Card Status register).
   2050           * @retval SD_Error: SD Card Error code.
   2051           */

   \                                 In section .text, align 2, keep-with-next
   2052          SD_Error SD_SendStatus (uint32_t *pcardstatus)
   2053          {
   \                     SD_SendStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2054                  SD_Error errorstatus = SD_OK;
   2055          
   2056                  if (pcardstatus == 0) {
   \   00000004   0xD101             BNE.N    ??SD_SendStatus_0
   2057                          errorstatus = SD_INVALID_PARAMETER;
   2058                          return (errorstatus);
   \   00000006   0x2026             MOVS     R0,#+38
   \   00000008   0xBD10             POP      {R4,PC}
   2059                  }
   2060          
   2061                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
   \                     ??SD_SendStatus_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable41
   \   0000000E   0x6EC1             LDR      R1,[R0, #+108]
   \   00000010   0x0409             LSLS     R1,R1,#+16
   \   00000012   0x6341             STR      R1,[R0, #+52]
   2062                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SEND_STATUS;
   \   00000014   0x210D             MOVS     R1,#+13
   \   00000016   0x6381             STR      R1,[R0, #+56]
   2063                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000018   0x2140             MOVS     R1,#+64
   \   0000001A   0x63C1             STR      R1,[R0, #+60]
   2064                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6401             STR      R1,[R0, #+64]
   2065                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000020   0xF44F 0x6180      MOV      R1,#+1024
   \   00000024   0x6441             STR      R1,[R0, #+68]
   2066                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000026   0x3034             ADDS     R0,R0,#+52
   \   00000028   0x.... 0x....      BL       SDIO_SendCommand
   2067          
   2068                  errorstatus = CmdResp1Error (SD_CMD_SEND_STATUS );
   \   0000002C   0x200D             MOVS     R0,#+13
   \   0000002E   0x.... 0x....      BL       CmdResp1Error
   2069          
   2070                  if (errorstatus != SD_OK) {
   \   00000032   0x0001             MOVS     R1,R0
   \   00000034   0xD104             BNE.N    ??SD_SendStatus_1
   2071                          return (errorstatus);
   2072                  }
   2073          
   2074                  *pcardstatus = SDIO_GetResponse (SDIO_RESP1);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      BL       SDIO_GetResponse
   \   0000003C   0x6020             STR      R0,[R4, #+0]
   2075          
   2076                  return (errorstatus);
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??SD_SendStatus_1: (+1)
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   2077          }
   2078          
   2079          /**
   2080           * @brief  Returns the current SD card's status.
   2081           * @param  psdstatus: pointer to the buffer that will contain the SD card status
   2082           *         (SD Status register).
   2083           * @retval SD_Error: SD Card Error code.
   2084           */

   \                                 In section .text, align 2, keep-with-next
   2085          SD_Error SD_SendSDStatus (uint32_t *psdstatus)
   2086          {
   \                     SD_SendSDStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   2087                  SD_Error errorstatus = SD_OK;
   2088                  uint32_t count = 0;
   2089          
   2090                  if (SDIO_GetResponse (SDIO_RESP1) & SD_CARD_LOCKED ) {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       SDIO_GetResponse
   \   0000000C   0x0180             LSLS     R0,R0,#+6
   \   0000000E   0xD501             BPL.N    ??SD_SendSDStatus_0
   2091                          errorstatus = SD_LOCK_UNLOCK_FAILED;
   2092                          return (errorstatus);
   \   00000010   0x200E             MOVS     R0,#+14
   \   00000012   0xE0A5             B.N      ??SD_SendSDStatus_1
   2093                  }
   2094          
   2095                  /*!< Set block size for card if it is not equal to current block size for card. */
   2096                  SDIO_CmdInitStructure.SDIO_Argument = 64;
   \                     ??SD_SendSDStatus_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable41
   \   00000018   0x2040             MOVS     R0,#+64
   \   0000001A   0x6368             STR      R0,[R5, #+52]
   2097                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   0000001C   0x2010             MOVS     R0,#+16
   \   0000001E   0x63A8             STR      R0,[R5, #+56]
   2098                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000020   0x2040             MOVS     R0,#+64
   \   00000022   0x63E8             STR      R0,[R5, #+60]
   2099                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6428             STR      R0,[R5, #+64]
   2100                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000028   0xF44F 0x6680      MOV      R6,#+1024
   \   0000002C   0x646E             STR      R6,[R5, #+68]
   2101                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000002E   0xF105 0x0034      ADD      R0,R5,#+52
   \   00000032   0x.... 0x....      BL       SDIO_SendCommand
   2102          
   2103                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   00000036   0x2010             MOVS     R0,#+16
   \   00000038   0x.... 0x....      BL       CmdResp1Error
   \   0000003C   0x4680             MOV      R8,R0
   2104          
   2105                  if (errorstatus != SD_OK) {
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD137             BNE.N    ??SD_SendSDStatus_2
   2106                          return (errorstatus);
   2107                  }
   2108          
   2109                  /*!< CMD55 */
   2110                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
   \   00000042   0x6EE8             LDR      R0,[R5, #+108]
   \   00000044   0x0400             LSLS     R0,R0,#+16
   \   00000046   0x6368             STR      R0,[R5, #+52]
   2111                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   00000048   0x2037             MOVS     R0,#+55
   \   0000004A   0x63A8             STR      R0,[R5, #+56]
   2112                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000004C   0x2040             MOVS     R0,#+64
   \   0000004E   0x63E8             STR      R0,[R5, #+60]
   2113                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6428             STR      R0,[R5, #+64]
   2114                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000054   0x646E             STR      R6,[R5, #+68]
   2115                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000056   0xF105 0x0034      ADD      R0,R5,#+52
   \   0000005A   0x.... 0x....      BL       SDIO_SendCommand
   2116                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   0000005E   0x2037             MOVS     R0,#+55
   \   00000060   0x.... 0x....      BL       CmdResp1Error
   \   00000064   0x4680             MOV      R8,R0
   2117          
   2118                  if (errorstatus != SD_OK) {
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD123             BNE.N    ??SD_SendSDStatus_2
   2119                          return (errorstatus);
   2120                  }
   2121          
   2122                  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   0000006A   0xF04F 0x37FF      MOV      R7,#-1
   \   0000006E   0x61EF             STR      R7,[R5, #+28]
   2123                  SDIO_DataInitStructure.SDIO_DataLength = 64;
   \   00000070   0x2040             MOVS     R0,#+64
   \   00000072   0x6228             STR      R0,[R5, #+32]
   2124                  SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_64b;
   \   00000074   0x2060             MOVS     R0,#+96
   \   00000076   0x6268             STR      R0,[R5, #+36]
   2125                  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x62A8             STR      R0,[R5, #+40]
   2126                  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x62E8             STR      R0,[R5, #+44]
   2127                  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x6328             STR      R0,[R5, #+48]
   2128                  SDIO_DataConfig (&SDIO_DataInitStructure);
   \   00000084   0xF105 0x001C      ADD      R0,R5,#+28
   \   00000088   0x.... 0x....      BL       SDIO_DataConfig
   2129          
   2130                  /*!< Send ACMD13 SD_APP_STAUS  with argument as card's RCA.*/
   2131                  SDIO_CmdInitStructure.SDIO_Argument = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x6368             STR      R0,[R5, #+52]
   2132                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SD_APP_STAUS;
   \   00000090   0x200D             MOVS     R0,#+13
   \   00000092   0x63A8             STR      R0,[R5, #+56]
   2133                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000094   0x2040             MOVS     R0,#+64
   \   00000096   0x63E8             STR      R0,[R5, #+60]
   2134                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x6428             STR      R0,[R5, #+64]
   2135                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   0000009C   0x646E             STR      R6,[R5, #+68]
   2136                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000009E   0xF105 0x0034      ADD      R0,R5,#+52
   \   000000A2   0x.... 0x....      BL       SDIO_SendCommand
   2137                  errorstatus = CmdResp1Error (SD_CMD_SD_APP_STAUS );
   \   000000A6   0x200D             MOVS     R0,#+13
   \   000000A8   0x.... 0x....      BL       CmdResp1Error
   \   000000AC   0x4680             MOV      R8,R0
   2138          
   2139                  if (errorstatus != SD_OK) {
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD009             BEQ.N    ??SD_SendSDStatus_3
   2140                          return (errorstatus);
   \                     ??SD_SendSDStatus_2: (+1)
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0xE054             B.N      ??SD_SendSDStatus_1
   2141                  }
   2142          
   2143                  while (!(SDIO ->STA & (SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))) {
   2144                          if (SDIO_GetFlagStatus (SDIO_FLAG_RXFIFOHF) != RESET) {
   2145                                  for (count = 0; count < 8; count++) {
   2146                                          *(psdstatus + count) = SDIO_ReadData ();
   \                     ??SD_SendSDStatus_4: (+1)
   \   000000B6   0x.... 0x....      BL       SDIO_ReadData
   \   000000BA   0xF844 0x0025      STR      R0,[R4, R5, LSL #+2]
   2147                                  }
   \   000000BE   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SD_SendSDStatus_5: (+1)
   \   000000C0   0x2D08             CMP      R5,#+8
   \   000000C2   0xD3F8             BCC.N    ??SD_SendSDStatus_4
   2148                                  psdstatus += 8;
   \   000000C4   0x3420             ADDS     R4,R4,#+32
   \                     ??SD_SendSDStatus_3: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable42_1  ;; 0x40012c34
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0xF240 0x612A      MOVW     R1,#+1578
   \   000000D0   0x4208             TST      R0,R1
   \   000000D2   0xD107             BNE.N    ??SD_SendSDStatus_6
   \   000000D4   0xF44F 0x4000      MOV      R0,#+32768
   \   000000D8   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD0F2             BEQ.N    ??SD_SendSDStatus_3
   \   000000E0   0x2500             MOVS     R5,#+0
   \   000000E2   0xE7ED             B.N      ??SD_SendSDStatus_5
   2149                          }
   2150                  }
   2151          
   2152                  if (SDIO_GetFlagStatus (SDIO_FLAG_DTIMEOUT) != RESET) {
   \                     ??SD_SendSDStatus_6: (+1)
   \   000000E4   0x2008             MOVS     R0,#+8
   \   000000E6   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD004             BEQ.N    ??SD_SendSDStatus_7
   2153                          SDIO_ClearFlag (SDIO_FLAG_DTIMEOUT);
   \   000000EE   0x2008             MOVS     R0,#+8
   \   000000F0   0x.... 0x....      BL       SDIO_ClearFlag
   2154                          errorstatus = SD_DATA_TIMEOUT;
   2155                          return (errorstatus);
   \   000000F4   0x2004             MOVS     R0,#+4
   \   000000F6   0xE033             B.N      ??SD_SendSDStatus_1
   2156                  }
   2157                  else if (SDIO_GetFlagStatus (SDIO_FLAG_DCRCFAIL) != RESET) {
   \                     ??SD_SendSDStatus_7: (+1)
   \   000000F8   0x2002             MOVS     R0,#+2
   \   000000FA   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD004             BEQ.N    ??SD_SendSDStatus_8
   2158                          SDIO_ClearFlag (SDIO_FLAG_DCRCFAIL);
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0x.... 0x....      BL       SDIO_ClearFlag
   2159                          errorstatus = SD_DATA_CRC_FAIL;
   2160                          return (errorstatus);
   \   00000108   0x2002             MOVS     R0,#+2
   \   0000010A   0xE029             B.N      ??SD_SendSDStatus_1
   2161                  }
   2162                  else if (SDIO_GetFlagStatus (SDIO_FLAG_RXOVERR) != RESET) {
   \                     ??SD_SendSDStatus_8: (+1)
   \   0000010C   0x2020             MOVS     R0,#+32
   \   0000010E   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD004             BEQ.N    ??SD_SendSDStatus_9
   2163                          SDIO_ClearFlag (SDIO_FLAG_RXOVERR);
   \   00000116   0x2020             MOVS     R0,#+32
   \   00000118   0x.... 0x....      BL       SDIO_ClearFlag
   2164                          errorstatus = SD_RX_OVERRUN;
   2165                          return (errorstatus);
   \   0000011C   0x2006             MOVS     R0,#+6
   \   0000011E   0xE01F             B.N      ??SD_SendSDStatus_1
   2166                  }
   2167                  else if (SDIO_GetFlagStatus (SDIO_FLAG_STBITERR) != RESET) {
   \                     ??SD_SendSDStatus_9: (+1)
   \   00000120   0xF44F 0x7000      MOV      R0,#+512
   \   00000124   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD005             BEQ.N    ??SD_SendSDStatus_10
   2168                          SDIO_ClearFlag (SDIO_FLAG_STBITERR);
   \   0000012C   0xF44F 0x7000      MOV      R0,#+512
   \   00000130   0x.... 0x....      BL       SDIO_ClearFlag
   2169                          errorstatus = SD_START_BIT_ERR;
   2170                          return (errorstatus);
   \   00000134   0x2007             MOVS     R0,#+7
   \   00000136   0xE013             B.N      ??SD_SendSDStatus_1
   2171                  }
   2172          
   2173                  count = SD_DATATIMEOUT;
   \                     ??SD_SendSDStatus_10: (+1)
   \   00000138   0x463D             MOV      R5,R7
   \   0000013A   0xE004             B.N      ??SD_SendSDStatus_11
   2174                  while ((SDIO_GetFlagStatus (SDIO_FLAG_RXDAVL) != RESET) && (count > 0)) {
   2175                          *psdstatus = SDIO_ReadData ();
   \                     ??SD_SendSDStatus_12: (+1)
   \   0000013C   0x.... 0x....      BL       SDIO_ReadData
   \   00000140   0xF844 0x0B04      STR      R0,[R4], #+4
   2176                          psdstatus++;
   2177                          count--;
   \   00000144   0x1E6D             SUBS     R5,R5,#+1
   2178                  }
   \                     ??SD_SendSDStatus_11: (+1)
   \   00000146   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000014A   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD001             BEQ.N    ??SD_SendSDStatus_13
   \   00000152   0x2D00             CMP      R5,#+0
   \   00000154   0xD1F2             BNE.N    ??SD_SendSDStatus_12
   2179                  /*!< Clear all the static status flags*/
   2180                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??SD_SendSDStatus_13: (+1)
   \   00000156   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000015A   0x.... 0x....      BL       SDIO_ClearFlag
   2181          
   2182                  return (errorstatus);
   \   0000015E   0x4640             MOV      R0,R8
   \                     ??SD_SendSDStatus_1: (+1)
   \   00000160   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2183          }
   2184          
   2185          /**
   2186           * @brief  Allows to process all the interrupts that are high.
   2187           * @param  None
   2188           * @retval SD_Error: SD Card Error code.
   2189           */

   \                                 In section .text, align 2, keep-with-next
   2190          SD_Error SD_ProcessIRQSrc (void)
   2191          {
   \                     SD_ProcessIRQSrc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2192                  if (SDIO_GetITStatus (SDIO_IT_DATAEND) != RESET) {
   \   00000002   0xF44F 0x7080      MOV      R0,#+256
   \   00000006   0x.... 0x....      BL       SDIO_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00A             BEQ.N    ??SD_ProcessIRQSrc_0
   2193                          TransferError = SD_OK;
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable41
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7620             STRB     R0,[R4, #+24]
   2194                          SDIO_ClearITPendingBit (SDIO_IT_DATAEND);
   \   00000016   0xF44F 0x7080      MOV      R0,#+256
   \   0000001A   0x.... 0x....      BL       SDIO_ClearITPendingBit
   2195                          TransferEnd = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x6760             STR      R0,[R4, #+116]
   \   00000022   0xE041             B.N      ??SD_ProcessIRQSrc_1
   2196                  }
   2197                  else if (SDIO_GetITStatus (SDIO_IT_DCRCFAIL) != RESET) {
   \                     ??SD_ProcessIRQSrc_0: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x.... 0x....      BL       SDIO_GetITStatus
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD007             BEQ.N    ??SD_ProcessIRQSrc_2
   2198                          SDIO_ClearITPendingBit (SDIO_IT_DCRCFAIL);
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       SDIO_ClearITPendingBit
   2199                          TransferError = SD_DATA_CRC_FAIL;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable41
   \   0000003A   0x7608             STRB     R0,[R1, #+24]
   \   0000003C   0xE034             B.N      ??SD_ProcessIRQSrc_1
   2200                  }
   2201                  else if (SDIO_GetITStatus (SDIO_IT_DTIMEOUT) != RESET) {
   \                     ??SD_ProcessIRQSrc_2: (+1)
   \   0000003E   0x2008             MOVS     R0,#+8
   \   00000040   0x.... 0x....      BL       SDIO_GetITStatus
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD007             BEQ.N    ??SD_ProcessIRQSrc_3
   2202                          SDIO_ClearITPendingBit (SDIO_IT_DTIMEOUT);
   \   00000048   0x2008             MOVS     R0,#+8
   \   0000004A   0x.... 0x....      BL       SDIO_ClearITPendingBit
   2203                          TransferError = SD_DATA_TIMEOUT;
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable41
   \   00000054   0x7608             STRB     R0,[R1, #+24]
   \   00000056   0xE027             B.N      ??SD_ProcessIRQSrc_1
   2204                  }
   2205                  else if (SDIO_GetITStatus (SDIO_IT_RXOVERR) != RESET) {
   \                     ??SD_ProcessIRQSrc_3: (+1)
   \   00000058   0x2020             MOVS     R0,#+32
   \   0000005A   0x.... 0x....      BL       SDIO_GetITStatus
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD007             BEQ.N    ??SD_ProcessIRQSrc_4
   2206                          SDIO_ClearITPendingBit (SDIO_IT_RXOVERR);
   \   00000062   0x2020             MOVS     R0,#+32
   \   00000064   0x.... 0x....      BL       SDIO_ClearITPendingBit
   2207                          TransferError = SD_RX_OVERRUN;
   \   00000068   0x2006             MOVS     R0,#+6
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable41
   \   0000006E   0x7608             STRB     R0,[R1, #+24]
   \   00000070   0xE01A             B.N      ??SD_ProcessIRQSrc_1
   2208                  }
   2209                  else if (SDIO_GetITStatus (SDIO_IT_TXUNDERR) != RESET) {
   \                     ??SD_ProcessIRQSrc_4: (+1)
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x.... 0x....      BL       SDIO_GetITStatus
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD007             BEQ.N    ??SD_ProcessIRQSrc_5
   2210                          SDIO_ClearITPendingBit (SDIO_IT_TXUNDERR);
   \   0000007C   0x2010             MOVS     R0,#+16
   \   0000007E   0x.... 0x....      BL       SDIO_ClearITPendingBit
   2211                          TransferError = SD_TX_UNDERRUN;
   \   00000082   0x2005             MOVS     R0,#+5
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable41
   \   00000088   0x7608             STRB     R0,[R1, #+24]
   \   0000008A   0xE00D             B.N      ??SD_ProcessIRQSrc_1
   2212                  }
   2213                  else if (SDIO_GetITStatus (SDIO_IT_STBITERR) != RESET) {
   \                     ??SD_ProcessIRQSrc_5: (+1)
   \   0000008C   0xF44F 0x7000      MOV      R0,#+512
   \   00000090   0x.... 0x....      BL       SDIO_GetITStatus
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD007             BEQ.N    ??SD_ProcessIRQSrc_1
   2214                          SDIO_ClearITPendingBit (SDIO_IT_STBITERR);
   \   00000098   0xF44F 0x7000      MOV      R0,#+512
   \   0000009C   0x.... 0x....      BL       SDIO_ClearITPendingBit
   2215                          TransferError = SD_START_BIT_ERR;
   \   000000A0   0x2007             MOVS     R0,#+7
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable41
   \   000000A6   0x7608             STRB     R0,[R1, #+24]
   2216                  }
   2217          
   2218                  SDIO_ITConfig (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR | SDIO_IT_RXOVERR | SDIO_IT_STBITERR, DISABLE);
   \                     ??SD_ProcessIRQSrc_1: (+1)
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xF24C 0x303A      MOVW     R0,#+49978
   \   000000AE   0x.... 0x....      BL       SDIO_ITConfig
   2219                  return (TransferError);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable41
   \   000000B6   0x7E00             LDRB     R0,[R0, #+24]
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
   2220          }
   2221          
   2222          /**
   2223           * @brief  This function waits until the SDIO DMA data transfer is finished.
   2224           * @param  None.
   2225           * @retval None.
   2226           */

   \                                 In section .text, align 2, keep-with-next
   2227          void SD_ProcessDMAIRQ (void)
   2228          {
   2229                  if (DMA2 ->LISR & SD_SDIO_DMA_FLAG_TCIF) {
   \                     SD_ProcessDMAIRQ: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable42_2  ;; 0x40026400
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF010 0x5FC0      TST      R0,#0x18000000
   \   0000000A   0xD009             BEQ.N    ??SD_ProcessDMAIRQ_0
   2230                          DMAEndOfTransfer = 0x01;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable41
   \   00000012   0x6788             STR      R0,[R1, #+120]
   2231                          DMA_ClearFlag (SD_SDIO_DMA_STREAM, SD_SDIO_DMA_FLAG_TCIF | SD_SDIO_DMA_FLAG_FEIF);
   \   00000014   0xF04F 0x51C2      MOV      R1,#+406847488
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable42_3  ;; 0x40026458
   \   0000001C   0x.... 0x....      B.W      DMA_ClearFlag
   2232                  }
   2233          }
   \                     ??SD_ProcessDMAIRQ_0: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   2234          
   2235          /**
   2236           * @brief  Checks for error conditions for CMD0.
   2237           * @param  None
   2238           * @retval SD_Error: SD Card Error code.
   2239           */

   \                                 In section .text, align 2, keep-with-next
   2240          static SD_Error CmdError (void)
   2241          {
   \                     CmdError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2242                  SD_Error errorstatus = SD_OK;
   2243                  uint32_t timeout;
   2244          
   2245                  timeout = SDIO_CMD0TIMEOUT; /*!< 10000 */
   \   00000002   0xF44F 0x3480      MOV      R4,#+65536
   \   00000006   0xE000             B.N      ??CmdError_0
   2246          
   2247                  while ((timeout > 0) && (SDIO_GetFlagStatus (SDIO_FLAG_CMDSENT) == RESET)) {
   2248                          timeout--;
   \                     ??CmdError_1: (+1)
   \   00000008   0x1E64             SUBS     R4,R4,#+1
   2249                  }
   \                     ??CmdError_0: (+1)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD004             BEQ.N    ??CmdError_2
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD0F7             BEQ.N    ??CmdError_1
   2250          
   2251                  if (timeout == 0) {
   \                     ??CmdError_2: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD101             BNE.N    ??CmdError_3
   2252                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2253                          return (errorstatus);
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xBD10             POP      {R4,PC}
   2254                  }
   2255          
   2256                  /*!< Clear all the static flags */
   2257                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??CmdError_3: (+1)
   \   00000020   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000024   0x.... 0x....      BL       SDIO_ClearFlag
   2258          
   2259                  return (errorstatus);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   2260          }
   2261          
   2262          /**
   2263           * @brief  Checks for error conditions for R7 response.
   2264           * @param  None
   2265           * @retval SD_Error: SD Card Error code.
   2266           */

   \                                 In section .text, align 2, keep-with-next
   2267          static SD_Error CmdResp7Error (void)
   2268          {
   \                     CmdResp7Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2269                  SD_Error errorstatus = SD_OK;
   2270                  uint32_t status;
   2271                  uint32_t timeout = SDIO_CMD0TIMEOUT;
   \   00000002   0xF44F 0x3080      MOV      R0,#+65536
   2272          
   2273                  status = SDIO ->STA;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable42_1  ;; 0x40012c34
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0xE001             B.N      ??CmdResp7Error_0
   2274          
   2275                  while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) && (timeout > 0)) {
   2276                          timeout--;
   \                     ??CmdResp7Error_1: (+1)
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   2277                          status = SDIO ->STA;
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   2278                  }
   \                     ??CmdResp7Error_0: (+1)
   \   00000012   0xF012 0x0F45      TST      R2,#0x45
   \   00000016   0xD101             BNE.N    ??CmdResp7Error_2
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F8             BNE.N    ??CmdResp7Error_1
   2279          
   2280                  if ((timeout == 0) || (status & SDIO_FLAG_CTIMEOUT)) {
   \                     ??CmdResp7Error_2: (+1)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??CmdResp7Error_3
   \   00000020   0x0750             LSLS     R0,R2,#+29
   \   00000022   0xD504             BPL.N    ??CmdResp7Error_4
   2281                          /*!< Card is not V2.0 complient or card does not support the set voltage range */
   2282                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2283                          SDIO_ClearFlag (SDIO_FLAG_CTIMEOUT);
   \                     ??CmdResp7Error_3: (+1)
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       SDIO_ClearFlag
   2284                          return (errorstatus);
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xBD02             POP      {R1,PC}
   2285                  }
   2286          
   2287                  if (status & SDIO_FLAG_CMDREND) {
   \                     ??CmdResp7Error_4: (+1)
   \   0000002E   0x0650             LSLS     R0,R2,#+25
   \   00000030   0xD504             BPL.N    ??CmdResp7Error_5
   2288                          /*!< Card is SD V2.0 compliant */
   2289                          errorstatus = SD_OK;
   2290                          SDIO_ClearFlag (SDIO_FLAG_CMDREND);
   \   00000032   0x2040             MOVS     R0,#+64
   \   00000034   0x.... 0x....      BL       SDIO_ClearFlag
   2291                          return (errorstatus);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD02             POP      {R1,PC}
   2292                  }
   2293                  return (errorstatus);
   \                     ??CmdResp7Error_5: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD02             POP      {R1,PC}          ;; return
   2294          }
   2295          
   2296          /**
   2297           * @brief  Checks for error conditions for R1 response.
   2298           * @param  cmd: The sent command index.
   2299           * @retval SD_Error: SD Card Error code.
   2300           */

   \                                 In section .text, align 2, keep-with-next
   2301          static SD_Error CmdResp1Error (uint8_t cmd)
   2302          {
   \                     CmdResp1Error: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2303                  SD_Error errorstatus = SD_OK;
   2304                  uint32_t status;
   2305                  uint32_t response_r1;
   2306          
   2307                  status = SDIO ->STA;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x40012c34
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xE000             B.N      ??CmdResp1Error_0
   2308          
   2309                  while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))) {
   2310                          status = SDIO ->STA;
   \                     ??CmdResp1Error_1: (+1)
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   2311                  }
   \                     ??CmdResp1Error_0: (+1)
   \   0000000E   0xF011 0x0F45      TST      R1,#0x45
   \   00000012   0xD0FB             BEQ.N    ??CmdResp1Error_1
   2312          
   2313                  if (status & SDIO_FLAG_CTIMEOUT) {
   \   00000014   0x0748             LSLS     R0,R1,#+29
   \   00000016   0xD504             BPL.N    ??CmdResp1Error_2
   2314                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2315                          SDIO_ClearFlag (SDIO_FLAG_CTIMEOUT);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x.... 0x....      BL       SDIO_ClearFlag
   2316                          return (errorstatus);
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0xBD10             POP      {R4,PC}
   2317                  }
   2318                  else if (status & SDIO_FLAG_CCRCFAIL) {
   \                     ??CmdResp1Error_2: (+1)
   \   00000022   0x07C8             LSLS     R0,R1,#+31
   \   00000024   0xD504             BPL.N    ??CmdResp1Error_3
   2319                          errorstatus = SD_CMD_CRC_FAIL;
   2320                          SDIO_ClearFlag (SDIO_FLAG_CCRCFAIL);
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       SDIO_ClearFlag
   2321                          return (errorstatus);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD10             POP      {R4,PC}
   2322                  }
   2323          
   2324                  /*!< Check response received is of desired command */
   2325                  if (SDIO_GetCommandResponse () != cmd) {
   \                     ??CmdResp1Error_3: (+1)
   \   00000030   0x.... 0x....      BL       SDIO_GetCommandResponse
   \   00000034   0x42A0             CMP      R0,R4
   \   00000036   0xD12D             BNE.N    ??CmdResp1Error_4
   2326                          errorstatus = SD_ILLEGAL_CMD;
   2327                          return (errorstatus);
   2328                  }
   2329          
   2330                  /*!< Clear all the static flags */
   2331                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \   00000038   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000003C   0x.... 0x....      BL       SDIO_ClearFlag
   2332          
   2333                  /*!< We have received response, retrieve it for analysis  */
   2334                  response_r1 = SDIO_GetResponse (SDIO_RESP1);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       SDIO_GetResponse
   2335          
   2336                  if ((response_r1 & SD_OCR_ERRORBITS )== SD_ALLZERO) {
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable42_4  ;; 0xfdffe008
   \   0000004A   0x4208             TST      R0,R1
   \   0000004C   0xD101             BNE.N    ??CmdResp1Error_5
   2337                          return (errorstatus);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD10             POP      {R4,PC}
   2338                  }
   2339          
   2340                  if (response_r1 & SD_OCR_ADDR_OUT_OF_RANGE ) {
   \                     ??CmdResp1Error_5: (+1)
   \   00000052   0xD501             BPL.N    ??CmdResp1Error_6
   2341                          return (SD_ADDR_OUT_OF_RANGE);
   \   00000054   0x201C             MOVS     R0,#+28
   \   00000056   0xBD10             POP      {R4,PC}
   2342                  }
   2343          
   2344                  if (response_r1 & SD_OCR_ADDR_MISALIGNED ) {
   \                     ??CmdResp1Error_6: (+1)
   \   00000058   0x0041             LSLS     R1,R0,#+1
   \   0000005A   0xD501             BPL.N    ??CmdResp1Error_7
   2345                          return (SD_ADDR_MISALIGNED);
   \   0000005C   0x2009             MOVS     R0,#+9
   \   0000005E   0xBD10             POP      {R4,PC}
   2346                  }
   2347          
   2348                  if (response_r1 & SD_OCR_BLOCK_LEN_ERR ) {
   \                     ??CmdResp1Error_7: (+1)
   \   00000060   0x0081             LSLS     R1,R0,#+2
   \   00000062   0xD501             BPL.N    ??CmdResp1Error_8
   2349                          return (SD_BLOCK_LEN_ERR);
   \   00000064   0x200A             MOVS     R0,#+10
   \   00000066   0xBD10             POP      {R4,PC}
   2350                  }
   2351          
   2352                  if (response_r1 & SD_OCR_ERASE_SEQ_ERR ) {
   \                     ??CmdResp1Error_8: (+1)
   \   00000068   0x00C1             LSLS     R1,R0,#+3
   \   0000006A   0xD501             BPL.N    ??CmdResp1Error_9
   2353                          return (SD_ERASE_SEQ_ERR);
   \   0000006C   0x200B             MOVS     R0,#+11
   \   0000006E   0xBD10             POP      {R4,PC}
   2354                  }
   2355          
   2356                  if (response_r1 & SD_OCR_BAD_ERASE_PARAM ) {
   \                     ??CmdResp1Error_9: (+1)
   \   00000070   0x0101             LSLS     R1,R0,#+4
   \   00000072   0xD501             BPL.N    ??CmdResp1Error_10
   2357                          return (SD_BAD_ERASE_PARAM);
   \   00000074   0x200C             MOVS     R0,#+12
   \   00000076   0xBD10             POP      {R4,PC}
   2358                  }
   2359          
   2360                  if (response_r1 & SD_OCR_WRITE_PROT_VIOLATION ) {
   \                     ??CmdResp1Error_10: (+1)
   \   00000078   0x0141             LSLS     R1,R0,#+5
   \   0000007A   0xD501             BPL.N    ??CmdResp1Error_11
   2361                          return (SD_WRITE_PROT_VIOLATION);
   \   0000007C   0x200D             MOVS     R0,#+13
   \   0000007E   0xBD10             POP      {R4,PC}
   2362                  }
   2363          
   2364                  if (response_r1 & SD_OCR_LOCK_UNLOCK_FAILED ) {
   \                     ??CmdResp1Error_11: (+1)
   \   00000080   0x01C1             LSLS     R1,R0,#+7
   \   00000082   0xD501             BPL.N    ??CmdResp1Error_12
   2365                          return (SD_LOCK_UNLOCK_FAILED);
   \   00000084   0x200E             MOVS     R0,#+14
   \   00000086   0xBD10             POP      {R4,PC}
   2366                  }
   2367          
   2368                  if (response_r1 & SD_OCR_COM_CRC_FAILED ) {
   \                     ??CmdResp1Error_12: (+1)
   \   00000088   0x0201             LSLS     R1,R0,#+8
   \   0000008A   0xD501             BPL.N    ??CmdResp1Error_13
   2369                          return (SD_COM_CRC_FAILED);
   \   0000008C   0x200F             MOVS     R0,#+15
   \   0000008E   0xBD10             POP      {R4,PC}
   2370                  }
   2371          
   2372                  if (response_r1 & SD_OCR_ILLEGAL_CMD ) {
   \                     ??CmdResp1Error_13: (+1)
   \   00000090   0x0241             LSLS     R1,R0,#+9
   \   00000092   0xD501             BPL.N    ??CmdResp1Error_14
   2373                          return (SD_ILLEGAL_CMD);
   \                     ??CmdResp1Error_4: (+1)
   \   00000094   0x2010             MOVS     R0,#+16
   \   00000096   0xBD10             POP      {R4,PC}
   2374                  }
   2375          
   2376                  if (response_r1 & SD_OCR_CARD_ECC_FAILED ) {
   \                     ??CmdResp1Error_14: (+1)
   \   00000098   0x0281             LSLS     R1,R0,#+10
   \   0000009A   0xD501             BPL.N    ??CmdResp1Error_15
   2377                          return (SD_CARD_ECC_FAILED);
   \   0000009C   0x2011             MOVS     R0,#+17
   \   0000009E   0xBD10             POP      {R4,PC}
   2378                  }
   2379          
   2380                  if (response_r1 & SD_OCR_CC_ERROR ) {
   \                     ??CmdResp1Error_15: (+1)
   \   000000A0   0x02C1             LSLS     R1,R0,#+11
   \   000000A2   0xD501             BPL.N    ??CmdResp1Error_16
   2381                          return (SD_CC_ERROR);
   \   000000A4   0x2012             MOVS     R0,#+18
   \   000000A6   0xBD10             POP      {R4,PC}
   2382                  }
   2383          
   2384                  if (response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR ) {
   \                     ??CmdResp1Error_16: (+1)
   \   000000A8   0x0301             LSLS     R1,R0,#+12
   \   000000AA   0xD501             BPL.N    ??CmdResp1Error_17
   2385                          return (SD_GENERAL_UNKNOWN_ERROR);
   \   000000AC   0x2013             MOVS     R0,#+19
   \   000000AE   0xBD10             POP      {R4,PC}
   2386                  }
   2387          
   2388                  if (response_r1 & SD_OCR_STREAM_READ_UNDERRUN ) {
   \                     ??CmdResp1Error_17: (+1)
   \   000000B0   0x0341             LSLS     R1,R0,#+13
   \   000000B2   0xD501             BPL.N    ??CmdResp1Error_18
   2389                          return (SD_STREAM_READ_UNDERRUN);
   \   000000B4   0x2014             MOVS     R0,#+20
   \   000000B6   0xBD10             POP      {R4,PC}
   2390                  }
   2391          
   2392                  if (response_r1 & SD_OCR_STREAM_WRITE_OVERRUN ) {
   \                     ??CmdResp1Error_18: (+1)
   \   000000B8   0x0381             LSLS     R1,R0,#+14
   \   000000BA   0xD501             BPL.N    ??CmdResp1Error_19
   2393                          return (SD_STREAM_WRITE_OVERRUN);
   \   000000BC   0x2015             MOVS     R0,#+21
   \   000000BE   0xBD10             POP      {R4,PC}
   2394                  }
   2395          
   2396                  if (response_r1 & SD_OCR_CID_CSD_OVERWRIETE ) {
   \                     ??CmdResp1Error_19: (+1)
   \   000000C0   0x03C1             LSLS     R1,R0,#+15
   \   000000C2   0xD501             BPL.N    ??CmdResp1Error_20
   2397                          return (SD_CID_CSD_OVERWRITE);
   \   000000C4   0x2016             MOVS     R0,#+22
   \   000000C6   0xBD10             POP      {R4,PC}
   2398                  }
   2399          
   2400                  if (response_r1 & SD_OCR_WP_ERASE_SKIP ) {
   \                     ??CmdResp1Error_20: (+1)
   \   000000C8   0x0401             LSLS     R1,R0,#+16
   \   000000CA   0xD501             BPL.N    ??CmdResp1Error_21
   2401                          return (SD_WP_ERASE_SKIP);
   \   000000CC   0x2017             MOVS     R0,#+23
   \   000000CE   0xBD10             POP      {R4,PC}
   2402                  }
   2403          
   2404                  if (response_r1 & SD_OCR_CARD_ECC_DISABLED ) {
   \                     ??CmdResp1Error_21: (+1)
   \   000000D0   0x0441             LSLS     R1,R0,#+17
   \   000000D2   0xD501             BPL.N    ??CmdResp1Error_22
   2405                          return (SD_CARD_ECC_DISABLED);
   \   000000D4   0x2018             MOVS     R0,#+24
   \   000000D6   0xBD10             POP      {R4,PC}
   2406                  }
   2407          
   2408                  if (response_r1 & SD_OCR_ERASE_RESET ) {
   \                     ??CmdResp1Error_22: (+1)
   \   000000D8   0x0481             LSLS     R1,R0,#+18
   \   000000DA   0xD501             BPL.N    ??CmdResp1Error_23
   2409                          return (SD_ERASE_RESET);
   \   000000DC   0x2019             MOVS     R0,#+25
   \   000000DE   0xBD10             POP      {R4,PC}
   2410                  }
   2411          
   2412                  if (response_r1 & SD_OCR_AKE_SEQ_ERROR ) {
   \                     ??CmdResp1Error_23: (+1)
   \   000000E0   0x0700             LSLS     R0,R0,#+28
   \   000000E2   0xD501             BPL.N    ??CmdResp1Error_24
   2413                          return (SD_AKE_SEQ_ERROR);
   \   000000E4   0x201A             MOVS     R0,#+26
   \   000000E6   0xBD10             POP      {R4,PC}
   2414                  }
   2415                  return (errorstatus);
   \                     ??CmdResp1Error_24: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xBD10             POP      {R4,PC}          ;; return
   2416          }
   2417          
   2418          /**
   2419           * @brief  Checks for error conditions for R3 (OCR) response.
   2420           * @param  None
   2421           * @retval SD_Error: SD Card Error code.
   2422           */

   \                                 In section .text, align 2, keep-with-next
   2423          static SD_Error CmdResp3Error (void)
   2424          {
   \                     CmdResp3Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2425                  SD_Error errorstatus = SD_OK;
   2426                  uint32_t status;
   2427          
   2428                  status = SDIO ->STA;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable42_1  ;; 0x40012c34
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xE000             B.N      ??CmdResp3Error_0
   2429          
   2430                  while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))) {
   2431                          status = SDIO ->STA;
   \                     ??CmdResp3Error_1: (+1)
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   2432                  }
   \                     ??CmdResp3Error_0: (+1)
   \   0000000C   0xF011 0x0F45      TST      R1,#0x45
   \   00000010   0xD0FB             BEQ.N    ??CmdResp3Error_1
   2433          
   2434                  if (status & SDIO_FLAG_CTIMEOUT) {
   \   00000012   0x0748             LSLS     R0,R1,#+29
   \   00000014   0xD504             BPL.N    ??CmdResp3Error_2
   2435                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2436                          SDIO_ClearFlag (SDIO_FLAG_CTIMEOUT);
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       SDIO_ClearFlag
   2437                          return (errorstatus);
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xBD02             POP      {R1,PC}
   2438                  }
   2439                  /*!< Clear all the static flags */
   2440                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??CmdResp3Error_2: (+1)
   \   00000020   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000024   0x.... 0x....      BL       SDIO_ClearFlag
   2441                  return (errorstatus);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
   2442          }
   2443          
   2444          /**
   2445           * @brief  Checks for error conditions for R2 (CID or CSD) response.
   2446           * @param  None
   2447           * @retval SD_Error: SD Card Error code.
   2448           */

   \                                 In section .text, align 2, keep-with-next
   2449          static SD_Error CmdResp2Error (void)
   2450          {
   \                     CmdResp2Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2451                  SD_Error errorstatus = SD_OK;
   2452                  uint32_t status;
   2453          
   2454                  status = SDIO ->STA;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable42_1  ;; 0x40012c34
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xE000             B.N      ??CmdResp2Error_0
   2455          
   2456                  while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CTIMEOUT | SDIO_FLAG_CMDREND))) {
   2457                          status = SDIO ->STA;
   \                     ??CmdResp2Error_1: (+1)
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   2458                  }
   \                     ??CmdResp2Error_0: (+1)
   \   0000000C   0xF011 0x0F45      TST      R1,#0x45
   \   00000010   0xD0FB             BEQ.N    ??CmdResp2Error_1
   2459          
   2460                  if (status & SDIO_FLAG_CTIMEOUT) {
   \   00000012   0x0748             LSLS     R0,R1,#+29
   \   00000014   0xD504             BPL.N    ??CmdResp2Error_2
   2461                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2462                          SDIO_ClearFlag (SDIO_FLAG_CTIMEOUT);
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       SDIO_ClearFlag
   2463                          return (errorstatus);
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xBD02             POP      {R1,PC}
   2464                  }
   2465                  else if (status & SDIO_FLAG_CCRCFAIL) {
   \                     ??CmdResp2Error_2: (+1)
   \   00000020   0x07C8             LSLS     R0,R1,#+31
   \   00000022   0xD504             BPL.N    ??CmdResp2Error_3
   2466                          errorstatus = SD_CMD_CRC_FAIL;
   2467                          SDIO_ClearFlag (SDIO_FLAG_CCRCFAIL);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       SDIO_ClearFlag
   2468                          return (errorstatus);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD02             POP      {R1,PC}
   2469                  }
   2470          
   2471                  /*!< Clear all the static flags */
   2472                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??CmdResp2Error_3: (+1)
   \   0000002E   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000032   0x.... 0x....      BL       SDIO_ClearFlag
   2473          
   2474                  return (errorstatus);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD02             POP      {R1,PC}          ;; return
   2475          }
   2476          
   2477          /**
   2478           * @brief  Checks for error conditions for R6 (RCA) response.
   2479           * @param  cmd: The sent command index.
   2480           * @param  prca: pointer to the variable that will contain the SD card relative
   2481           *         address RCA.
   2482           * @retval SD_Error: SD Card Error code.
   2483           */

   \                                 In section .text, align 2, keep-with-next
   2484          static SD_Error CmdResp6Error (uint8_t cmd, uint16_t *prca)
   2485          {
   \                     CmdResp6Error: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2486                  SD_Error errorstatus = SD_OK;
   2487                  uint32_t status;
   2488                  uint32_t response_r1;
   2489          
   2490                  status = SDIO ->STA;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_1  ;; 0x40012c34
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xE000             B.N      ??CmdResp6Error_0
   2491          
   2492                  while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CTIMEOUT | SDIO_FLAG_CMDREND))) {
   2493                          status = SDIO ->STA;
   \                     ??CmdResp6Error_1: (+1)
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   2494                  }
   \                     ??CmdResp6Error_0: (+1)
   \   00000010   0xF011 0x0F45      TST      R1,#0x45
   \   00000014   0xD0FB             BEQ.N    ??CmdResp6Error_1
   2495          
   2496                  if (status & SDIO_FLAG_CTIMEOUT) {
   \   00000016   0x0748             LSLS     R0,R1,#+29
   \   00000018   0xD504             BPL.N    ??CmdResp6Error_2
   2497                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2498                          SDIO_ClearFlag (SDIO_FLAG_CTIMEOUT);
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0x.... 0x....      BL       SDIO_ClearFlag
   2499                          return (errorstatus);
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
   2500                  }
   2501                  else if (status & SDIO_FLAG_CCRCFAIL) {
   \                     ??CmdResp6Error_2: (+1)
   \   00000024   0x07C8             LSLS     R0,R1,#+31
   \   00000026   0xD504             BPL.N    ??CmdResp6Error_3
   2502                          errorstatus = SD_CMD_CRC_FAIL;
   2503                          SDIO_ClearFlag (SDIO_FLAG_CCRCFAIL);
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       SDIO_ClearFlag
   2504                          return (errorstatus);
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
   2505                  }
   2506          
   2507                  /*!< Check response received is of desired command */
   2508                  if (SDIO_GetCommandResponse () != cmd) {
   \                     ??CmdResp6Error_3: (+1)
   \   00000032   0x.... 0x....      BL       SDIO_GetCommandResponse
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xD113             BNE.N    ??CmdResp6Error_4
   2509                          errorstatus = SD_ILLEGAL_CMD;
   2510                          return (errorstatus);
   2511                  }
   2512          
   2513                  /*!< Clear all the static flags */
   2514                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \   0000003A   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000003E   0x.... 0x....      BL       SDIO_ClearFlag
   2515          
   2516                  /*!< We have received response, retrieve it.  */
   2517                  response_r1 = SDIO_GetResponse (SDIO_RESP1);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       SDIO_GetResponse
   2518          
   2519                  if (SD_ALLZERO == (response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED ))) {
   \   00000048   0xF410 0x4F60      TST      R0,#0xE000
   \   0000004C   0xD103             BNE.N    ??CmdResp6Error_5
   2520                          *prca = (uint16_t) (response_r1 >> 16);
   \   0000004E   0x0C00             LSRS     R0,R0,#+16
   \   00000050   0x8028             STRH     R0,[R5, #+0]
   2521                          return (errorstatus);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}
   2522                  }
   2523          
   2524                  if (response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR ) {
   \                     ??CmdResp6Error_5: (+1)
   \   00000056   0x0481             LSLS     R1,R0,#+18
   \   00000058   0xD501             BPL.N    ??CmdResp6Error_6
   2525                          return (SD_GENERAL_UNKNOWN_ERROR);
   \   0000005A   0x2013             MOVS     R0,#+19
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}
   2526                  }
   2527          
   2528                  if (response_r1 & SD_R6_ILLEGAL_CMD ) {
   \                     ??CmdResp6Error_6: (+1)
   \   0000005E   0x0441             LSLS     R1,R0,#+17
   \   00000060   0xD501             BPL.N    ??CmdResp6Error_7
   2529                          return (SD_ILLEGAL_CMD);
   \                     ??CmdResp6Error_4: (+1)
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}
   2530                  }
   2531          
   2532                  if (response_r1 & SD_R6_COM_CRC_FAILED ) {
   \                     ??CmdResp6Error_7: (+1)
   \   00000066   0x0400             LSLS     R0,R0,#+16
   \   00000068   0xD501             BPL.N    ??CmdResp6Error_8
   2533                          return (SD_COM_CRC_FAILED);
   \   0000006A   0x200F             MOVS     R0,#+15
   \   0000006C   0xBD32             POP      {R1,R4,R5,PC}
   2534                  }
   2535          
   2536                  return (errorstatus);
   \                     ??CmdResp6Error_8: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2537          }
   2538          
   2539          /**
   2540           * @brief  Enables or disables the SDIO wide bus mode.
   2541           * @param  NewState: new state of the SDIO wide bus mode.
   2542           *   This parameter can be: ENABLE or DISABLE.
   2543           * @retval SD_Error: SD Card Error code.
   2544           */

   \                                 In section .text, align 2, keep-with-next
   2545          static SD_Error SDEnWideBus (FunctionalState NewState)
   2546          {
   \                     SDEnWideBus: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4605             MOV      R5,R0
   2547                  SD_Error errorstatus = SD_OK;
   2548          
   2549                  uint32_t scr[2] = { 0, 0 };
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x460A             MOV      R2,R1
   \   0000000C   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
   2550          
   2551                  if (SDIO_GetResponse (SDIO_RESP1) & SD_CARD_LOCKED ) {
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x.... 0x....      BL       SDIO_GetResponse
   \   00000016   0x0180             LSLS     R0,R0,#+6
   \   00000018   0xD501             BPL.N    ??SDEnWideBus_0
   2552                          errorstatus = SD_LOCK_UNLOCK_FAILED;
   2553                          return (errorstatus);
   \   0000001A   0x200E             MOVS     R0,#+14
   \   0000001C   0xBD3E             POP      {R1-R5,PC}
   2554                  }
   2555          
   2556                  /*!< Get SCR Register */
   2557                  errorstatus = FindSCR (RCA, scr);
   \                     ??SDEnWideBus_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable41
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x6EE0             LDR      R0,[R4, #+108]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x.... 0x....      BL       FindSCR
   2558          
   2559                  if (errorstatus != SD_OK) {
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0xD159             BNE.N    ??SDEnWideBus_1
   \   00000030   0x9801             LDR      R0,[SP, #+4]
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD12A             BNE.N    ??SDEnWideBus_2
   2560                          return (errorstatus);
   2561                  }
   2562          
   2563                  /*!< If wide bus operation to be enabled */
   2564                  if (NewState == ENABLE) {
   2565                          /*!< If requested card supports wide bus operation */
   2566                          if ((scr[1] & SD_WIDE_BUS_SUPPORT )!= SD_ALLZERO) {
   \   00000036   0x0340             LSLS     R0,R0,#+13
   \   00000038   0xD553             BPL.N    ??SDEnWideBus_3
   2567                                  /*!< Send CMD55 APP_CMD with argument as card's RCA.*/
   2568                                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
   \   0000003A   0x6EE0             LDR      R0,[R4, #+108]
   \   0000003C   0x0400             LSLS     R0,R0,#+16
   \   0000003E   0x6360             STR      R0,[R4, #+52]
   2569                                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   00000040   0x2037             MOVS     R0,#+55
   \   00000042   0x63A0             STR      R0,[R4, #+56]
   2570                                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000044   0x2040             MOVS     R0,#+64
   \   00000046   0x63E0             STR      R0,[R4, #+60]
   2571                                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6420             STR      R0,[R4, #+64]
   2572                                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   0000004C   0xF44F 0x6580      MOV      R5,#+1024
   \   00000050   0x6465             STR      R5,[R4, #+68]
   2573                                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000052   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000056   0x.... 0x....      BL       SDIO_SendCommand
   2574          
   2575                                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   0000005A   0x2037             MOVS     R0,#+55
   \   0000005C   0x.... 0x....      BL       CmdResp1Error
   2576          
   2577                                  if (errorstatus != SD_OK) {
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0xD13F             BNE.N    ??SDEnWideBus_1
   2578                                          return (errorstatus);
   2579                                  }
   2580          
   2581                                  /*!< Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
   2582                                  SDIO_CmdInitStructure.SDIO_Argument = 0x2;
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x6360             STR      R0,[R4, #+52]
   2583                                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_SD_SET_BUSWIDTH;
   \   00000068   0x2006             MOVS     R0,#+6
   \   0000006A   0x63A0             STR      R0,[R4, #+56]
   2584                                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000006C   0x2040             MOVS     R0,#+64
   \   0000006E   0x63E0             STR      R0,[R4, #+60]
   2585                                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6420             STR      R0,[R4, #+64]
   2586                                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000074   0x6465             STR      R5,[R4, #+68]
   2587                                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000076   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000007A   0x.... 0x....      BL       SDIO_SendCommand
   2588          
   2589                                  errorstatus = CmdResp1Error (SD_CMD_APP_SD_SET_BUSWIDTH );
   \   0000007E   0x2006             MOVS     R0,#+6
   \   00000080   0x.... 0x....      BL       CmdResp1Error
   2590          
   2591                                  if (errorstatus != SD_OK) {
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0xD12D             BNE.N    ??SDEnWideBus_1
   2592                                          return (errorstatus);
   2593                                  }
   2594                                  return (errorstatus);
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBD3E             POP      {R1-R5,PC}
   2595                          }
   2596                          else {
   2597                                  errorstatus = SD_REQUEST_NOT_APPLICABLE;
   2598                                  return (errorstatus);
   2599                          }
   2600                  } /*!< If wide bus operation to be disabled */
   2601                  else {
   2602                          /*!< If requested card supports 1 bit mode operation */
   2603                          if ((scr[1] & SD_SINGLE_BUS_SUPPORT )!= SD_ALLZERO) {
   \                     ??SDEnWideBus_2: (+1)
   \   0000008C   0x03C0             LSLS     R0,R0,#+15
   \   0000008E   0xD528             BPL.N    ??SDEnWideBus_3
   2604                                  /*!< Send CMD55 APP_CMD with argument as card's RCA.*/
   2605                                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
   \   00000090   0x6EE0             LDR      R0,[R4, #+108]
   \   00000092   0x0400             LSLS     R0,R0,#+16
   \   00000094   0x6360             STR      R0,[R4, #+52]
   2606                                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   00000096   0x2037             MOVS     R0,#+55
   \   00000098   0x63A0             STR      R0,[R4, #+56]
   2607                                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000009A   0x2040             MOVS     R0,#+64
   \   0000009C   0x63E0             STR      R0,[R4, #+60]
   2608                                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x6420             STR      R0,[R4, #+64]
   2609                                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000A2   0xF44F 0x6580      MOV      R5,#+1024
   \   000000A6   0x6465             STR      R5,[R4, #+68]
   2610                                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000A8   0xF104 0x0034      ADD      R0,R4,#+52
   \   000000AC   0x.... 0x....      BL       SDIO_SendCommand
   2611          
   2612                                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   000000B0   0x2037             MOVS     R0,#+55
   \   000000B2   0x.... 0x....      BL       CmdResp1Error
   2613          
   2614                                  if (errorstatus != SD_OK) {
   \   000000B6   0x0001             MOVS     R1,R0
   \   000000B8   0xD114             BNE.N    ??SDEnWideBus_1
   2615                                          return (errorstatus);
   2616                                  }
   2617          
   2618                                  /*!< Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
   2619                                  SDIO_CmdInitStructure.SDIO_Argument = 0x00;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6360             STR      R0,[R4, #+52]
   2620                                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_SD_SET_BUSWIDTH;
   \   000000BE   0x2006             MOVS     R0,#+6
   \   000000C0   0x63A0             STR      R0,[R4, #+56]
   2621                                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000C2   0x2040             MOVS     R0,#+64
   \   000000C4   0x63E0             STR      R0,[R4, #+60]
   2622                                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x6420             STR      R0,[R4, #+64]
   2623                                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000CA   0x6465             STR      R5,[R4, #+68]
   2624                                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000CC   0xF104 0x0034      ADD      R0,R4,#+52
   \   000000D0   0x.... 0x....      BL       SDIO_SendCommand
   2625          
   2626                                  errorstatus = CmdResp1Error (SD_CMD_APP_SD_SET_BUSWIDTH );
   \   000000D4   0x2006             MOVS     R0,#+6
   \   000000D6   0x.... 0x....      BL       CmdResp1Error
   2627          
   2628                                  if (errorstatus != SD_OK) {
   \   000000DA   0x0001             MOVS     R1,R0
   \   000000DC   0xD102             BNE.N    ??SDEnWideBus_1
   2629                                          return (errorstatus);
   2630                                  }
   2631          
   2632                                  return (errorstatus);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xBD3E             POP      {R1-R5,PC}
   2633                          }
   2634                          else {
   2635                                  errorstatus = SD_REQUEST_NOT_APPLICABLE;
   2636                                  return (errorstatus);
   \                     ??SDEnWideBus_3: (+1)
   \   000000E2   0x2025             MOVS     R0,#+37
   \                     ??SDEnWideBus_1: (+1)
   \   000000E4   0xBD3E             POP      {R1-R5,PC}       ;; return
   2637                          }
   2638                  }
   2639          }
   2640          
   2641          /**
   2642           * @brief  Checks if the SD card is in programming state.
   2643           * @param  pstatus: pointer to the variable that will contain the SD card state.
   2644           * @retval SD_Error: SD Card Error code.
   2645           */

   \                                 In section .text, align 2, keep-with-next
   2646          static SD_Error IsCardProgramming (uint8_t *pstatus)
   2647          {
   \                     IsCardProgramming: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2648                  SD_Error errorstatus = SD_OK;
   2649                  __IO uint32_t respR1 = 0, status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x9001             STR      R0,[SP, #+4]
   2650          
   2651                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable41
   \   0000000E   0x6EC1             LDR      R1,[R0, #+108]
   \   00000010   0x0409             LSLS     R1,R1,#+16
   \   00000012   0x6341             STR      R1,[R0, #+52]
   2652                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SEND_STATUS;
   \   00000014   0x210D             MOVS     R1,#+13
   \   00000016   0x6381             STR      R1,[R0, #+56]
   2653                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000018   0x2140             MOVS     R1,#+64
   \   0000001A   0x63C1             STR      R1,[R0, #+60]
   2654                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6401             STR      R1,[R0, #+64]
   2655                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000020   0xF44F 0x6180      MOV      R1,#+1024
   \   00000024   0x6441             STR      R1,[R0, #+68]
   2656                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000026   0x3034             ADDS     R0,R0,#+52
   \   00000028   0x.... 0x....      BL       SDIO_SendCommand
   2657          
   2658                  status = SDIO ->STA;
   \   0000002C   0x....             LDR.N    R0,??DataTable36  ;; 0x40012c34
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x9101             STR      R1,[SP, #+4]
   \   00000032   0xE001             B.N      ??IsCardProgramming_0
   2659                  while (!(status & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))) {
   2660                          status = SDIO ->STA;
   \                     ??IsCardProgramming_1: (+1)
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x9101             STR      R1,[SP, #+4]
   2661                  }
   \                     ??IsCardProgramming_0: (+1)
   \   00000038   0x9901             LDR      R1,[SP, #+4]
   \   0000003A   0xF011 0x0F45      TST      R1,#0x45
   \   0000003E   0xD0F9             BEQ.N    ??IsCardProgramming_1
   2662          
   2663                  if (status & SDIO_FLAG_CTIMEOUT) {
   \   00000040   0x9801             LDR      R0,[SP, #+4]
   \   00000042   0x0740             LSLS     R0,R0,#+29
   \   00000044   0xD504             BPL.N    ??IsCardProgramming_2
   2664                          errorstatus = SD_CMD_RSP_TIMEOUT;
   2665                          SDIO_ClearFlag (SDIO_FLAG_CTIMEOUT);
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x.... 0x....      BL       SDIO_ClearFlag
   2666                          return (errorstatus);
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xBD16             POP      {R1,R2,R4,PC}
   2667                  }
   2668                  else if (status & SDIO_FLAG_CCRCFAIL) {
   \                     ??IsCardProgramming_2: (+1)
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0x07C0             LSLS     R0,R0,#+31
   \   00000054   0xD504             BPL.N    ??IsCardProgramming_3
   2669                          errorstatus = SD_CMD_CRC_FAIL;
   2670                          SDIO_ClearFlag (SDIO_FLAG_CCRCFAIL);
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x.... 0x....      BL       SDIO_ClearFlag
   2671                          return (errorstatus);
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD16             POP      {R1,R2,R4,PC}
   2672                  }
   2673          
   2674                  status = (uint32_t) SDIO_GetCommandResponse ();
   \                     ??IsCardProgramming_3: (+1)
   \   00000060   0x.... 0x....      BL       SDIO_GetCommandResponse
   \   00000064   0x9001             STR      R0,[SP, #+4]
   2675          
   2676                  /*!< Check response received is of desired command */
   2677                  if (status != SD_CMD_SEND_STATUS ) {
   \   00000066   0x9801             LDR      R0,[SP, #+4]
   \   00000068   0x280D             CMP      R0,#+13
   \   0000006A   0xD13E             BNE.N    ??IsCardProgramming_4
   2678                          errorstatus = SD_ILLEGAL_CMD;
   2679                          return (errorstatus);
   2680                  }
   2681          
   2682                  /*!< Clear all the static flags */
   2683                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \   0000006C   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000070   0x.... 0x....      BL       SDIO_ClearFlag
   2684          
   2685                  /*!< We have received response, retrieve it for analysis  */
   2686                  respR1 = SDIO_GetResponse (SDIO_RESP1);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      BL       SDIO_GetResponse
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   2687          
   2688                  /*!< Find out card status */
   2689                  *pstatus = (uint8_t) ((respR1 >> 9) & 0x0000000F);
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x0A40             LSRS     R0,R0,#+9
   \   00000080   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000084   0x7020             STRB     R0,[R4, #+0]
   2690          
   2691                  if ((respR1 & SD_OCR_ERRORBITS )== SD_ALLZERO) {
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable42_4  ;; 0xfdffe008
   \   0000008C   0x4208             TST      R0,R1
   \   0000008E   0xD101             BNE.N    ??IsCardProgramming_5
   2692                          return (errorstatus);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xBD16             POP      {R1,R2,R4,PC}
   2693                  }
   2694          
   2695                  if (respR1 & SD_OCR_ADDR_OUT_OF_RANGE ) {
   \                     ??IsCardProgramming_5: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD501             BPL.N    ??IsCardProgramming_6
   2696                          return (SD_ADDR_OUT_OF_RANGE);
   \   0000009A   0x201C             MOVS     R0,#+28
   \   0000009C   0xBD16             POP      {R1,R2,R4,PC}
   2697                  }
   2698          
   2699                  if (respR1 & SD_OCR_ADDR_MISALIGNED ) {
   \                     ??IsCardProgramming_6: (+1)
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x0040             LSLS     R0,R0,#+1
   \   000000A2   0xD501             BPL.N    ??IsCardProgramming_7
   2700                          return (SD_ADDR_MISALIGNED);
   \   000000A4   0x2009             MOVS     R0,#+9
   \   000000A6   0xBD16             POP      {R1,R2,R4,PC}
   2701                  }
   2702          
   2703                  if (respR1 & SD_OCR_BLOCK_LEN_ERR ) {
   \                     ??IsCardProgramming_7: (+1)
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
   \   000000AA   0x0080             LSLS     R0,R0,#+2
   \   000000AC   0xD501             BPL.N    ??IsCardProgramming_8
   2704                          return (SD_BLOCK_LEN_ERR);
   \   000000AE   0x200A             MOVS     R0,#+10
   \   000000B0   0xBD16             POP      {R1,R2,R4,PC}
   2705                  }
   2706          
   2707                  if (respR1 & SD_OCR_ERASE_SEQ_ERR ) {
   \                     ??IsCardProgramming_8: (+1)
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x00C0             LSLS     R0,R0,#+3
   \   000000B6   0xD501             BPL.N    ??IsCardProgramming_9
   2708                          return (SD_ERASE_SEQ_ERR);
   \   000000B8   0x200B             MOVS     R0,#+11
   \   000000BA   0xBD16             POP      {R1,R2,R4,PC}
   2709                  }
   2710          
   2711                  if (respR1 & SD_OCR_BAD_ERASE_PARAM ) {
   \                     ??IsCardProgramming_9: (+1)
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0x0100             LSLS     R0,R0,#+4
   \   000000C0   0xD501             BPL.N    ??IsCardProgramming_10
   2712                          return (SD_BAD_ERASE_PARAM);
   \   000000C2   0x200C             MOVS     R0,#+12
   \   000000C4   0xBD16             POP      {R1,R2,R4,PC}
   2713                  }
   2714          
   2715                  if (respR1 & SD_OCR_WRITE_PROT_VIOLATION ) {
   \                     ??IsCardProgramming_10: (+1)
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x0140             LSLS     R0,R0,#+5
   \   000000CA   0xD501             BPL.N    ??IsCardProgramming_11
   2716                          return (SD_WRITE_PROT_VIOLATION);
   \   000000CC   0x200D             MOVS     R0,#+13
   \   000000CE   0xBD16             POP      {R1,R2,R4,PC}
   2717                  }
   2718          
   2719                  if (respR1 & SD_OCR_LOCK_UNLOCK_FAILED ) {
   \                     ??IsCardProgramming_11: (+1)
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0x01C0             LSLS     R0,R0,#+7
   \   000000D4   0xD501             BPL.N    ??IsCardProgramming_12
   2720                          return (SD_LOCK_UNLOCK_FAILED);
   \   000000D6   0x200E             MOVS     R0,#+14
   \   000000D8   0xBD16             POP      {R1,R2,R4,PC}
   2721                  }
   2722          
   2723                  if (respR1 & SD_OCR_COM_CRC_FAILED ) {
   \                     ??IsCardProgramming_12: (+1)
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x0200             LSLS     R0,R0,#+8
   \   000000DE   0xD501             BPL.N    ??IsCardProgramming_13
   2724                          return (SD_COM_CRC_FAILED);
   \   000000E0   0x200F             MOVS     R0,#+15
   \   000000E2   0xBD16             POP      {R1,R2,R4,PC}
   2725                  }
   2726          
   2727                  if (respR1 & SD_OCR_ILLEGAL_CMD ) {
   \                     ??IsCardProgramming_13: (+1)
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0x0240             LSLS     R0,R0,#+9
   \   000000E8   0xD501             BPL.N    ??IsCardProgramming_14
   2728                          return (SD_ILLEGAL_CMD);
   \                     ??IsCardProgramming_4: (+1)
   \   000000EA   0x2010             MOVS     R0,#+16
   \   000000EC   0xBD16             POP      {R1,R2,R4,PC}
   2729                  }
   2730          
   2731                  if (respR1 & SD_OCR_CARD_ECC_FAILED ) {
   \                     ??IsCardProgramming_14: (+1)
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x0280             LSLS     R0,R0,#+10
   \   000000F2   0xD501             BPL.N    ??IsCardProgramming_15
   2732                          return (SD_CARD_ECC_FAILED);
   \   000000F4   0x2011             MOVS     R0,#+17
   \   000000F6   0xBD16             POP      {R1,R2,R4,PC}
   2733                  }
   2734          
   2735                  if (respR1 & SD_OCR_CC_ERROR ) {
   \                     ??IsCardProgramming_15: (+1)
   \   000000F8   0x9800             LDR      R0,[SP, #+0]
   \   000000FA   0x02C0             LSLS     R0,R0,#+11
   \   000000FC   0xD501             BPL.N    ??IsCardProgramming_16
   2736                          return (SD_CC_ERROR);
   \   000000FE   0x2012             MOVS     R0,#+18
   \   00000100   0xBD16             POP      {R1,R2,R4,PC}
   2737                  }
   2738          
   2739                  if (respR1 & SD_OCR_GENERAL_UNKNOWN_ERROR ) {
   \                     ??IsCardProgramming_16: (+1)
   \   00000102   0x9800             LDR      R0,[SP, #+0]
   \   00000104   0x0300             LSLS     R0,R0,#+12
   \   00000106   0xD501             BPL.N    ??IsCardProgramming_17
   2740                          return (SD_GENERAL_UNKNOWN_ERROR);
   \   00000108   0x2013             MOVS     R0,#+19
   \   0000010A   0xBD16             POP      {R1,R2,R4,PC}
   2741                  }
   2742          
   2743                  if (respR1 & SD_OCR_STREAM_READ_UNDERRUN ) {
   \                     ??IsCardProgramming_17: (+1)
   \   0000010C   0x9800             LDR      R0,[SP, #+0]
   \   0000010E   0x0340             LSLS     R0,R0,#+13
   \   00000110   0xD501             BPL.N    ??IsCardProgramming_18
   2744                          return (SD_STREAM_READ_UNDERRUN);
   \   00000112   0x2014             MOVS     R0,#+20
   \   00000114   0xBD16             POP      {R1,R2,R4,PC}
   2745                  }
   2746          
   2747                  if (respR1 & SD_OCR_STREAM_WRITE_OVERRUN ) {
   \                     ??IsCardProgramming_18: (+1)
   \   00000116   0x9800             LDR      R0,[SP, #+0]
   \   00000118   0x0380             LSLS     R0,R0,#+14
   \   0000011A   0xD501             BPL.N    ??IsCardProgramming_19
   2748                          return (SD_STREAM_WRITE_OVERRUN);
   \   0000011C   0x2015             MOVS     R0,#+21
   \   0000011E   0xBD16             POP      {R1,R2,R4,PC}
   2749                  }
   2750          
   2751                  if (respR1 & SD_OCR_CID_CSD_OVERWRIETE ) {
   \                     ??IsCardProgramming_19: (+1)
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   \   00000122   0x03C0             LSLS     R0,R0,#+15
   \   00000124   0xD501             BPL.N    ??IsCardProgramming_20
   2752                          return (SD_CID_CSD_OVERWRITE);
   \   00000126   0x2016             MOVS     R0,#+22
   \   00000128   0xBD16             POP      {R1,R2,R4,PC}
   2753                  }
   2754          
   2755                  if (respR1 & SD_OCR_WP_ERASE_SKIP ) {
   \                     ??IsCardProgramming_20: (+1)
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0x0400             LSLS     R0,R0,#+16
   \   0000012E   0xD501             BPL.N    ??IsCardProgramming_21
   2756                          return (SD_WP_ERASE_SKIP);
   \   00000130   0x2017             MOVS     R0,#+23
   \   00000132   0xBD16             POP      {R1,R2,R4,PC}
   2757                  }
   2758          
   2759                  if (respR1 & SD_OCR_CARD_ECC_DISABLED ) {
   \                     ??IsCardProgramming_21: (+1)
   \   00000134   0x9800             LDR      R0,[SP, #+0]
   \   00000136   0x0440             LSLS     R0,R0,#+17
   \   00000138   0xD501             BPL.N    ??IsCardProgramming_22
   2760                          return (SD_CARD_ECC_DISABLED);
   \   0000013A   0x2018             MOVS     R0,#+24
   \   0000013C   0xBD16             POP      {R1,R2,R4,PC}
   2761                  }
   2762          
   2763                  if (respR1 & SD_OCR_ERASE_RESET ) {
   \                     ??IsCardProgramming_22: (+1)
   \   0000013E   0x9800             LDR      R0,[SP, #+0]
   \   00000140   0x0480             LSLS     R0,R0,#+18
   \   00000142   0xD501             BPL.N    ??IsCardProgramming_23
   2764                          return (SD_ERASE_RESET);
   \   00000144   0x2019             MOVS     R0,#+25
   \   00000146   0xBD16             POP      {R1,R2,R4,PC}
   2765                  }
   2766          
   2767                  if (respR1 & SD_OCR_AKE_SEQ_ERROR ) {
   \                     ??IsCardProgramming_23: (+1)
   \   00000148   0x9800             LDR      R0,[SP, #+0]
   \   0000014A   0x0700             LSLS     R0,R0,#+28
   \   0000014C   0xD501             BPL.N    ??IsCardProgramming_24
   2768                          return (SD_AKE_SEQ_ERROR);
   \   0000014E   0x201A             MOVS     R0,#+26
   \   00000150   0xBD16             POP      {R1,R2,R4,PC}
   2769                  }
   2770          
   2771                  return (errorstatus);
   \                     ??IsCardProgramming_24: (+1)
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2772          }
   2773          
   2774          /**
   2775           * @brief  Find the SD card SCR register value.
   2776           * @param  rca: selected card address.
   2777           * @param  pscr: pointer to the buffer that will contain the SCR value.
   2778           * @retval SD_Error: SD Card Error code.
   2779           */

   \                                 In section .text, align 2, keep-with-next
   2780          static SD_Error FindSCR (uint16_t rca, uint32_t *pscr)
   2781          {
   \                     FindSCR: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
   2782                  uint32_t index = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   2783                  SD_Error errorstatus = SD_OK;
   2784                  uint32_t tempscr[2] = { 0, 0 };
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x460A             MOV      R2,R1
   \   0000000E   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
   2785          
   2786                  /*!< Set Block Size To 8 Bytes */
   2787                  /*!< Send CMD55 APP_CMD with argument as card's RCA */
   2788                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) 8;
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable41
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x6370             STR      R0,[R6, #+52]
   2789                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x63B0             STR      R0,[R6, #+56]
   2790                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000001E   0x2040             MOVS     R0,#+64
   \   00000020   0x63F0             STR      R0,[R6, #+60]
   2791                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x6430             STR      R0,[R6, #+64]
   2792                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000026   0xF44F 0x6780      MOV      R7,#+1024
   \   0000002A   0x6477             STR      R7,[R6, #+68]
   2793                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000002C   0xF106 0x0034      ADD      R0,R6,#+52
   \   00000030   0x.... 0x....      BL       SDIO_SendCommand
   2794          
   2795                  errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   00000034   0x2010             MOVS     R0,#+16
   \   00000036   0x.... 0x....      BL       CmdResp1Error
   2796          
   2797                  if (errorstatus != SD_OK) {
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xF040 0x8098      BNE.W    ??FindSCR_0
   2798                          return (errorstatus);
   2799                  }
   2800          
   2801                  /*!< Send CMD55 APP_CMD with argument as card's RCA */
   2802                  SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) RCA << 16;
   \   00000040   0x6EF0             LDR      R0,[R6, #+108]
   \   00000042   0x0400             LSLS     R0,R0,#+16
   \   00000044   0x6370             STR      R0,[R6, #+52]
   2803                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_APP_CMD;
   \   00000046   0x2037             MOVS     R0,#+55
   \   00000048   0x63B0             STR      R0,[R6, #+56]
   2804                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   0000004A   0x2040             MOVS     R0,#+64
   \   0000004C   0x63F0             STR      R0,[R6, #+60]
   2805                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x6430             STR      R0,[R6, #+64]
   2806                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   00000052   0x6477             STR      R7,[R6, #+68]
   2807                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000054   0xF106 0x0034      ADD      R0,R6,#+52
   \   00000058   0x.... 0x....      BL       SDIO_SendCommand
   2808          
   2809                  errorstatus = CmdResp1Error (SD_CMD_APP_CMD );
   \   0000005C   0x2037             MOVS     R0,#+55
   \   0000005E   0x.... 0x....      BL       CmdResp1Error
   2810          
   2811                  if (errorstatus != SD_OK) {
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xF040 0x8084      BNE.W    ??FindSCR_0
   2812                          return (errorstatus);
   2813                  }
   2814                  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   00000068   0xF04F 0x30FF      MOV      R0,#-1
   \   0000006C   0x61F0             STR      R0,[R6, #+28]
   2815                  SDIO_DataInitStructure.SDIO_DataLength = 8;
   \   0000006E   0x2008             MOVS     R0,#+8
   \   00000070   0x6230             STR      R0,[R6, #+32]
   2816                  SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_8b;
   \   00000072   0x2030             MOVS     R0,#+48
   \   00000074   0x6270             STR      R0,[R6, #+36]
   2817                  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x62B0             STR      R0,[R6, #+40]
   2818                  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0x62F0             STR      R0,[R6, #+44]
   2819                  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x6330             STR      R0,[R6, #+48]
   2820                  SDIO_DataConfig (&SDIO_DataInitStructure);
   \   00000082   0xF106 0x001C      ADD      R0,R6,#+28
   \   00000086   0x.... 0x....      BL       SDIO_DataConfig
   2821          
   2822                  /*!< Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
   2823                  SDIO_CmdInitStructure.SDIO_Argument = 0x0;
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x6370             STR      R0,[R6, #+52]
   2824                  SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SD_APP_SEND_SCR;
   \   0000008E   0x2033             MOVS     R0,#+51
   \   00000090   0x63B0             STR      R0,[R6, #+56]
   2825                  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000092   0x2040             MOVS     R0,#+64
   \   00000094   0x63F0             STR      R0,[R6, #+60]
   2826                  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x6430             STR      R0,[R6, #+64]
   2827                  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   0000009A   0x6477             STR      R7,[R6, #+68]
   2828                  SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   0000009C   0xF106 0x0034      ADD      R0,R6,#+52
   \   000000A0   0x.... 0x....      BL       SDIO_SendCommand
   2829          
   2830                  errorstatus = CmdResp1Error (SD_CMD_SD_APP_SEND_SCR );
   \   000000A4   0x2033             MOVS     R0,#+51
   \   000000A6   0x.... 0x....      BL       CmdResp1Error
   \   000000AA   0x4680             MOV      R8,R0
   2831          
   2832                  if (errorstatus != SD_OK) {
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD00C             BEQ.N    ??FindSCR_1
   2833                          return (errorstatus);
   \   000000B0   0xE05E             B.N      ??FindSCR_0
   2834                  }
   2835          
   2836                  while (!(SDIO ->STA & (SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))) {
   2837                          if (SDIO_GetFlagStatus (SDIO_FLAG_RXDAVL) != RESET) {
   \                     ??FindSCR_2: (+1)
   \   000000B2   0xF44F 0x1000      MOV      R0,#+2097152
   \   000000B6   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD005             BEQ.N    ??FindSCR_1
   2838                                  *(tempscr + index) = SDIO_ReadData ();
   \   000000BE   0x.... 0x....      BL       SDIO_ReadData
   \   000000C2   0x4669             MOV      R1,SP
   \   000000C4   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   2839                                  index++;
   \   000000C8   0x1C6D             ADDS     R5,R5,#+1
   2840                          }
   2841                  }
   \                     ??FindSCR_1: (+1)
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable42_1  ;; 0x40012c34
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF240 0x612A      MOVW     R1,#+1578
   \   000000D4   0x4208             TST      R0,R1
   \   000000D6   0xD0EC             BEQ.N    ??FindSCR_2
   2842          
   2843                  if (SDIO_GetFlagStatus (SDIO_FLAG_DTIMEOUT) != RESET) {
   \   000000D8   0x2008             MOVS     R0,#+8
   \   000000DA   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD004             BEQ.N    ??FindSCR_3
   2844                          SDIO_ClearFlag (SDIO_FLAG_DTIMEOUT);
   \   000000E2   0x2008             MOVS     R0,#+8
   \   000000E4   0x.... 0x....      BL       SDIO_ClearFlag
   2845                          errorstatus = SD_DATA_TIMEOUT;
   2846                          return (errorstatus);
   \   000000E8   0x2004             MOVS     R0,#+4
   \   000000EA   0xE041             B.N      ??FindSCR_0
   2847                  }
   2848                  else if (SDIO_GetFlagStatus (SDIO_FLAG_DCRCFAIL) != RESET) {
   \                     ??FindSCR_3: (+1)
   \   000000EC   0x2002             MOVS     R0,#+2
   \   000000EE   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD004             BEQ.N    ??FindSCR_4
   2849                          SDIO_ClearFlag (SDIO_FLAG_DCRCFAIL);
   \   000000F6   0x2002             MOVS     R0,#+2
   \   000000F8   0x.... 0x....      BL       SDIO_ClearFlag
   2850                          errorstatus = SD_DATA_CRC_FAIL;
   2851                          return (errorstatus);
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0xE037             B.N      ??FindSCR_0
   2852                  }
   2853                  else if (SDIO_GetFlagStatus (SDIO_FLAG_RXOVERR) != RESET) {
   \                     ??FindSCR_4: (+1)
   \   00000100   0x2020             MOVS     R0,#+32
   \   00000102   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD004             BEQ.N    ??FindSCR_5
   2854                          SDIO_ClearFlag (SDIO_FLAG_RXOVERR);
   \   0000010A   0x2020             MOVS     R0,#+32
   \   0000010C   0x.... 0x....      BL       SDIO_ClearFlag
   2855                          errorstatus = SD_RX_OVERRUN;
   2856                          return (errorstatus);
   \   00000110   0x2006             MOVS     R0,#+6
   \   00000112   0xE02D             B.N      ??FindSCR_0
   2857                  }
   2858                  else if (SDIO_GetFlagStatus (SDIO_FLAG_STBITERR) != RESET) {
   \                     ??FindSCR_5: (+1)
   \   00000114   0xF44F 0x7000      MOV      R0,#+512
   \   00000118   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD005             BEQ.N    ??FindSCR_6
   2859                          SDIO_ClearFlag (SDIO_FLAG_STBITERR);
   \   00000120   0xF44F 0x7000      MOV      R0,#+512
   \   00000124   0x.... 0x....      BL       SDIO_ClearFlag
   2860                          errorstatus = SD_START_BIT_ERR;
   2861                          return (errorstatus);
   \   00000128   0x2007             MOVS     R0,#+7
   \   0000012A   0xE021             B.N      ??FindSCR_0
   2862                  }
   2863          
   2864                  /*!< Clear all the static flags */
   2865                  SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??FindSCR_6: (+1)
   \   0000012C   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000130   0x.... 0x....      BL       SDIO_ClearFlag
   2866          
   2867                  *(pscr + 1) = ((tempscr[0] & SD_0TO7BITS )<< 24)|((tempscr[0] & SD_8TO15BITS )<< 8)|((tempscr[0] & SD_16TO23BITS )>> 8)|((tempscr[0] & SD_24TO31BITS )>> 24);
   \   00000134   0x9800             LDR      R0,[SP, #+0]
   \   00000136   0x4601             MOV      R1,R0
   \   00000138   0x0209             LSLS     R1,R1,#+8
   \   0000013A   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \   0000013E   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000142   0x9900             LDR      R1,[SP, #+0]
   \   00000144   0x0A09             LSRS     R1,R1,#+8
   \   00000146   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   0000014A   0x4308             ORRS     R0,R1,R0
   \   0000014C   0x9900             LDR      R1,[SP, #+0]
   \   0000014E   0xEA40 0x6011      ORR      R0,R0,R1, LSR #+24
   \   00000152   0x6060             STR      R0,[R4, #+4]
   \   00000154   0x9801             LDR      R0,[SP, #+4]
   \   00000156   0x0201             LSLS     R1,R0,#+8
   \   00000158   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \   0000015C   0xEA41 0x6100      ORR      R1,R1,R0, LSL #+24
   \   00000160   0x0A02             LSRS     R2,R0,#+8
   \   00000162   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   00000166   0x4311             ORRS     R1,R2,R1
   \   00000168   0xEA41 0x6010      ORR      R0,R1,R0, LSR #+24
   \   0000016C   0x6020             STR      R0,[R4, #+0]
   2868          
   2869                  *(pscr) = ((tempscr[1] & SD_0TO7BITS )<< 24)|((tempscr[1] & SD_8TO15BITS )<< 8)|((tempscr[1] & SD_16TO23BITS )>> 8)|((tempscr[1] & SD_24TO31BITS )>> 24);
   2870          
   2871                  return (errorstatus);
   \   0000016E   0x4640             MOV      R0,R8
   \                     ??FindSCR_0: (+1)
   \   00000170   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2872          }
   2873          
   2874          /**
   2875           * @brief  Converts the number of bytes in power of two and returns the power.
   2876           * @param  NumberOfBytes: number of bytes.
   2877           * @retval None
   2878           */

   \                                 In section .text, align 2, keep-with-next
   2879          uint8_t convert_from_bytes_to_power_of_two (uint16_t NumberOfBytes)
   2880          {
   2881                  uint8_t count = 0;
   \                     convert_from_bytes_to_power_of_two: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??convert_from_bytes_to_power_of_two_0
   2882          
   2883                  while (NumberOfBytes != 1) {
   2884                          NumberOfBytes >>= 1;
   \                     ??convert_from_bytes_to_power_of_two_1: (+1)
   \   00000004   0x0840             LSRS     R0,R0,#+1
   2885                          count++;
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   2886                  }
   \                     ??convert_from_bytes_to_power_of_two_0: (+1)
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD1FB             BNE.N    ??convert_from_bytes_to_power_of_two_1
   2887                  return (count);
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x4770             BX       LR               ;; return
   2888          }
   2889          
   2890          /**
   2891           * @brief  Switch mode High-Speed
   2892           * @note   This function must be used after "Transfer State"
   2893           * @note   This operation should be followed by the configuration
   2894           *         of PLL to have SDIOCK clock between 67 and 75 MHz
   2895           * @param  None
   2896           * @retval SD_Error: SD Card Error code.
   2897           */

   \                                 In section .text, align 2, keep-with-next
   2898          SD_Error SD_HighSpeed (void)
   2899          {
   \                     SD_HighSpeed: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB092             SUB      SP,SP,#+72
   2900                  SD_Error errorstatus = SD_OK;
   2901                  uint32_t scr[2] = { 0, 0 };
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x460A             MOV      R2,R1
   \   0000000C   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
   2902                  uint32_t SD_SPEC = 0;
   \   00000010   0x460D             MOV      R5,R1
   2903                  uint8_t hs[64] = { 0 };
   \   00000012   0xA802             ADD      R0,SP,#+8
   \   00000014   0x2140             MOVS     R1,#+64
   \   00000016   0x.... 0x....      BL       __aeabi_memclr4
   2904                  uint32_t count = 0, *tempbuff = (uint32_t *) hs;
   \   0000001A   0xAC02             ADD      R4,SP,#+8
   2905                  TransferError = SD_OK;
   \   0000001C   0x....             LDR.N    R6,??DataTable41
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x7630             STRB     R0,[R6, #+24]
   2906                  TransferEnd = 0;
   \   00000022   0x6770             STR      R0,[R6, #+116]
   2907                  StopCondition = 0;
   \   00000024   0x6730             STR      R0,[R6, #+112]
   2908          
   2909                  SDIO ->DCTRL = 0x0;
   \   00000026   0x.... 0x....      LDR.W    R7,??DataTable42_5  ;; 0x40012c2c
   \   0000002A   0x6038             STR      R0,[R7, #+0]
   2910          
   2911                  /*!< Get SCR Register */
   2912                  errorstatus = FindSCR (RCA, scr);
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x6EF0             LDR      R0,[R6, #+108]
   \   00000030   0xB280             UXTH     R0,R0
   \   00000032   0x.... 0x....      BL       FindSCR
   2913          
   2914                  if (errorstatus != SD_OK) {
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0xF040 0x809A      BNE.W    ??SD_HighSpeed_0
   2915                          return (errorstatus);
   2916                  }
   2917          
   2918                  /* Test the Version supported by the card*/
   2919                  SD_SPEC = (scr[1] & 0x01000000) || (scr[1] & 0x02000000);
   \   0000003C   0x9901             LDR      R1,[SP, #+4]
   \   0000003E   0xF011 0x7F40      TST      R1,#0x3000000
   \   00000042   0xD000             BEQ.N    ??SD_HighSpeed_1
   \   00000044   0x2501             MOVS     R5,#+1
   2920          
   2921                  if (SD_SPEC != SD_ALLZERO ) {
   \                     ??SD_HighSpeed_1: (+1)
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xF000 0x8092      BEQ.W    ??SD_HighSpeed_0
   2922                          /* Set Block Size for Card */
   2923                          SDIO_CmdInitStructure.SDIO_Argument = (uint32_t) 64;
   \   0000004C   0x2040             MOVS     R0,#+64
   \   0000004E   0x6370             STR      R0,[R6, #+52]
   2924                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_SET_BLOCKLEN;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0x63B0             STR      R0,[R6, #+56]
   2925                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   00000054   0x2040             MOVS     R0,#+64
   \   00000056   0x63F0             STR      R0,[R6, #+60]
   2926                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6430             STR      R0,[R6, #+64]
   2927                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   0000005C   0xF44F 0x6580      MOV      R5,#+1024
   \   00000060   0x6475             STR      R5,[R6, #+68]
   2928                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   00000062   0xF106 0x0034      ADD      R0,R6,#+52
   \   00000066   0x.... 0x....      BL       SDIO_SendCommand
   2929                          errorstatus = CmdResp1Error (SD_CMD_SET_BLOCKLEN );
   \   0000006A   0x2010             MOVS     R0,#+16
   \   0000006C   0x.... 0x....      BL       CmdResp1Error
   2930                          if (errorstatus != SD_OK) {
   \   00000070   0x0001             MOVS     R1,R0
   \   00000072   0xD17D             BNE.N    ??SD_HighSpeed_0
   2931                                  return (errorstatus);
   2932                          }
   2933                          SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
   \   00000074   0xF04F 0x38FF      MOV      R8,#-1
   \   00000078   0xF8C6 0x801C      STR      R8,[R6, #+28]
   2934                          SDIO_DataInitStructure.SDIO_DataLength = 64;
   \   0000007C   0x2040             MOVS     R0,#+64
   \   0000007E   0x6230             STR      R0,[R6, #+32]
   2935                          SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_64b;
   \   00000080   0x2060             MOVS     R0,#+96
   \   00000082   0x6270             STR      R0,[R6, #+36]
   2936                          SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x62B0             STR      R0,[R6, #+40]
   2937                          SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x62F0             STR      R0,[R6, #+44]
   2938                          SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Enable;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x6330             STR      R0,[R6, #+48]
   2939                          SDIO_DataConfig (&SDIO_DataInitStructure);
   \   00000090   0xF106 0x001C      ADD      R0,R6,#+28
   \   00000094   0x.... 0x....      BL       SDIO_DataConfig
   2940          
   2941                          /*!< Send CMD6 switch mode */
   2942                          SDIO_CmdInitStructure.SDIO_Argument = 0x80FFFF01;
   \   00000098   0x....             LDR.N    R0,??DataTable42_6  ;; 0x80ffff01
   \   0000009A   0x6370             STR      R0,[R6, #+52]
   2943                          SDIO_CmdInitStructure.SDIO_CmdIndex = SD_CMD_HS_SWITCH;
   \   0000009C   0x2006             MOVS     R0,#+6
   \   0000009E   0x63B0             STR      R0,[R6, #+56]
   2944                          SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
   \   000000A0   0x2040             MOVS     R0,#+64
   \   000000A2   0x63F0             STR      R0,[R6, #+60]
   2945                          SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x6430             STR      R0,[R6, #+64]
   2946                          SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
   \   000000A8   0x6475             STR      R5,[R6, #+68]
   2947                          SDIO_SendCommand (&SDIO_CmdInitStructure);
   \   000000AA   0xF106 0x0034      ADD      R0,R6,#+52
   \   000000AE   0x.... 0x....      BL       SDIO_SendCommand
   2948                          errorstatus = CmdResp1Error (SD_CMD_HS_SWITCH );
   \   000000B2   0x2006             MOVS     R0,#+6
   \   000000B4   0x.... 0x....      BL       CmdResp1Error
   2949          
   2950                          if (errorstatus != SD_OK) {
   \   000000B8   0x0001             MOVS     R1,R0
   \   000000BA   0xD159             BNE.N    ??SD_HighSpeed_0
   \   000000BC   0xE007             B.N      ??SD_HighSpeed_2
   2951                                  return (errorstatus);
   2952                          }
   2953                          while (!(SDIO ->STA & (SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))) {
   2954                                  if (SDIO_GetFlagStatus (SDIO_FLAG_RXFIFOHF) != RESET) {
   2955                                          for (count = 0; count < 8; count++) {
   2956                                                  *(tempbuff + count) = SDIO_ReadData ();
   \                     ??SD_HighSpeed_3: (+1)
   \   000000BE   0x.... 0x....      BL       SDIO_ReadData
   \   000000C2   0xF844 0x0025      STR      R0,[R4, R5, LSL #+2]
   2957                                          }
   \   000000C6   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SD_HighSpeed_4: (+1)
   \   000000C8   0x2D08             CMP      R5,#+8
   \   000000CA   0xD3F8             BCC.N    ??SD_HighSpeed_3
   2958                                          tempbuff += 8;
   \   000000CC   0x3420             ADDS     R4,R4,#+32
   \                     ??SD_HighSpeed_2: (+1)
   \   000000CE   0x68B8             LDR      R0,[R7, #+8]
   \   000000D0   0xF240 0x612A      MOVW     R1,#+1578
   \   000000D4   0x4208             TST      R0,R1
   \   000000D6   0xD107             BNE.N    ??SD_HighSpeed_5
   \   000000D8   0xF44F 0x4000      MOV      R0,#+32768
   \   000000DC   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD0F4             BEQ.N    ??SD_HighSpeed_2
   \   000000E4   0x2500             MOVS     R5,#+0
   \   000000E6   0xE7EF             B.N      ??SD_HighSpeed_4
   2959                                  }
   2960                          }
   2961          
   2962                          if (SDIO_GetFlagStatus (SDIO_FLAG_DTIMEOUT) != RESET) {
   \                     ??SD_HighSpeed_5: (+1)
   \   000000E8   0x2008             MOVS     R0,#+8
   \   000000EA   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD004             BEQ.N    ??SD_HighSpeed_6
   2963                                  SDIO_ClearFlag (SDIO_FLAG_DTIMEOUT);
   \   000000F2   0x2008             MOVS     R0,#+8
   \   000000F4   0x.... 0x....      BL       SDIO_ClearFlag
   2964                                  errorstatus = SD_DATA_TIMEOUT;
   2965                                  return (errorstatus);
   \   000000F8   0x2004             MOVS     R0,#+4
   \   000000FA   0xE039             B.N      ??SD_HighSpeed_0
   2966                          }
   2967                          else if (SDIO_GetFlagStatus (SDIO_FLAG_DCRCFAIL) != RESET) {
   \                     ??SD_HighSpeed_6: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD004             BEQ.N    ??SD_HighSpeed_7
   2968                                  SDIO_ClearFlag (SDIO_FLAG_DCRCFAIL);
   \   00000106   0x2002             MOVS     R0,#+2
   \   00000108   0x.... 0x....      BL       SDIO_ClearFlag
   2969                                  errorstatus = SD_DATA_CRC_FAIL;
   2970                                  return (errorstatus);
   \   0000010C   0x2002             MOVS     R0,#+2
   \   0000010E   0xE02F             B.N      ??SD_HighSpeed_0
   2971                          }
   2972                          else if (SDIO_GetFlagStatus (SDIO_FLAG_RXOVERR) != RESET) {
   \                     ??SD_HighSpeed_7: (+1)
   \   00000110   0x2020             MOVS     R0,#+32
   \   00000112   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD004             BEQ.N    ??SD_HighSpeed_8
   2973                                  SDIO_ClearFlag (SDIO_FLAG_RXOVERR);
   \   0000011A   0x2020             MOVS     R0,#+32
   \   0000011C   0x.... 0x....      BL       SDIO_ClearFlag
   2974                                  errorstatus = SD_RX_OVERRUN;
   2975                                  return (errorstatus);
   \   00000120   0x2006             MOVS     R0,#+6
   \   00000122   0xE025             B.N      ??SD_HighSpeed_0
   2976                          }
   2977                          else if (SDIO_GetFlagStatus (SDIO_FLAG_STBITERR) != RESET) {
   \                     ??SD_HighSpeed_8: (+1)
   \   00000124   0xF44F 0x7000      MOV      R0,#+512
   \   00000128   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD005             BEQ.N    ??SD_HighSpeed_9
   2978                                  SDIO_ClearFlag (SDIO_FLAG_STBITERR);
   \   00000130   0xF44F 0x7000      MOV      R0,#+512
   \   00000134   0x.... 0x....      BL       SDIO_ClearFlag
   2979                                  errorstatus = SD_START_BIT_ERR;
   2980                                  return (errorstatus);
   \   00000138   0x2007             MOVS     R0,#+7
   \   0000013A   0xE019             B.N      ??SD_HighSpeed_0
   2981                          }
   2982                          count = SD_DATATIMEOUT;
   \                     ??SD_HighSpeed_9: (+1)
   \   0000013C   0x4645             MOV      R5,R8
   \   0000013E   0xE004             B.N      ??SD_HighSpeed_10
   2983                          while ((SDIO_GetFlagStatus (SDIO_FLAG_RXDAVL) != RESET) && (count > 0)) {
   2984                                  *tempbuff = SDIO_ReadData ();
   \                     ??SD_HighSpeed_11: (+1)
   \   00000140   0x.... 0x....      BL       SDIO_ReadData
   \   00000144   0xF844 0x0B04      STR      R0,[R4], #+4
   2985                                  tempbuff++;
   2986                                  count--;
   \   00000148   0x1E6D             SUBS     R5,R5,#+1
   2987                          }
   \                     ??SD_HighSpeed_10: (+1)
   \   0000014A   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000014E   0x.... 0x....      BL       SDIO_GetFlagStatus
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD001             BEQ.N    ??SD_HighSpeed_12
   \   00000156   0x2D00             CMP      R5,#+0
   \   00000158   0xD1F2             BNE.N    ??SD_HighSpeed_11
   2988          
   2989                          /*!< Clear all the static flags */
   2990                          SDIO_ClearFlag (SDIO_STATIC_FLAGS );
   \                     ??SD_HighSpeed_12: (+1)
   \   0000015A   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000015E   0x.... 0x....      BL       SDIO_ClearFlag
   2991          
   2992                          /* Test if the switch mode HS is ok */
   2993                          if ((hs[13] & 0x2) == 0x2) {
   \   00000162   0xF89D 0x0015      LDRB     R0,[SP, #+21]
   \   00000166   0x0780             LSLS     R0,R0,#+30
   \   00000168   0xD501             BPL.N    ??SD_HighSpeed_13
   2994                                  errorstatus = SD_OK;
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0xE000             B.N      ??SD_HighSpeed_0
   2995                          }
   2996                          else {
   2997                                  errorstatus = SD_UNSUPPORTED_FEATURE;
   \                     ??SD_HighSpeed_13: (+1)
   \   0000016E   0x2027             MOVS     R0,#+39
   2998                          }
   2999                  }
   3000                  return (errorstatus);
   \                     ??SD_HighSpeed_0: (+1)
   \   00000170   0xB012             ADD      SP,SP,#+72
   \   00000172   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3001          }
   3002          
   3003          /**
   3004           ******************************************************************************
   3005           * @author  MCD Application Team (modified by lukasz.iwaszkiewicz@gmail.com)
   3006           * @version V1.0.3
   3007           * @date    13-November-2013
   3008           * @brief   This file provides
   3009           *            - set of firmware functions to manage Leds, push-button and COM ports
   3010           *            - low level initialization functions for SD card (on SDIO) and EEPROM
   3011           *          available on STM324x9I-EVAL evaluation board(MB1045) RevB from
   3012           *          STMicroelectronics.
   3013           ******************************************************************************
   3014           * @attention
   3015           *
   3016           * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
   3017           *
   3018           * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
   3019           * You may not use this file except in compliance with the License.
   3020           * You may obtain a copy of the License at:
   3021           *
   3022           *        http://www.st.com/software_license_agreement_liberty_v2
   3023           *
   3024           * Unless required by applicable law or agreed to in writing, software
   3025           * distributed under the License is distributed on an "AS IS" BASIS,
   3026           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   3027           * See the License for the specific language governing permissions and
   3028           * limitations under the License.
   3029           *
   3030           ******************************************************************************
   3031           */
   3032          
   3033          /**
   3034           * @brief  DeInitializes the SDIO interface.
   3035           * @param  None
   3036           * @retval None
   3037           */

   \                                 In section .text, align 2, keep-with-next
   3038          void SD_LowLevel_DeInit (void)
   3039          {
   \                     SD_LowLevel_DeInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   3040              GPIO_InitTypeDef GPIO_InitStructure;
   3041          
   3042              /*!< Disable SDIO Clock */
   3043              SDIO_ClockCmd (DISABLE);
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       SDIO_ClockCmd
   3044          
   3045              /*!< Set Power State to OFF */
   3046              SDIO_SetPowerState (SDIO_PowerState_OFF);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       SDIO_SetPowerState
   3047          
   3048              /*!< DeInitializes the SDIO peripheral */
   3049              SDIO_DeInit ();
   \   00000010   0x.... 0x....      BL       SDIO_DeInit
   3050          
   3051              /* Disable the SDIO APB2 Clock */
   3052              RCC_APB2PeriphClockCmd (RCC_APB2Periph_SDIO, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF44F 0x6000      MOV      R0,#+2048
   \   0000001A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   3053          
   3054          #if FATFS_SDIO_4BIT == 1
   3055          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource8, GPIO_AF_MCO);		//D0
   \   0000001E   0x....             LDR.N    R4,??DataTable42_7  ;; 0x40020800
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x2108             MOVS     R1,#+8
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       GPIO_PinAFConfig
   3056          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource9, GPIO_AF_MCO);		//D1
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2109             MOVS     R1,#+9
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       GPIO_PinAFConfig
   3057          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource10, GPIO_AF_MCO);	//D2
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x210A             MOVS     R1,#+10
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       GPIO_PinAFConfig
   3058          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource11, GPIO_AF_MCO);	//D3
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x210B             MOVS     R1,#+11
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       GPIO_PinAFConfig
   3059          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource12, GPIO_AF_MCO);	//CLK
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x210C             MOVS     R1,#+12
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       GPIO_PinAFConfig
   3060          		GPIO_PinAFConfig (GPIOD, GPIO_PinSource2, GPIO_AF_MCO);		//CMD
   \   00000052   0x....             LDR.N    R5,??DataTable42_8  ;; 0x40020c00
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0x.... 0x....      BL       GPIO_PinAFConfig
   3061          		//							  D0		   D1			D2			  D3
   3062          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
   \   0000005E   0xF44F 0x6070      MOV      R0,#+3840
   \   00000062   0x9000             STR      R0,[SP, #+0]
   3063          #else
   3064          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource8, GPIO_AF_MCO);		//D0
   3065          		GPIO_PinAFConfig (GPIOC, GPIO_PinSource12, GPIO_AF_MCO);	//CLK
   3066          		GPIO_PinAFConfig (GPIOD, GPIO_PinSource2, GPIO_AF_MCO);		//CMD
   3067          		
   3068          		//							  D0
   3069          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
   3070          #endif
   3071          
   3072              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF88D 0x0004      STRB     R0,[SP, #+4]
   3073              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   0000006A   0xF88D 0x0007      STRB     R0,[SP, #+7]
   3074              GPIO_Init (GPIOC, &GPIO_InitStructure);
   \   0000006E   0x4669             MOV      R1,SP
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       GPIO_Init
   3075          
   3076              /* Configure PD.02 CMD line */
   3077              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0x9000             STR      R0,[SP, #+0]
   3078              GPIO_Init (GPIOD, &GPIO_InitStructure);
   \   0000007A   0x4669             MOV      R1,SP
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       GPIO_Init
   3079          
   3080              /* Configure PC.12 pin: CLK pin */
   3081              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
   \   00000082   0xF44F 0x5080      MOV      R0,#+4096
   \   00000086   0x9000             STR      R0,[SP, #+0]
   3082              GPIO_Init (GPIOC, &GPIO_InitStructure);
   \   00000088   0x4669             MOV      R1,SP
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       GPIO_Init
   3083          }
   \   00000090   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   3084          
   3085          /**
   3086           * @brief  Initializes the SD Card and put it into StandBy State (Ready for
   3087           *         data transfer).
   3088           * @param  None
   3089           * @retval None
   3090           */

   \                                 In section .text, align 2, keep-with-next
   3091          void SD_LowLevel_Init (void)
   3092          {
   \                     SD_LowLevel_Init: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   3093                  GPIO_InitTypeDef GPIO_InitStructure;
   3094          		NVIC_InitTypeDef NVIC_InitStructure;
   3095          
   3096              /* GPIOC and GPIOD Periph clock enable */
   3097              RCC_AHB1PeriphClockCmd (RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOD, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x200C             MOVS     R0,#+12
   \   00000006   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   3098          
   3099          		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   0000000A   0xF44F 0x60A0      MOV      R0,#+1280
   \   0000000E   0x.... 0x....      BL       NVIC_PriorityGroupConfig
   3100          
   3101          		NVIC_InitStructure.NVIC_IRQChannel					 = SDIO_IRQn;
   \   00000012   0x2031             MOVS     R0,#+49
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3102          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3103          		NVIC_InitStructure.NVIC_IRQChannelSubPriority		 = 0;
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
   3104          		NVIC_InitStructure.NVIC_IRQChannelCmd				 = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
   3105          		NVIC_Init(&NVIC_InitStructure);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       NVIC_Init
   3106          
   3107          		NVIC_InitStructure.NVIC_IRQChannel					 = SD_SDIO_DMA_IRQn;
   \   0000002E   0x203B             MOVS     R0,#+59
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3108          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3109          		NVIC_InitStructure.NVIC_IRQChannelSubPriority		 = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   3110          		NVIC_InitStructure.NVIC_IRQChannelCmd				 = ENABLE;
   \   00000040   0xF88D 0x0003      STRB     R0,[SP, #+3]
   3111          		NVIC_Init(&NVIC_InitStructure);
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       NVIC_Init
   3112          
   3113          
   3114          
   3115          #if FATFS_SDIO_4BIT == 1
   3116          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource8, GPIO_AF_SDIO);		//D0
   \   0000004A   0x....             LDR.N    R4,??DataTable42_7  ;; 0x40020800
   \   0000004C   0x220C             MOVS     R2,#+12
   \   0000004E   0x2108             MOVS     R1,#+8
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       GPIO_PinAFConfig
   3117          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_SDIO);		//D1
   \   00000056   0x220C             MOVS     R2,#+12
   \   00000058   0x2109             MOVS     R1,#+9
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       GPIO_PinAFConfig
   3118          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_SDIO);	//D2
   \   00000060   0x220C             MOVS     R2,#+12
   \   00000062   0x210A             MOVS     R1,#+10
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       GPIO_PinAFConfig
   3119          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_SDIO);	//D3
   \   0000006A   0x220C             MOVS     R2,#+12
   \   0000006C   0x210B             MOVS     R1,#+11
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       GPIO_PinAFConfig
   3120          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_SDIO);	//CLK
   \   00000074   0x220C             MOVS     R2,#+12
   \   00000076   0x4611             MOV      R1,R2
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       GPIO_PinAFConfig
   3121          		GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_SDIO);		//CMD
   \   0000007E   0x....             LDR.N    R5,??DataTable42_8  ;; 0x40020c00
   \   00000080   0x220C             MOVS     R2,#+12
   \   00000082   0x2102             MOVS     R1,#+2
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       GPIO_PinAFConfig
   3122          		//							  D0		   D1			D2			  D3
   3123          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
   \   0000008A   0xF44F 0x6070      MOV      R0,#+3840
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   3124          	
   3125          #else
   3126          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource8, GPIO_AF_SDIO);		//D0
   3127          		GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_SDIO);	//CLK
   3128          		GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_SDIO);		//CMD
   3129          		//D0 pin
   3130          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
   3131          #endif
   3132          
   3133              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xF88D 0x0009      STRB     R0,[SP, #+9]
   3134              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000096   0xF88D 0x0008      STRB     R0,[SP, #+8]
   3135              GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF88D 0x000A      STRB     R0,[SP, #+10]
   3136              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF88D 0x000B      STRB     R0,[SP, #+11]
   3137              GPIO_Init (GPIOC, &GPIO_InitStructure);
   \   000000A6   0xA901             ADD      R1,SP,#+4
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       GPIO_Init
   3138          
   3139              /* Configure PD.02 CMD line */
   3140              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   000000AE   0x2004             MOVS     R0,#+4
   \   000000B0   0x9001             STR      R0,[SP, #+4]
   3141              GPIO_Init (GPIOD, &GPIO_InitStructure);
   \   000000B2   0xA901             ADD      R1,SP,#+4
   \   000000B4   0x4628             MOV      R0,R5
   \   000000B6   0x.... 0x....      BL       GPIO_Init
   3142          
   3143              /* Configure PC.12 pin: CLK pin */
   3144              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
   \   000000BA   0xF44F 0x5080      MOV      R0,#+4096
   \   000000BE   0x9001             STR      R0,[SP, #+4]
   3145              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF88D 0x000B      STRB     R0,[SP, #+11]
   3146              GPIO_Init (GPIOC, &GPIO_InitStructure);
   \   000000C6   0xA901             ADD      R1,SP,#+4
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       GPIO_Init
   3147          
   3148              /* Enable the SDIO APB2 Clock */
   3149              RCC_APB2PeriphClockCmd (RCC_APB2Periph_SDIO, ENABLE);
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0xF44F 0x6000      MOV      R0,#+2048
   \   000000D4   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   3150          
   3151              /* Enable the DMA2 Clock */
   3152              RCC_AHB1PeriphClockCmd (SD_SDIO_DMA_CLK, ENABLE);
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0xF44F 0x0080      MOV      R0,#+4194304
   \   000000DE   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   3153          }
   \   000000E2   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   3154          
   3155          /**
   3156           * @brief  Configures the DMA2 Channel4 for SDIO Tx request.
   3157           * @param  BufferSRC: pointer to the source buffer
   3158           * @param  BufferSize: buffer size
   3159           * @retval None
   3160           */

   \                                 In section .text, align 2, keep-with-next
   3161          void SD_LowLevel_DMA_TxConfig (uint32_t *BufferSRC, uint32_t BufferSize) {
   \                     SD_LowLevel_DMA_TxConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x4605             MOV      R5,R0
   3162          	DMA_InitTypeDef SDDMA_InitStructure;
   3163          
   3164          	DMA_ClearFlag (SD_SDIO_DMA_STREAM, SD_SDIO_DMA_FLAG_FEIF | SD_SDIO_DMA_FLAG_DMEIF | SD_SDIO_DMA_FLAG_TEIF | SD_SDIO_DMA_FLAG_HTIF | SD_SDIO_DMA_FLAG_TCIF);
   \   00000006   0x....             LDR.N    R4,??DataTable42_3  ;; 0x40026458
   \   00000008   0xF04F 0x51FA      MOV      R1,#+524288000
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       DMA_ClearFlag
   3165          
   3166          	/* DMA2 Stream3  or Stream6 disable */
   3167          	DMA_Cmd (SD_SDIO_DMA_STREAM, DISABLE);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       DMA_Cmd
   3168          
   3169          	/* DMA2 Stream3  or Stream6 Config */
   3170          	DMA_DeInit (SD_SDIO_DMA_STREAM );
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       DMA_DeInit
   3171          
   3172          	SDDMA_InitStructure.DMA_Channel = SD_SDIO_DMA_CHANNEL;
   \   00000020   0xF04F 0x6000      MOV      R0,#+134217728
   \   00000024   0x9000             STR      R0,[SP, #+0]
   3173          	SDDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)SDIO_FIFO_ADDRESS;
   \   00000026   0x....             LDR.N    R0,??DataTable42_9  ;; 0x40012c80
   \   00000028   0x9001             STR      R0,[SP, #+4]
   3174          	SDDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) BufferSRC;
   \   0000002A   0x9502             STR      R5,[SP, #+8]
   3175          	SDDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
   \   0000002C   0x2040             MOVS     R0,#+64
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   3176          	SDDMA_InitStructure.DMA_BufferSize = 0;//1
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9004             STR      R0,[SP, #+16]
   3177          	SDDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000034   0x9005             STR      R0,[SP, #+20]
   3178          	SDDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000036   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003A   0x9006             STR      R0,[SP, #+24]
   3179          	SDDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
   \   0000003C   0xF44F 0x5080      MOV      R0,#+4096
   \   00000040   0x9007             STR      R0,[SP, #+28]
   3180          	SDDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; /* DMA_MemoryDataSize_Word */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9008             STR      R0,[SP, #+32]
   3181          	SDDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000046   0x9009             STR      R0,[SP, #+36]
   3182          	SDDMA_InitStructure.DMA_Priority = DMA_Priority_High;
   \   00000048   0xF44F 0x3000      MOV      R0,#+131072
   \   0000004C   0x900A             STR      R0,[SP, #+40]
   3183          	SDDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x900B             STR      R0,[SP, #+44]
   3184          	SDDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull; /* DMA_FIFOThreshold_Full */
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x900C             STR      R0,[SP, #+48]
   3185          	SDDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single; /* DMA_MemoryBurst_INC4 */
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x900D             STR      R0,[SP, #+52]
   3186          	SDDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_INC4;
   \   0000005A   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000005E   0x900E             STR      R0,[SP, #+56]
   3187          	DMA_Init (SD_SDIO_DMA_STREAM, &SDDMA_InitStructure);
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       DMA_Init
   3188          	DMA_ITConfig (SD_SDIO_DMA_STREAM, DMA_IT_TC, ENABLE);
   \   00000068   0x2201             MOVS     R2,#+1
   \   0000006A   0x2110             MOVS     R1,#+16
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       DMA_ITConfig
   3189          	DMA_FlowControllerConfig (SD_SDIO_DMA_STREAM, DMA_FlowCtrl_Peripheral);
   \   00000072   0x2120             MOVS     R1,#+32
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       DMA_FlowControllerConfig
   3190          
   3191          	/* DMA2 Stream3  or Stream6 enable */
   3192          	DMA_Cmd (SD_SDIO_DMA_STREAM, ENABLE);
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       DMA_Cmd
   3193          }
   \   00000082   0xB00F             ADD      SP,SP,#+60
   \   00000084   0xBD30             POP      {R4,R5,PC}       ;; return
   3194          /**
   3195           * @brief  Configures the DMA2 Channel4 for SDIO Rx request.
   3196           * @param  BufferDST: pointer to the destination buffer
   3197           * @param  BufferSize: buffer size
   3198           * @retval None
   3199           */

   \                                 In section .text, align 2, keep-with-next
   3200          void SD_LowLevel_DMA_RxConfig (uint32_t *BufferDST, uint32_t BufferSize)
   3201          {
   \                     SD_LowLevel_DMA_RxConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x4605             MOV      R5,R0
   3202          	DMA_InitTypeDef SDDMA_InitStructure;
   3203          
   3204          	DMA_ClearFlag (SD_SDIO_DMA_STREAM, SD_SDIO_DMA_FLAG_FEIF | SD_SDIO_DMA_FLAG_DMEIF | SD_SDIO_DMA_FLAG_TEIF | SD_SDIO_DMA_FLAG_HTIF | SD_SDIO_DMA_FLAG_TCIF);
   \   00000006   0x....             LDR.N    R4,??DataTable42_3  ;; 0x40026458
   \   00000008   0xF04F 0x51FA      MOV      R1,#+524288000
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       DMA_ClearFlag
   3205          
   3206          	/* DMA2 Stream3  or Stream6 disable */
   3207          	DMA_Cmd (SD_SDIO_DMA_STREAM, DISABLE);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       DMA_Cmd
   3208          
   3209          	/* DMA2 Stream3 or Stream6 Config */
   3210          	DMA_DeInit (SD_SDIO_DMA_STREAM);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       DMA_DeInit
   3211          
   3212          	SDDMA_InitStructure.DMA_Channel = SD_SDIO_DMA_CHANNEL;
   \   00000020   0xF04F 0x6000      MOV      R0,#+134217728
   \   00000024   0x9000             STR      R0,[SP, #+0]
   3213          	SDDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) SDIO_FIFO_ADDRESS;
   \   00000026   0x....             LDR.N    R0,??DataTable42_9  ;; 0x40012c80
   \   00000028   0x9001             STR      R0,[SP, #+4]
   3214          	SDDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) BufferDST;
   \   0000002A   0x9502             STR      R5,[SP, #+8]
   3215          	SDDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   3216          	SDDMA_InitStructure.DMA_BufferSize = 0;//1
   \   00000030   0x9004             STR      R0,[SP, #+16]
   3217          	SDDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000032   0x9005             STR      R0,[SP, #+20]
   3218          	SDDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000034   0xF44F 0x6080      MOV      R0,#+1024
   \   00000038   0x9006             STR      R0,[SP, #+24]
   3219          	SDDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
   \   0000003A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000003E   0x9007             STR      R0,[SP, #+28]
   3220          	SDDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
   \   00000040   0xF44F 0x4080      MOV      R0,#+16384
   \   00000044   0x9008             STR      R0,[SP, #+32]
   3221          	SDDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9009             STR      R0,[SP, #+36]
   3222          	SDDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
   \   0000004A   0xF44F 0x3040      MOV      R0,#+196608
   \   0000004E   0x900A             STR      R0,[SP, #+40]
   3223          	SDDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   00000050   0x2004             MOVS     R0,#+4
   \   00000052   0x900B             STR      R0,[SP, #+44]
   3224          	SDDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0x900C             STR      R0,[SP, #+48]
   3225          	SDDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_INC4;
   \   00000058   0xF44F 0x0000      MOV      R0,#+8388608
   \   0000005C   0x900D             STR      R0,[SP, #+52]
   3226          	SDDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_INC4;
   \   0000005E   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000062   0x900E             STR      R0,[SP, #+56]
   3227          	DMA_Init (SD_SDIO_DMA_STREAM, &SDDMA_InitStructure);
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       DMA_Init
   3228          	DMA_ITConfig (SD_SDIO_DMA_STREAM, DMA_IT_TC, ENABLE);
   \   0000006C   0x2201             MOVS     R2,#+1
   \   0000006E   0x2110             MOVS     R1,#+16
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       DMA_ITConfig
   3229          	DMA_FlowControllerConfig (SD_SDIO_DMA_STREAM, DMA_FlowCtrl_Peripheral);
   \   00000076   0x2120             MOVS     R1,#+32
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       DMA_FlowControllerConfig
   3230          
   3231          	/* DMA2 Stream3 or Stream6 enable */
   3232          	DMA_Cmd (SD_SDIO_DMA_STREAM, ENABLE);
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       DMA_Cmd
   3233          }
   \   00000086   0xB00F             ADD      SP,SP,#+60
   \   00000088   0xBD30             POP      {R4,R5,PC}       ;; return
   3234          

   \                                 In section .text, align 2, keep-with-next
   3235          void SDIO_IRQHandler(void) 
   3236          {
   3237          	SD_ProcessIRQSrc();
   \                     SDIO_IRQHandler: (+1)
   \   00000000   0x.... 0x....      B.W      SD_ProcessIRQSrc
   3238          }
   3239          #ifdef SD_SDIO_DMA_STREAM3

   \                                 In section .text, align 2, keep-with-next
   3240          void DMA2_Stream3_IRQHandler(void)
   3241          {
   3242          	SD_ProcessDMAIRQ();
   \                     DMA2_Stream3_IRQHandler: (+1)
   \   00000000   0x.... 0x....      B.W      SD_ProcessDMAIRQ
   3243          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     TM_FATFS_SD_SDIO_Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     SDIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     SDCardInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     SDIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x80100000         DC32     0x80100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     SDSTATUS_Tab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x40012C2C         DC32     0x40012c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x40012C34         DC32     0x40012c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x........         DC32     SDIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_1:
   \   00000000   0x0001D4C0         DC32     0x1d4c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x40012C04         DC32     0x40012c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \   00000000   0x40012C34         DC32     0x40012c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \   00000000   0x40026400         DC32     0x40026400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_3:
   \   00000000   0x40026458         DC32     0x40026458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_4:
   \   00000000   0xFDFFE008         DC32     0xfdffe008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_5:
   \   00000000   0x40012C2C         DC32     0x40012c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_6:
   \   00000000   0x80FFFF01         DC32     0x80ffff01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_7:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_8:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_9:
   \   00000000   0x40012C80         DC32     0x40012c80

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   3244          #endif
   3245          
   3246          #ifdef SD_SDIO_DMA_STREAM6
   3247          void DMA2_Stream6_IRQHandler(void)
   3248          {
   3249          	SD_ProcessDMAIRQ();
   3250          }
   3251          #endif
   3252          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CmdError
         8   -> SDIO_ClearFlag
         8   -> SDIO_GetFlagStatus
       8   CmdResp1Error
         8   -> SDIO_ClearFlag
         8   -> SDIO_GetCommandResponse
         8   -> SDIO_GetResponse
       8   CmdResp2Error
         8   -> SDIO_ClearFlag
       8   CmdResp3Error
         8   -> SDIO_ClearFlag
      16   CmdResp6Error
        16   -> SDIO_ClearFlag
        16   -> SDIO_GetCommandResponse
        16   -> SDIO_GetResponse
       8   CmdResp7Error
         8   -> SDIO_ClearFlag
       0   DMA2_Stream3_IRQHandler
         0   -> SD_ProcessDMAIRQ
      32   FindSCR
        32   -> CmdResp1Error
        32   -> SDIO_ClearFlag
        32   -> SDIO_DataConfig
        32   -> SDIO_GetFlagStatus
        32   -> SDIO_ReadData
        32   -> SDIO_SendCommand
      16   IsCardProgramming
        16   -> SDIO_ClearFlag
        16   -> SDIO_GetCommandResponse
        16   -> SDIO_GetResponse
        16   -> SDIO_SendCommand
      24   SDEnWideBus
        24   -> CmdResp1Error
        24   -> FindSCR
        24   -> SDIO_GetResponse
        24   -> SDIO_SendCommand
       0   SDIO_IRQHandler
         0   -> SD_ProcessIRQSrc
       0   SD_DeInit
         0   -> SD_LowLevel_DeInit
       8   SD_Detect
         8   -> GPIO_ReadInputDataBit
      16   SD_EnableWideBusOperation
        16   -> SDEnWideBus
        16   -> SDIO_Init
      40   SD_Erase
        40   -> CmdResp1Error
        40   -> IsCardProgramming
        40   -> SDIO_GetResponse
        40   -> SDIO_SendCommand
      24   SD_GetCardInfo
      16   SD_GetCardStatus
        16   -> SD_SendSDStatus
       8   SD_GetState
         8   -> SD_Detect
         8   -> SD_SendStatus
       8   SD_GetStatus
         8   -> SD_GetState
       0   SD_GetTransferState
      96   SD_HighSpeed
        96   -> CmdResp1Error
        96   -> FindSCR
        96   -> SDIO_ClearFlag
        96   -> SDIO_DataConfig
        96   -> SDIO_GetFlagStatus
        96   -> SDIO_ReadData
        96   -> SDIO_SendCommand
        96   -> __aeabi_memclr4
      16   SD_Init
        16   -> SDIO_DeInit
        16   -> SDIO_Init
        16   -> SD_EnableWideBusOperation
        16   -> SD_GetCardInfo
        16   -> SD_InitializeCards
        16   -> SD_PowerON
        16   -> SD_SelectDeselect
      16   SD_InitializeCards
        16   -> CmdResp2Error
        16   -> CmdResp6Error
        16   -> SDIO_GetPowerState
        16   -> SDIO_GetResponse
        16   -> SDIO_SendCommand
      72   SD_LowLevel_DMA_RxConfig
        72   -> DMA_ClearFlag
        72   -> DMA_Cmd
        72   -> DMA_DeInit
        72   -> DMA_FlowControllerConfig
        72   -> DMA_ITConfig
        72   -> DMA_Init
      72   SD_LowLevel_DMA_TxConfig
        72   -> DMA_ClearFlag
        72   -> DMA_Cmd
        72   -> DMA_DeInit
        72   -> DMA_FlowControllerConfig
        72   -> DMA_ITConfig
        72   -> DMA_Init
      24   SD_LowLevel_DeInit
        24   -> GPIO_Init
        24   -> GPIO_PinAFConfig
        24   -> RCC_APB2PeriphClockCmd
        24   -> SDIO_ClockCmd
        24   -> SDIO_DeInit
        24   -> SDIO_SetPowerState
      24   SD_LowLevel_Init
        24   -> GPIO_Init
        24   -> GPIO_PinAFConfig
        24   -> NVIC_Init
        24   -> NVIC_PriorityGroupConfig
        24   -> RCC_AHB1PeriphClockCmd
        24   -> RCC_APB2PeriphClockCmd
       8   SD_PowerOFF
         8   -> SDIO_SetPowerState
      32   SD_PowerON
        32   -> CmdError
        32   -> CmdResp1Error
        32   -> CmdResp3Error
        32   -> CmdResp7Error
        32   -> SDIO_ClockCmd
        32   -> SDIO_GetResponse
        32   -> SDIO_Init
        32   -> SDIO_SendCommand
        32   -> SDIO_SetPowerState
       0   SD_ProcessDMAIRQ
         0   -> DMA_ClearFlag
       8   SD_ProcessIRQSrc
         8   -> SDIO_ClearITPendingBit
         8   -> SDIO_GetITStatus
         8   -> SDIO_ITConfig
      24   SD_ReadBlock
        24   -> CmdResp1Error
        24   -> SDIO_DMACmd
        24   -> SDIO_DataConfig
        24   -> SDIO_ITConfig
        24   -> SDIO_SendCommand
        24   -> SD_LowLevel_DMA_RxConfig
      32   SD_ReadMultiBlocks
        32   -> CmdResp1Error
        32   -> SDIO_DMACmd
        32   -> SDIO_DataConfig
        32   -> SDIO_ITConfig
        32   -> SDIO_SendCommand
        32   -> SD_LowLevel_DMA_RxConfig
      32   SD_ReadMultiBlocksFIXED
        32   -> CmdResp1Error
        32   -> SDIO_DMACmd
        32   -> SDIO_DataConfig
        32   -> SDIO_ITConfig
        32   -> SDIO_SendCommand
        32   -> SD_LowLevel_DMA_RxConfig
       8   SD_SelectDeselect
         0   -> CmdResp1Error
         8   -> SDIO_SendCommand
      24   SD_SendSDStatus
        24   -> CmdResp1Error
        24   -> SDIO_ClearFlag
        24   -> SDIO_DataConfig
        24   -> SDIO_GetFlagStatus
        24   -> SDIO_GetResponse
        24   -> SDIO_ReadData
        24   -> SDIO_SendCommand
       8   SD_SendStatus
         8   -> CmdResp1Error
         8   -> SDIO_GetResponse
         8   -> SDIO_SendCommand
       8   SD_StopTransfer
         0   -> CmdResp1Error
         8   -> SDIO_SendCommand
      16   SD_WaitReadOperation
        16   -> SDIO_ClearFlag
        16   -> SD_StopTransfer
      16   SD_WaitWriteOperation
        16   -> SDIO_ClearFlag
        16   -> SD_StopTransfer
      24   SD_WriteBlock
        24   -> CmdResp1Error
        24   -> SDIO_DMACmd
        24   -> SDIO_DataConfig
        24   -> SDIO_ITConfig
        24   -> SDIO_SendCommand
        24   -> SD_LowLevel_DMA_TxConfig
      32   SD_WriteMultiBlocks
        32   -> CmdResp1Error
        32   -> SDIO_DMACmd
        32   -> SDIO_DataConfig
        32   -> SDIO_ITConfig
        32   -> SDIO_SendCommand
        32   -> SD_LowLevel_DMA_TxConfig
      32   SD_WriteMultiBlocksFIXED
        32   -> CmdResp1Error
        32   -> SDIO_DMACmd
        32   -> SDIO_DataConfig
        32   -> SDIO_ITConfig
        32   -> SDIO_SendCommand
        32   -> SD_LowLevel_DMA_TxConfig
       0   TM_FATFS_SDIO_WriteEnabled
       8   TM_FATFS_SD_SDIO_disk_initialize
         8   -> SD_Init
         8   -> SD_LowLevel_DeInit
         8   -> SD_LowLevel_Init
         8   -> TM_FATFS_SDIO_WriteEnabled
       0   TM_FATFS_SD_SDIO_disk_ioctl
      16   TM_FATFS_SD_SDIO_disk_read
        16   -> SD_GetStatus
        16   -> SD_ReadMultiBlocks
        16   -> SD_WaitReadOperation
       8   TM_FATFS_SD_SDIO_disk_status
         8   -> SD_Detect
         8   -> TM_FATFS_SDIO_WriteEnabled
      24   TM_FATFS_SD_SDIO_disk_write
        24   -> SD_Detect
        24   -> SD_GetStatus
        24   -> SD_WaitWriteOperation
        24   -> SD_WriteMultiBlocks
        24   -> TM_FATFS_SDIO_WriteEnabled
       0   convert_from_bytes_to_power_of_two


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable32
       4  ??DataTable34
       4  ??DataTable36
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_2
       4  ??DataTable42_3
       4  ??DataTable42_4
       4  ??DataTable42_5
       4  ??DataTable42_6
       4  ??DataTable42_7
       4  ??DataTable42_8
       4  ??DataTable42_9
       8  ?_0
       8  ?_1
       8  ?_2
      64  ?_3
      44  CmdError
     236  CmdResp1Error
      58  CmdResp2Error
      44  CmdResp3Error
     114  CmdResp6Error
      64  CmdResp7Error
       4  DMA2_Stream3_IRQHandler
     372  FindSCR
     342  IsCardProgramming
      88  SDCardInfo
     230  SDEnWideBus
       4  SDIO_IRQHandler
     124  SDIO_InitStructure
          TransferError
          SDIO_DataInitStructure
          SDIO_CmdInitStructure
          CSD_Tab
          CID_Tab
          CardType
          RCA
          StopCondition
          TransferEnd
          DMAEndOfTransfer
      16  SDSTATUS_Tab
       4  SD_DeInit
      34  SD_Detect
     118  SD_EnableWideBusOperation
     314  SD_Erase
     820  SD_GetCardInfo
     126  SD_GetCardStatus
      42  SD_GetState
      26  SD_GetStatus
      20  SD_GetTransferState
     374  SD_HighSpeed
     150  SD_Init
     252  SD_InitializeCards
     138  SD_LowLevel_DMA_RxConfig
     134  SD_LowLevel_DMA_TxConfig
     146  SD_LowLevel_DeInit
     228  SD_LowLevel_Init
      12  SD_PowerOFF
     402  SD_PowerON
      34  SD_ProcessDMAIRQ
     186  SD_ProcessIRQSrc
     220  SD_ReadBlock
     234  SD_ReadMultiBlocks
     228  SD_ReadMultiBlocksFIXED
      44  SD_SelectDeselect
     356  SD_SendSDStatus
      66  SD_SendStatus
      40  SD_StopTransfer
     126  SD_WaitReadOperation
     108  SD_WaitWriteOperation
     218  SD_WriteBlock
     326  SD_WriteMultiBlocks
     324  SD_WriteMultiBlocksFIXED
       4  TM_FATFS_SDIO_WriteEnabled
       1  TM_FATFS_SD_SDIO_Stat
      66  TM_FATFS_SD_SDIO_disk_initialize
      26  TM_FATFS_SD_SDIO_disk_ioctl
      58  TM_FATFS_SD_SDIO_disk_read
      46  TM_FATFS_SD_SDIO_disk_status
      76  TM_FATFS_SD_SDIO_disk_write
      18  convert_from_bytes_to_power_of_two

 
   228 bytes in section .bss
     1 byte  in section .data
    88 bytes in section .rodata
 7 740 bytes in section .text
 
 7 740 bytes of CODE  memory
    88 bytes of CONST memory
   229 bytes of DATA  memory

Errors: none
Warnings: none
