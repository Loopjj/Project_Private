###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\stm32f2xx_flash.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\stm32f2xx_flash.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    07-October-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            - FLASH Interface configuration
     10            *            - FLASH Memory Programming
     11            *            - Option Bytes Programming
     12            *            - Interrupts and flags management
     13            *  
     14            *  @verbatim
     15            *  
     16            *          ===================================================================
     17            *                                 How to use this driver
     18            *          ===================================================================
     19            *                           
     20            *          This driver provides functions to configure and program the FLASH 
     21            *          memory of all STM32F2xx devices.
     22            *          These functions are split in 4 groups:
     23            * 
     24            *           1. FLASH Interface configuration functions: this group includes the
     25            *              management of the following features:
     26            *                    - Set the latency
     27            *                    - Enable/Disable the prefetch buffer
     28            *                    - Enable/Disable the Instruction cache and the Data cache
     29            *                    - Reset the Instruction cache and the Data cache
     30            *  
     31            *           2. FLASH Memory Programming functions: this group includes all needed
     32            *              functions to erase and program the main memory:
     33            *                    - Lock and Unlock the FLASH interface
     34            *                    - Erase function: Erase sector, erase all sectors
     35            *                    - Program functions: byte, half word, word and double word
     36            *  
     37            *           3. Option Bytes Programming functions: this group includes all needed
     38            *              functions to manage the Option Bytes:
     39            *                    - Set/Reset the write protection
     40            *                    - Set the Read protection Level
     41            *                    - Set the BOR level
     42            *                    - Program the user Option Bytes
     43            *                    - Launch the Option Bytes loader
     44            *  
     45            *           4. Interrupts and flags management functions: this group 
     46            *              includes all needed functions to:
     47            *                    - Enable/Disable the FLASH interrupt sources
     48            *                    - Get flags status
     49            *                    - Clear flags
     50            *                    - Get FLASH operation status
     51            *                    - Wait for last FLASH operation
     52            * 
     53            *  @endverbatim
     54            *                      
     55            ******************************************************************************
     56            * @attention
     57            *
     58            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     59            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     60            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     61            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     62            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     63            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     64            *
     65            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     66            ******************************************************************************
     67            */
     68          
     69          /* Includes ------------------------------------------------------------------*/
     70          #include "stm32f2xx_flash.h"
     71          
     72          /** @addtogroup STM32F2xx_StdPeriph_Driver
     73            * @{
     74            */
     75          
     76          /** @defgroup FLASH 
     77            * @brief FLASH driver modules
     78            * @{
     79            */ 
     80          
     81          /* Private typedef -----------------------------------------------------------*/
     82          /* Private define ------------------------------------------------------------*/ 
     83          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     84          
     85          /* Private macro -------------------------------------------------------------*/
     86          /* Private variables ---------------------------------------------------------*/
     87          /* Private function prototypes -----------------------------------------------*/
     88          /* Private functions ---------------------------------------------------------*/
     89          
     90          /** @defgroup FLASH_Private_Functions
     91            * @{
     92            */ 
     93          
     94          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
     95            *  @brief   FLASH Interface configuration functions 
     96           *
     97          
     98          @verbatim   
     99           ===============================================================================
    100                                 FLASH Interface configuration functions
    101           ===============================================================================
    102          
    103             This group includes the following functions:
    104              - void FLASH_SetLatency(uint32_t FLASH_Latency)
    105                 To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    106                 must be correctly programmed according to the frequency of the CPU clock 
    107                (HCLK) and the supply voltage of the device.
    108           +-------------------------------------------------------------------------------------+     
    109           | Latency       |                HCLK clock frequency (MHz)                           |
    110           |               |---------------------------------------------------------------------|     
    111           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    112           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    113           |---------------|----------------|----------------|-----------------|-----------------|              
    114           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    115           |---------------|----------------|----------------|-----------------|-----------------|   
    116           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  | 
    117           |---------------|----------------|----------------|-----------------|-----------------|   
    118           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    119           |---------------|----------------|----------------|-----------------|-----------------| 
    120           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    121           |---------------|----------------|----------------|-----------------|-----------------| 
    122           |4WS(5CPU cycle)|      NA        |96 < HCLK <= 120|72 < HCLK <= 90  |64 < HCLK <= 80  |
    123           |---------------|----------------|----------------|-----------------|-----------------| 
    124           |5WS(6CPU cycle)|      NA        |      NA        |90 < HCLK <= 108 |80 < HCLK <= 96  | 
    125           |---------------|----------------|----------------|-----------------|-----------------| 
    126           |6WS(7CPU cycle)|      NA        |      NA        |108 < HCLK <= 120|96 < HCLK <= 112 | 
    127           |---------------|----------------|----------------|-----------------|-----------------| 
    128           |7WS(8CPU cycle)|      NA        |      NA        |     NA          |112 < HCLK <= 120| 
    129           |***************|****************|****************|*****************|*****************|*****************************+
    130           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    131           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    132           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    133           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    134           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    135           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    136           +-------------------------------------------------------------------------------------------------------------------+  
    137              
    138              - void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    139              - void FLASH_InstructionCacheCmd(FunctionalState NewState)
    140              - void FLASH_DataCacheCmd(FunctionalState NewState)
    141              - void FLASH_InstructionCacheReset(void)
    142              - void FLASH_DataCacheReset(void)
    143             
    144             The unlock sequence is not needed for these functions.
    145           
    146          @endverbatim
    147            * @{
    148            */
    149           
    150          /**
    151            * @brief  Sets the code latency value.
    152            * @param  FLASH_Latency: specifies the FLASH Latency value.
    153            *          This parameter can be one of the following values:
    154            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    155            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    156            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    157            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    158            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    159            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    160            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    161            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles      
    162            * @retval None
    163            */

   \                                 In section .text, align 2, keep-with-next
    164          void FLASH_SetLatency(uint32_t FLASH_Latency)
    165          {
    166            /* Check the parameters */
    167            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    168            
    169            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    170            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
   \                     FLASH_SetLatency: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable28  ;; 0x40023c00
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    171          }
   \   00000004   0x4770             BX       LR               ;; return
    172          
    173          /**
    174            * @brief  Enables or disables the Prefetch Buffer.
    175            * @param  NewState: new state of the Prefetch Buffer.
    176            *          This parameter  can be: ENABLE or DISABLE.
    177            * @retval None
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    180          {
    181            /* Check the parameters */
    182            assert_param(IS_FUNCTIONAL_STATE(NewState));
    183            
    184            /* Enable or disable the Prefetch Buffer */
    185            if(NewState != DISABLE)
   \                     FLASH_PrefetchBufferCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable28  ;; 0x40023c00
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??FLASH_PrefetchBufferCmd_0
    186            {
    187              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \   00000008   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    188            }
    189            else
    190            {
    191              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
   \                     ??FLASH_PrefetchBufferCmd_0: (+1)
   \   00000010   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000014   0x6008             STR      R0,[R1, #+0]
    192            }
    193          }
   \   00000016   0x4770             BX       LR               ;; return
    194          
    195          /**
    196            * @brief  Enables or disables the Instruction Cache feature.
    197            * @param  NewState: new state of the Instruction Cache.
    198            *          This parameter  can be: ENABLE or DISABLE.
    199            * @retval None
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    202          {
    203            /* Check the parameters */
    204            assert_param(IS_FUNCTIONAL_STATE(NewState));
    205            
    206            if(NewState != DISABLE)
   \                     FLASH_InstructionCacheCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable28  ;; 0x40023c00
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??FLASH_InstructionCacheCmd_0
    207            {
    208              FLASH->ACR |= FLASH_ACR_ICEN;
   \   00000008   0xF440 0x7000      ORR      R0,R0,#0x200
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    209            }
    210            else
    211            {
    212              FLASH->ACR &= (~FLASH_ACR_ICEN);
   \                     ??FLASH_InstructionCacheCmd_0: (+1)
   \   00000010   0xF420 0x7000      BIC      R0,R0,#0x200
   \   00000014   0x6008             STR      R0,[R1, #+0]
    213            }
    214          }
   \   00000016   0x4770             BX       LR               ;; return
    215          
    216          /**
    217            * @brief  Enables or disables the Data Cache feature.
    218            * @param  NewState: new state of the Data Cache.
    219            *          This parameter  can be: ENABLE or DISABLE.
    220            * @retval None
    221            */

   \                                 In section .text, align 2, keep-with-next
    222          void FLASH_DataCacheCmd(FunctionalState NewState)
    223          {
    224            /* Check the parameters */
    225            assert_param(IS_FUNCTIONAL_STATE(NewState));
    226            
    227            if(NewState != DISABLE)
   \                     FLASH_DataCacheCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable28  ;; 0x40023c00
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??FLASH_DataCacheCmd_0
    228            {
    229              FLASH->ACR |= FLASH_ACR_DCEN;
   \   00000008   0xF440 0x6080      ORR      R0,R0,#0x400
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    230            }
    231            else
    232            {
    233              FLASH->ACR &= (~FLASH_ACR_DCEN);
   \                     ??FLASH_DataCacheCmd_0: (+1)
   \   00000010   0xF420 0x6080      BIC      R0,R0,#0x400
   \   00000014   0x6008             STR      R0,[R1, #+0]
    234            }
    235          }
   \   00000016   0x4770             BX       LR               ;; return
    236          
    237          /**
    238            * @brief  Resets the Instruction Cache.
    239            * @note   This function must be used only when the Instruction Cache is disabled.  
    240            * @param  None
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void FLASH_InstructionCacheReset(void)
    244          {
    245            FLASH->ACR |= FLASH_ACR_ICRST;
   \                     FLASH_InstructionCacheReset: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28  ;; 0x40023c00
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000008   0x6001             STR      R1,[R0, #+0]
    246          }
   \   0000000A   0x4770             BX       LR               ;; return
    247          
    248          /**
    249            * @brief  Resets the Data Cache.
    250            * @note   This function must be used only when the Data Cache is disabled.  
    251            * @param  None
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void FLASH_DataCacheReset(void)
    255          {
    256            FLASH->ACR |= FLASH_ACR_DCRST;
   \                     FLASH_DataCacheReset: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28  ;; 0x40023c00
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000008   0x6001             STR      R1,[R0, #+0]
    257          }
   \   0000000A   0x4770             BX       LR               ;; return
    258          
    259          /**
    260            * @}
    261            */
    262          
    263          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    264           *  @brief   FLASH Memory Programming functions
    265           *
    266          @verbatim   
    267           ===============================================================================
    268                                FLASH Memory Programming functions
    269           ===============================================================================   
    270          
    271             This group includes the following functions:
    272              - void FLASH_Unlock(void)
    273              - void FLASH_Lock(void)
    274              - FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    275              - FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    276              - FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    277              - FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    278              - FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    279              - FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    280             
    281             Any operation of erase or program should follow these steps:
    282             1. Call the FLASH_Unlock() function to enable the FLASH control register access
    283          
    284             2. Call the desired function to erase sector(s) or program data
    285          
    286             3. Call the FLASH_Lock() function to disable the FLASH control register access
    287                (recommended to protect the FLASH memory against possible unwanted operation)
    288              
    289          @endverbatim
    290            * @{
    291            */
    292          
    293          /**
    294            * @brief  Unlocks the FLASH control register access
    295            * @param  None
    296            * @retval None
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          void FLASH_Unlock(void)
    299          {
    300            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40023c04
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD503             BPL.N    ??FLASH_Unlock_0
    301            {
    302              /* Authorize the FLASH Registers access */
    303              FLASH->KEYR = FLASH_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable28_2  ;; 0x45670123
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    304              FLASH->KEYR = FLASH_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable28_3  ;; 0xcdef89ab
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    305            }  
    306          }
   \                     ??FLASH_Unlock_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    307          
    308          /**
    309            * @brief  Locks the FLASH control register access
    310            * @param  None
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void FLASH_Lock(void)
    314          {
    315            /* Set the LOCK Bit to lock the FLASH Registers access */
    316            FLASH->CR |= FLASH_CR_LOCK;
   \                     FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_4  ;; 0x40023c10
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000008   0x6001             STR      R1,[R0, #+0]
    317          }
   \   0000000A   0x4770             BX       LR               ;; return
    318          
    319          /**
    320            * @brief  Erases a specified FLASH Sector.
    321            *   
    322            * @param  FLASH_Sector: The Sector number to be erased.
    323            *          This parameter can be a value between FLASH_Sector_0 and FLASH_Sector_11
    324            *    
    325            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    326            *          This parameter can be one of the following values:
    327            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    328            *                                  the operation will be done by byte (8-bit) 
    329            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    330            *                                  the operation will be done by half word (16-bit)
    331            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    332            *                                  the operation will be done by word (32-bit)
    333            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    334            *                                  the operation will be done by double word (64-bit)
    335            *       
    336            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    337            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    340          {
   \                     FLASH_EraseSector: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    341            uint32_t tmp_psize = 0x0;
   \   00000004   0x2600             MOVS     R6,#+0
    342            FLASH_Status status = FLASH_COMPLETE;
    343          
    344            /* Check the parameters */
    345            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
    346            assert_param(IS_VOLTAGERANGE(VoltageRange));
    347            
    348            if(VoltageRange == VoltageRange_1)
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0xD00B             BEQ.N    ??FLASH_EraseSector_0
    349            {
    350               tmp_psize = FLASH_PSIZE_BYTE;
    351            }
    352            else if(VoltageRange == VoltageRange_2)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD102             BNE.N    ??FLASH_EraseSector_1
    353            {
    354              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   0000000E   0xF44F 0x7680      MOV      R6,#+256
   \   00000012   0xE006             B.N      ??FLASH_EraseSector_0
    355            }
    356            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseSector_1: (+1)
   \   00000014   0x2902             CMP      R1,#+2
   \   00000016   0xD102             BNE.N    ??FLASH_EraseSector_2
    357            {
    358              tmp_psize = FLASH_PSIZE_WORD;
   \   00000018   0xF44F 0x7600      MOV      R6,#+512
   \   0000001C   0xE001             B.N      ??FLASH_EraseSector_0
    359            }
    360            else
    361            {
    362              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseSector_2: (+1)
   \   0000001E   0xF44F 0x7640      MOV      R6,#+768
    363            }
    364            /* Wait for last operation to be completed */
    365            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_EraseSector_0: (+1)
   \   00000022   0x.... 0x....      BL       FLASH_WaitForLastOperation
    366            
    367            if(status == FLASH_COMPLETE)
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD121             BNE.N    ??FLASH_EraseSector_3
    368            { 
    369              /* if the previous operation is completed, proceed to erase the sector */
    370              FLASH->CR &= CR_PSIZE_MASK;
   \   0000002A   0x....             LDR.N    R5,??DataTable28_4  ;; 0x40023c10
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000032   0x6028             STR      R0,[R5, #+0]
    371              FLASH->CR |= tmp_psize;
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x4330             ORRS     R0,R6,R0
   \   00000038   0x6028             STR      R0,[R5, #+0]
    372              FLASH->CR &= SECTOR_MASK;
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0xF06F 0x01F8      MVN      R1,#+248
   \   00000040   0x4008             ANDS     R0,R1,R0
   \   00000042   0x6028             STR      R0,[R5, #+0]
    373              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0xF044 0x0102      ORR      R1,R4,#0x2
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x6028             STR      R0,[R5, #+0]
    374              FLASH->CR |= FLASH_CR_STRT;
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000054   0x6028             STR      R0,[R5, #+0]
    375              
    376              /* Wait for last operation to be completed */
    377              status = FLASH_WaitForLastOperation();
   \   00000056   0x.... 0x....      BL       FLASH_WaitForLastOperation
    378              
    379              /* if the erase operation is completed, disable the SER Bit */
    380              FLASH->CR &= (~FLASH_CR_SER);
   \   0000005A   0x6829             LDR      R1,[R5, #+0]
   \   0000005C   0xF06F 0x0202      MVN      R2,#+2
   \   00000060   0x4011             ANDS     R1,R2,R1
   \   00000062   0x6029             STR      R1,[R5, #+0]
    381              FLASH->CR &= SECTOR_MASK; 
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0xF06F 0x02F8      MVN      R2,#+248
   \   0000006A   0x4011             ANDS     R1,R2,R1
   \   0000006C   0x6029             STR      R1,[R5, #+0]
    382            }
    383            /* Return the Erase Status */
    384            return status;
   \                     ??FLASH_EraseSector_3: (+1)
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    385          }
    386          
    387          /**
    388            * @brief  Erases all FLASH Sectors.
    389            *    
    390            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    391            *          This parameter can be one of the following values:
    392            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    393            *                                  the operation will be done by byte (8-bit) 
    394            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    395            *                                  the operation will be done by half word (16-bit)
    396            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    397            *                                  the operation will be done by word (32-bit)
    398            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    399            *                                  the operation will be done by double word (64-bit)
    400            *       
    401            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    402            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    403            */

   \                                 In section .text, align 2, keep-with-next
    404          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    405          {
   \                     FLASH_EraseAllSectors: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    406            uint32_t tmp_psize = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    407            FLASH_Status status = FLASH_COMPLETE;
    408            
    409            /* Wait for last operation to be completed */
    410            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
    411            assert_param(IS_VOLTAGERANGE(VoltageRange));
    412            
    413            if(VoltageRange == VoltageRange_1)
   \   0000000A   0x0021             MOVS     R1,R4
   \   0000000C   0xD00B             BEQ.N    ??FLASH_EraseAllSectors_0
    414            {
    415               tmp_psize = FLASH_PSIZE_BYTE;
    416            }
    417            else if(VoltageRange == VoltageRange_2)
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD102             BNE.N    ??FLASH_EraseAllSectors_1
    418            {
    419              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000012   0xF44F 0x7580      MOV      R5,#+256
   \   00000016   0xE006             B.N      ??FLASH_EraseAllSectors_0
    420            }
    421            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllSectors_1: (+1)
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD102             BNE.N    ??FLASH_EraseAllSectors_2
    422            {
    423              tmp_psize = FLASH_PSIZE_WORD;
   \   0000001C   0xF44F 0x7500      MOV      R5,#+512
   \   00000020   0xE001             B.N      ??FLASH_EraseAllSectors_0
    424            }
    425            else
    426            {
    427              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllSectors_2: (+1)
   \   00000022   0xF44F 0x7540      MOV      R5,#+768
    428            }  
    429            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllSectors_0: (+1)
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD116             BNE.N    ??FLASH_EraseAllSectors_3
    430            {
    431              /* if the previous operation is completed, proceed to erase all sectors */
    432               FLASH->CR &= CR_PSIZE_MASK;
   \   0000002A   0x....             LDR.N    R4,??DataTable28_4  ;; 0x40023c10
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000032   0x6020             STR      R0,[R4, #+0]
    433               FLASH->CR |= tmp_psize;
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x4328             ORRS     R0,R5,R0
   \   00000038   0x6020             STR      R0,[R4, #+0]
    434               FLASH->CR |= FLASH_CR_MER;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000040   0x6020             STR      R0,[R4, #+0]
    435               FLASH->CR |= FLASH_CR_STRT;
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000048   0x6020             STR      R0,[R4, #+0]
    436              
    437              /* Wait for last operation to be completed */
    438              status = FLASH_WaitForLastOperation();
   \   0000004A   0x.... 0x....      BL       FLASH_WaitForLastOperation
    439          
    440              /* if the erase operation is completed, disable the MER Bit */
    441              FLASH->CR &= (~FLASH_CR_MER);
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0xF06F 0x0204      MVN      R2,#+4
   \   00000054   0x4011             ANDS     R1,R2,R1
   \   00000056   0x6021             STR      R1,[R4, #+0]
    442          
    443            }   
    444            /* Return the Erase Status */
    445            return status;
   \                     ??FLASH_EraseAllSectors_3: (+1)
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    446          }
    447          
    448          /**
    449            * @brief  Programs a double word (64-bit) at a specified address.
    450            * @note   This function must be used when the device voltage range is from
    451            *         2.7V to 3.6V and an External Vpp is present.           
    452            * @param  Address: specifies the address to be programmed.
    453            * @param  Data: specifies the data to be programmed.
    454            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    455            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    458          {
   \                     FLASH_ProgramDoubleWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
    459            FLASH_Status status = FLASH_COMPLETE;
    460          
    461            /* Check the parameters */
    462            assert_param(IS_FLASH_ADDRESS(Address));
    463          
    464            /* Wait for last operation to be completed */
    465            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    466            
    467            if(status == FLASH_COMPLETE)
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD114             BNE.N    ??FLASH_ProgramDoubleWord_0
    468            {
    469              /* if the previous operation is completed, proceed to program the new data */
    470              FLASH->CR &= CR_PSIZE_MASK;
   \   00000010   0x....             LDR.N    R7,??DataTable28_4  ;; 0x40023c10
   \   00000012   0x6838             LDR      R0,[R7, #+0]
   \   00000014   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000018   0x6038             STR      R0,[R7, #+0]
    471              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   0000001A   0x6838             LDR      R0,[R7, #+0]
   \   0000001C   0xF440 0x7040      ORR      R0,R0,#0x300
   \   00000020   0x6038             STR      R0,[R7, #+0]
    472              FLASH->CR |= FLASH_CR_PG;
   \   00000022   0x6838             LDR      R0,[R7, #+0]
   \   00000024   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000028   0x6038             STR      R0,[R7, #+0]
    473            
    474              *(__IO uint64_t*)Address = Data;
   \   0000002A   0xE9C6 0x4500      STRD     R4,R5,[R6, #+0]
    475                  
    476              /* Wait for last operation to be completed */
    477              status = FLASH_WaitForLastOperation();
   \   0000002E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    478          
    479              /* if the program operation is completed, disable the PG Bit */
    480              FLASH->CR &= (~FLASH_CR_PG);
   \   00000032   0x6839             LDR      R1,[R7, #+0]
   \   00000034   0x0849             LSRS     R1,R1,#+1
   \   00000036   0x0049             LSLS     R1,R1,#+1
   \   00000038   0x6039             STR      R1,[R7, #+0]
    481            } 
    482            /* Return the Program Status */
    483            return status;
   \                     ??FLASH_ProgramDoubleWord_0: (+1)
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    484          }
    485          
    486          /**
    487            * @brief  Programs a word (32-bit) at a specified address.
    488            * @param  Address: specifies the address to be programmed.
    489            *         This parameter can be any address in Program memory zone or in OTP zone.  
    490            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    491            * @param  Data: specifies the data to be programmed.
    492            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    493            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    496          {
   \                     FLASH_ProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    497            FLASH_Status status = FLASH_COMPLETE;
    498          
    499            /* Check the parameters */
    500            assert_param(IS_FLASH_ADDRESS(Address));
    501          
    502            /* Wait for last operation to be completed */
    503            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
    504            
    505            if(status == FLASH_COMPLETE)
   \   0000000A   0x2808             CMP      R0,#+8
   \   0000000C   0xD113             BNE.N    ??FLASH_ProgramWord_0
    506            {
    507              /* if the previous operation is completed, proceed to program the new data */
    508              FLASH->CR &= CR_PSIZE_MASK;
   \   0000000E   0x....             LDR.N    R6,??DataTable28_4  ;; 0x40023c10
   \   00000010   0x6830             LDR      R0,[R6, #+0]
   \   00000012   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000016   0x6030             STR      R0,[R6, #+0]
    509              FLASH->CR |= FLASH_PSIZE_WORD;
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0xF440 0x7000      ORR      R0,R0,#0x200
   \   0000001E   0x6030             STR      R0,[R6, #+0]
    510              FLASH->CR |= FLASH_CR_PG;
   \   00000020   0x6830             LDR      R0,[R6, #+0]
   \   00000022   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000026   0x6030             STR      R0,[R6, #+0]
    511            
    512              *(__IO uint32_t*)Address = Data;
   \   00000028   0x6025             STR      R5,[R4, #+0]
    513                  
    514              /* Wait for last operation to be completed */
    515              status = FLASH_WaitForLastOperation();
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
    516          
    517              /* if the program operation is completed, disable the PG Bit */
    518              FLASH->CR &= (~FLASH_CR_PG);
   \   0000002E   0x6831             LDR      R1,[R6, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0x6031             STR      R1,[R6, #+0]
    519            } 
    520            /* Return the Program Status */
    521            return status;
   \                     ??FLASH_ProgramWord_0: (+1)
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    522          }
    523          
    524          /**
    525            * @brief  Programs a half word (16-bit) at a specified address. 
    526            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V.               
    527            * @param  Address: specifies the address to be programmed.
    528            *         This parameter can be any address in Program memory zone or in OTP zone.  
    529            * @param  Data: specifies the data to be programmed.
    530            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    531            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    532            */

   \                                 In section .text, align 2, keep-with-next
    533          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    534          {
   \                     FLASH_ProgramHalfWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    535            FLASH_Status status = FLASH_COMPLETE;
    536          
    537            /* Check the parameters */
    538            assert_param(IS_FLASH_ADDRESS(Address));
    539          
    540            /* Wait for last operation to be completed */
    541            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
    542            
    543            if(status == FLASH_COMPLETE)
   \   0000000A   0x2808             CMP      R0,#+8
   \   0000000C   0xD113             BNE.N    ??FLASH_ProgramHalfWord_0
    544            {
    545              /* if the previous operation is completed, proceed to program the new data */
    546              FLASH->CR &= CR_PSIZE_MASK;
   \   0000000E   0x....             LDR.N    R6,??DataTable28_4  ;; 0x40023c10
   \   00000010   0x6830             LDR      R0,[R6, #+0]
   \   00000012   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000016   0x6030             STR      R0,[R6, #+0]
    547              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000001E   0x6030             STR      R0,[R6, #+0]
    548              FLASH->CR |= FLASH_CR_PG;
   \   00000020   0x6830             LDR      R0,[R6, #+0]
   \   00000022   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000026   0x6030             STR      R0,[R6, #+0]
    549            
    550              *(__IO uint16_t*)Address = Data;
   \   00000028   0x8025             STRH     R5,[R4, #+0]
    551                  
    552              /* Wait for last operation to be completed */
    553              status = FLASH_WaitForLastOperation();
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
    554          
    555              /* if the program operation is completed, disable the PG Bit */
    556              FLASH->CR &= (~FLASH_CR_PG);
   \   0000002E   0x6831             LDR      R1,[R6, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0x6031             STR      R1,[R6, #+0]
    557            } 
    558            /* Return the Program Status */
    559            return status;
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    560          }
    561          
    562          /**
    563            * @brief  Programs a byte (8-bit) at a specified address.
    564            * @note   This function can be used within all the device supply voltage ranges.               
    565            * @param  Address: specifies the address to be programmed.
    566            *         This parameter can be any address in Program memory zone or in OTP zone.  
    567            * @param  Data: specifies the data to be programmed.
    568            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    569            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    570            */

   \                                 In section .text, align 2, keep-with-next
    571          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    572          {
   \                     FLASH_ProgramByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
    573            FLASH_Status status = FLASH_COMPLETE;
    574          
    575            /* Check the parameters */
    576            assert_param(IS_FLASH_ADDRESS(Address));
    577          
    578            /* Wait for last operation to be completed */
    579            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
    580            
    581            if(status == FLASH_COMPLETE)
   \   0000000A   0x2808             CMP      R0,#+8
   \   0000000C   0xD111             BNE.N    ??FLASH_ProgramByte_0
    582            {
    583              /* if the previous operation is completed, proceed to program the new data */
    584              FLASH->CR &= CR_PSIZE_MASK;
   \   0000000E   0x....             LDR.N    R4,??DataTable28_4  ;; 0x40023c10
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000016   0x6020             STR      R0,[R4, #+0]
    585              FLASH->CR |= FLASH_PSIZE_BYTE;
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    586              FLASH->CR |= FLASH_CR_PG;
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000022   0x6020             STR      R0,[R4, #+0]
    587            
    588              *(__IO uint8_t*)Address = Data;
   \   00000024   0x702E             STRB     R6,[R5, #+0]
    589                  
    590              /* Wait for last operation to be completed */
    591              status = FLASH_WaitForLastOperation();
   \   00000026   0x.... 0x....      BL       FLASH_WaitForLastOperation
    592          
    593              /* if the program operation is completed, disable the PG Bit */
    594              FLASH->CR &= (~FLASH_CR_PG);
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x0849             LSRS     R1,R1,#+1
   \   0000002E   0x0049             LSLS     R1,R1,#+1
   \   00000030   0x6021             STR      R1,[R4, #+0]
    595            } 
    596          
    597            /* Return the Program Status */
    598            return status;
   \                     ??FLASH_ProgramByte_0: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    599          }
    600          
    601          /**
    602            * @}
    603            */
    604          
    605          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    606           *  @brief   Option Bytes Programming functions 
    607           *
    608          @verbatim   
    609           ===============================================================================
    610                                  Option Bytes Programming functions
    611           ===============================================================================  
    612           
    613             This group includes the following functions:
    614             - void FLASH_OB_Unlock(void)
    615             - void FLASH_OB_Lock(void)
    616             - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    617             - void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    618             - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    619             - void FLASH_OB_BORConfig(uint8_t OB_BOR)
    620             - FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)							
    621             - FLASH_Status FLASH_OB_Launch(void)
    622             - uint32_t FLASH_OB_GetUser(void)						
    623             - uint8_t FLASH_OB_GetWRP(void)						
    624             - uint8_t FLASH_OB_GetRDP(void)							
    625             - uint8_t FLASH_OB_GetBOR(void)
    626             
    627             Any operation of erase or program should follow these steps:
    628             1. Call the FLASH_OB_Unlock() function to enable the FLASH option control register access
    629          
    630             2. Call one or several functions to program the desired Option Bytes:
    631                - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    632                  the desired sector write protection
    633                - void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level
    634                - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    635                  the user Option Bytes.
    636                - void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    637          
    638             3. Once all needed Option Bytes to be programmed are correctly written, call the
    639                FLASH_OB_Launch() function to launch the Option Bytes programming process.
    640               
    641               @note When changing the IWDG mode from HW to SW or from SW to HW, a system 
    642                     reset is needed to make the change effective.  
    643          
    644             4. Call the FLASH_OB_Lock() function to disable the FLASH option control register
    645                access (recommended to protect the Option Bytes against possible unwanted operations)
    646              
    647          @endverbatim
    648            * @{
    649            */
    650          
    651          /**
    652            * @brief  Unlocks the FLASH Option Control Registers access.
    653            * @param  None
    654            * @retval None
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          void FLASH_OB_Unlock(void)
    657          {
    658            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_5  ;; 0x40023c08
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD503             BPL.N    ??FLASH_OB_Unlock_0
    659            {
    660              /* Authorizes the Option Byte register programming */
    661              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable28_6  ;; 0x8192a3b
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    662              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable28_7  ;; 0x4c5d6e7f
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    663            }  
    664          }
   \                     ??FLASH_OB_Unlock_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    665          
    666          /**
    667            * @brief  Locks the FLASH Option Control Registers access.
    668            * @param  None
    669            * @retval None
    670            */

   \                                 In section .text, align 2, keep-with-next
    671          void FLASH_OB_Lock(void)
    672          {
    673            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    674            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_8  ;; 0x40023c14
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    675          }
   \   0000000A   0x4770             BX       LR               ;; return
    676          
    677          /**
    678            * @brief  Enables or disables the write protection of the desired sectors
    679            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    680            *          This parameter can be one of the following values:
    681            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    682            *            @arg OB_WRP_Sector_All
    683            * @param  Newstate: new state of the Write Protection.
    684            *          This parameter can be: ENABLE or DISABLE.
    685            * @retval None  
    686            */

   \                                 In section .text, align 2, keep-with-next
    687          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    688          { 
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    689            FLASH_Status status = FLASH_COMPLETE;
    690            
    691            /* Check the parameters */
    692            assert_param(IS_OB_WRP(OB_WRP));
    693            assert_param(IS_FUNCTIONAL_STATE(NewState));
    694              
    695            status = FLASH_WaitForLastOperation();
    696          
    697            if(status == FLASH_COMPLETE)
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000A   0x2808             CMP      R0,#+8
   \   0000000C   0xD108             BNE.N    ??FLASH_OB_WRPConfig_0
    698            { 
    699              if(NewState != DISABLE)
   \   0000000E   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c16
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0xD002             BEQ.N    ??FLASH_OB_WRPConfig_1
    700              {
    701                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
   \   00000016   0x43A1             BICS     R1,R1,R4
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}
    702              }
    703              else
    704              {
    705                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   0000001C   0x4321             ORRS     R1,R4,R1
   \   0000001E   0x8001             STRH     R1,[R0, #+0]
    706              }
    707            }
    708          }
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    709          
    710          /**
    711            * @brief  Sets the read protection level.
    712            * @param  OB_RDP: specifies the read protection level.
    713            *          This parameter can be one of the following values:
    714            *            @arg OB_RDP_Level_0: No protection
    715            *            @arg OB_RDP_Level_1: Read protection of the memory
    716            *            @arg OB_RDP_Level_2: Full chip protection
    717            *   
    718            * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
    719            *    
    720            * @retval None
    721            */

   \                                 In section .text, align 2, keep-with-next
    722          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    723          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    724            FLASH_Status status = FLASH_COMPLETE;
    725          
    726            /* Check the parameters */
    727            assert_param(IS_OB_RDP(OB_RDP));
    728          
    729            status = FLASH_WaitForLastOperation();
    730          
    731            if(status == FLASH_COMPLETE)
   \   00000004   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD101             BNE.N    ??FLASH_OB_RDPConfig_0
    732            {
    733              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
   \   0000000C   0x....             LDR.N    R0,??DataTable28_10  ;; 0x40023c15
   \   0000000E   0x7004             STRB     R4,[R0, #+0]
    734          
    735            }
    736          }
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    737          
    738          /**
    739            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
    740            * @param  OB_IWDG: Selects the IWDG mode
    741            *          This parameter can be one of the following values:
    742            *            @arg OB_IWDG_SW: Software IWDG selected
    743            *            @arg OB_IWDG_HW: Hardware IWDG selected
    744            * @param  OB_STOP: Reset event when entering STOP mode.
    745            *          This parameter  can be one of the following values:
    746            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
    747            *            @arg OB_STOP_RST: Reset generated when entering in STOP
    748            * @param  OB_STDBY: Reset event when entering Standby mode.
    749            *          This parameter  can be one of the following values:
    750            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
    751            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
    752            * @retval None
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    755          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    756            uint8_t optiontmp = 0xFF;
    757            FLASH_Status status = FLASH_COMPLETE; 
    758          
    759            /* Check the parameters */
    760            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    761            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    762            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    763          
    764            /* Wait for last operation to be completed */
    765            status = FLASH_WaitForLastOperation();
    766            
    767            if(status == FLASH_COMPLETE)
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD108             BNE.N    ??FLASH_OB_UserConfig_0
    768            { 
    769              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    770              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
   \   00000010   0x....             LDR.N    R0,??DataTable28_8  ;; 0x40023c14
   \   00000012   0x7801             LDRB     R1,[R0, #+0]
   \   00000014   0xF001 0x010F      AND      R1,R1,#0xF
    771          
    772              /* Update User Option Byte */
    773              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
   \   00000018   0xEA46 0x0204      ORR      R2,R6,R4
   \   0000001C   0x432A             ORRS     R2,R5,R2
   \   0000001E   0x4311             ORRS     R1,R1,R2
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    774            }  
    775          }
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    776          
    777          /**
    778            * @brief  Sets the BOR Level. 
    779            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
    780            *          This parameter can be one of the following values:
    781            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    782            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    783            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    784            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
    785            * @retval None
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          void FLASH_OB_BORConfig(uint8_t OB_BOR)
    788          {
    789            /* Check the parameters */
    790            assert_param(IS_OB_BOR(OB_BOR));
    791          
    792            /* Set the BOR Level */
    793            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable28_8  ;; 0x40023c14
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xF002 0x02F3      AND      R2,R2,#0xF3
   \   00000008   0x700A             STRB     R2,[R1, #+0]
    794            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
   \   0000000A   0x780A             LDRB     R2,[R1, #+0]
   \   0000000C   0x4310             ORRS     R0,R0,R2
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    795          
    796          }
   \   00000010   0x4770             BX       LR               ;; return
    797          
    798          /**
    799            * @brief  Launch the option byte loading.
    800            * @param  None
    801            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    802            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    803            */

   \                                 In section .text, align 2, keep-with-next
    804          FLASH_Status FLASH_OB_Launch(void)
    805          {
    806            FLASH_Status status = FLASH_COMPLETE;
    807          
    808            /* Set the OPTSTRT bit in OPTCR register */
    809            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \                     FLASH_OB_Launch: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_8  ;; 0x40023c14
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    810          
    811            /* Wait for last operation to be completed */
    812            status = FLASH_WaitForLastOperation();
    813          
    814            return status;
   \   0000000A   0x....             B.N      FLASH_WaitForLastOperation
    815          }
    816          
    817          /**
    818            * @brief  Returns the FLASH User Option Bytes values.
    819            * @param  None
    820            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
    821            *         and RST_STDBY(Bit2).
    822            */

   \                                 In section .text, align 2, keep-with-next
    823          uint8_t FLASH_OB_GetUser(void)
    824          {
    825            /* Return the User Option Byte */
    826            return (uint8_t)(FLASH->OPTCR >> 5);
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_8  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0940             LSRS     R0,R0,#+5
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
    827          }
    828          
    829          /**
    830            * @brief  Returns the FLASH Write Protection Option Bytes value.
    831            * @param  None
    832            * @retval The FLASH Write Protection  Option Bytes value
    833            */

   \                                 In section .text, align 2, keep-with-next
    834          uint16_t FLASH_OB_GetWRP(void)
    835          {
    836            /* Return the FLASH write protection Register value */
    837            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_9  ;; 0x40023c16
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    838          }
    839          
    840          /**
    841            * @brief  Returns the FLASH Read Protection level.
    842            * @param  None
    843            * @retval FLASH ReadOut Protection Status:
    844            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
    845            *           - RESET, when OB_RDP_Level_0 is set
    846            */

   \                                 In section .text, align 2, keep-with-next
    847          FlagStatus FLASH_OB_GetRDP(void)
    848          {
    849            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    850          
    851            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
   \   00000002   0x....             LDR.N    R1,??DataTable28_10  ;; 0x40023c15
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x29AA             CMP      R1,#+170
   \   00000008   0xD000             BEQ.N    ??FLASH_OB_GetRDP_0
    852            {
    853              readstatus = SET;
   \   0000000A   0x2001             MOVS     R0,#+1
    854            }
    855            else
    856            {
    857              readstatus = RESET;
    858            }
    859            return readstatus;
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    860          }
    861          
    862          /**
    863            * @brief  Returns the FLASH BOR level.
    864            * @param  None
    865            * @retval The FLASH BOR level:
    866            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    867            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    868            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    869            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
    870            */

   \                                 In section .text, align 2, keep-with-next
    871          uint8_t FLASH_OB_GetBOR(void)
    872          {
    873            /* Return the FLASH BOR level */
    874            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable28_8  ;; 0x40023c14
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF000 0x000C      AND      R0,R0,#0xC
   \   00000008   0x4770             BX       LR               ;; return
    875          }
    876          
    877          /**
    878            * @}
    879            */
    880          
    881          /** @defgroup FLASH_Group4 Interrupts and flags management functions
    882           *  @brief   Interrupts and flags management functions
    883           *
    884          @verbatim   
    885           ===============================================================================
    886                            Interrupts and flags management functions
    887           ===============================================================================  
    888          
    889          @endverbatim
    890            * @{
    891            */
    892          
    893          /**
    894            * @brief  Enables or disables the specified FLASH interrupts.
    895            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
    896            *          This parameter can be any combination of the following values:
    897            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
    898            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
    899            * @retval None 
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
    902          {
    903            /* Check the parameters */
    904            assert_param(IS_FLASH_IT(FLASH_IT)); 
    905            assert_param(IS_FUNCTIONAL_STATE(NewState));
    906          
    907            if(NewState != DISABLE)
   \                     FLASH_ITConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable28_4  ;; 0x40023c10
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xD002             BEQ.N    ??FLASH_ITConfig_0
    908            {
    909              /* Enable the interrupt sources */
    910              FLASH->CR |= FLASH_IT;
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    911            }
    912            else
    913            {
    914              /* Disable the interrupt sources */
    915              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_0: (+1)
   \   0000000E   0xEA21 0x0000      BIC      R0,R1,R0
   \   00000012   0x6010             STR      R0,[R2, #+0]
    916            }
    917          }
   \   00000014   0x4770             BX       LR               ;; return
    918          
    919          /**
    920            * @brief  Checks whether the specified FLASH flag is set or not.
    921            * @param  FLASH_FLAG: specifies the FLASH flag to check.
    922            *          This parameter can be one of the following values:
    923            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    924            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    925            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    926            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
    927            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    928            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    929            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
    930            * @retval The new state of FLASH_FLAG (SET or RESET).
    931            */

   \                                 In section .text, align 2, keep-with-next
    932          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
    933          {
    934            FlagStatus bitstatus = RESET;
   \                     FLASH_GetFlagStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    935            /* Check the parameters */
    936            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
    937          
    938            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \   00000002   0x....             LDR.N    R2,??DataTable28_11  ;; 0x40023c0c
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x4202             TST      R2,R0
   \   00000008   0xD000             BEQ.N    ??FLASH_GetFlagStatus_0
    939            {
    940              bitstatus = SET;
   \   0000000A   0x2101             MOVS     R1,#+1
    941            }
    942            else
    943            {
    944              bitstatus = RESET;
    945            }
    946            /* Return the new state of FLASH_FLAG (SET or RESET) */
    947            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    948          }
    949          
    950          /**
    951            * @brief  Clears the FLASH's pending flags.
    952            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
    953            *          This parameter can be any combination of the following values:
    954            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    955            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    956            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    957            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
    958            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    959            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    960            * @retval None
    961            */

   \                                 In section .text, align 2, keep-with-next
    962          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
    963          {
    964            /* Check the parameters */
    965            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
    966            
    967            /* Clear the flags */
    968            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable28_11  ;; 0x40023c0c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    969          }
   \   00000004   0x4770             BX       LR               ;; return
    970          
    971          /**
    972            * @brief  Returns the FLASH Status.
    973            * @param  None
    974            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    975            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    976            */

   \                                 In section .text, align 2, keep-with-next
    977          FLASH_Status FLASH_GetStatus(void)
    978          {
    979            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \   00000000   0x2008             MOVS     R0,#+8
    980            
    981            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R1,??DataTable28_11  ;; 0x40023c0c
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x03D2             LSLS     R2,R2,#+15
   \   00000008   0xD501             BPL.N    ??FLASH_GetStatus_0
    982            {
    983              flashstatus = FLASH_BUSY;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    984            }
    985            else 
    986            {  
    987              if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_0: (+1)
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x06D2             LSLS     R2,R2,#+27
   \   00000012   0xD501             BPL.N    ??FLASH_GetStatus_1
    988              { 
    989                flashstatus = FLASH_ERROR_WRP;
   \   00000014   0x2005             MOVS     R0,#+5
   \   00000016   0x4770             BX       LR
    990              }
    991              else 
    992              {
    993                if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_1: (+1)
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0xF012 0x0FEF      TST      R2,#0xEF
   \   0000001E   0xD001             BEQ.N    ??FLASH_GetStatus_2
    994                {
    995                  flashstatus = FLASH_ERROR_PROGRAM; 
   \   00000020   0x2006             MOVS     R0,#+6
   \   00000022   0x4770             BX       LR
    996                }
    997                else
    998                {
    999                  if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2: (+1)
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD500             BPL.N    ??FLASH_GetStatus_3
   1000                  {
   1001                    flashstatus = FLASH_ERROR_OPERATION;
   \   0000002A   0x2007             MOVS     R0,#+7
   1002                  }
   1003                  else
   1004                  {
   1005                    flashstatus = FLASH_COMPLETE;
   1006                  }
   1007                }
   1008              }
   1009            }
   1010            /* Return the FLASH Status */
   1011            return flashstatus;
   \                     ??FLASH_GetStatus_3: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   1012          }
   1013          
   1014          /**
   1015            * @brief  Waits for a FLASH operation to complete.
   1016            * @param  None
   1017            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1018            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1019            */

   \                                 In section .text, align 2, keep-with-next
   1020          FLASH_Status FLASH_WaitForLastOperation(void)
   1021          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1022            __IO FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1023             
   1024            /* Check for the FLASH Status */
   1025            status = FLASH_GetStatus();
   \   00000008   0x.... 0x....      BL       FLASH_GetStatus
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE003             B.N      ??FLASH_WaitForLastOperation_0
   1026          
   1027            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1028               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1029               flag will be set */
   1030            while(status == FLASH_BUSY)
   1031            {
   1032              status = FLASH_GetStatus();
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   00000012   0x.... 0x....      BL       FLASH_GetStatus
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1033            }
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD0F7             BEQ.N    ??FLASH_WaitForLastOperation_1
   1034            /* Return the operation status */
   1035            return status;
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   1036          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0x40023C16         DC32     0x40023c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0x40023C15         DC32     0x40023c15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0x40023C0C         DC32     0x40023c0c
   1037          
   1038          /**
   1039            * @}
   1040            */ 
   1041          
   1042          /**
   1043            * @}
   1044            */ 
   1045          
   1046          /**
   1047            * @}
   1048            */ 
   1049          
   1050          /**
   1051            * @}
   1052            */
   1053          
   1054          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
       0   FLASH_DataCacheCmd
       0   FLASH_DataCacheReset
      16   FLASH_EraseAllSectors
        16   -> FLASH_WaitForLastOperation
      16   FLASH_EraseSector
        16   -> FLASH_WaitForLastOperation
       0   FLASH_GetFlagStatus
       0   FLASH_GetStatus
       0   FLASH_ITConfig
       0   FLASH_InstructionCacheCmd
       0   FLASH_InstructionCacheReset
       0   FLASH_Lock
       0   FLASH_OB_BORConfig
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       0   FLASH_OB_Launch
         0   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Lock
       8   FLASH_OB_RDPConfig
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Unlock
      16   FLASH_OB_UserConfig
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_PrefetchBufferCmd
      16   FLASH_ProgramByte
        16   -> FLASH_WaitForLastOperation
      24   FLASH_ProgramDoubleWord
        24   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
       6  FLASH_ClearFlag
      24  FLASH_DataCacheCmd
      12  FLASH_DataCacheReset
      90  FLASH_EraseAllSectors
     112  FLASH_EraseSector
      16  FLASH_GetFlagStatus
      46  FLASH_GetStatus
      22  FLASH_ITConfig
      24  FLASH_InstructionCacheCmd
      12  FLASH_InstructionCacheReset
      12  FLASH_Lock
      18  FLASH_OB_BORConfig
      10  FLASH_OB_GetBOR
      14  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       6  FLASH_OB_GetWRP
      12  FLASH_OB_Launch
      12  FLASH_OB_Lock
      18  FLASH_OB_RDPConfig
      18  FLASH_OB_Unlock
      36  FLASH_OB_UserConfig
      34  FLASH_OB_WRPConfig
      24  FLASH_PrefetchBufferCmd
      52  FLASH_ProgramByte
      60  FLASH_ProgramDoubleWord
      56  FLASH_ProgramHalfWord
      56  FLASH_ProgramWord
       6  FLASH_SetLatency
      18  FLASH_Unlock
      40  FLASH_WaitForLastOperation

 
 924 bytes in section .text
 
 924 bytes of CODE memory

Errors: none
Warnings: none
