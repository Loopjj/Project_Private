###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:17
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\drivers\fatfs_usb.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\drivers\fatfs_usb.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\fatfs_usb.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\fatfs_usb.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\drivers\fatfs_usb.c
      1          /**	
      2           * |----------------------------------------------------------------------
      3           * | Copyright (C) Tilen Majerle, 2014
      4           * | 
      5           * | This program is free software: you can redistribute it and/or modify
      6           * | it under the terms of the GNU General Public License as published by
      7           * | the Free Software Foundation, either version 3 of the License, or
      8           * | any later version.
      9           * |  
     10           * | This program is distributed in the hope that it will be useful,
     11           * | but WITHOUT ANY WARRANTY; without even the implied warranty of
     12           * | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     13           * | GNU General Public License for more details.
     14           * | 
     15           * | You should have received a copy of the GNU General Public License
     16           * | along with this program.  If not, see <http://www.gnu.org/licenses/>.
     17           * |----------------------------------------------------------------------
     18           */
     19          #include "usb_conf.h"
     20          #include "usbh_usr.h"
     21          #include "fatfs_usb.h"
     22          #include "usbh_msc_core.h"
     23          #include "usb_msc_app.h"
     24          

   \                                 In section .data, align 1
     25          static volatile DSTATUS USB_Stat = STA_NOINIT;	/* Disk status */
   \                     USB_Stat:
   \   00000000   0x01               DC8 1
     26          extern TM_USB_MSCHOST_Result_t 	TM_USB_MSCHOST_INT_Result;
     27          
     28          extern USB_OTG_CORE_HANDLE   USB_OTG_Core;
     29          extern USBH_HOST             USB_Host;
     30          
     31          #define USB_WAIT			500					//Wait 100msec
     32          
     33          
     34          
     35          /*-----------------------------------------------------------------------*/
     36          /* Initialize USB                                                        */
     37          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     38          DSTATUS TM_FATFS_USB_disk_initialize(void) {
   \                     TM_FATFS_USB_disk_initialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     39          	if (HCD_IsDeviceConnected(&USB_OTG_Core) && TM_USB_MSCHOST_INT_Result == TM_USB_MSCHOST_Result_Connected) {
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD009             BEQ.N    ??TM_FATFS_USB_disk_initialize_0
   \   0000000C   0x....             LDR.N    R0,??DataTable4_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD105             BNE.N    ??TM_FATFS_USB_disk_initialize_0
     40          		USB_Stat &= ~STA_NOINIT;
   \   00000014   0x....             LDR.N    R0,??DataTable4_2
   \   00000016   0x7801             LDRB     R1,[R0, #+0]
   \   00000018   0xF001 0x01FE      AND      R1,R1,#0xFE
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
   \   0000001E   0xE004             B.N      ??TM_FATFS_USB_disk_initialize_1
     41          	} else {
     42          		USB_Stat |= STA_NOINIT;
   \                     ??TM_FATFS_USB_disk_initialize_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable4_2
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   \   00000024   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000028   0x7001             STRB     R1,[R0, #+0]
     43          	}
     44          
     45          	return USB_Stat;
   \                     ??TM_FATFS_USB_disk_initialize_1: (+1)
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
     46          }
     47          
     48          /*-----------------------------------------------------------------------*/
     49          /* Get Disk Status                                                       */
     50          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     51          DSTATUS TM_FATFS_USB_disk_status(void) {
     52          	return USB_Stat;
   \                     TM_FATFS_USB_disk_status: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     53          }
     54          
     55          /*-----------------------------------------------------------------------*/
     56          /* Read Sector(s)                                                        */
     57          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     58          DRESULT TM_FATFS_USB_disk_read (
     59          	BYTE *buff,		/* Data buffer to store read data */
     60          	DWORD sector,	/* Sector address (LBA) */
     61          	UINT count		/* Number of sectors to read (1..128) */
     62          )
     63          {
   \                     TM_FATFS_USB_disk_read: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
     64          	BYTE status = USBH_MSC_OK;
   \   0000000A   0x2700             MOVS     R7,#+0
     65          
     66          	if (!count) {
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD101             BNE.N    ??TM_FATFS_USB_disk_read_0
     67          		return RES_PARERR;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE029             B.N      ??TM_FATFS_USB_disk_read_1
     68          	}
     69          	if (USB_Stat & STA_NOINIT) {
   \                     ??TM_FATFS_USB_disk_read_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable4_2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD501             BPL.N    ??TM_FATFS_USB_disk_read_2
     70          		return RES_NOTRDY;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE023             B.N      ??TM_FATFS_USB_disk_read_1
     71          	}
     72          
     73          	if (HCD_IsDeviceConnected(&USB_OTG_Core) && TM_USB_MSCHOST_INT_Result == TM_USB_MSCHOST_Result_Connected) {
   \                     ??TM_FATFS_USB_disk_read_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R8,??DataTable4
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD017             BEQ.N    ??TM_FATFS_USB_disk_read_3
   \   0000002E   0x....             LDR.N    R0,??DataTable4_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD113             BNE.N    ??TM_FATFS_USB_disk_read_3
     74          		do
     75          		{
     76          			status = USBH_MSC_Read10(&USB_OTG_Core, buff, sector, 512 * count);
   \                     ??TM_FATFS_USB_disk_read_4: (+1)
   \   00000036   0x0273             LSLS     R3,R6,#+9
   \   00000038   0x462A             MOV      R2,R5
   \   0000003A   0x4621             MOV      R1,R4
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x.... 0x....      BL       USBH_MSC_Read10
   \   00000042   0x4607             MOV      R7,R0
     77          			USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
   \   00000044   0x....             LDR.N    R1,??DataTable4_3
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       USBH_MSC_HandleBOTXfer
     78          
     79          			if (!HCD_IsDeviceConnected(&USB_OTG_Core)) { 
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD101             BNE.N    ??TM_FATFS_USB_disk_read_5
     80          				return RES_ERROR;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xE006             B.N      ??TM_FATFS_USB_disk_read_1
     81          			}
     82          		} while (status == USBH_MSC_BUSY);
   \                     ??TM_FATFS_USB_disk_read_5: (+1)
   \   0000005A   0x2F03             CMP      R7,#+3
   \   0000005C   0xD0EB             BEQ.N    ??TM_FATFS_USB_disk_read_4
     83          	}
     84          
     85          	if (status == USBH_MSC_OK) {
   \                     ??TM_FATFS_USB_disk_read_3: (+1)
   \   0000005E   0x4638             MOV      R0,R7
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x4180             SBCS     R0,R0,R0
   \   00000064   0x43C0             MVNS     R0,R0
   \   00000066   0x0FC0             LSRS     R0,R0,#+31
     86          		return RES_OK;
   \                     ??TM_FATFS_USB_disk_read_1: (+1)
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     87          	}
     88          	return RES_ERROR;
     89          }
     90          
     91          /*-----------------------------------------------------------------------*/
     92          /* Write Sector(s)                                                       */
     93          /*-----------------------------------------------------------------------*/
     94          #if _USE_WRITE

   \                                 In section .text, align 2, keep-with-next
     95          DRESULT TM_FATFS_USB_disk_write (
     96          	const BYTE *buff,	/* Data to be written */
     97          	DWORD sector,		/* Sector address (LBA) */
     98          	UINT count			/* Number of sectors to write (1..128) */
     99          )
    100          {
   \                     TM_FATFS_USB_disk_write: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    101          	BYTE status = USBH_MSC_OK;
   \   0000000A   0x2700             MOVS     R7,#+0
    102          	if (!count) {
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD101             BNE.N    ??TM_FATFS_USB_disk_write_0
    103          		return RES_PARERR;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE031             B.N      ??TM_FATFS_USB_disk_write_1
    104          	}
    105          	if (USB_Stat & STA_NOINIT) {
   \                     ??TM_FATFS_USB_disk_write_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable4_2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD501             BPL.N    ??TM_FATFS_USB_disk_write_2
    106          		return RES_NOTRDY;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE02B             B.N      ??TM_FATFS_USB_disk_write_1
    107          	}
    108          	if (TM_USB_MSCHOST_INT_Result == TM_USB_MSCHOST_Result_WriteProtected) {
   \                     ??TM_FATFS_USB_disk_write_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R8,??DataTable4_1
   \   00000024   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000028   0x2804             CMP      R0,#+4
   \   0000002A   0xD101             BNE.N    ??TM_FATFS_USB_disk_write_3
    109          		return RES_WRPRT;
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xE023             B.N      ??TM_FATFS_USB_disk_write_1
    110          	}
    111          
    112          	if (HCD_IsDeviceConnected(&USB_OTG_Core) && TM_USB_MSCHOST_INT_Result == TM_USB_MSCHOST_Result_Connected) {
   \                     ??TM_FATFS_USB_disk_write_3: (+1)
   \   00000030   0x.... 0x....      LDR.W    R9,??DataTable4
   \   00000034   0x4648             MOV      R0,R9
   \   00000036   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD017             BEQ.N    ??TM_FATFS_USB_disk_write_4
   \   0000003E   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD113             BNE.N    ??TM_FATFS_USB_disk_write_4
    113          		do
    114          		{
    115          			status = USBH_MSC_Write10(&USB_OTG_Core, (BYTE*)buff, sector, 512 * count);
   \                     ??TM_FATFS_USB_disk_write_5: (+1)
   \   00000046   0x0273             LSLS     R3,R6,#+9
   \   00000048   0x462A             MOV      R2,R5
   \   0000004A   0x4621             MOV      R1,R4
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       USBH_MSC_Write10
   \   00000052   0x4607             MOV      R7,R0
    116          			USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
   \   00000054   0x....             LDR.N    R1,??DataTable4_3
   \   00000056   0x4648             MOV      R0,R9
   \   00000058   0x.... 0x....      BL       USBH_MSC_HandleBOTXfer
    117          
    118          			if (!HCD_IsDeviceConnected(&USB_OTG_Core)) {
   \   0000005C   0x4648             MOV      R0,R9
   \   0000005E   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD101             BNE.N    ??TM_FATFS_USB_disk_write_6
    119          				return RES_ERROR;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE006             B.N      ??TM_FATFS_USB_disk_write_1
    120          			}
    121          		} while (status == USBH_MSC_BUSY);
   \                     ??TM_FATFS_USB_disk_write_6: (+1)
   \   0000006A   0x2F03             CMP      R7,#+3
   \   0000006C   0xD0EB             BEQ.N    ??TM_FATFS_USB_disk_write_5
    122          	}
    123          
    124          	if (status == USBH_MSC_OK) {
   \                     ??TM_FATFS_USB_disk_write_4: (+1)
   \   0000006E   0x4638             MOV      R0,R7
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x4180             SBCS     R0,R0,R0
   \   00000074   0x43C0             MVNS     R0,R0
   \   00000076   0x0FC0             LSRS     R0,R0,#+31
    125          		return RES_OK;
   \                     ??TM_FATFS_USB_disk_write_1: (+1)
   \   00000078   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    126          	}
    127          	return RES_ERROR;
    128          }
    129          #endif
    130          
    131          
    132          /*-----------------------------------------------------------------------*/
    133          /* Miscellaneous Functions                                               */
    134          /*-----------------------------------------------------------------------*/
    135          
    136          #if _USE_IOCTL

   \                                 In section .text, align 4, keep-with-next
    137          DRESULT TM_FATFS_USB_disk_ioctl (
    138          	BYTE cmd,		/* Control code */
    139          	void *buff		/* Buffer to send/receive control data */
    140          )
    141          {
    142          	DRESULT res = RES_OK;
   \                     TM_FATFS_USB_disk_ioctl: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    143          
    144          	if (USB_Stat & STA_NOINIT) {
   \   00000002   0x....             LDR.N    R3,??DataTable4_2
   \   00000004   0x781B             LDRB     R3,[R3, #+0]
   \   00000006   0x07DB             LSLS     R3,R3,#+31
   \   00000008   0xD501             BPL.N    ??TM_FATFS_USB_disk_ioctl_1
    145          		return RES_NOTRDY;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x4770             BX       LR
    146          	}
    147          
    148          	switch (cmd) {
   \                     ??TM_FATFS_USB_disk_ioctl_1: (+1)
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD80F             BHI.N    ??TM_FATFS_USB_disk_ioctl_2
   \   00000012   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??TM_FATFS_USB_disk_ioctl_0:
   \   00000016   0x0F 0x02          DC8      0xF,0x2,0x6,0xA
   \              0x06 0x0A    
    149          		case CTRL_SYNC :		/* Make sure that no pending write process */
    150          			res = RES_OK;
    151          			break;
    152          
    153          		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
    154          			*(DWORD*)buff = (DWORD) USBH_MSC_Param.MSCapacity;
   \                     ??TM_FATFS_USB_disk_ioctl_3: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable4_4
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    155          			res = RES_OK;
    156          			break;
   \   00000020   0xE008             B.N      ??TM_FATFS_USB_disk_ioctl_4
    157          
    158          		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
    159          			*(WORD*)buff = 512;
   \                     ??TM_FATFS_USB_disk_ioctl_5: (+1)
   \   00000022   0xF44F 0x7000      MOV      R0,#+512
   \   00000026   0x8008             STRH     R0,[R1, #+0]
    160          			res = RES_OK;
    161          			break;
   \   00000028   0xE004             B.N      ??TM_FATFS_USB_disk_ioctl_4
    162          
    163          		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
    164          			*(DWORD*)buff = 512;
   \                     ??TM_FATFS_USB_disk_ioctl_6: (+1)
   \   0000002A   0xF44F 0x7000      MOV      R0,#+512
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    165          			break;
   \   00000030   0xE000             B.N      ??TM_FATFS_USB_disk_ioctl_4
    166          
    167          		default:
    168          			res = RES_PARERR;
   \                     ??TM_FATFS_USB_disk_ioctl_2: (+1)
   \   00000032   0x2204             MOVS     R2,#+4
    169          	}
    170          
    171          	return res;
   \                     ??TM_FATFS_USB_disk_ioctl_4: (+1)
   \   00000034   0x4610             MOV      R0,R2
   \   00000036   0x4770             BX       LR               ;; return
    172          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     USB_OTG_Core

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     TM_USB_MSCHOST_INT_Result

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     USB_Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     USB_Host

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     USBH_MSC_Param
    173          #endif
    174          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   TM_FATFS_USB_disk_initialize
         8   -> HCD_IsDeviceConnected
       0   TM_FATFS_USB_disk_ioctl
      24   TM_FATFS_USB_disk_read
        24   -> HCD_IsDeviceConnected
        24   -> USBH_MSC_HandleBOTXfer
        24   -> USBH_MSC_Read10
       0   TM_FATFS_USB_disk_status
      32   TM_FATFS_USB_disk_write
        32   -> HCD_IsDeviceConnected
        32   -> USBH_MSC_HandleBOTXfer
        32   -> USBH_MSC_Write10


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      46  TM_FATFS_USB_disk_initialize
      56  TM_FATFS_USB_disk_ioctl
     108  TM_FATFS_USB_disk_read
       6  TM_FATFS_USB_disk_status
     124  TM_FATFS_USB_disk_write
       1  USB_Stat

 
   1 byte  in section .data
 360 bytes in section .text
 
 360 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
