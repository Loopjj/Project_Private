###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_hcs.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_hcs.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_hcs.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_hcs.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_hcs.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_hcs.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file implements functions for opening and closing host channels
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_hcs.h"
     30          
     31          /** @addtogroup USBH_LIB
     32            * @{
     33            */
     34          
     35          /** @addtogroup USBH_LIB_CORE
     36          * @{
     37          */
     38            
     39          /** @defgroup USBH_HCS
     40            * @brief This file includes opening and closing host channels
     41            * @{
     42            */ 
     43          
     44          /** @defgroup USBH_HCS_Private_Defines
     45            * @{
     46            */ 
     47          /**
     48            * @}
     49            */ 
     50          
     51          /** @defgroup USBH_HCS_Private_TypesDefinitions
     52            * @{
     53            */ 
     54          /**
     55            * @}
     56            */ 
     57          
     58          
     59          /** @defgroup USBH_HCS_Private_Macros
     60            * @{
     61            */ 
     62          /**
     63            * @}
     64            */ 
     65          
     66          
     67          /** @defgroup USBH_HCS_Private_Variables
     68            * @{
     69            */ 
     70          
     71          /**
     72            * @}
     73            */ 
     74          
     75          
     76          /** @defgroup USBH_HCS_Private_FunctionPrototypes
     77            * @{
     78            */ 
     79          static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev);
     80          /**
     81            * @}
     82            */ 
     83          
     84          
     85          /** @defgroup USBH_HCS_Private_Functions
     86            * @{
     87            */ 
     88          
     89          
     90          
     91          /**
     92            * @brief  USBH_Open_Channel
     93            *         Open a  pipe
     94            * @param  pdev : Selected device
     95            * @param  hc_num: Host channel Number
     96            * @param  dev_address: USB Device address allocated to attached device
     97            * @param  speed : USB device speed (Full/Low)
     98            * @param  ep_type: end point type (Bulk/int/ctl)
     99            * @param  mps: max pkt size
    100            * @retval Status
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          uint8_t USBH_Open_Channel  (USB_OTG_CORE_HANDLE *pdev,
    103                                      uint8_t hc_num,
    104                                      uint8_t dev_address,
    105                                      uint8_t speed,
    106                                      uint8_t ep_type,
    107                                      uint16_t mps)
    108          {
   \                     USBH_Open_Channel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    109          
    110            pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
   \   00000002   0xEB00 0x1441      ADD      R4,R0,R1, LSL #+5
   \   00000006   0xF44F 0x756B      MOV      R5,#+940
   \   0000000A   0x442C             ADD      R4,R4,R5
   \   0000000C   0xEB00 0x0541      ADD      R5,R0,R1, LSL #+1
   \   00000010   0xF895 0x658C      LDRB     R6,[R5, #+1420]
   \   00000014   0xF006 0x067F      AND      R6,R6,#0x7F
   \   00000018   0x7066             STRB     R6,[R4, #+1]
    111            pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
   \   0000001A   0xF8B5 0x558C      LDRH     R5,[R5, #+1420]
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x09ED             LSRS     R5,R5,#+7
   \   00000022   0x70A5             STRB     R5,[R4, #+2]
    112            pdev->host.hc[hc_num].dev_addr = dev_address;  
   \   00000024   0x7022             STRB     R2,[R4, #+0]
    113            pdev->host.hc[hc_num].ep_type = ep_type;  
   \   00000026   0x9A04             LDR      R2,[SP, #+16]
   \   00000028   0x7162             STRB     R2,[R4, #+5]
    114            pdev->host.hc[hc_num].max_packet = mps; 
   \   0000002A   0x9A05             LDR      R2,[SP, #+20]
   \   0000002C   0x80E2             STRH     R2,[R4, #+6]
    115            pdev->host.hc[hc_num].speed = speed; 
   \   0000002E   0x70E3             STRB     R3,[R4, #+3]
    116            pdev->host.hc[hc_num].toggle_in = 0; 
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x7622             STRB     R2,[R4, #+24]
    117            pdev->host.hc[hc_num].toggle_out = 0;   
   \   00000034   0x7662             STRB     R2,[R4, #+25]
    118            if(speed == HPRT0_PRTSPD_HIGH_SPEED)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD101             BNE.N    ??USBH_Open_Channel_0
    119            {
    120              pdev->host.hc[hc_num].do_ping = 1;
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x7122             STRB     R2,[R4, #+4]
    121            }
    122            
    123            USB_OTG_HC_Init(pdev, hc_num) ;
   \                     ??USBH_Open_Channel_0: (+1)
   \   0000003E   0x.... 0x....      BL       USB_OTG_HC_Init
    124            
    125            return HC_OK; 
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    126          
    127          }
    128          
    129          /**
    130            * @brief  USBH_Modify_Channel
    131            *         Modify a  pipe
    132            * @param  pdev : Selected device
    133            * @param  hc_num: Host channel Number
    134            * @param  dev_address: USB Device address allocated to attached device
    135            * @param  speed : USB device speed (Full/Low)
    136            * @param  ep_type: end point type (Bulk/int/ctl)
    137            * @param  mps: max pkt size
    138            * @retval Status
    139            */

   \                                 In section .text, align 2, keep-with-next
    140          uint8_t USBH_Modify_Channel (USB_OTG_CORE_HANDLE *pdev,
    141                                      uint8_t hc_num,
    142                                      uint8_t dev_address,
    143                                      uint8_t speed,
    144                                      uint8_t ep_type,
    145                                      uint16_t mps)
    146          {
   \                     USBH_Modify_Channel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    147            
    148            if(dev_address != 0)
   \   00000002   0xEB00 0x1441      ADD      R4,R0,R1, LSL #+5
   \   00000006   0xF44F 0x756B      MOV      R5,#+940
   \   0000000A   0x442C             ADD      R4,R4,R5
   \   0000000C   0x0015             MOVS     R5,R2
   \   0000000E   0xD000             BEQ.N    ??USBH_Modify_Channel_0
    149            {
    150              pdev->host.hc[hc_num].dev_addr = dev_address;  
   \   00000010   0x7022             STRB     R2,[R4, #+0]
   \                     ??USBH_Modify_Channel_0: (+1)
   \   00000012   0x9A05             LDR      R2,[SP, #+20]
    151            }
    152            
    153            if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
   \   00000014   0x88E5             LDRH     R5,[R4, #+6]
   \   00000016   0x4616             MOV      R6,R2
   \   00000018   0x42B5             CMP      R5,R6
   \   0000001A   0xD002             BEQ.N    ??USBH_Modify_Channel_1
   \   0000001C   0x0015             MOVS     R5,R2
   \   0000001E   0xD000             BEQ.N    ??USBH_Modify_Channel_1
    154            {
    155              pdev->host.hc[hc_num].max_packet = mps; 
   \   00000020   0x80E2             STRH     R2,[R4, #+6]
    156            }
    157            
    158            if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
   \                     ??USBH_Modify_Channel_1: (+1)
   \   00000022   0x78E2             LDRB     R2,[R4, #+3]
   \   00000024   0x461D             MOV      R5,R3
   \   00000026   0x42AA             CMP      R2,R5
   \   00000028   0xD002             BEQ.N    ??USBH_Modify_Channel_2
   \   0000002A   0x001A             MOVS     R2,R3
   \   0000002C   0xD000             BEQ.N    ??USBH_Modify_Channel_2
    159            {
    160              pdev->host.hc[hc_num].speed = speed; 
   \   0000002E   0x70E3             STRB     R3,[R4, #+3]
    161            }
    162            
    163            USB_OTG_HC_Init(pdev, hc_num);
   \                     ??USBH_Modify_Channel_2: (+1)
   \   00000030   0x.... 0x....      BL       USB_OTG_HC_Init
    164            return HC_OK; 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    165          
    166          }
    167          
    168          /**
    169            * @brief  USBH_Alloc_Channel
    170            *         Allocate a new channel for the pipe
    171            * @param  ep_addr: End point for which the channel to be allocated
    172            * @retval hc_num: Host channel number
    173            */

   \                                 In section .text, align 2, keep-with-next
    174          uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
    175          {
   \                     USBH_Alloc_Channel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    176            uint16_t hc_num;
    177            
    178            hc_num =  USBH_GetFreeChannel(pdev);
   \   00000006   0x.... 0x....      BL       USBH_GetFreeChannel
    179          
    180            if (hc_num != HC_ERROR)
   \   0000000A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD005             BEQ.N    ??USBH_Alloc_Channel_0
    181            {
    182          	pdev->host.channel[hc_num] = HC_USED | ep_addr;
   \   00000012   0xF445 0x4100      ORR      R1,R5,#0x8000
   \   00000016   0xEB04 0x0240      ADD      R2,R4,R0, LSL #+1
   \   0000001A   0xF8A2 0x158C      STRH     R1,[R2, #+1420]
    183            }
    184            return hc_num;
   \                     ??USBH_Alloc_Channel_0: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    185          }
    186          
    187          /**
    188            * @brief  USBH_Free_Pipe
    189            *         Free the USB host channel
    190            * @param  idx: Channel number to be freed 
    191            * @retval Status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          uint8_t USBH_Free_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t idx)
    194          {
    195             if(idx < HC_MAX)
   \                     USBH_Free_Channel: (+1)
   \   00000000   0x2908             CMP      R1,#+8
   \   00000002   0xDA07             BGE.N    ??USBH_Free_Channel_0
    196             {
    197          	 pdev->host.channel[idx] &= HC_USED_MASK;
   \   00000004   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000008   0xF8B0 0x158C      LDRH     R1,[R0, #+1420]
   \   0000000C   0xF3C1 0x010E      UBFX     R1,R1,#+0,#+15
   \   00000010   0xF8A0 0x158C      STRH     R1,[R0, #+1420]
    198             }
    199             return USBH_OK;
   \                     ??USBH_Free_Channel_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    200          }
    201          
    202          
    203          /**
    204            * @brief  USBH_DeAllocate_AllChannel
    205            *         Free all USB host channel
    206          * @param  pdev : core instance
    207            * @retval Status
    208            */

   \                                 In section .text, align 2, keep-with-next
    209          uint8_t USBH_DeAllocate_AllChannel  (USB_OTG_CORE_HANDLE *pdev)
    210          {
    211             uint8_t idx;
    212             
    213             for (idx = 2; idx < HC_MAX ; idx ++)
   \                     USBH_DeAllocate_AllChannel: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE004             B.N      ??USBH_DeAllocate_AllChannel_0
    214             {
    215          	 pdev->host.channel[idx] = 0;
   \                     ??USBH_DeAllocate_AllChannel_1: (+1)
   \   00000006   0xEB00 0x0242      ADD      R2,R0,R2, LSL #+1
   \   0000000A   0xF8A2 0x358C      STRH     R3,[R2, #+1420]
    216             }
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \                     ??USBH_DeAllocate_AllChannel_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0x2A08             CMP      R2,#+8
   \   00000016   0xDBF6             BLT.N    ??USBH_DeAllocate_AllChannel_1
    217             return USBH_OK;
   \   00000018   0x4618             MOV      R0,R3
   \   0000001A   0x4770             BX       LR               ;; return
    218          }
    219          
    220          /**
    221            * @brief  USBH_GetFreeChannel
    222            *         Get a free channel number for allocation to a device endpoint
    223            * @param  None
    224            * @retval idx: Free Channel number
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev)
    227          {
    228            uint8_t idx = 0;
   \                     USBH_GetFreeChannel: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    229            
    230            for (idx = 0 ; idx < HC_MAX ; idx++)
   \   00000002   0xE000             B.N      ??USBH_GetFreeChannel_0
   \                     ??USBH_GetFreeChannel_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??USBH_GetFreeChannel_0: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x2A08             CMP      R2,#+8
   \   0000000C   0xDA07             BGE.N    ??USBH_GetFreeChannel_2
    231            {
    232          	if ((pdev->host.channel[idx] & HC_USED) == 0)
   \   0000000E   0xEB00 0x0242      ADD      R2,R0,R2, LSL #+1
   \   00000012   0xF8B2 0x258C      LDRH     R2,[R2, #+1420]
   \   00000016   0x0412             LSLS     R2,R2,#+16
   \   00000018   0xD4F4             BMI.N    ??USBH_GetFreeChannel_1
    233          	{
    234          	   return idx;
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR
    235          	} 
    236            }
    237            return HC_ERROR;
   \                     ??USBH_GetFreeChannel_2: (+1)
   \   0000001E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000022   0x4770             BX       LR               ;; return
    238          }
    239          
    240          
    241          /**
    242          * @}
    243          */ 
    244          
    245          /**
    246          * @}
    247          */ 
    248          
    249          /**
    250          * @}
    251          */
    252          
    253          /**
    254          * @}
    255          */ 
    256          
    257          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    258          
    259          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USBH_Alloc_Channel
        16   -> USBH_GetFreeChannel
       0   USBH_DeAllocate_AllChannel
       0   USBH_Free_Channel
       0   USBH_GetFreeChannel
      16   USBH_Modify_Channel
        16   -> USB_OTG_HC_Init
      16   USBH_Open_Channel
        16   -> USB_OTG_HC_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      34  USBH_Alloc_Channel
      28  USBH_DeAllocate_AllChannel
      24  USBH_Free_Channel
      36  USBH_GetFreeChannel
      56  USBH_Modify_Channel
      70  USBH_Open_Channel

 
 248 bytes in section .text
 
 248 bytes of CODE memory

Errors: none
Warnings: none
