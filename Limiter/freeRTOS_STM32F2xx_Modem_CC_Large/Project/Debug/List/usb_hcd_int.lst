###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_OTG_Driver\src\usb_hcd_int.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_OTG_Driver\src\usb_hcd_int.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usb_hcd_int.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usb_hcd_int.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_OTG_Driver\src\usb_hcd_int.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_hcd_int.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   Host driver interrupt subroutines
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usb_core.h"
     30          #include "usb_defines.h"
     31          #include "usb_hcd_int.h"
     32          
     33          #if defined   (__CC_ARM) /*!< ARM Compiler */
     34          #pragma O0
     35          #elif defined (__GNUC__) /*!< GNU Compiler */
     36          #pragma GCC optimize ("O0")
     37          #elif defined  (__TASKING__) /*!< TASKING Compiler */ 
     38          #pragma optimize=0                          
     39          
     40          #endif /* __CC_ARM */
     41          
     42          /** @addtogroup USB_OTG_DRIVER
     43          * @{
     44          */
     45          
     46          /** @defgroup USB_HCD_INT 
     47          * @brief This file contains the interrupt subroutines for the Host mode.
     48          * @{
     49          */
     50          
     51          
     52          /** @defgroup USB_HCD_INT_Private_Defines
     53          * @{
     54          */ 
     55          /**
     56          * @}
     57          */ 
     58          
     59          
     60          /** @defgroup USB_HCD_INT_Private_TypesDefinitions
     61          * @{
     62          */ 
     63          /**
     64          * @}
     65          */ 
     66          
     67          
     68          
     69          /** @defgroup USB_HCD_INT_Private_Macros
     70          * @{
     71          */ 
     72          /**
     73          * @}
     74          */ 
     75          
     76          
     77          /** @defgroup USB_HCD_INT_Private_Variables
     78          * @{
     79          */ 
     80          /**
     81          * @}
     82          */ 
     83          
     84          
     85          /** @defgroup USB_HCD_INT_Private_FunctionPrototypes
     86          * @{
     87          */ 
     88          
     89          static uint32_t USB_OTG_USBH_handle_sof_ISR(USB_OTG_CORE_HANDLE *pdev);
     90          static uint32_t USB_OTG_USBH_handle_port_ISR(USB_OTG_CORE_HANDLE *pdev);
     91          static uint32_t USB_OTG_USBH_handle_hc_ISR (USB_OTG_CORE_HANDLE *pdev);
     92          static uint32_t USB_OTG_USBH_handle_hc_n_In_ISR (USB_OTG_CORE_HANDLE *pdev ,
     93                                                           uint32_t num);
     94          static uint32_t USB_OTG_USBH_handle_hc_n_Out_ISR (USB_OTG_CORE_HANDLE *pdev , 
     95                                                            uint32_t num);
     96          static uint32_t USB_OTG_USBH_handle_rx_qlvl_ISR (USB_OTG_CORE_HANDLE *pdev);
     97          static uint32_t USB_OTG_USBH_handle_nptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev);
     98          static uint32_t USB_OTG_USBH_handle_ptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev);
     99          static uint32_t USB_OTG_USBH_handle_Disconnect_ISR (USB_OTG_CORE_HANDLE *pdev);
    100          static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev);
    101          
    102          /**
    103          * @}
    104          */ 
    105          
    106          
    107          /** @defgroup USB_HCD_INT_Private_Functions
    108          * @{
    109          */ 
    110          
    111          /**
    112          * @brief  HOST_Handle_ISR 
    113          *         This function handles all USB Host Interrupts
    114          * @param  pdev: Selected device
    115          * @retval status 
    116          */
    117          

   \                                 In section .text, align 2, keep-with-next
    118          uint32_t USBH_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    119          {
   \                     USBH_OTG_ISR_Handler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    120            USB_OTG_GINTSTS_TypeDef  gintsts;
    121            uint32_t retval = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    122            
    123            gintsts.d32 = 0;
    124            
    125            /* Check if HOST Mode */
    126            if (USB_OTG_IsHostMode(pdev))
   \   00000006   0x.... 0x....      BL       USB_OTG_IsHostMode
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD046             BEQ.N    ??USBH_OTG_ISR_Handler_0
    127            {
    128              gintsts.d32 = USB_OTG_ReadCoreItr(pdev);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       USB_OTG_ReadCoreItr
   \   00000014   0x0005             MOVS     R5,R0
    129              if (!gintsts.d32)
   \   00000016   0xD101             BNE.N    ??USBH_OTG_ISR_Handler_1
    130              {
    131                return 0;
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0xBD70             POP      {R4-R6,PC}
    132              }
    133              
    134              if (gintsts.b.sofintr)
   \                     ??USBH_OTG_ISR_Handler_1: (+1)
   \   0000001C   0xF3C5 0x00C0      UBFX     R0,R5,#+3,#+1
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_2
    135              {
    136                retval |= USB_OTG_USBH_handle_sof_ISR (pdev);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USB_OTG_USBH_handle_sof_ISR
   \   0000002A   0x4606             MOV      R6,R0
    137              }
    138              
    139              if (gintsts.b.rxstsqlvl)
   \                     ??USBH_OTG_ISR_Handler_2: (+1)
   \   0000002C   0xF3C5 0x1000      UBFX     R0,R5,#+4,#+1
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_3
    140              {
    141                retval |= USB_OTG_USBH_handle_rx_qlvl_ISR (pdev);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       USB_OTG_USBH_handle_rx_qlvl_ISR
   \   0000003A   0x4306             ORRS     R6,R0,R6
    142              }
    143              
    144              if (gintsts.b.nptxfempty)
   \                     ??USBH_OTG_ISR_Handler_3: (+1)
   \   0000003C   0xF3C5 0x1040      UBFX     R0,R5,#+5,#+1
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_4
    145              {
    146                retval |= USB_OTG_USBH_handle_nptxfempty_ISR (pdev);
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       USB_OTG_USBH_handle_nptxfempty_ISR
   \   0000004A   0x4306             ORRS     R6,R0,R6
    147              }
    148              
    149              if (gintsts.b.ptxfempty)
   \                     ??USBH_OTG_ISR_Handler_4: (+1)
   \   0000004C   0xF3C5 0x6080      UBFX     R0,R5,#+26,#+1
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_5
    150              {
    151                retval |= USB_OTG_USBH_handle_ptxfempty_ISR (pdev);
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       USB_OTG_USBH_handle_ptxfempty_ISR
   \   0000005A   0x4306             ORRS     R6,R0,R6
    152              }    
    153              
    154              if (gintsts.b.hcintr)
   \                     ??USBH_OTG_ISR_Handler_5: (+1)
   \   0000005C   0xF3C5 0x6040      UBFX     R0,R5,#+25,#+1
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_6
    155              {
    156                retval |= USB_OTG_USBH_handle_hc_ISR (pdev);
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       USB_OTG_USBH_handle_hc_ISR
   \   0000006A   0x4306             ORRS     R6,R0,R6
    157              }
    158              
    159              if (gintsts.b.portintr)
   \                     ??USBH_OTG_ISR_Handler_6: (+1)
   \   0000006C   0xF3C5 0x6000      UBFX     R0,R5,#+24,#+1
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_7
    160              {
    161                retval |= USB_OTG_USBH_handle_port_ISR (pdev);
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       USB_OTG_USBH_handle_port_ISR
   \   0000007A   0x4306             ORRS     R6,R0,R6
    162              }
    163              
    164              if (gintsts.b.disconnect)
   \                     ??USBH_OTG_ISR_Handler_7: (+1)
   \   0000007C   0xF3C5 0x7040      UBFX     R0,R5,#+29,#+1
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_8
    165              {
    166                retval |= USB_OTG_USBH_handle_Disconnect_ISR (pdev);  
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       USB_OTG_USBH_handle_Disconnect_ISR
   \   0000008A   0x4306             ORRS     R6,R0,R6
    167                
    168              }
    169              
    170              if (gintsts.b.incomplisoout)
   \                     ??USBH_OTG_ISR_Handler_8: (+1)
   \   0000008C   0xF3C5 0x5040      UBFX     R0,R5,#+21,#+1
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD003             BEQ.N    ??USBH_OTG_ISR_Handler_0
    171              {
    172                retval |= USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (pdev);
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR
   \   0000009A   0x4306             ORRS     R6,R0,R6
    173              }
    174              
    175              
    176            }
    177            return retval;
   \                     ??USBH_OTG_ISR_Handler_0: (+1)
   \   0000009C   0x4630             MOV      R0,R6
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
    178          }
    179          
    180          /**
    181          * @brief  USB_OTG_USBH_handle_hc_ISR 
    182          *         This function indicates that one or more host channels has a pending
    183          * @param  pdev: Selected device
    184          * @retval status 
    185          */

   \                                 In section .text, align 2, keep-with-next
    186          static uint32_t USB_OTG_USBH_handle_hc_ISR (USB_OTG_CORE_HANDLE *pdev)
    187          {
   \                     USB_OTG_USBH_handle_hc_ISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    188            USB_OTG_HAINT_TypeDef        haint;
    189            USB_OTG_HCCHAR_TypeDef       hcchar;
    190            uint32_t i = 0;
   \   00000004   0x2700             MOVS     R7,#+0
    191            uint32_t retval = 0;
   \   00000006   0x463E             MOV      R6,R7
    192            
    193            /* Clear appropriate bits in HCINTn to clear the interrupt bit in
    194            * GINTSTS */
    195            
    196            haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
   \   00000008   0x.... 0x....      BL       USB_OTG_ReadHostAllChannels_intr
   \   0000000C   0x4605             MOV      R5,R0
    197            
    198            for (i = 0; i < pdev->cfg.host_channels ; i++)
   \   0000000E   0xE003             B.N      ??USB_OTG_USBH_handle_hc_ISR_0
    199            {
    200              if (haint.b.chint & (1 << i))
    201              {
    202                hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
    203                
    204                if (hcchar.b.epdir)
    205                {
    206                  retval |= USB_OTG_USBH_handle_hc_n_In_ISR (pdev, i);
    207                }
    208                else
    209                {
    210                  retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
   \                     ??USB_OTG_USBH_handle_hc_ISR_1: (+1)
   \   00000010   0x.... 0x....      BL       USB_OTG_USBH_handle_hc_n_Out_ISR
   \   00000014   0x4306             ORRS     R6,R0,R6
    211                }
   \                     ??USB_OTG_USBH_handle_hc_ISR_2: (+1)
   \   00000016   0x1C7F             ADDS     R7,R7,#+1
   \                     ??USB_OTG_USBH_handle_hc_ISR_0: (+1)
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x4287             CMP      R7,R0
   \   0000001C   0xD214             BCS.N    ??USB_OTG_USBH_handle_hc_ISR_3
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x40B8             LSLS     R0,R0,R7
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB289             UXTH     R1,R1
   \   00000026   0x4201             TST      R1,R0
   \   00000028   0xD0F5             BEQ.N    ??USB_OTG_USBH_handle_hc_ISR_2
   \   0000002A   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   0000002E   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF3C0 0x30C0      UBFX     R0,R0,#+15,#+1
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xD0E7             BEQ.N    ??USB_OTG_USBH_handle_hc_ISR_1
   \   00000040   0x.... 0x....      BL       USB_OTG_USBH_handle_hc_n_In_ISR
   \   00000044   0x4306             ORRS     R6,R0,R6
   \   00000046   0xE7E6             B.N      ??USB_OTG_USBH_handle_hc_ISR_2
    212              }
    213            }
    214            
    215            return retval;
   \                     ??USB_OTG_USBH_handle_hc_ISR_3: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    216          }
    217          
    218          /**
    219          * @brief  USB_OTG_otg_hcd_handle_sof_intr 
    220          *         Handles the start-of-frame interrupt in host mode.
    221          * @param  pdev: Selected device
    222          * @retval status 
    223          */

   \                                 In section .text, align 2, keep-with-next
    224          static uint32_t USB_OTG_USBH_handle_sof_ISR (USB_OTG_CORE_HANDLE *pdev)
    225          {
   \                     USB_OTG_USBH_handle_sof_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    226            USB_OTG_GINTSTS_TypeDef      gintsts;
    227            gintsts.d32 = 0;
    228            
    229            USBH_HCD_INT_fops->SOF(pdev);
   \   00000004   0x....             LDR.N    R1,??DataTable2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4788             BLX      R1
    230            
    231            /* Clear interrupt */
    232            gintsts.b.sofintr = 1;
    233            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0x68E1             LDR      R1,[R4, #+12]
   \   00000010   0x6148             STR      R0,[R1, #+20]
    234            
    235            return 1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    236          }
    237          
    238          /**
    239          * @brief  USB_OTG_USBH_handle_Disconnect_ISR 
    240          *         Handles disconnect event.
    241          * @param  pdev: Selected device
    242          * @retval status 
    243          */

   \                                 In section .text, align 2, keep-with-next
    244          static uint32_t USB_OTG_USBH_handle_Disconnect_ISR (USB_OTG_CORE_HANDLE *pdev)
    245          {
   \                     USB_OTG_USBH_handle_Disconnect_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    246            USB_OTG_GINTSTS_TypeDef      gintsts;
    247            
    248            gintsts.d32 = 0;
    249            
    250            USBH_HCD_INT_fops->DevDisconnected(pdev);
   \   00000004   0x....             LDR.N    R1,??DataTable2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6889             LDR      R1,[R1, #+8]
   \   0000000A   0x4788             BLX      R1
    251            
    252            /* Clear interrupt */
    253            gintsts.b.disconnect = 1;
    254            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   0000000C   0xF04F 0x5000      MOV      R0,#+536870912
   \   00000010   0x68E1             LDR      R1,[R4, #+12]
   \   00000012   0x6148             STR      R0,[R1, #+20]
    255            
    256            return 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    257          }
    258          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    259          #pragma optimize = none
    260          #endif /* __CC_ARM */
    261          /**
    262          * @brief  USB_OTG_USBH_handle_nptxfempty_ISR 
    263          *         Handles non periodic tx fifo empty.
    264          * @param  pdev: Selected device
    265          * @retval status 
    266          */

   \                                 In section .text, align 2, keep-with-next
    267          static uint32_t USB_OTG_USBH_handle_nptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
    268          {
   \                     USB_OTG_USBH_handle_nptxfempty_ISR: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    269            USB_OTG_GINTMSK_TypeDef      intmsk;
    270            USB_OTG_HNPTXSTS_TypeDef     hnptxsts; 
    271            uint16_t                     len_words , len; 
    272            
    273            hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x6AC0             LDR      R0,[R0, #+44]
   \   00000008   0x9000             STR      R0,[SP, #+0]
    274            
    275            len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   00000010   0x0140             LSLS     R0,R0,#+5
   \   00000012   0x4420             ADD      R0,R4,R0
   \   00000014   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000018   0x1CC0             ADDS     R0,R0,#+3
   \   0000001A   0x0880             LSRS     R0,R0,#+2
   \   0000001C   0x0006             MOVS     R6,R0
    276            
    277            while ((hnptxsts.b.nptxfspcavail > len_words)&&
    278                   (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len != 0))
   \                     ??USB_OTG_USBH_handle_nptxfempty_ISR_0: (+1)
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xDA75             BGE.N    ??USB_OTG_USBH_handle_nptxfempty_ISR_1
   \   00000028   0x9801             LDR      R0,[SP, #+4]
   \   0000002A   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   0000002E   0x0140             LSLS     R0,R0,#+5
   \   00000030   0x4420             ADD      R0,R4,R0
   \   00000032   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD06C             BEQ.N    ??USB_OTG_USBH_handle_nptxfempty_ISR_1
    279            {
    280              
    281              len = hnptxsts.b.nptxfspcavail * 4;
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x0080             LSLS     R0,R0,#+2
   \   00000040   0x0007             MOVS     R7,R0
    282              
    283              if (len > pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len)
   \   00000042   0x9801             LDR      R0,[SP, #+4]
   \   00000044   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   00000048   0x0140             LSLS     R0,R0,#+5
   \   0000004A   0x4420             ADD      R0,R4,R0
   \   0000004C   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x42B8             CMP      R0,R7
   \   00000054   0xD210             BCS.N    ??USB_OTG_USBH_handle_nptxfempty_ISR_2
    284              {
    285                /* Last packet */
    286                len = pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len;
   \   00000056   0x9801             LDR      R0,[SP, #+4]
   \   00000058   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   0000005C   0x0140             LSLS     R0,R0,#+5
   \   0000005E   0x4420             ADD      R0,R4,R0
   \   00000060   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000064   0x0007             MOVS     R7,R0
    287                
    288                intmsk.d32 = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x0005             MOVS     R5,R0
    289                intmsk.b.nptxfempty = 1;
   \   0000006A   0xF055 0x0520      ORRS     R5,R5,#0x20
    290                USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);       
   \   0000006E   0x68E0             LDR      R0,[R4, #+12]
   \   00000070   0x6980             LDR      R0,[R0, #+24]
   \   00000072   0x43A8             BICS     R0,R0,R5
   \   00000074   0x68E1             LDR      R1,[R4, #+12]
   \   00000076   0x6188             STR      R0,[R1, #+24]
    291              }
    292              
    293              len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
   \                     ??USB_OTG_USBH_handle_nptxfempty_ISR_2: (+1)
   \   00000078   0x9801             LDR      R0,[SP, #+4]
   \   0000007A   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   0000007E   0x0140             LSLS     R0,R0,#+5
   \   00000080   0x4420             ADD      R0,R4,R0
   \   00000082   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000086   0x1CC0             ADDS     R0,R0,#+3
   \   00000088   0x0880             LSRS     R0,R0,#+2
   \   0000008A   0x0006             MOVS     R6,R0
    294              
    295              USB_OTG_WritePacket (pdev , pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_buff, hnptxsts.b.nptxqtop.chnum, len);
   \   0000008C   0x003B             MOVS     R3,R7
   \   0000008E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000090   0x9801             LDR      R0,[SP, #+4]
   \   00000092   0xF3C0 0x02C3      UBFX     R2,R0,#+3,#+4
   \   00000096   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000098   0x9801             LDR      R0,[SP, #+4]
   \   0000009A   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   0000009E   0x0140             LSLS     R0,R0,#+5
   \   000000A0   0x4420             ADD      R0,R4,R0
   \   000000A2   0xF8D0 0x13B8      LDR      R1,[R0, #+952]
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       USB_OTG_WritePacket
    296              
    297              pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_buff  += len;
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000B2   0x0140             LSLS     R0,R0,#+5
   \   000000B4   0x4420             ADD      R0,R4,R0
   \   000000B6   0x9901             LDR      R1,[SP, #+4]
   \   000000B8   0xF3C1 0x01C3      UBFX     R1,R1,#+3,#+4
   \   000000BC   0x0149             LSLS     R1,R1,#+5
   \   000000BE   0x4421             ADD      R1,R4,R1
   \   000000C0   0xF8D1 0x13B8      LDR      R1,[R1, #+952]
   \   000000C4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C6   0x4439             ADD      R1,R1,R7
   \   000000C8   0xF8C0 0x13B8      STR      R1,[R0, #+952]
    298              pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len   -= len;
   \   000000CC   0x9801             LDR      R0,[SP, #+4]
   \   000000CE   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000D2   0x0140             LSLS     R0,R0,#+5
   \   000000D4   0x4420             ADD      R0,R4,R0
   \   000000D6   0x9901             LDR      R1,[SP, #+4]
   \   000000D8   0xF3C1 0x01C3      UBFX     R1,R1,#+3,#+4
   \   000000DC   0x0149             LSLS     R1,R1,#+5
   \   000000DE   0x4421             ADD      R1,R4,R1
   \   000000E0   0xF8D1 0x13BC      LDR      R1,[R1, #+956]
   \   000000E4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000E6   0x1BC9             SUBS     R1,R1,R7
   \   000000E8   0xF8C0 0x13BC      STR      R1,[R0, #+956]
    299              pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_count  += len; 
   \   000000EC   0x9801             LDR      R0,[SP, #+4]
   \   000000EE   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000F2   0x0140             LSLS     R0,R0,#+5
   \   000000F4   0x4420             ADD      R0,R4,R0
   \   000000F6   0x9901             LDR      R1,[SP, #+4]
   \   000000F8   0xF3C1 0x01C3      UBFX     R1,R1,#+3,#+4
   \   000000FC   0x0149             LSLS     R1,R1,#+5
   \   000000FE   0x4421             ADD      R1,R4,R1
   \   00000100   0xF8D1 0x13C0      LDR      R1,[R1, #+960]
   \   00000104   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000106   0x1879             ADDS     R1,R7,R1
   \   00000108   0xF8C0 0x13C0      STR      R1,[R0, #+960]
    300              
    301              hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   \   0000010C   0x68E0             LDR      R0,[R4, #+12]
   \   0000010E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000110   0x9000             STR      R0,[SP, #+0]
   \   00000112   0xE784             B.N      ??USB_OTG_USBH_handle_nptxfempty_ISR_0
    302            }  
    303            
    304            return 1;
   \                     ??USB_OTG_USBH_handle_nptxfempty_ISR_1: (+1)
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0xBDFE             POP      {R1-R7,PC}       ;; return
    305          }
    306          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    307          #pragma optimize = none
    308          #endif /* __CC_ARM */
    309          /**
    310          * @brief  USB_OTG_USBH_handle_ptxfempty_ISR 
    311          *         Handles periodic tx fifo empty
    312          * @param  pdev: Selected device
    313          * @retval status 
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          static uint32_t USB_OTG_USBH_handle_ptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
    316          {
   \                     USB_OTG_USBH_handle_ptxfempty_ISR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    317            USB_OTG_GINTMSK_TypeDef      intmsk;
    318            USB_OTG_HPTXSTS_TypeDef      hptxsts; 
    319            uint16_t                     len_words , len; 
    320            
    321            hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   \   00000006   0x6960             LDR      R0,[R4, #+20]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    322            
    323            len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   00000012   0x0140             LSLS     R0,R0,#+5
   \   00000014   0x4420             ADD      R0,R4,R0
   \   00000016   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   0000001A   0x1CC0             ADDS     R0,R0,#+3
   \   0000001C   0x0880             LSRS     R0,R0,#+2
   \   0000001E   0x0006             MOVS     R6,R0
    324            
    325            while ((hptxsts.b.ptxfspcavail > len_words)&&
    326                   (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len != 0))    
   \                     ??USB_OTG_USBH_handle_ptxfempty_ISR_0: (+1)
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xDA75             BGE.N    ??USB_OTG_USBH_handle_ptxfempty_ISR_1
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   00000030   0x0140             LSLS     R0,R0,#+5
   \   00000032   0x4420             ADD      R0,R4,R0
   \   00000034   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD06C             BEQ.N    ??USB_OTG_USBH_handle_ptxfempty_ISR_1
    327            {
    328              
    329              len = hptxsts.b.ptxfspcavail * 4;
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000040   0x0080             LSLS     R0,R0,#+2
   \   00000042   0x0007             MOVS     R7,R0
    330              
    331              if (len > pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len)
   \   00000044   0x9801             LDR      R0,[SP, #+4]
   \   00000046   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   0000004A   0x0140             LSLS     R0,R0,#+5
   \   0000004C   0x4420             ADD      R0,R4,R0
   \   0000004E   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000052   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000054   0x42B8             CMP      R0,R7
   \   00000056   0xD210             BCS.N    ??USB_OTG_USBH_handle_ptxfempty_ISR_2
    332              {
    333                len = pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len;
   \   00000058   0x9801             LDR      R0,[SP, #+4]
   \   0000005A   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   0000005E   0x0140             LSLS     R0,R0,#+5
   \   00000060   0x4420             ADD      R0,R4,R0
   \   00000062   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000066   0x0007             MOVS     R7,R0
    334                /* Last packet */
    335                intmsk.d32 = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0005             MOVS     R5,R0
    336                intmsk.b.ptxfempty = 1;
   \   0000006C   0xF055 0x6580      ORRS     R5,R5,#0x4000000
    337                USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0); 
   \   00000070   0x68E0             LDR      R0,[R4, #+12]
   \   00000072   0x6980             LDR      R0,[R0, #+24]
   \   00000074   0x43A8             BICS     R0,R0,R5
   \   00000076   0x68E1             LDR      R1,[R4, #+12]
   \   00000078   0x6188             STR      R0,[R1, #+24]
    338              }
    339              
    340              len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
   \                     ??USB_OTG_USBH_handle_ptxfempty_ISR_2: (+1)
   \   0000007A   0x9801             LDR      R0,[SP, #+4]
   \   0000007C   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   00000080   0x0140             LSLS     R0,R0,#+5
   \   00000082   0x4420             ADD      R0,R4,R0
   \   00000084   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000088   0x1CC0             ADDS     R0,R0,#+3
   \   0000008A   0x0880             LSRS     R0,R0,#+2
   \   0000008C   0x0006             MOVS     R6,R0
    341              
    342              USB_OTG_WritePacket (pdev , pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_buff, hptxsts.b.ptxqtop.chnum, len);
   \   0000008E   0x003B             MOVS     R3,R7
   \   00000090   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000092   0x9801             LDR      R0,[SP, #+4]
   \   00000094   0xF3C0 0x02C3      UBFX     R2,R0,#+3,#+4
   \   00000098   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000A0   0x0140             LSLS     R0,R0,#+5
   \   000000A2   0x4420             ADD      R0,R4,R0
   \   000000A4   0xF8D0 0x13B8      LDR      R1,[R0, #+952]
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       USB_OTG_WritePacket
    343              
    344              pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_buff  += len;
   \   000000AE   0x9801             LDR      R0,[SP, #+4]
   \   000000B0   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000B4   0x0140             LSLS     R0,R0,#+5
   \   000000B6   0x4420             ADD      R0,R4,R0
   \   000000B8   0x9901             LDR      R1,[SP, #+4]
   \   000000BA   0xF3C1 0x01C3      UBFX     R1,R1,#+3,#+4
   \   000000BE   0x0149             LSLS     R1,R1,#+5
   \   000000C0   0x4421             ADD      R1,R4,R1
   \   000000C2   0xF8D1 0x13B8      LDR      R1,[R1, #+952]
   \   000000C6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C8   0x4439             ADD      R1,R1,R7
   \   000000CA   0xF8C0 0x13B8      STR      R1,[R0, #+952]
    345              pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len   -= len;
   \   000000CE   0x9801             LDR      R0,[SP, #+4]
   \   000000D0   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000D4   0x0140             LSLS     R0,R0,#+5
   \   000000D6   0x4420             ADD      R0,R4,R0
   \   000000D8   0x9901             LDR      R1,[SP, #+4]
   \   000000DA   0xF3C1 0x01C3      UBFX     R1,R1,#+3,#+4
   \   000000DE   0x0149             LSLS     R1,R1,#+5
   \   000000E0   0x4421             ADD      R1,R4,R1
   \   000000E2   0xF8D1 0x13BC      LDR      R1,[R1, #+956]
   \   000000E6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000E8   0x1BC9             SUBS     R1,R1,R7
   \   000000EA   0xF8C0 0x13BC      STR      R1,[R0, #+956]
    346              pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_count  += len; 
   \   000000EE   0x9801             LDR      R0,[SP, #+4]
   \   000000F0   0xF3C0 0x00C3      UBFX     R0,R0,#+3,#+4
   \   000000F4   0x0140             LSLS     R0,R0,#+5
   \   000000F6   0x4420             ADD      R0,R4,R0
   \   000000F8   0x9901             LDR      R1,[SP, #+4]
   \   000000FA   0xF3C1 0x01C3      UBFX     R1,R1,#+3,#+4
   \   000000FE   0x0149             LSLS     R1,R1,#+5
   \   00000100   0x4421             ADD      R1,R4,R1
   \   00000102   0xF8D1 0x13C0      LDR      R1,[R1, #+960]
   \   00000106   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000108   0x1879             ADDS     R1,R7,R1
   \   0000010A   0xF8C0 0x13C0      STR      R1,[R0, #+960]
    347              
    348              hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   \   0000010E   0x6960             LDR      R0,[R4, #+20]
   \   00000110   0x6900             LDR      R0,[R0, #+16]
   \   00000112   0x9000             STR      R0,[SP, #+0]
   \   00000114   0xE784             B.N      ??USB_OTG_USBH_handle_ptxfempty_ISR_0
    349            }  
    350            
    351            return 1;
   \                     ??USB_OTG_USBH_handle_ptxfempty_ISR_1: (+1)
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0xBDFE             POP      {R1-R7,PC}       ;; return
    352          }
    353          
    354          /**
    355          * @brief  USB_OTG_USBH_handle_port_ISR 
    356          *         This function determines which interrupt conditions have occurred
    357          * @param  pdev: Selected device
    358          * @retval status 
    359          */
    360          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    361          #pragma optimize = none
    362          #endif /* __CC_ARM */

   \                                 In section .text, align 2, keep-with-next
    363          static uint32_t USB_OTG_USBH_handle_port_ISR (USB_OTG_CORE_HANDLE *pdev)
    364          {
   \                     USB_OTG_USBH_handle_port_ISR: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    365            USB_OTG_HPRT0_TypeDef  hprt0;
    366            USB_OTG_HPRT0_TypeDef  hprt0_dup;
    367            USB_OTG_HCFG_TypeDef   hcfg;    
    368            uint32_t do_reset = 0;
   \   00000006   0xF05F 0x0800      MOVS     R8,#+0
    369            uint32_t retval = 0;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
    370            
    371            hcfg.d32 = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0007             MOVS     R7,R0
    372            hprt0.d32 = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0005             MOVS     R5,R0
    373            hprt0_dup.d32 = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0006             MOVS     R6,R0
    374            
    375            hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
   \   0000001A   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0005             MOVS     R5,R0
    376            hprt0_dup.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
   \   00000022   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0006             MOVS     R6,R0
    377            
    378            /* Clear the interrupt bits in GINTSTS */
    379            
    380            hprt0_dup.b.prtena = 0;
   \   0000002A   0xF07F 0x0004      MVNS     R0,#+4
   \   0000002E   0x4006             ANDS     R6,R0,R6
    381            hprt0_dup.b.prtconndet = 0;
   \   00000030   0xF07F 0x0002      MVNS     R0,#+2
   \   00000034   0x4006             ANDS     R6,R0,R6
    382            hprt0_dup.b.prtenchng = 0;
   \   00000036   0xF07F 0x0008      MVNS     R0,#+8
   \   0000003A   0x4006             ANDS     R6,R0,R6
    383            hprt0_dup.b.prtovrcurrchng = 0;
   \   0000003C   0xF07F 0x0020      MVNS     R0,#+32
   \   00000040   0x4006             ANDS     R6,R0,R6
    384            
    385            /* Port Connect Detected */
    386            if (hprt0.b.prtconndet)
   \   00000042   0xF3C5 0x0040      UBFX     R0,R5,#+1,#+1
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD008             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_0
    387            {
    388          
    389              hprt0_dup.b.prtconndet = 1;
   \   0000004A   0xF056 0x0602      ORRS     R6,R6,#0x2
    390              USBH_HCD_INT_fops->DevConnected(pdev);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x....             LDR.N    R1,??DataTable2
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x6849             LDR      R1,[R1, #+4]
   \   00000056   0x4788             BLX      R1
    391              retval |= 1;
   \   00000058   0xF059 0x0901      ORRS     R9,R9,#0x1
    392            }
    393            
    394            /* Port Enable Changed */
    395            if (hprt0.b.prtenchng)
   \                     ??USB_OTG_USBH_handle_port_ISR_0: (+1)
   \   0000005C   0xF3C5 0x00C0      UBFX     R0,R5,#+3,#+1
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD03C             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_1
    396            {
    397              hprt0_dup.b.prtenchng = 1;
   \   00000064   0xF056 0x0608      ORRS     R6,R6,#0x8
    398              
    399              if (hprt0.b.prtena == 1)
   \   00000068   0xF3C5 0x0080      UBFX     R0,R5,#+2,#+1
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD036             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_1
    400              {
    401                
    402                USBH_HCD_INT_fops->DevConnected(pdev);
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x....             LDR.N    R1,??DataTable2
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x6849             LDR      R1,[R1, #+4]
   \   00000078   0x4788             BLX      R1
    403                
    404                if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
    405                    (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
   \   0000007A   0xF3C5 0x4041      UBFX     R0,R5,#+17,#+2
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD003             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_2
   \   00000082   0xF3C5 0x4041      UBFX     R0,R5,#+17,#+2
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD127             BNE.N    ??USB_OTG_USBH_handle_port_ISR_3
    406                {
    407                  
    408                  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
   \                     ??USB_OTG_USBH_handle_port_ISR_2: (+1)
   \   0000008A   0x6960             LDR      R0,[R4, #+20]
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x0007             MOVS     R7,R0
    409                  
    410                  if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
   \   00000090   0xF3C5 0x4041      UBFX     R0,R5,#+17,#+2
   \   00000094   0x2802             CMP      R0,#+2
   \   00000096   0xD111             BNE.N    ??USB_OTG_USBH_handle_port_ISR_4
    411                  {
    412                    USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 6000 );
   \   00000098   0xF241 0x7070      MOVW     R0,#+6000
   \   0000009C   0x6961             LDR      R1,[R4, #+20]
   \   0000009E   0x6048             STR      R0,[R1, #+4]
    413                    if (hcfg.b.fslspclksel != HCFG_6_MHZ)
   \   000000A0   0xF017 0x0003      ANDS     R0,R7,#0x3
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD01A             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_1
    414                    {
    415                      if(pdev->cfg.phy_itface  == USB_OTG_EMBEDDED_PHY)
   \   000000A8   0x7A20             LDRB     R0,[R4, #+8]
   \   000000AA   0x2802             CMP      R0,#+2
   \   000000AC   0xD103             BNE.N    ??USB_OTG_USBH_handle_port_ISR_5
    416                      {
    417                        USB_OTG_InitFSLSPClkSel(pdev ,HCFG_6_MHZ );
   \   000000AE   0x2102             MOVS     R1,#+2
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       USB_OTG_InitFSLSPClkSel
    418                      }
    419                      do_reset = 1;
   \                     ??USB_OTG_USBH_handle_port_ISR_5: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x4680             MOV      R8,R0
   \   000000BA   0xE010             B.N      ??USB_OTG_USBH_handle_port_ISR_1
    420                    }
    421                  }
    422                  else
    423                  {
    424                    
    425                    USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 48000 );            
   \                     ??USB_OTG_USBH_handle_port_ISR_4: (+1)
   \   000000BC   0xF64B 0x3080      MOVW     R0,#+48000
   \   000000C0   0x6961             LDR      R1,[R4, #+20]
   \   000000C2   0x6048             STR      R0,[R1, #+4]
    426                    if (hcfg.b.fslspclksel != HCFG_48_MHZ)
   \   000000C4   0xF017 0x0003      ANDS     R0,R7,#0x3
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD008             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_1
    427                    {
    428                      USB_OTG_InitFSLSPClkSel(pdev ,HCFG_48_MHZ );
   \   000000CC   0x2101             MOVS     R1,#+1
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       USB_OTG_InitFSLSPClkSel
    429                      do_reset = 1;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x4680             MOV      R8,R0
   \   000000D8   0xE001             B.N      ??USB_OTG_USBH_handle_port_ISR_1
    430                    }
    431                  }
    432                }
    433                else
    434                {
    435                  do_reset = 1;
   \                     ??USB_OTG_USBH_handle_port_ISR_3: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x4680             MOV      R8,R0
    436                }
    437              }
    438            }
    439            /* Overcurrent Change Interrupt */
    440            if (hprt0.b.prtovrcurrchng)
   \                     ??USB_OTG_USBH_handle_port_ISR_1: (+1)
   \   000000DE   0xF3C5 0x1040      UBFX     R0,R5,#+5,#+1
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD003             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_6
    441            {
    442              hprt0_dup.b.prtovrcurrchng = 1;
   \   000000E6   0xF056 0x0620      ORRS     R6,R6,#0x20
    443              retval |= 1;
   \   000000EA   0xF059 0x0901      ORRS     R9,R9,#0x1
    444            }
    445            if (do_reset)
   \                     ??USB_OTG_USBH_handle_port_ISR_6: (+1)
   \   000000EE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F2   0xD002             BEQ.N    ??USB_OTG_USBH_handle_port_ISR_7
    446            {
    447              USB_OTG_ResetPort(pdev);
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       USB_OTG_ResetPort
    448            }
    449            /* Clear Port Interrupts */
    450            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0_dup.d32);
   \                     ??USB_OTG_USBH_handle_port_ISR_7: (+1)
   \   000000FA   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \   000000FE   0x6006             STR      R6,[R0, #+0]
    451            
    452            return retval;
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    453          }
    454          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    455          #pragma optimize = none
    456          #endif /* __CC_ARM */
    457          /**
    458          * @brief  USB_OTG_USBH_handle_hc_n_Out_ISR 
    459          *         Handles interrupt for a specific Host Channel
    460          * @param  pdev: Selected device
    461          * @param  hc_num: Channel number
    462          * @retval status 
    463          */

   \                                 In section .text, align 2, keep-with-next
    464          uint32_t USB_OTG_USBH_handle_hc_n_Out_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
    465          {
   \                     USB_OTG_USBH_handle_hc_n_Out_ISR: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    466            
    467            USB_OTG_HCINTn_TypeDef     hcint;
    468            USB_OTG_HCINTMSK_TypeDef  hcintmsk;
    469            USB_OTG_HC_REGS *hcreg;
    470            USB_OTG_HCCHAR_TypeDef     hcchar; 
    471            
    472            hcreg = pdev->regs.HC_REGS[num];
   \   00000008   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   0000000C   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   00000010   0x0007             MOVS     R7,R0
    473            hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
   \   00000012   0x68B8             LDR      R0,[R7, #+8]
   \   00000014   0x4681             MOV      R9,R0
    474            hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCINTMSK);
   \   00000016   0x68F8             LDR      R0,[R7, #+12]
   \   00000018   0x0006             MOVS     R6,R0
    475            hcint.d32 = hcint.d32 & hcintmsk.d32;
   \   0000001A   0xEA16 0x0909      ANDS     R9,R6,R9
    476            
    477            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
   \   0000001E   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000022   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4680             MOV      R8,R0
    478            
    479            if (hcint.b.ahberr)
   \   0000002A   0xF3C9 0x0080      UBFX     R0,R9,#+2,#+1
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD012             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_0
    480            {
    481              CLEAR_HC_INT(hcreg ,ahberr);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x0008             MOVS     R0,R1
   \   00000036   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000003A   0x60B8             STR      R0,[R7, #+8]
    482              UNMASK_HOST_INT_CHH (num);
   \   0000003C   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000040   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000044   0x68C9             LDR      R1,[R1, #+12]
   \   00000046   0x0008             MOVS     R0,R1
   \   00000048   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004C   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000050   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000054   0x60C8             STR      R0,[R1, #+12]
   \   00000056   0xE17D             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    483            } 
    484            else if (hcint.b.ack)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_0: (+1)
   \   00000058   0xF3C9 0x1040      UBFX     R0,R9,#+5,#+1
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD005             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_2
    485            {
    486              CLEAR_HC_INT(hcreg , ack);
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x0008             MOVS     R0,R1
   \   00000064   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000068   0x60B8             STR      R0,[R7, #+8]
   \   0000006A   0xE173             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    487            }
    488            else if (hcint.b.frmovrun)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_2: (+1)
   \   0000006C   0xF3C9 0x2040      UBFX     R0,R9,#+9,#+1
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD017             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_3
    489            {
    490              UNMASK_HOST_INT_CHH (num);
   \   00000074   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000078   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000007C   0x68C9             LDR      R1,[R1, #+12]
   \   0000007E   0x0008             MOVS     R0,R1
   \   00000080   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000084   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000088   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000008C   0x60C8             STR      R0,[R1, #+12]
    491              USB_OTG_HC_Halt(pdev, num);
   \   0000008E   0x0029             MOVS     R1,R5
   \   00000090   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       USB_OTG_HC_Halt
    492              CLEAR_HC_INT(hcreg ,frmovrun);
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x0008             MOVS     R0,R1
   \   0000009C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000A0   0x60B8             STR      R0,[R7, #+8]
   \   000000A2   0xE157             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    493            }
    494            else if (hcint.b.xfercompl)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_3: (+1)
   \   000000A4   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000A8   0xD521             BPL.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_4
    495            {
    496              pdev->host.ErrCnt[num] = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000000B0   0xF8C1 0x0314      STR      R0,[R1, #+788]
    497              UNMASK_HOST_INT_CHH (num);
   \   000000B4   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000000B8   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000000BC   0x68C9             LDR      R1,[R1, #+12]
   \   000000BE   0x0008             MOVS     R0,R1
   \   000000C0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000C4   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000000C8   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000000CC   0x60C8             STR      R0,[R1, #+12]
    498              USB_OTG_HC_Halt(pdev, num);
   \   000000CE   0x0029             MOVS     R1,R5
   \   000000D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       USB_OTG_HC_Halt
    499              CLEAR_HC_INT(hcreg , xfercompl);
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x0008             MOVS     R0,R1
   \   000000DC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000E0   0x60B8             STR      R0,[R7, #+8]
    500              pdev->host.HC_Status[num] = HC_XFRC;            
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xEB04 0x0105      ADD      R1,R4,R5
   \   000000E8   0xF881 0x038C      STRB     R0,[R1, #+908]
   \   000000EC   0xE132             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    501            }
    502            
    503            else if (hcint.b.stall)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_4: (+1)
   \   000000EE   0xF3C9 0x00C0      UBFX     R0,R9,#+3,#+1
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD01C             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_5
    504            {
    505              CLEAR_HC_INT(hcreg , stall);
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x0008             MOVS     R0,R1
   \   000000FA   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000FE   0x60B8             STR      R0,[R7, #+8]
    506              UNMASK_HOST_INT_CHH (num);
   \   00000100   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000104   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000108   0x68C9             LDR      R1,[R1, #+12]
   \   0000010A   0x0008             MOVS     R0,R1
   \   0000010C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000110   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000114   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000118   0x60C8             STR      R0,[R1, #+12]
    507              USB_OTG_HC_Halt(pdev, num);
   \   0000011A   0x0029             MOVS     R1,R5
   \   0000011C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0x.... 0x....      BL       USB_OTG_HC_Halt
    508              pdev->host.HC_Status[num] = HC_STALL;      
   \   00000124   0x2005             MOVS     R0,#+5
   \   00000126   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000012A   0xF881 0x038C      STRB     R0,[R1, #+908]
   \   0000012E   0xE111             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    509            }
    510            
    511            else if (hcint.b.nak)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_5: (+1)
   \   00000130   0xF3C9 0x1000      UBFX     R0,R9,#+4,#+1
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD021             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_6
    512            {
    513              pdev->host.ErrCnt[num] = 0;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   0000013E   0xF8C1 0x0314      STR      R0,[R1, #+788]
    514              UNMASK_HOST_INT_CHH (num);
   \   00000142   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000146   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000014A   0x68C9             LDR      R1,[R1, #+12]
   \   0000014C   0x0008             MOVS     R0,R1
   \   0000014E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000152   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000156   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000015A   0x60C8             STR      R0,[R1, #+12]
    515              USB_OTG_HC_Halt(pdev, num);
   \   0000015C   0x0029             MOVS     R1,R5
   \   0000015E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x.... 0x....      BL       USB_OTG_HC_Halt
    516              CLEAR_HC_INT(hcreg , nak);
   \   00000166   0x2100             MOVS     R1,#+0
   \   00000168   0x0008             MOVS     R0,R1
   \   0000016A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000016E   0x60B8             STR      R0,[R7, #+8]
    517              pdev->host.HC_Status[num] = HC_NAK;      
   \   00000170   0x2003             MOVS     R0,#+3
   \   00000172   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000176   0xF881 0x038C      STRB     R0,[R1, #+908]
   \   0000017A   0xE0EB             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    518            }
    519            
    520            else if (hcint.b.xacterr)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_6: (+1)
   \   0000017C   0xF3C9 0x10C0      UBFX     R0,R9,#+7,#+1
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD025             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_7
    521            {
    522              UNMASK_HOST_INT_CHH (num);
   \   00000184   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000188   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000018C   0x68C9             LDR      R1,[R1, #+12]
   \   0000018E   0x0008             MOVS     R0,R1
   \   00000190   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000194   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000198   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000019C   0x60C8             STR      R0,[R1, #+12]
    523              USB_OTG_HC_Halt(pdev, num);
   \   0000019E   0x0029             MOVS     R1,R5
   \   000001A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A2   0x0020             MOVS     R0,R4
   \   000001A4   0x.... 0x....      BL       USB_OTG_HC_Halt
    524              pdev->host.ErrCnt[num] ++;
   \   000001A8   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   000001AC   0xF8D0 0x0314      LDR      R0,[R0, #+788]
   \   000001B0   0x1C40             ADDS     R0,R0,#+1
   \   000001B2   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000001B6   0xF8C1 0x0314      STR      R0,[R1, #+788]
    525              pdev->host.HC_Status[num] = HC_XACTERR;
   \   000001BA   0x2006             MOVS     R0,#+6
   \   000001BC   0xEB04 0x0105      ADD      R1,R4,R5
   \   000001C0   0xF881 0x038C      STRB     R0,[R1, #+908]
    526              CLEAR_HC_INT(hcreg , xacterr);
   \   000001C4   0x2100             MOVS     R1,#+0
   \   000001C6   0x0008             MOVS     R0,R1
   \   000001C8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001CC   0x60B8             STR      R0,[R7, #+8]
   \   000001CE   0xE0C1             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    527            }
    528            else if (hcint.b.nyet)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_7: (+1)
   \   000001D0   0xF3C9 0x1080      UBFX     R0,R9,#+6,#+1
   \   000001D4   0x2800             CMP      R0,#+0
   \   000001D6   0xD021             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_8
    529            {
    530              pdev->host.ErrCnt[num] = 0;
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000001DE   0xF8C1 0x0314      STR      R0,[R1, #+788]
    531              UNMASK_HOST_INT_CHH (num);
   \   000001E2   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000001E6   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000001EA   0x68C9             LDR      R1,[R1, #+12]
   \   000001EC   0x0008             MOVS     R0,R1
   \   000001EE   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000001F2   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000001F6   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000001FA   0x60C8             STR      R0,[R1, #+12]
    532              USB_OTG_HC_Halt(pdev, num);
   \   000001FC   0x0029             MOVS     R1,R5
   \   000001FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000200   0x0020             MOVS     R0,R4
   \   00000202   0x.... 0x....      BL       USB_OTG_HC_Halt
    533              CLEAR_HC_INT(hcreg , nyet);
   \   00000206   0x2100             MOVS     R1,#+0
   \   00000208   0x0008             MOVS     R0,R1
   \   0000020A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000020E   0x60B8             STR      R0,[R7, #+8]
    534              pdev->host.HC_Status[num] = HC_NYET;    
   \   00000210   0x2004             MOVS     R0,#+4
   \   00000212   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000216   0xF881 0x038C      STRB     R0,[R1, #+908]
   \   0000021A   0xE09B             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    535            }
    536            else if (hcint.b.datatglerr)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_8: (+1)
   \   0000021C   0xF3C9 0x2080      UBFX     R0,R9,#+10,#+1
   \   00000220   0x2800             CMP      R0,#+0
   \   00000222   0xD021             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_9
    537            {
    538              
    539              UNMASK_HOST_INT_CHH (num);
   \   00000224   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000228   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000022C   0x68C9             LDR      R1,[R1, #+12]
   \   0000022E   0x0008             MOVS     R0,R1
   \   00000230   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000234   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000238   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000023C   0x60C8             STR      R0,[R1, #+12]
    540              USB_OTG_HC_Halt(pdev, num);
   \   0000023E   0x0029             MOVS     R1,R5
   \   00000240   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000242   0x0020             MOVS     R0,R4
   \   00000244   0x.... 0x....      BL       USB_OTG_HC_Halt
    541              CLEAR_HC_INT(hcreg , nak);   
   \   00000248   0x2100             MOVS     R1,#+0
   \   0000024A   0x0008             MOVS     R0,R1
   \   0000024C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000250   0x60B8             STR      R0,[R7, #+8]
    542              pdev->host.HC_Status[num] = HC_DATATGLERR;
   \   00000252   0x2008             MOVS     R0,#+8
   \   00000254   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000258   0xF881 0x038C      STRB     R0,[R1, #+908]
    543              
    544              CLEAR_HC_INT(hcreg , datatglerr);
   \   0000025C   0x2100             MOVS     R1,#+0
   \   0000025E   0x0008             MOVS     R0,R1
   \   00000260   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000264   0x60B8             STR      R0,[R7, #+8]
   \   00000266   0xE075             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    545            }  
    546            else if (hcint.b.chhltd)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_9: (+1)
   \   00000268   0xF3C9 0x0040      UBFX     R0,R9,#+1,#+1
   \   0000026C   0x2800             CMP      R0,#+0
   \   0000026E   0xD071             BEQ.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_1
    547            {
    548              MASK_HOST_INT_CHH (num);
   \   00000270   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000274   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000278   0x68C9             LDR      R1,[R1, #+12]
   \   0000027A   0x0008             MOVS     R0,R1
   \   0000027C   0xF07F 0x0102      MVNS     R1,#+2
   \   00000280   0x4008             ANDS     R0,R1,R0
   \   00000282   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000286   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000028A   0x60C8             STR      R0,[R1, #+12]
    549              
    550              if(pdev->host.HC_Status[num] == HC_XFRC)
   \   0000028C   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000290   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   00000294   0x2801             CMP      R0,#+1
   \   00000296   0xD113             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_10
    551              {
    552                pdev->host.URB_State[num] = URB_DONE;  
   \   00000298   0x2001             MOVS     R0,#+1
   \   0000029A   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000029E   0xF881 0x039B      STRB     R0,[R1, #+923]
    553                
    554                if (hcchar.b.eptype == EP_TYPE_BULK)
   \   000002A2   0xF3C8 0x4081      UBFX     R0,R8,#+18,#+2
   \   000002A6   0x2802             CMP      R0,#+2
   \   000002A8   0xD14F             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    555                {
    556                  pdev->host.hc[num].toggle_out ^= 1; 
   \   000002AA   0x0168             LSLS     R0,R5,#+5
   \   000002AC   0x4420             ADD      R0,R4,R0
   \   000002AE   0xF890 0x03C5      LDRB     R0,[R0, #+965]
   \   000002B2   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000002B6   0x0169             LSLS     R1,R5,#+5
   \   000002B8   0x4421             ADD      R1,R4,R1
   \   000002BA   0xF881 0x03C5      STRB     R0,[R1, #+965]
   \   000002BE   0xE044             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    557                }
    558              }
    559              else if(pdev->host.HC_Status[num] == HC_NAK)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_10: (+1)
   \   000002C0   0xEB04 0x0005      ADD      R0,R4,R5
   \   000002C4   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   000002C8   0x2803             CMP      R0,#+3
   \   000002CA   0xD105             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_12
    560              {
    561                pdev->host.URB_State[num] = URB_NOTREADY;      
   \   000002CC   0x2002             MOVS     R0,#+2
   \   000002CE   0xEB04 0x0105      ADD      R1,R4,R5
   \   000002D2   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   000002D6   0xE038             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    562              }    
    563              else if(pdev->host.HC_Status[num] == HC_NYET)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_12: (+1)
   \   000002D8   0xEB04 0x0005      ADD      R0,R4,R5
   \   000002DC   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   000002E0   0x2804             CMP      R0,#+4
   \   000002E2   0xD110             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_13
    564              {
    565                if(pdev->host.hc[num].do_ping == 1)
   \   000002E4   0x0168             LSLS     R0,R5,#+5
   \   000002E6   0x4420             ADD      R0,R4,R0
   \   000002E8   0xF890 0x03B0      LDRB     R0,[R0, #+944]
   \   000002EC   0x2801             CMP      R0,#+1
   \   000002EE   0xD104             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_14
    566                {
    567                  USB_OTG_HC_DoPing(pdev, num);
   \   000002F0   0x0029             MOVS     R1,R5
   \   000002F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002F4   0x0020             MOVS     R0,R4
   \   000002F6   0x.... 0x....      BL       USB_OTG_HC_DoPing
    568                }
    569                pdev->host.URB_State[num] = URB_NOTREADY;      
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_14: (+1)
   \   000002FA   0x2002             MOVS     R0,#+2
   \   000002FC   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000300   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   00000304   0xE021             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    570              }      
    571              else if(pdev->host.HC_Status[num] == HC_STALL)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_13: (+1)
   \   00000306   0xEB04 0x0005      ADD      R0,R4,R5
   \   0000030A   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   0000030E   0x2805             CMP      R0,#+5
   \   00000310   0xD105             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_15
    572              {
    573                pdev->host.URB_State[num] = URB_STALL;      
   \   00000312   0x2004             MOVS     R0,#+4
   \   00000314   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000318   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   0000031C   0xE015             B.N      ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    574              }  
    575              else if(pdev->host.HC_Status[num] == HC_XACTERR)
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_15: (+1)
   \   0000031E   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000322   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   00000326   0x2806             CMP      R0,#+6
   \   00000328   0xD10F             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    576              {
    577                if (pdev->host.ErrCnt[num] == 3)
   \   0000032A   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   0000032E   0xF8D0 0x0314      LDR      R0,[R0, #+788]
   \   00000332   0x2803             CMP      R0,#+3
   \   00000334   0xD109             BNE.N    ??USB_OTG_USBH_handle_hc_n_Out_ISR_11
    578                {
    579                  pdev->host.URB_State[num] = URB_ERROR;  
   \   00000336   0x2003             MOVS     R0,#+3
   \   00000338   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000033C   0xF881 0x039B      STRB     R0,[R1, #+923]
    580                  pdev->host.ErrCnt[num] = 0;
   \   00000340   0x2000             MOVS     R0,#+0
   \   00000342   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000346   0xF8C1 0x0314      STR      R0,[R1, #+788]
    581                }
    582              }
    583              CLEAR_HC_INT(hcreg , chhltd);    
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_11: (+1)
   \   0000034A   0x2100             MOVS     R1,#+0
   \   0000034C   0x0008             MOVS     R0,R1
   \   0000034E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000352   0x60B8             STR      R0,[R7, #+8]
    584            }
    585            
    586            
    587            return 1;
   \                     ??USB_OTG_USBH_handle_hc_n_Out_ISR_1: (+1)
   \   00000354   0x2001             MOVS     R0,#+1
   \   00000356   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    588          }
    589          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    590          #pragma optimize = none
    591          #endif /* __CC_ARM */
    592          /**
    593          * @brief  USB_OTG_USBH_handle_hc_n_In_ISR 
    594          *         Handles interrupt for a specific Host Channel
    595          * @param  pdev: Selected device
    596          * @param  hc_num: Channel number
    597          * @retval status 
    598          */

   \                                 In section .text, align 2, keep-with-next
    599          uint32_t USB_OTG_USBH_handle_hc_n_In_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
    600          {
   \                     USB_OTG_USBH_handle_hc_n_In_ISR: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    601            USB_OTG_HCINTn_TypeDef     hcint;
    602            USB_OTG_HCINTMSK_TypeDef  hcintmsk;
    603            USB_OTG_HCCHAR_TypeDef     hcchar; 
    604            USB_OTG_HCTSIZn_TypeDef  hctsiz;
    605            USB_OTG_HC_REGS *hcreg;
    606            
    607            
    608            hcreg = pdev->regs.HC_REGS[num];
   \   00000008   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   0000000C   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   00000010   0x4681             MOV      R9,R0
    609            hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
   \   00000012   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000016   0x4682             MOV      R10,R0
    610            hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCINTMSK);
   \   00000018   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   0000001C   0x0006             MOVS     R6,R0
    611            hcint.d32 = hcint.d32 & hcintmsk.d32;
   \   0000001E   0xEA16 0x0A0A      ANDS     R10,R6,R10
    612            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
   \   00000022   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000026   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0007             MOVS     R7,R0
    613            hcintmsk.d32 = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0006             MOVS     R6,R0
    614            
    615            
    616            if (hcint.b.ahberr)
   \   00000032   0xF3CA 0x0080      UBFX     R0,R10,#+2,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD013             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_0
    617            {
    618              CLEAR_HC_INT(hcreg ,ahberr);
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x0008             MOVS     R0,R1
   \   0000003E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000042   0xF8C9 0x0008      STR      R0,[R9, #+8]
    619              UNMASK_HOST_INT_CHH (num);
   \   00000046   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   0000004A   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000004E   0x68C9             LDR      R1,[R1, #+12]
   \   00000050   0x0008             MOVS     R0,R1
   \   00000052   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000056   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   0000005A   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
   \   00000060   0xE05D             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_1
    620            }  
    621            else if (hcint.b.ack)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_0: (+1)
   \   00000062   0xF3CA 0x1040      UBFX     R0,R10,#+5,#+1
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD006             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_2
    622            {
    623              CLEAR_HC_INT(hcreg ,ack);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x0008             MOVS     R0,R1
   \   0000006E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000072   0xF8C9 0x0008      STR      R0,[R9, #+8]
   \   00000076   0xE052             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_1
    624            }
    625            
    626            else if (hcint.b.stall)  
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_2: (+1)
   \   00000078   0xF3CA 0x00C0      UBFX     R0,R10,#+3,#+1
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD027             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_3
    627            {
    628              UNMASK_HOST_INT_CHH (num);
   \   00000080   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000084   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000088   0x68C9             LDR      R1,[R1, #+12]
   \   0000008A   0x0008             MOVS     R0,R1
   \   0000008C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000090   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000094   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000098   0x60C8             STR      R0,[R1, #+12]
    629              pdev->host.HC_Status[num] = HC_STALL; 
   \   0000009A   0x2005             MOVS     R0,#+5
   \   0000009C   0xEB04 0x0105      ADD      R1,R4,R5
   \   000000A0   0xF881 0x038C      STRB     R0,[R1, #+908]
    630              CLEAR_HC_INT(hcreg , nak);   /* Clear the NAK Condition */
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x0008             MOVS     R0,R1
   \   000000A8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000AC   0xF8C9 0x0008      STR      R0,[R9, #+8]
    631              CLEAR_HC_INT(hcreg , stall); /* Clear the STALL Condition */
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x0008             MOVS     R0,R1
   \   000000B4   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000B8   0xF8C9 0x0008      STR      R0,[R9, #+8]
    632              hcint.b.nak = 0;           /* NOTE: When there is a 'stall', reset also nak, 
   \   000000BC   0xF07F 0x0010      MVNS     R0,#+16
   \   000000C0   0xEA10 0x0A0A      ANDS     R10,R0,R10
    633                                            else, the pdev->host.HC_Status = HC_STALL
    634              will be overwritten by 'nak' in code below */
    635              USB_OTG_HC_Halt(pdev, num);    
   \   000000C4   0x0029             MOVS     R1,R5
   \   000000C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       USB_OTG_HC_Halt
   \   000000CE   0xE026             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_1
    636            }
    637            else if (hcint.b.datatglerr)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_3: (+1)
   \   000000D0   0xF3CA 0x2080      UBFX     R0,R10,#+10,#+1
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD022             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_1
    638            {
    639              
    640              UNMASK_HOST_INT_CHH (num);
   \   000000D8   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000000DC   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000000E0   0x68C9             LDR      R1,[R1, #+12]
   \   000000E2   0x0008             MOVS     R0,R1
   \   000000E4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000E8   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000000EC   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000000F0   0x60C8             STR      R0,[R1, #+12]
    641              USB_OTG_HC_Halt(pdev, num);
   \   000000F2   0x0029             MOVS     R1,R5
   \   000000F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0x.... 0x....      BL       USB_OTG_HC_Halt
    642              CLEAR_HC_INT(hcreg , nak);   
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0x0008             MOVS     R0,R1
   \   00000100   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000104   0xF8C9 0x0008      STR      R0,[R9, #+8]
    643              pdev->host.HC_Status[num] = HC_DATATGLERR; 
   \   00000108   0x2008             MOVS     R0,#+8
   \   0000010A   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000010E   0xF881 0x038C      STRB     R0,[R1, #+908]
    644              CLEAR_HC_INT(hcreg , datatglerr);
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x0008             MOVS     R0,R1
   \   00000116   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000011A   0xF8C9 0x0008      STR      R0,[R9, #+8]
    645            }    
    646            
    647            if (hcint.b.frmovrun)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_1: (+1)
   \   0000011E   0xF3CA 0x2040      UBFX     R0,R10,#+9,#+1
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD018             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_4
    648            {
    649              UNMASK_HOST_INT_CHH (num);
   \   00000126   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   0000012A   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000012E   0x68C9             LDR      R1,[R1, #+12]
   \   00000130   0x0008             MOVS     R0,R1
   \   00000132   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000136   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   0000013A   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000013E   0x60C8             STR      R0,[R1, #+12]
    650              USB_OTG_HC_Halt(pdev, num);
   \   00000140   0x0029             MOVS     R1,R5
   \   00000142   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000144   0x0020             MOVS     R0,R4
   \   00000146   0x.... 0x....      BL       USB_OTG_HC_Halt
    651              CLEAR_HC_INT(hcreg ,frmovrun);
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x0008             MOVS     R0,R1
   \   0000014E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000152   0xF8C9 0x0008      STR      R0,[R9, #+8]
   \   00000156   0xE11C             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    652            }
    653            
    654            else if (hcint.b.xfercompl)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_4: (+1)
   \   00000158   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000015C   0xD561             BPL.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_6
    655            {
    656              
    657              if (pdev->cfg.dma_enable == 1)
   \   0000015E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000160   0x2801             CMP      R0,#+1
   \   00000162   0xD111             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_7
    658              {
    659                hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCTSIZ);
   \   00000164   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000168   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   0000016C   0x6900             LDR      R0,[R0, #+16]
   \   0000016E   0x4680             MOV      R8,R0
    660                pdev->host.XferCnt[num] =  pdev->host.hc[num].xfer_len - hctsiz.b.xfersize;
   \   00000170   0x0168             LSLS     R0,R5,#+5
   \   00000172   0x4420             ADD      R0,R4,R0
   \   00000174   0xF8D0 0x03BC      LDR      R0,[R0, #+956]
   \   00000178   0xEA5F 0x3148      LSLS     R1,R8,#+13       ;; ZeroExtS R1,R8,#+13,#+13
   \   0000017C   0x0B49             LSRS     R1,R1,#+13
   \   0000017E   0x1A40             SUBS     R0,R0,R1
   \   00000180   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000184   0xF8C1 0x0350      STR      R0,[R1, #+848]
    661              }
    662              
    663              pdev->host.HC_Status[num] = HC_XFRC;     
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_7: (+1)
   \   00000188   0x2001             MOVS     R0,#+1
   \   0000018A   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000018E   0xF881 0x038C      STRB     R0,[R1, #+908]
    664              pdev->host.ErrCnt [num]= 0;
   \   00000192   0x2000             MOVS     R0,#+0
   \   00000194   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000198   0xF8C1 0x0314      STR      R0,[R1, #+788]
    665              CLEAR_HC_INT(hcreg , xfercompl);
   \   0000019C   0x2100             MOVS     R1,#+0
   \   0000019E   0x0008             MOVS     R0,R1
   \   000001A0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000001A4   0xF8C9 0x0008      STR      R0,[R9, #+8]
    666              
    667              if ((hcchar.b.eptype == EP_TYPE_CTRL)||
    668                  (hcchar.b.eptype == EP_TYPE_BULK))
   \   000001A8   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD003             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_8
   \   000001B0   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   000001B4   0x2802             CMP      R0,#+2
   \   000001B6   0xD122             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_9
    669              {
    670                UNMASK_HOST_INT_CHH (num);
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_8: (+1)
   \   000001B8   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000001BC   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000001C0   0x68C9             LDR      R1,[R1, #+12]
   \   000001C2   0x0008             MOVS     R0,R1
   \   000001C4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000001C8   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000001CC   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000001D0   0x60C8             STR      R0,[R1, #+12]
    671                USB_OTG_HC_Halt(pdev, num);
   \   000001D2   0x0029             MOVS     R1,R5
   \   000001D4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D6   0x0020             MOVS     R0,R4
   \   000001D8   0x.... 0x....      BL       USB_OTG_HC_Halt
    672                CLEAR_HC_INT(hcreg , nak); 
   \   000001DC   0x2100             MOVS     R1,#+0
   \   000001DE   0x0008             MOVS     R0,R1
   \   000001E0   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000001E4   0xF8C9 0x0008      STR      R0,[R9, #+8]
    673                pdev->host.hc[num].toggle_in ^= 1;
   \   000001E8   0x0168             LSLS     R0,R5,#+5
   \   000001EA   0x4420             ADD      R0,R4,R0
   \   000001EC   0xF890 0x03C4      LDRB     R0,[R0, #+964]
   \   000001F0   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000001F4   0x0169             LSLS     R1,R5,#+5
   \   000001F6   0x4421             ADD      R1,R4,R1
   \   000001F8   0xF881 0x03C4      STRB     R0,[R1, #+964]
   \   000001FC   0xE0C9             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    674                
    675              }
    676              else if(hcchar.b.eptype == EP_TYPE_INTR)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_9: (+1)
   \   000001FE   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   00000202   0x2803             CMP      R0,#+3
   \   00000204   0xF040 0x80C5      BNE.W    ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    677              {
    678                hcchar.b.oddfrm  = 1;
   \   00000208   0xF057 0x5700      ORRS     R7,R7,#0x20000000
    679                USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
   \   0000020C   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000210   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   00000214   0x6007             STR      R7,[R0, #+0]
    680                pdev->host.URB_State[num] = URB_DONE;  
   \   00000216   0x2001             MOVS     R0,#+1
   \   00000218   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000021C   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   00000220   0xE0B7             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    681              }
    682              
    683            }
    684            else if (hcint.b.chhltd)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_6: (+1)
   \   00000222   0xF3CA 0x0040      UBFX     R0,R10,#+1,#+1
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD051             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_10
    685            {
    686              MASK_HOST_INT_CHH (num);
   \   0000022A   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   0000022E   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000232   0x68C9             LDR      R1,[R1, #+12]
   \   00000234   0x0008             MOVS     R0,R1
   \   00000236   0xF07F 0x0102      MVNS     R1,#+2
   \   0000023A   0x4008             ANDS     R0,R1,R0
   \   0000023C   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000240   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   00000244   0x60C8             STR      R0,[R1, #+12]
    687              
    688              if(pdev->host.HC_Status[num] == HC_XFRC)
   \   00000246   0xEB04 0x0005      ADD      R0,R4,R5
   \   0000024A   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   0000024E   0x2801             CMP      R0,#+1
   \   00000250   0xD105             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_11
    689              {
    690                pdev->host.URB_State[num] = URB_DONE;      
   \   00000252   0x2001             MOVS     R0,#+1
   \   00000254   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000258   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   0000025C   0xE030             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_12
    691              }
    692              
    693              else if (pdev->host.HC_Status[num] == HC_STALL) 
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_11: (+1)
   \   0000025E   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000262   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   00000266   0x2805             CMP      R0,#+5
   \   00000268   0xD105             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_13
    694              {
    695                pdev->host.URB_State[num] = URB_STALL;
   \   0000026A   0x2004             MOVS     R0,#+4
   \   0000026C   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000270   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   00000274   0xE024             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_12
    696              }   
    697              
    698              else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
    699                      (pdev->host.HC_Status[num] == HC_DATATGLERR))
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_13: (+1)
   \   00000276   0xEB04 0x0005      ADD      R0,R4,R5
   \   0000027A   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   0000027E   0x2806             CMP      R0,#+6
   \   00000280   0xD005             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_14
   \   00000282   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000286   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   0000028A   0x2808             CMP      R0,#+8
   \   0000028C   0xD10A             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_15
    700              {
    701                pdev->host.ErrCnt[num] = 0;
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_14: (+1)
   \   0000028E   0x2000             MOVS     R0,#+0
   \   00000290   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000294   0xF8C1 0x0314      STR      R0,[R1, #+788]
    702                pdev->host.URB_State[num] = URB_ERROR;  
   \   00000298   0x2003             MOVS     R0,#+3
   \   0000029A   0xEB04 0x0105      ADD      R1,R4,R5
   \   0000029E   0xF881 0x039B      STRB     R0,[R1, #+923]
   \   000002A2   0xE00D             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_12
    703                
    704              }
    705              else if(hcchar.b.eptype == EP_TYPE_INTR)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_15: (+1)
   \   000002A4   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   000002A8   0x2803             CMP      R0,#+3
   \   000002AA   0xD109             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_12
    706              {
    707                pdev->host.hc[num].toggle_in ^= 1;
   \   000002AC   0x0168             LSLS     R0,R5,#+5
   \   000002AE   0x4420             ADD      R0,R4,R0
   \   000002B0   0xF890 0x03C4      LDRB     R0,[R0, #+964]
   \   000002B4   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000002B8   0x0169             LSLS     R1,R5,#+5
   \   000002BA   0x4421             ADD      R1,R4,R1
   \   000002BC   0xF881 0x03C4      STRB     R0,[R1, #+964]
    708              }
    709              
    710              CLEAR_HC_INT(hcreg , chhltd);    
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_12: (+1)
   \   000002C0   0x2100             MOVS     R1,#+0
   \   000002C2   0x0008             MOVS     R0,R1
   \   000002C4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000002C8   0xF8C9 0x0008      STR      R0,[R9, #+8]
   \   000002CC   0xE061             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    711              
    712            }    
    713            else if (hcint.b.xacterr)
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_10: (+1)
   \   000002CE   0xF3CA 0x10C0      UBFX     R0,R10,#+7,#+1
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD026             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_16
    714            {
    715              UNMASK_HOST_INT_CHH (num);
   \   000002D6   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000002DA   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000002DE   0x68C9             LDR      R1,[R1, #+12]
   \   000002E0   0x0008             MOVS     R0,R1
   \   000002E2   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000002E6   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000002EA   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   000002EE   0x60C8             STR      R0,[R1, #+12]
    716              pdev->host.ErrCnt[num] ++;
   \   000002F0   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   000002F4   0xF8D0 0x0314      LDR      R0,[R0, #+788]
   \   000002F8   0x1C40             ADDS     R0,R0,#+1
   \   000002FA   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   000002FE   0xF8C1 0x0314      STR      R0,[R1, #+788]
    717              pdev->host.HC_Status[num] = HC_XACTERR;
   \   00000302   0x2006             MOVS     R0,#+6
   \   00000304   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000308   0xF881 0x038C      STRB     R0,[R1, #+908]
    718              USB_OTG_HC_Halt(pdev, num);
   \   0000030C   0x0029             MOVS     R1,R5
   \   0000030E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000310   0x0020             MOVS     R0,R4
   \   00000312   0x.... 0x....      BL       USB_OTG_HC_Halt
    719              CLEAR_HC_INT(hcreg , xacterr);    
   \   00000316   0x2100             MOVS     R1,#+0
   \   00000318   0x0008             MOVS     R0,R1
   \   0000031A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000031E   0xF8C9 0x0008      STR      R0,[R9, #+8]
   \   00000322   0xE036             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    720              
    721            }
    722            else if (hcint.b.nak)  
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_16: (+1)
   \   00000324   0xF3CA 0x1000      UBFX     R0,R10,#+4,#+1
   \   00000328   0x2800             CMP      R0,#+0
   \   0000032A   0xD032             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_5
    723            {  
    724              if(hcchar.b.eptype == EP_TYPE_INTR)
   \   0000032C   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   00000330   0x2803             CMP      R0,#+3
   \   00000332   0xD112             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_17
    725              {
    726                UNMASK_HOST_INT_CHH (num);
   \   00000334   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000338   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000033C   0x68C9             LDR      R1,[R1, #+12]
   \   0000033E   0x0008             MOVS     R0,R1
   \   00000340   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000344   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000348   0xF8D1 0x1090      LDR      R1,[R1, #+144]
   \   0000034C   0x60C8             STR      R0,[R1, #+12]
    727                USB_OTG_HC_Halt(pdev, num);
   \   0000034E   0x0029             MOVS     R1,R5
   \   00000350   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000352   0x0020             MOVS     R0,R4
   \   00000354   0x.... 0x....      BL       USB_OTG_HC_Halt
   \   00000358   0xE010             B.N      ??USB_OTG_USBH_handle_hc_n_In_ISR_18
    728              }
    729              else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
    730                        (hcchar.b.eptype == EP_TYPE_BULK))
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_17: (+1)
   \   0000035A   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   0000035E   0x2800             CMP      R0,#+0
   \   00000360   0xD003             BEQ.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_19
   \   00000362   0xF3C7 0x4081      UBFX     R0,R7,#+18,#+2
   \   00000366   0x2802             CMP      R0,#+2
   \   00000368   0xD108             BNE.N    ??USB_OTG_USBH_handle_hc_n_In_ISR_18
    731              {
    732                /* re-activate the channel  */
    733                hcchar.b.chen = 1;
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_19: (+1)
   \   0000036A   0xF057 0x4700      ORRS     R7,R7,#0x80000000
    734                hcchar.b.chdis = 0;
   \   0000036E   0xF037 0x4780      BICS     R7,R7,#0x40000000
    735                USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
   \   00000372   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000376   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   0000037A   0x6007             STR      R7,[R0, #+0]
    736              }
    737              pdev->host.HC_Status[num] = HC_NAK;
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_18: (+1)
   \   0000037C   0x2003             MOVS     R0,#+3
   \   0000037E   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000382   0xF881 0x038C      STRB     R0,[R1, #+908]
    738              CLEAR_HC_INT(hcreg , nak);   
   \   00000386   0x2100             MOVS     R1,#+0
   \   00000388   0x0008             MOVS     R0,R1
   \   0000038A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000038E   0xF8C9 0x0008      STR      R0,[R9, #+8]
    739            }
    740            
    741            
    742            return 1;
   \                     ??USB_OTG_USBH_handle_hc_n_In_ISR_5: (+1)
   \   00000392   0x2001             MOVS     R0,#+1
   \   00000394   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    743            
    744          }
    745          
    746          /**
    747          * @brief  USB_OTG_USBH_handle_rx_qlvl_ISR 
    748          *         Handles the Rx Status Queue Level Interrupt
    749          * @param  pdev: Selected device
    750          * @retval status 
    751          */
    752          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    753          #pragma optimize = none
    754          #endif /* __CC_ARM */

   \                                 In section .text, align 2, keep-with-next
    755          static uint32_t USB_OTG_USBH_handle_rx_qlvl_ISR (USB_OTG_CORE_HANDLE *pdev)
    756          {
   \                     USB_OTG_USBH_handle_rx_qlvl_ISR: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    757            USB_OTG_GRXFSTS_TypeDef       grxsts;
    758            USB_OTG_GINTMSK_TypeDef       intmsk;
    759            USB_OTG_HCTSIZn_TypeDef       hctsiz; 
    760            USB_OTG_HCCHAR_TypeDef        hcchar;
    761            __IO uint8_t                  channelnum =0;  
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    762            uint32_t                      count;    
    763            
    764            /* Disable the Rx Status Queue Level interrupt */
    765            intmsk.d32 = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4680             MOV      R8,R0
    766            intmsk.b.rxstsqlvl = 1;
   \   00000010   0xF058 0x0810      ORRS     R8,R8,#0x10
    767            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0xEA30 0x0008      BICS     R0,R0,R8
   \   0000001C   0x68E1             LDR      R1,[R4, #+12]
   \   0000001E   0x6188             STR      R0,[R1, #+24]
    768            
    769            grxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRXSTSP);
   \   00000020   0x68E0             LDR      R0,[R4, #+12]
   \   00000022   0x6A00             LDR      R0,[R0, #+32]
   \   00000024   0x0005             MOVS     R5,R0
    770            channelnum = grxsts.b.chnum;  
   \   00000026   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    771            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR);
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000038   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0007             MOVS     R7,R0
    772            
    773            switch (grxsts.b.pktsts)
   \   00000040   0xF3C5 0x4043      UBFX     R0,R5,#+17,#+4
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD15B             BNE.N    ??USB_OTG_USBH_handle_rx_qlvl_ISR_0
    774            {
    775            case GRXSTS_PKTSTS_IN:
    776              /* Read the data into the host buffer. */
    777              if ((grxsts.b.bcnt > 0) && (pdev->host.hc[channelnum].xfer_buff != (void  *)0))
   \   00000048   0xF3C5 0x100A      UBFX     R0,R5,#+4,#+11
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xDB56             BLT.N    ??USB_OTG_USBH_handle_rx_qlvl_ISR_1
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x0140             LSLS     R0,R0,#+5
   \   00000056   0x4420             ADD      R0,R4,R0
   \   00000058   0xF8D0 0x03B8      LDR      R0,[R0, #+952]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD04E             BEQ.N    ??USB_OTG_USBH_handle_rx_qlvl_ISR_1
    778              {  
    779                
    780                USB_OTG_ReadPacket(pdev, pdev->host.hc[channelnum].xfer_buff, grxsts.b.bcnt);
   \   00000060   0xF3C5 0x120A      UBFX     R2,R5,#+4,#+11
   \   00000064   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000066   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006A   0x0140             LSLS     R0,R0,#+5
   \   0000006C   0x4420             ADD      R0,R4,R0
   \   0000006E   0xF8D0 0x13B8      LDR      R1,[R0, #+952]
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       USB_OTG_ReadPacket
    781                /*manage multiple Xfer */
    782                pdev->host.hc[grxsts.b.chnum].xfer_buff += grxsts.b.bcnt;           
   \   00000078   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   0000007C   0x0140             LSLS     R0,R0,#+5
   \   0000007E   0x4420             ADD      R0,R4,R0
   \   00000080   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   00000084   0x0149             LSLS     R1,R1,#+5
   \   00000086   0x4421             ADD      R1,R4,R1
   \   00000088   0xF8D1 0x13B8      LDR      R1,[R1, #+952]
   \   0000008C   0xF3C5 0x120A      UBFX     R2,R5,#+4,#+11
   \   00000090   0x4411             ADD      R1,R1,R2
   \   00000092   0xF8C0 0x13B8      STR      R1,[R0, #+952]
    783                pdev->host.hc[grxsts.b.chnum].xfer_count  += grxsts.b.bcnt;
   \   00000096   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   0000009A   0x0140             LSLS     R0,R0,#+5
   \   0000009C   0x4420             ADD      R0,R4,R0
   \   0000009E   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   000000A2   0x0149             LSLS     R1,R1,#+5
   \   000000A4   0x4421             ADD      R1,R4,R1
   \   000000A6   0xF8D1 0x13C0      LDR      R1,[R1, #+960]
   \   000000AA   0xF3C5 0x120A      UBFX     R2,R5,#+4,#+11
   \   000000AE   0x1851             ADDS     R1,R2,R1
   \   000000B0   0xF8C0 0x13C0      STR      R1,[R0, #+960]
    784                
    785                
    786                count = pdev->host.hc[channelnum].xfer_count;
   \   000000B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B8   0x0140             LSLS     R0,R0,#+5
   \   000000BA   0x4420             ADD      R0,R4,R0
   \   000000BC   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   000000C0   0x4681             MOV      R9,R0
    787                pdev->host.XferCnt[channelnum]  = count;
   \   000000C2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C6   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000CA   0xF8C0 0x9350      STR      R9,[R0, #+848]
    788                
    789                hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCTSIZ);
   \   000000CE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000D8   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   000000DC   0x6900             LDR      R0,[R0, #+16]
   \   000000DE   0x0006             MOVS     R6,R0
    790                if(hctsiz.b.pktcnt > 0)
   \   000000E0   0xF3C6 0x40C9      UBFX     R0,R6,#+19,#+10
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xDB0A             BLT.N    ??USB_OTG_USBH_handle_rx_qlvl_ISR_1
    791                {
    792                  /* re-activate the channel when more packets are expected */
    793                  hcchar.b.chen = 1;
   \   000000E8   0xF057 0x4700      ORRS     R7,R7,#0x80000000
    794                  hcchar.b.chdis = 0;
   \   000000EC   0xF037 0x4780      BICS     R7,R7,#0x40000000
    795                  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
   \   000000F0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F4   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000F8   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   000000FC   0x6007             STR      R7,[R0, #+0]
    796                }
    797              }
    798              break;
   \                     ??USB_OTG_USBH_handle_rx_qlvl_ISR_1: (+1)
   \   000000FE   0xE7FF             B.N      ??USB_OTG_USBH_handle_rx_qlvl_ISR_2
    799              
    800            case GRXSTS_PKTSTS_IN_XFER_COMP:
    801              
    802            case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
    803            case GRXSTS_PKTSTS_CH_HALTED:
    804            default:
    805              break;
    806            }
    807            
    808            /* Enable the Rx Status Queue Level interrupt */
    809            intmsk.b.rxstsqlvl = 1;
   \                     ??USB_OTG_USBH_handle_rx_qlvl_ISR_0: (+1)
   \                     ??USB_OTG_USBH_handle_rx_qlvl_ISR_2: (+1)
   \   00000100   0xF058 0x0810      ORRS     R8,R8,#0x10
    810            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);
   \   00000104   0x68E0             LDR      R0,[R4, #+12]
   \   00000106   0x6980             LDR      R0,[R0, #+24]
   \   00000108   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000010C   0x68E1             LDR      R1,[R4, #+12]
   \   0000010E   0x6188             STR      R0,[R1, #+24]
    811            return 1;
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    812          }
    813          
    814          /**
    815          * @brief  USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR 
    816          *         Handles the incomplete Periodic transfer Interrupt
    817          * @param  pdev: Selected device
    818          * @retval status 
    819          */
    820          #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    821          #pragma optimize = none
    822          #endif /* __CC_ARM */

   \                                 In section .text, align 2, keep-with-next
    823          static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev)
    824          {
   \                     USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    825            
    826            USB_OTG_GINTSTS_TypeDef       gintsts;
    827            USB_OTG_HCCHAR_TypeDef        hcchar; 
    828            
    829            
    830            
    831            
    832            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[0]->HCCHAR);
   \   00000002   0xF8D1 0x0090      LDR      R0,[R1, #+144]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0003             MOVS     R3,R0
    833            hcchar.b.chen = 1;
   \   0000000A   0xF053 0x4300      ORRS     R3,R3,#0x80000000
    834            hcchar.b.chdis = 1;
   \   0000000E   0xF053 0x4380      ORRS     R3,R3,#0x40000000
    835            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[0]->HCCHAR, hcchar.d32);  
   \   00000012   0xF8D1 0x0090      LDR      R0,[R1, #+144]
   \   00000016   0x6003             STR      R3,[R0, #+0]
    836            
    837            gintsts.d32 = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0002             MOVS     R2,R0
    838            /* Clear interrupt */
    839            gintsts.b.incomplisoout = 1;
   \   0000001C   0xF452 0x1200      ORRS     R2,R2,#0x200000
    840            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000020   0x68C8             LDR      R0,[R1, #+12]
   \   00000022   0x6142             STR      R2,[R0, #+20]
    841            
    842            return 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x4770             BX       LR               ;; return
    843          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     USBH_HCD_INT_fops
    844          
    845          /**
    846          * @}
    847          */ 
    848          
    849          /**
    850          * @}
    851          */ 
    852          
    853          /**
    854          * @}
    855          */
    856          
    857          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    858          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USBH_OTG_ISR_Handler
        16   -> USB_OTG_IsHostMode
        16   -> USB_OTG_ReadCoreItr
        16   -> USB_OTG_USBH_handle_Disconnect_ISR
        16   -> USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR
        16   -> USB_OTG_USBH_handle_hc_ISR
        16   -> USB_OTG_USBH_handle_nptxfempty_ISR
        16   -> USB_OTG_USBH_handle_port_ISR
        16   -> USB_OTG_USBH_handle_ptxfempty_ISR
        16   -> USB_OTG_USBH_handle_rx_qlvl_ISR
        16   -> USB_OTG_USBH_handle_sof_ISR
       8   USB_OTG_USBH_handle_Disconnect_ISR
         8   -- Indirect call
       0   USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR
      24   USB_OTG_USBH_handle_hc_ISR
        24   -> USB_OTG_ReadHostAllChannels_intr
        24   -> USB_OTG_USBH_handle_hc_n_In_ISR
        24   -> USB_OTG_USBH_handle_hc_n_Out_ISR
      32   USB_OTG_USBH_handle_hc_n_In_ISR
        32   -> USB_OTG_HC_Halt
      32   USB_OTG_USBH_handle_hc_n_Out_ISR
        32   -> USB_OTG_HC_DoPing
        32   -> USB_OTG_HC_Halt
      32   USB_OTG_USBH_handle_nptxfempty_ISR
        32   -> USB_OTG_WritePacket
      32   USB_OTG_USBH_handle_port_ISR
        32   -- Indirect call
        32   -> USB_OTG_InitFSLSPClkSel
        32   -> USB_OTG_ResetPort
      32   USB_OTG_USBH_handle_ptxfempty_ISR
        32   -> USB_OTG_WritePacket
      32   USB_OTG_USBH_handle_rx_qlvl_ISR
        32   -> USB_OTG_ReadPacket
       8   USB_OTG_USBH_handle_sof_ISR
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
     160  USBH_OTG_ISR_Handler
      24  USB_OTG_USBH_handle_Disconnect_ISR
      40  USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR
      76  USB_OTG_USBH_handle_hc_ISR
     920  USB_OTG_USBH_handle_hc_n_In_ISR
     858  USB_OTG_USBH_handle_hc_n_Out_ISR
     280  USB_OTG_USBH_handle_nptxfempty_ISR
     262  USB_OTG_USBH_handle_port_ISR
     282  USB_OTG_USBH_handle_ptxfempty_ISR
     278  USB_OTG_USBH_handle_rx_qlvl_ISR
      22  USB_OTG_USBH_handle_sof_ISR

 
 3 206 bytes in section .text
 
 3 206 bytes of CODE memory

Errors: none
Warnings: none
