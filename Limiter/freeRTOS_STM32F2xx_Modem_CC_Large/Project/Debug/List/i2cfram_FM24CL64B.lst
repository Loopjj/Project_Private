###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\i2cfram_FM24CL64B.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\i2cfram_FM24CL64B.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\i2cfram_FM24CL64B.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\i2cfram_FM24CL64B.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\i2cfram_FM24CL64B.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2015 LOOP *************************************
      3          *
      4          * File Name          : i2cfram_FM24CL64B.c
      5          *
      6          * Author             : Reserch & Developing 1 Team
      7          *
      8          * Version            : V1.0.1
      9          *
     10          * Date               : 09/23/2015
     11          *
     12          * Description        : I2C_DEV line interface configuration
     13          *
     14          * FRAM Size			     : 64Kbit(8KByte) : 0x00 ~ 0x1FFF 
     15          *********************************************************************************************************
     16          */
     17          
     18          /*
     19          *********************************************************************************************************
     20          *                                             INCLUDE FILES
     21          *********************************************************************************************************
     22          */
     23          
     24          #define I2CFRAM_GLOBALS
     25          #include "includes.h"
     26          
     27          
     28          #define I2C_BUF_SIZE	1024
     29          #define TIMEOUT			  30
     30          
     31          

   \                                 In section .bss, align 4
     32          __IO I2C_Dir I2C_DIR;
   \                     I2C_DIR:
   \   00000000                      DS8 1
     33          __IO uint8_t I2C_BLOCKED    = 0;
   \                     I2C_BLOCKED:
   \   00000001                      DS8 1
     34          __IO uint8_t I2CADDRESS     = 0;
   \                     I2CADDRESS:
   \   00000002                      DS8 1
     35          __IO uint8_t rx_buffer_len  = 0;
   \                     rx_buffer_len:
   \   00000003                      DS8 1
     36          __IO uint8_t tx_buffer_len  = 0;
   \                     tx_buffer_len:
   \   00000004                      DS8 1
     37          __IO uint8_t tx_buffer_ix   = 0;
   \                     tx_buffer_ix:
   \   00000005                      DS8 1
     38          __IO uint8_t rx_buffer_ix   = 0;
   \                     rx_buffer_ix:
   \   00000006                      DS8 1
   \   00000007                      DS8 1
     39          __IO uint8_t tx_buffer[I2C_BUF_SIZE];
     40          __IO uint8_t *rx_buffer_ptr;
   \                     rx_buffer_ptr:
   \   00000008                      DS8 4
   \                     tx_buffer:
   \   0000000C                      DS8 1024
     41          
     42          /*
     43          ********************************************************************************
     44          * Description : framSemaphore_Init
     45          * Arguments   : none
     46          * Return      : 
     47          * Note        : 
     48          ******************************************************************************** 
     49          */

   \                                 In section .text, align 2, keep-with-next
     50          void framSemaphore_Init(void)
     51          {
   \                     framSemaphore_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     52          	BSP_I2C1Sem = xSemaphoreCreateMutex();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable24_4
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       xQueueCreateMutex
   \   0000000C   0x6020             STR      R0,[R4, #+0]
     53          	vSemaphoreCreateBinary(BSP_I2C1Sem);
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       xQueueGenericCreate
   \   00000018   0x6020             STR      R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD006             BEQ.N    ??framSemaphore_Init_0
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x4611             MOV      R1,R2
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      xQueueGenericSend
     54          }
   \                     ??framSemaphore_Init_0: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
     55          
     56          /*
     57          ********************************************************************************
     58          * Description : i2c_write
     59          * Arguments   : buffer, len
     60          * Return      : 
     61          * Note        : 
     62          ******************************************************************************** 
     63          */
     64          

   \                                 In section .text, align 2, keep-with-next
     65          uint8_t i2c_write(uint8_t *buffer, uint8_t len) 
     66          {
   \                     i2c_write: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
     67            uint32_t startime;
     68          
     69          	assert_param(len <= I2C_BUF_SIZE && len > 0);
     70          
     71          	if(BSP_I2C1Sem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable24_4
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??i2c_write_0
     72          	{
     73          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`i2c_write::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
     74          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE060             B.N      ??i2c_write_1
     75          	}
     76          	if(xSemaphoreTake(BSP_I2C1Sem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??i2c_write_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD158             BNE.N    ??i2c_write_2
     77          	{
     78          		// disable interrupts
     79          		I2C_ITConfig(I2C_DEV, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
   \   00000030   0x.... 0x....      LDR.W    R8,??DataTable24_5  ;; 0x40005400
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0xF44F 0x61E0      MOV      R1,#+1792
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       I2C_ITConfig
     80          	        
     81          		/*
     82          		 * check if I2C interace is in use
     83          		*/
     84          		if(I2C_BLOCKED == 0)
   \   00000040   0x.... 0x....      LDR.W    R4,??DataTable24_6
   \   00000044   0x7860             LDRB     R0,[R4, #+1]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD13C             BNE.N    ??i2c_write_3
     85          		{
     86          			I2CADDRESS = SLAVE_ADDRESS;
   \   0000004A   0x20A0             MOVS     R0,#+160
   \   0000004C   0x70A0             STRB     R0,[R4, #+2]
     87          			I2C_DIR = TX;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7020             STRB     R0,[R4, #+0]
     88          			// set buffer length and start index
     89          			tx_buffer_len = len;
   \   00000052   0x7127             STRB     R7,[R4, #+4]
     90          			tx_buffer_ix = 0;
   \   00000054   0x7160             STRB     R0,[R4, #+5]
     91          			rx_buffer_len = 0;
   \   00000056   0x70E0             STRB     R0,[R4, #+3]
     92          			rx_buffer_ix = 0;
   \   00000058   0x71A0             STRB     R0,[R4, #+6]
     93          	                
     94          			__IO uint8_t *tmp_buffer_ptr = tx_buffer;
   \   0000005A   0xF104 0x000C      ADD      R0,R4,#+12
     95          			uint8_t i;
     96          			for(i=0; i<len; ++i) 
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x463B             MOV      R3,R7
   \   00000062   0xE004             B.N      ??i2c_write_4
     97          			{
     98          				*tmp_buffer_ptr++ = *buffer++; // copies faster than using indexed arrays
   \                     ??i2c_write_5: (+1)
   \   00000064   0xF816 0x2B01      LDRB     R2,[R6], #+1
   \   00000068   0xF800 0x2B01      STRB     R2,[R0], #+1
     99          			}
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \                     ??i2c_write_4: (+1)
   \   0000006E   0x460A             MOV      R2,R1
   \   00000070   0xB2D2             UXTB     R2,R2
   \   00000072   0x429A             CMP      R2,R3
   \   00000074   0xD3F6             BCC.N    ??i2c_write_5
    100          	                    
    101          			// start with ACK
    102          			I2C_AcknowledgeConfig(I2C_DEV, ENABLE);
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      BL       I2C_AcknowledgeConfig
    103          			// enable I2V2 event, buffer and error interrupt
    104          			I2C_ITConfig(I2C_DEV, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, ENABLE);
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0xF44F 0x61E0      MOV      R1,#+1792
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       I2C_ITConfig
    105          
    106          			// notify that transfer has started
    107          			I2C_BLOCKED = 1; 
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x7060             STRB     R0,[R4, #+1]
    108          
    109          			// send start condition
    110          			I2C_GenerateSTART(I2C_DEV, ENABLE);
   \   0000008E   0x4601             MOV      R1,R0
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       I2C_GenerateSTART
    111          		}
    112          		else
    113          		{
    114          			xSemaphoreGive(BSP_I2C1Sem);
    115          			return ERROR;
    116          		}
    117          		/*
    118          		 * wait till finished
    119          		*/
    120          		//while(I2C_BLOCKED == 1);
    121          	 
    122          		startime =  systick_uptime();
   \   00000096   0x.... 0x....      BL       systick_uptime
   \   0000009A   0x4606             MOV      R6,R0
    123          		while(I2C_BLOCKED == 1)
   \                     ??i2c_write_6: (+1)
   \   0000009C   0x7860             LDRB     R0,[R4, #+1]
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD104             BNE.N    ??i2c_write_7
    124          		{
    125          		   if ((systick_uptime() - startime) > TIMEOUT)
   \   000000A2   0x.... 0x....      BL       systick_uptime
   \   000000A6   0x1B80             SUBS     R0,R0,R6
   \   000000A8   0x281F             CMP      R0,#+31
   \   000000AA   0xD3F7             BCC.N    ??i2c_write_6
    126          		   {
    127          				break;
    128          		   }
    129          		}
    130          		if(I2C_BLOCKED == 1)	//time out
   \                     ??i2c_write_7: (+1)
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x7861             LDRB     R1,[R4, #+1]
   \   000000B0   0x2901             CMP      R1,#+1
   \   000000B2   0xD10F             BNE.N    ??i2c_write_8
    131          		{
    132          			I2C_BLOCKED = 0;
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x7061             STRB     R1,[R4, #+1]
    133          			xSemaphoreGive(BSP_I2C1Sem);
   \   000000B8   0x460B             MOV      R3,R1
   \   000000BA   0x460A             MOV      R2,R1
   \   000000BC   0x.... 0x....      BL       xQueueGenericSend
    134          			return ERROR;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE00F             B.N      ??i2c_write_1
    135          		}
   \                     ??i2c_write_3: (+1)
   \   000000C4   0x2300             MOVS     R3,#+0
   \   000000C6   0x461A             MOV      R2,R3
   \   000000C8   0x4611             MOV      R1,R2
   \   000000CA   0x6828             LDR      R0,[R5, #+0]
   \   000000CC   0x.... 0x....      BL       xQueueGenericSend
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE007             B.N      ??i2c_write_1
    136          		xSemaphoreGive(BSP_I2C1Sem);
   \                     ??i2c_write_8: (+1)
   \   000000D4   0x2300             MOVS     R3,#+0
   \   000000D6   0x461A             MOV      R2,R3
   \   000000D8   0x4611             MOV      R1,R2
   \   000000DA   0x.... 0x....      BL       xQueueGenericSend
    137          		return OK;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0xE000             B.N      ??i2c_write_1
    138          	}
    139          	return ERROR;
   \                     ??i2c_write_2: (+1)
   \   000000E2   0x2000             MOVS     R0,#+0
   \                     ??i2c_write_1: (+1)
   \   000000E4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    140          }
    141           
    142          /*
    143          ********************************************************************************
    144          * Description : i2c_read
    145          * Arguments   : tx_buf, txlen, rx_buffer, rxlen
    146          * Return      : state
    147          * Note        : 
    148          ******************************************************************************** 
    149          */ 
    150          

   \                                 In section .text, align 2, keep-with-next
    151          uint8_t i2c_read(uint8_t *tx_buf, uint8_t txlen, uint8_t *rx_buffer, uint8_t rxlen)
    152          {
   \                     i2c_read: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
    153            uint32_t startime;
    154          
    155          	assert_param(len <= I2C_BUF_SIZE && rxlen > 0);
    156              assert_param(txlen <= 2);
    157          
    158          	if(BSP_I2C1Sem == NULL)
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable24_4
   \   00000010   0x6838             LDR      R0,[R7, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD107             BNE.N    ??i2c_read_0
    159          	{
    160          		printk("%s err\n",__func__);
   \   00000016   0x.... 0x....      ADR.W    R1,`i2c_read::__func__`
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       printk
    161          		return ERROR;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE064             B.N      ??i2c_read_1
    162          	}
    163          	if(xSemaphoreTake(BSP_I2C1Sem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??i2c_read_0: (+1)
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x461A             MOV      R2,R3
   \   0000002A   0x4611             MOV      R1,R2
   \   0000002C   0x.... 0x....      BL       xQueueGenericReceive
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD15C             BNE.N    ??i2c_read_2
    164          	{
    165          		// disable interrupts
    166          		I2C_ITConfig(I2C_DEV, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
   \   00000034   0x.... 0x....      LDR.W    R8,??DataTable24_5  ;; 0x40005400
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0xF44F 0x61E0      MOV      R1,#+1792
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x.... 0x....      BL       I2C_ITConfig
    167          	                
    168          		/*
    169          		 * check if I2C interface is in use
    170          		 */
    171          		if(I2C_BLOCKED == 0)
   \   00000044   0x.... 0x....      LDR.W    R4,??DataTable24_6
   \   00000048   0x7860             LDRB     R0,[R4, #+1]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD140             BNE.N    ??i2c_read_3
    172          		{
    173          			I2CADDRESS = SLAVE_ADDRESS;
   \   0000004E   0x20A0             MOVS     R0,#+160
   \   00000050   0x70A0             STRB     R0,[R4, #+2]
    174          			I2C_DIR = TXREG;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    175          			rx_buffer_len = rxlen;
   \   00000056   0xF884 0xA003      STRB     R10,[R4, #+3]
    176          			rx_buffer_ix = 0;        
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x71A0             STRB     R0,[R4, #+6]
    177          			rx_buffer_ptr = rx_buffer;
   \   0000005E   0xF8C4 0x9008      STR      R9,[R4, #+8]
    178          			tx_buffer_ix = 0;
   \   00000062   0x7160             STRB     R0,[R4, #+5]
    179          			tx_buffer_len = txlen;
   \   00000064   0x7126             STRB     R6,[R4, #+4]
    180          
    181          			__IO uint8_t *tmp_buffer_ptr = tx_buffer;
   \   00000066   0xF104 0x000C      ADD      R0,R4,#+12
    182          			uint8_t i;
    183          			for(i=0; i<txlen; ++i) {
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x4633             MOV      R3,R6
   \   0000006E   0xE004             B.N      ??i2c_read_4
    184          				*tmp_buffer_ptr++ = *tx_buf++; // copies faster than using indexed arrays
   \                     ??i2c_read_5: (+1)
   \   00000070   0xF815 0x2B01      LDRB     R2,[R5], #+1
   \   00000074   0xF800 0x2B01      STRB     R2,[R0], #+1
    185          			}
   \   00000078   0x1C49             ADDS     R1,R1,#+1
   \                     ??i2c_read_4: (+1)
   \   0000007A   0x460A             MOV      R2,R1
   \   0000007C   0xB2D2             UXTB     R2,R2
   \   0000007E   0x429A             CMP      R2,R3
   \   00000080   0xD3F6             BCC.N    ??i2c_read_5
    186          			// start with ACK
    187          			I2C_AcknowledgeConfig(I2C_DEV, ENABLE);
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       I2C_AcknowledgeConfig
    188          
    189          			// enable I2V2 event, buffer and error interrupt
    190          			I2C_ITConfig(I2C_DEV, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, ENABLE);
   \   0000008A   0x2201             MOVS     R2,#+1
   \   0000008C   0xF44F 0x61E0      MOV      R1,#+1792
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       I2C_ITConfig
    191          
    192          			// notify that transfer has started
    193          			I2C_BLOCKED = 1; 
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x7060             STRB     R0,[R4, #+1]
    194          
    195          			// send start condition
    196          			I2C_GenerateSTART(I2C_DEV, ENABLE);
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x.... 0x....      BL       I2C_GenerateSTART
    197          		}
    198          		else
    199          		{
    200          			xSemaphoreGive(BSP_I2C1Sem);
    201                return ERROR;
    202          		}
    203          		/*
    204          		 * wait till finished
    205          		*/
    206          		startime =  systick_uptime();
   \   000000A2   0x.... 0x....      BL       systick_uptime
   \   000000A6   0x4605             MOV      R5,R0
    207          
    208          		while(I2C_BLOCKED == 1)
   \                     ??i2c_read_6: (+1)
   \   000000A8   0x7860             LDRB     R0,[R4, #+1]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD104             BNE.N    ??i2c_read_7
    209          		{
    210          		   if ((systick_uptime() - startime) > TIMEOUT)
   \   000000AE   0x.... 0x....      BL       systick_uptime
   \   000000B2   0x1B40             SUBS     R0,R0,R5
   \   000000B4   0x281F             CMP      R0,#+31
   \   000000B6   0xD3F7             BCC.N    ??i2c_read_6
    211          		   {
    212          			   break;
    213          		   }
    214          		}
    215          		if(I2C_BLOCKED == 1)	//time out
   \                     ??i2c_read_7: (+1)
   \   000000B8   0x6838             LDR      R0,[R7, #+0]
   \   000000BA   0x7861             LDRB     R1,[R4, #+1]
   \   000000BC   0x2901             CMP      R1,#+1
   \   000000BE   0xD10F             BNE.N    ??i2c_read_8
    216          		{
    217          			I2C_BLOCKED = 0;
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x7061             STRB     R1,[R4, #+1]
    218          			xSemaphoreGive(BSP_I2C1Sem);
   \   000000C4   0x460B             MOV      R3,R1
   \   000000C6   0x460A             MOV      R2,R1
   \   000000C8   0x.... 0x....      BL       xQueueGenericSend
    219          			return ERROR;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE00F             B.N      ??i2c_read_1
    220          		}
   \                     ??i2c_read_3: (+1)
   \   000000D0   0x2300             MOVS     R3,#+0
   \   000000D2   0x461A             MOV      R2,R3
   \   000000D4   0x4611             MOV      R1,R2
   \   000000D6   0x6838             LDR      R0,[R7, #+0]
   \   000000D8   0x.... 0x....      BL       xQueueGenericSend
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xE007             B.N      ??i2c_read_1
    221          		xSemaphoreGive(BSP_I2C1Sem);
   \                     ??i2c_read_8: (+1)
   \   000000E0   0x2300             MOVS     R3,#+0
   \   000000E2   0x461A             MOV      R2,R3
   \   000000E4   0x4611             MOV      R1,R2
   \   000000E6   0x.... 0x....      BL       xQueueGenericSend
    222          	  
    223          		return OK;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE000             B.N      ??i2c_read_1
    224          	}
    225          	return ERROR;
   \                     ??i2c_read_2: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \                     ??i2c_read_1: (+1)
   \   000000F0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    226          }
    227           
    228          
    229          /*
    230          ********************************************************************************
    231          * Description : i2c_is_busy
    232          * Arguments   : none
    233          * Return      : state
    234          * Note        : 
    235          ******************************************************************************** 
    236          */  

   \                                 In section .text, align 2, keep-with-next
    237          uint8_t i2c_is_busy(void)
    238          {
    239             return I2C_BLOCKED;
   \                     i2c_is_busy: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_6
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x4770             BX       LR               ;; return
    240          }
    241          
    242          /*
    243          ********************************************************************************
    244          * Description : eepwrite
    245          * Arguments   : address, data
    246          * Return      : state
    247          * Note        : 
    248          ******************************************************************************** 
    249          */  

   \                                 In section .text, align 2, keep-with-next
    250          int FRAMByteWrite(char data, int address)
    251          {
   \                     FRAMByteWrite: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    252          	int ret = 0;
    253          	uint8_t buff[3];
    254          	
    255          	buff[0] = (address >> 8) & 0x1F;
   \   00000002   0x120A             ASRS     R2,R1,#+8
   \   00000004   0xF002 0x021F      AND      R2,R2,#0x1F
   \   00000008   0xF88D 0x2000      STRB     R2,[SP, #+0]
    256          	buff[1] = (address & 0xFF);
   \   0000000C   0xF88D 0x1001      STRB     R1,[SP, #+1]
    257          	buff[2] = data;
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    258          	ret = i2c_write(buff, 3);
   \   00000014   0x2103             MOVS     R1,#+3
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       i2c_write
    259          
    260          	return ret;
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    261          }
    262          
    263          /*
    264          ********************************************************************************
    265          * Description : eepread
    266          * Arguments   : address, data
    267          * Return      : state
    268          * Note        : 
    269          ******************************************************************************** 
    270          */  

   \                                 In section .text, align 2, keep-with-next
    271          int FRAMByteRead(char *data, int address)
    272          {
   \                     FRAMByteRead: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    273          	int ret = 0;
    274          	uint8_t buff[2];
    275          	
    276          	buff[0] = (address >> 8) & 0x1F;
   \   00000002   0x120A             ASRS     R2,R1,#+8
   \   00000004   0xF002 0x021F      AND      R2,R2,#0x1F
   \   00000008   0xF88D 0x2000      STRB     R2,[SP, #+0]
    277          	buff[1] = (address & 0xFF);
   \   0000000C   0xF88D 0x1001      STRB     R1,[SP, #+1]
    278          
    279          	ret = i2c_read(buff, 2, (uint8_t *)data, 1);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       i2c_read
    280          
    281          	return ret;
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    282          
    283          }
    284          
    285          /*
    286          ********************************************************************************
    287          * Description : eepwrite_multi
    288          * Arguments   : address, data, len
    289          * Return      : state
    290          * Note        : 
    291          ******************************************************************************** 
    292          */  

   \                                 In section .text, align 2, keep-with-next
    293          int eepwrite_multi(u16 addr, u8 *data, u16 len)
    294          {
   \                     eepwrite_multi: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4617             MOV      R7,R2
    295            u16 i, m, p, n;
    296            int ret = 0;
    297            u8 buff[32+2];
    298            int idx;
    299            
    300            m = 32-(addr%32);
   \   0000000C   0xF1CA 0x0020      RSB      R0,R10,#+32
   \   00000010   0xEA4F 0x112A      ASR      R1,R10,#+4
   \   00000014   0xEB0A 0x61D1      ADD      R1,R10,R1, LSR #+27
   \   00000018   0x1149             ASRS     R1,R1,#+5
   \   0000001A   0xEB00 0x1941      ADD      R9,R0,R1, LSL #+5
   \   0000001E   0xFA1F 0xF989      UXTH     R9,R9
    301            
    302            if(m >= len) {
   \   00000022   0x4650             MOV      R0,R10
   \   00000024   0x0A00             LSRS     R0,R0,#+8
   \   00000026   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000002A   0x466D             MOV      R5,SP
   \   0000002C   0x45B9             CMP      R9,R7
   \   0000002E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000032   0xF885 0xA001      STRB     R10,[R5, #+1]
   \   00000036   0xDB0A             BLT.N    ??eepwrite_multi_0
    303              buff[0] = (addr >> 8) & 0x1F;
    304              buff[1] = (addr & 0xFF);
    305              memcpy(&buff[2], data, len);
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000003E   0x.... 0x....      BL       __aeabi_memcpy
    306              ret = i2c_write(buff, len+2);
   \   00000042   0x1CB9             ADDS     R1,R7,#+2
   \   00000044   0xB2C9             UXTB     R1,R1
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       i2c_write
   \   0000004C   0xE055             B.N      ??eepwrite_multi_1
    307            }
    308            else {
    309              buff[0] = (addr >> 8) & 0x1F;
    310              buff[1] = (addr & 0xFF);
    311              memcpy(&buff[2], data, m);
   \                     ??eepwrite_multi_0: (+1)
   \   0000004E   0x464A             MOV      R2,R9
   \   00000050   0x4621             MOV      R1,R4
   \   00000052   0xF10D 0x0002      ADD      R0,SP,#+2
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy
    312              ret = i2c_write(buff, m+2);
   \   0000005A   0xF109 0x0102      ADD      R1,R9,#+2
   \   0000005E   0xB2C9             UXTB     R1,R1
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0x.... 0x....      BL       i2c_write
    313              if(ret == ERROR) return ret;
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD047             BEQ.N    ??eepwrite_multi_1
    314          
    315              addr = addr+m;
   \   0000006A   0x44CA             ADD      R10,R9,R10
    316              len = len-m;
   \   0000006C   0xEBA7 0x0709      SUB      R7,R7,R9
    317              idx = m;
    318              p = len/32;
   \   00000070   0x4639             MOV      R1,R7
   \   00000072   0xB289             UXTH     R1,R1
   \   00000074   0x094E             LSRS     R6,R1,#+5
    319              n = len%32;
   \   00000076   0xB2BF             UXTH     R7,R7
   \   00000078   0x1139             ASRS     R1,R7,#+4
   \   0000007A   0xEB07 0x61D1      ADD      R1,R7,R1, LSR #+27
   \   0000007E   0x1149             ASRS     R1,R1,#+5
   \   00000080   0xEBA7 0x1741      SUB      R7,R7,R1, LSL #+5
   \   00000084   0xB2BF             UXTH     R7,R7
    320              for(i = 0; i < p; i++) {
   \   00000086   0xF04F 0x0800      MOV      R8,#+0
   \   0000008A   0xE01B             B.N      ??eepwrite_multi_2
    321                buff[0] = (addr >> 8) & 0x1F;
   \                     ??eepwrite_multi_3: (+1)
   \   0000008C   0x4650             MOV      R0,R10
   \   0000008E   0xB280             UXTH     R0,R0
   \   00000090   0x0A00             LSRS     R0,R0,#+8
   \   00000092   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000096   0xF88D 0x0000      STRB     R0,[SP, #+0]
    322                buff[1] = (addr & 0xFF);
   \   0000009A   0xF885 0xA001      STRB     R10,[R5, #+1]
    323                memcpy(&buff[2], &data[idx], 32);
   \   0000009E   0x2220             MOVS     R2,#+32
   \   000000A0   0xEB04 0x0109      ADD      R1,R4,R9
   \   000000A4   0xF10D 0x0002      ADD      R0,SP,#+2
   \   000000A8   0x.... 0x....      BL       __aeabi_memcpy
    324                ret = i2c_write(buff, 34);
   \   000000AC   0x2122             MOVS     R1,#+34
   \   000000AE   0x4668             MOV      R0,SP
   \   000000B0   0x.... 0x....      BL       i2c_write
    325                if(ret == ERROR) return ret;
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD020             BEQ.N    ??eepwrite_multi_1
    326                addr += 32;
   \   000000B8   0xF10A 0x0A20      ADD      R10,R10,#+32
    327                idx += 32;
   \   000000BC   0xF109 0x0920      ADD      R9,R9,#+32
    328              }
   \   000000C0   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??eepwrite_multi_2: (+1)
   \   000000C4   0xFA1F 0xF888      UXTH     R8,R8
   \   000000C8   0x45B0             CMP      R8,R6
   \   000000CA   0xDBDF             BLT.N    ??eepwrite_multi_3
    329              if(n > 0) {
   \   000000CC   0x2F00             CMP      R7,#+0
   \   000000CE   0xD014             BEQ.N    ??eepwrite_multi_1
    330                buff[0] = (addr >> 8) & 0x1F;
   \   000000D0   0x4650             MOV      R0,R10
   \   000000D2   0xB280             UXTH     R0,R0
   \   000000D4   0x0A00             LSRS     R0,R0,#+8
   \   000000D6   0xF000 0x001F      AND      R0,R0,#0x1F
   \   000000DA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    331                buff[1] = (addr & 0xFF);
   \   000000DE   0xF885 0xA001      STRB     R10,[R5, #+1]
    332                memcpy(&buff[2], &data[idx], n);
   \   000000E2   0x463A             MOV      R2,R7
   \   000000E4   0xEB04 0x0109      ADD      R1,R4,R9
   \   000000E8   0xF10D 0x0002      ADD      R0,SP,#+2
   \   000000EC   0x.... 0x....      BL       __aeabi_memcpy
    333                ret = i2c_write(buff, n+2);
   \   000000F0   0x1CB9             ADDS     R1,R7,#+2
   \   000000F2   0xB2C9             UXTB     R1,R1
   \   000000F4   0x4668             MOV      R0,SP
   \   000000F6   0x.... 0x....      BL       i2c_write
    334              }
    335            }
    336            return ret;
   \                     ??eepwrite_multi_1: (+1)
   \   000000FA   0xB00A             ADD      SP,SP,#+40
   \   000000FC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    337          }
    338          
    339          /*
    340          ********************************************************************************
    341          * Description : eepread_multi
    342          * Arguments   : address, data, len
    343          * Return      : state
    344          * Note        : 
    345          ******************************************************************************** 
    346          */  

   \                                 In section .text, align 2, keep-with-next
    347          int eepread_multi(INT16U address, INT8U *data, int len)
    348          {
   \                     eepread_multi: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460C             MOV      R4,R1
    349          	int ret = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    350          	uint8_t buff[2];
    351            u16 i, p, n;
    352            u16 addr, idx = 0;
   \   0000000A   0x4605             MOV      R5,R0
    353          
    354            addr = address;
    355            p = len/64;
   \   0000000C   0x1151             ASRS     R1,R2,#+5
   \   0000000E   0xEB02 0x6191      ADD      R1,R2,R1, LSR #+26
   \   00000012   0xEA4F 0x19A1      ASR      R9,R1,#+6
   \   00000016   0xFA1F 0xF989      UXTH     R9,R9
    356            n = len%64;
   \   0000001A   0xEBA2 0x1689      SUB      R6,R2,R9, LSL #+6
   \   0000001E   0xB2B6             UXTH     R6,R6
    357          
    358            for(i = 0; i < p; i++) {
   \   00000020   0x4680             MOV      R8,R0
   \   00000022   0xE015             B.N      ??eepread_multi_0
    359              buff[0] = (addr >> 8) & 0x1F;
   \                     ??eepread_multi_1: (+1)
   \   00000024   0x1238             ASRS     R0,R7,#+8
   \   00000026   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    360              buff[1] = (addr & 0xFF);
   \   0000002E   0x4638             MOV      R0,R7
   \   00000030   0xF88D 0x0001      STRB     R0,[SP, #+1]
    361              ret = i2c_read(buff, 2, (uint8_t *)&data[idx], 64);
   \   00000034   0x2340             MOVS     R3,#+64
   \   00000036   0x1962             ADDS     R2,R4,R5
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x.... 0x....      BL       i2c_read
    362              if(ret == ERROR) return ret;
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD019             BEQ.N    ??eepread_multi_2
    363              addr += 64;
   \   00000044   0x3740             ADDS     R7,R7,#+64
   \   00000046   0xB2BF             UXTH     R7,R7
    364              idx += 64;
   \   00000048   0x3540             ADDS     R5,R5,#+64
   \   0000004A   0xB2AD             UXTH     R5,R5
    365            }
   \   0000004C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??eepread_multi_0: (+1)
   \   00000050   0xFA1F 0xF888      UXTH     R8,R8
   \   00000054   0x45C8             CMP      R8,R9
   \   00000056   0xDBE5             BLT.N    ??eepread_multi_1
    366            if(n > 0) {
   \   00000058   0x0031             MOVS     R1,R6
   \   0000005A   0xD00D             BEQ.N    ??eepread_multi_2
    367              buff[0] = (addr >> 8) & 0x1F;
   \   0000005C   0x1238             ASRS     R0,R7,#+8
   \   0000005E   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000062   0xF88D 0x0000      STRB     R0,[SP, #+0]
    368              buff[1] = (addr & 0xFF);
   \   00000066   0xF88D 0x7001      STRB     R7,[SP, #+1]
    369              ret = i2c_read(buff, 2, (uint8_t *)&data[idx], n);
   \   0000006A   0x4633             MOV      R3,R6
   \   0000006C   0xB2DB             UXTB     R3,R3
   \   0000006E   0x1962             ADDS     R2,R4,R5
   \   00000070   0x2102             MOVS     R1,#+2
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x.... 0x....      BL       i2c_read
    370            }
    371          	
    372          //	int ret = 0;
    373          //	uint8_t buff[2];
    374          //
    375          //	buff[0] = (address >> 8) & 0x1F;
    376          //	buff[1] = (address & 0xFF);
    377          //
    378          //	ret = i2c_read(buff, 2, (uint8_t *)data, len);
    379          
    380          	return ret;
   \                     ??eepread_multi_2: (+1)
   \   00000078   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    381          }
    382          
    383          /*
    384          ********************************************************************************
    385          * Description : FRAM_Wait
    386          * Arguments   : add_offset, save
    387          * Return      : state
    388          * Note        : 
    389          ******************************************************************************** 
    390          */

   \                                 In section .bss, align 1
    391          INT8U FRAM_WaitFlag;
   \                     FRAM_WaitFlag:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    392          uint8_t FRAM_Wait(void) 
    393          {
   \                     FRAM_Wait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    394            uint32_t wcnt = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE003             B.N      ??FRAM_Wait_0
    395            
    396            while(FRAM_WaitFlag) {
    397              if (wcnt > 500)
    398               return ERROR;
    399              vTaskDelay(1);
   \                     ??FRAM_Wait_1: (+1)
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       vTaskDelay
    400              wcnt++;
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??FRAM_Wait_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable24_7
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??FRAM_Wait_2
   \   00000016   0xF5B4 0x7FFA      CMP      R4,#+500
   \   0000001A   0xD9F4             BLS.N    ??FRAM_Wait_1
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}
    401            }
    402            return OK;
   \                     ??FRAM_Wait_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    403          }
    404          
    405          /*
    406          ********************************************************************************
    407          * Description : WriteArray_i2c
    408          * Arguments   : dest, src, sz
    409          * Return      : state
    410          * Note        : 
    411          ******************************************************************************** 
    412          */ 

   \                                 In section .text, align 2, keep-with-next
    413          int WriteArray_i2c(int dest, INT8U *src,int sz)
    414          {
   \                     WriteArray_i2c: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    415          	int ret;
    416            
    417            if(FRAM_Wait() == ERROR)
   \   00000008   0x.... 0x....      BL       FRAM_Wait
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??WriteArray_i2c_0
    418              return ERROR;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
    419            
    420            FRAM_WaitFlag = 1;	
   \                     ??WriteArray_i2c_0: (+1)
   \   00000014   0x....             LDR.N    R7,??DataTable24_7
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7038             STRB     R0,[R7, #+0]
    421            ret = eepwrite_multi(dest, (u8*)src, sz);
   \   0000001A   0x4632             MOV      R2,R6
   \   0000001C   0xB292             UXTH     R2,R2
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB280             UXTH     R0,R0
   \   00000024   0x.... 0x....      BL       eepwrite_multi
    422            FRAM_WaitFlag = 0;  
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7039             STRB     R1,[R7, #+0]
    423            return ret;
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    424          
    425          //	int i,ret;
    426          //  
    427          //	for ( i=0;i<sz;i++){
    428          //		ret = eepwrite(dest+i,src[i]);
    429          //		if(ret == ERROR) return ERROR;
    430          //	}
    431          //	return OK;
    432          }
    433          
    434          /*
    435          ********************************************************************************
    436          * Description : ReadArray_i2c
    437          * Arguments   : target, src, sz
    438          * Return      : state
    439          * Note        : 
    440          ******************************************************************************** 
    441          */ 

   \                                 In section .text, align 2, keep-with-next
    442          int ReadArray_i2c(INT8U *target,int src,int sz)
    443          {
   \                     ReadArray_i2c: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    444            int ret;
    445          
    446            if(FRAM_Wait() == ERROR)
   \   00000008   0x.... 0x....      BL       FRAM_Wait
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??ReadArray_i2c_0
    447              return ERROR;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
    448            
    449            FRAM_WaitFlag = 1;	  
   \                     ??ReadArray_i2c_0: (+1)
   \   00000014   0x....             LDR.N    R7,??DataTable24_7
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7038             STRB     R0,[R7, #+0]
    450            ret = eepread_multi(src, target, sz);
   \   0000001A   0x4632             MOV      R2,R6
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xB280             UXTH     R0,R0
   \   00000022   0x.... 0x....      BL       eepread_multi
    451            FRAM_WaitFlag = 0;  
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7039             STRB     R1,[R7, #+0]
    452            return ret;
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    453            
    454          //	int i,ret;
    455          //	
    456          //	for ( i=0;i<sz;i++){
    457          //		ret = eepread(src+i,&target[i]);
    458          //		if(ret == ERROR) return ERROR;
    459          //	}
    460          //	return OK;
    461          }
    462          
    463          /*
    464          ********************************************************************************
    465          * Description : WriteArray_i2c
    466          * Arguments   : dest, src, sz
    467          * Return      : state
    468          * Note        : 
    469          ******************************************************************************** 
    470          */ 

   \                                 In section .text, align 2, keep-with-next
    471          int FRAMMultiWrite(INT8U *src, int dest, int sz)
    472          {
   \                     FRAMMultiWrite: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    473          	int ret;
    474            
    475            if(FRAM_Wait() == ERROR)
   \   00000008   0x.... 0x....      BL       FRAM_Wait
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??FRAMMultiWrite_0
    476              return ERROR;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
    477            
    478            FRAM_WaitFlag = 1;	
   \                     ??FRAMMultiWrite_0: (+1)
   \   00000014   0x....             LDR.N    R7,??DataTable24_7
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7038             STRB     R0,[R7, #+0]
    479            ret = eepwrite_multi(dest, (u8*)src, sz);
   \   0000001A   0x4632             MOV      R2,R6
   \   0000001C   0xB292             UXTH     R2,R2
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0xB280             UXTH     R0,R0
   \   00000024   0x.... 0x....      BL       eepwrite_multi
    480            FRAM_WaitFlag = 0;  
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7039             STRB     R1,[R7, #+0]
    481            return ret;
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    482          }
    483          
    484          /*
    485          ********************************************************************************
    486          * Description : ReadArray_i2c
    487          * Arguments   : target, src, sz
    488          * Return      : state
    489          * Note        : 
    490          ******************************************************************************** 
    491          */ 

   \                                 In section .text, align 2, keep-with-next
    492          int FRAMMultiRead(INT8U *target, int src, int sz)
    493          {
   \                     FRAMMultiRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    494            int ret;
    495          
    496            if(FRAM_Wait() == ERROR)
   \   00000008   0x.... 0x....      BL       FRAM_Wait
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??FRAMMultiRead_0
    497              return ERROR;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
    498            
    499            FRAM_WaitFlag = 1;	  
   \                     ??FRAMMultiRead_0: (+1)
   \   00000014   0x....             LDR.N    R7,??DataTable24_7
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7038             STRB     R0,[R7, #+0]
    500            ret = eepread_multi(src, target, sz);
   \   0000001A   0x4632             MOV      R2,R6
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xB280             UXTH     R0,R0
   \   00000022   0x.... 0x....      BL       eepread_multi
    501            FRAM_WaitFlag = 0;  
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7039             STRB     R1,[R7, #+0]
    502            return ret;
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    503          }
    504          
    505          /*
    506          ********************************************************************************
    507          * Description : FRAM_Checksum
    508          * Arguments   : pszData, nLength
    509          * Return      : state
    510          * Note        : 
    511          ******************************************************************************** 
    512          */

   \                                 In section .text, align 2, keep-with-next
    513          INT8S FRAM_Checksum(INT8S *pszData, int nLength)
    514          {
   \                     FRAM_Checksum: (+1)
   \   00000000   0xB410             PUSH     {R4}
    515          	int nCount;
    516          	INT8S ucChkSum=0;
   \   00000002   0x2200             MOVS     R2,#+0
    517          
    518          	for(nCount=0; nCount<nLength; nCount++){
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xE002             B.N      ??FRAM_Checksum_0
    519          		ucChkSum+=pszData[nCount];
   \                     ??FRAM_Checksum_1: (+1)
   \   00000008   0x56C4             LDRSB    R4,[R0, R3]
   \   0000000A   0x18A2             ADDS     R2,R4,R2
    520          	}
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??FRAM_Checksum_0: (+1)
   \   0000000E   0x428B             CMP      R3,R1
   \   00000010   0xDBFA             BLT.N    ??FRAM_Checksum_1
    521          
    522          	return ucChkSum;
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0xB240             SXTB     R0,R0
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    523          }
    524          
    525          /*
    526          ********************************************************************************
    527          * Description : FRAM_Write_ChkSum
    528          * Arguments   : mp, addr, len
    529          * Return      : state
    530          * Note        : 
    531          ******************************************************************************** 
    532          */

   \                                 In section .text, align 2, keep-with-next
    533          void FRAM_Write_ChkSum(INT8U* mp, u16 addr, u32 len)
    534          {
   \                     FRAM_Write_ChkSum: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   \   00000002   0x460B             MOV      R3,R1
    535            INT8U *tp;
    536            int i;
    537            u16 cs = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    538            
    539            tp = mp;
   \   00000006   0x4604             MOV      R4,R0
    540            for(i = 0; i < len-2; i++) {
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0xE004             B.N      ??FRAM_Write_ChkSum_0
    541              cs += *tp++;
   \                     ??FRAM_Write_ChkSum_1: (+1)
   \   0000000C   0xF814 0x6B01      LDRB     R6,[R4], #+1
   \   00000010   0x1871             ADDS     R1,R6,R1
   \   00000012   0xB289             UXTH     R1,R1
    542            }
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
   \                     ??FRAM_Write_ChkSum_0: (+1)
   \   00000016   0x1E96             SUBS     R6,R2,#+2
   \   00000018   0x42B5             CMP      R5,R6
   \   0000001A   0xD3F7             BCC.N    ??FRAM_Write_ChkSum_1
    543            *tp = cs & 0xff;
   \   0000001C   0x7021             STRB     R1,[R4, #+0]
    544            tp++;
    545            *tp = (cs>>8) & 0xff;
   \   0000001E   0x0A09             LSRS     R1,R1,#+8
   \   00000020   0x7061             STRB     R1,[R4, #+1]
    546            
    547            WriteArray_i2c(addr, mp, len); 
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0x4618             MOV      R0,R3
   \   00000026   0xBC78             POP      {R3-R6}
   \   00000028   0x....             B.N      WriteArray_i2c
    548          }
    549          
    550          /*
    551          ********************************************************************************
    552          * Description : FRAM_Read_ChkSum
    553          * Arguments   : mp, addr, len
    554          * Return      : state
    555          * Note        : 
    556          ******************************************************************************** 
    557          */

   \                                 In section .text, align 2, keep-with-next
    558          int FRAM_Read_ChkSum(INT8U* mp, u16 addr, u32 len)
    559          {
   \                     FRAM_Read_ChkSum: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x4616             MOV      R6,R2
    560            INT8U *tp;
    561            int i;
    562            u16 cs = 0, rs = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    563            
    564            ReadArray_i2c(mp, addr, len); 
   \   00000008   0x.... 0x....      BL       ReadArray_i2c
    565            
    566            tp = mp;
    567            for(i = 0; i < len-2; i++) {
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE004             B.N      ??FRAM_Read_ChkSum_0
    568              cs += *tp++;
   \                     ??FRAM_Read_ChkSum_1: (+1)
   \   00000010   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000014   0x190C             ADDS     R4,R1,R4
   \   00000016   0xB2A4             UXTH     R4,R4
    569            }
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \                     ??FRAM_Read_ChkSum_0: (+1)
   \   0000001A   0x1EB1             SUBS     R1,R6,#+2
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD3F7             BCC.N    ??FRAM_Read_ChkSum_1
    570            rs = *tp;
    571            tp++;
    572            rs |= *tp << 8;
    573          
    574            if(cs == rs) return 0;
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x7869             LDRB     R1,[R5, #+1]
   \   00000024   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD101             BNE.N    ??FRAM_Read_ChkSum_2
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD70             POP      {R4-R6,PC}
    575            printk("fram checksum error!!\n");
   \                     ??FRAM_Read_ChkSum_2: (+1)
   \   00000030   0x.... 0x....      ADR.W    R0,?_1
   \   00000034   0x.... 0x....      BL       printk
    576            
    577            return 1; 
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    578          }
    579          
    580          /*
    581          ********************************************************************************
    582          * Description : BKRAM_Write_ChkSum
    583          * Arguments   : mp, addr, len
    584          * Return      : state
    585          * Note        : 
    586          ******************************************************************************** 
    587          */

   \                                 In section .text, align 2, keep-with-next
    588          void BKRAM_Write_ChkSum(char* mp, u16 addr, u32 len)
    589          {
   \                     BKRAM_Write_ChkSum: (+1)
   \   00000000   0xB410             PUSH     {R4}
    590            char *tp;
    591            int i;
    592            u16 cs = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    593            
    594            tp = mp;
    595            for(i = 0; i < len-2; i++) {
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0xE004             B.N      ??BKRAM_Write_ChkSum_0
    596              cs += *tp++;
   \                     ??BKRAM_Write_ChkSum_1: (+1)
   \   00000008   0xF810 0x4B01      LDRB     R4,[R0], #+1
   \   0000000C   0x1861             ADDS     R1,R4,R1
   \   0000000E   0xB289             UXTH     R1,R1
    597            }
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
   \                     ??BKRAM_Write_ChkSum_0: (+1)
   \   00000012   0x1E94             SUBS     R4,R2,#+2
   \   00000014   0x42A3             CMP      R3,R4
   \   00000016   0xD3F7             BCC.N    ??BKRAM_Write_ChkSum_1
    598            *tp = cs & 0xff;
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    599            tp++;
    600            *tp = (cs>>8) & 0xff;
   \   0000001A   0x0A09             LSRS     R1,R1,#+8
   \   0000001C   0x7041             STRB     R1,[R0, #+1]
    601            
    602          //  write_to_backup_sram((INT8U *)&mp, len, addr);
    603          }
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    604          
    605          
    606          /*
    607          ********************************************************************************
    608          * Description : dbg_fram_read
    609          * Arguments   : none
    610          * Return      : state
    611          * Note        : 
    612          ******************************************************************************** 
    613          */

   \                                 In section .text, align 2, keep-with-next
    614          INT16U dbg_fram_read(void)
    615          {
   \                     dbg_fram_read: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
    616          	INT8U temp, buf[0x10];
    617          	int addr, len, i, j, ret = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    618            
    619          	memset(buf, 0x0, sizeof(buf));
   \   00000008   0x462A             MOV      R2,R5
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0xA801             ADD      R0,SP,#+4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset4
    620          	
    621          	if(CLI_GetArgCnt() < 2) return INV_PRM;
   \   00000012   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD201             BCS.N    ??dbg_fram_read_0
   \   0000001A   0x20CA             MOVS     R0,#+202
   \   0000001C   0xE06A             B.N      ??dbg_fram_read_1
    622          	
    623          	addr = comparison_num((char *)P_ARG(1));
   \                     ??dbg_fram_read_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       Argument
   \   00000024   0x.... 0x....      BL       comparison_num
   \   00000028   0x4606             MOV      R6,R0
    624          	len = comparison_num((char *)P_ARG(2));
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x.... 0x....      BL       Argument
   \   00000030   0x.... 0x....      BL       comparison_num
   \   00000034   0x4607             MOV      R7,R0
    625            
    626            printk("\n");
   \   00000036   0x....             ADR.N    R4,??DataTable24  ;; "\n"
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       printk
    627          
    628          	for(i=0; i<len; i++)
   \   0000003E   0x46A8             MOV      R8,R5
   \   00000040   0xE012             B.N      ??dbg_fram_read_2
    629          	{
    630          		ret = ReadArray_i2c((INT8U *)&temp, addr+i, 1);
    631          		if((i&0xF) == 0){
    632          			if(i){
    633          				for(j=0; j<0x10; j++){
    634          					if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
    635          						printk("%c",buf[j]);
    636          					}
    637          					else{
    638          						printk(".");
    639          					}
    640          				}
    641          			}
    642          			printk("\n%05X : ",addr+i);
   \                     ??dbg_fram_read_3: (+1)
   \   00000042   0x4649             MOV      R1,R9
   \   00000044   0x.... 0x....      ADR.W    R0,?_5
   \   00000048   0x.... 0x....      BL       printk
    643          		}
    644          		buf[i&0xF] = temp;
   \                     ??dbg_fram_read_4: (+1)
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0xA901             ADD      R1,SP,#+4
   \   00000052   0xF008 0x020F      AND      R2,R8,#0xF
   \   00000056   0x5488             STRB     R0,[R1, R2]
    645          		printk("%02X ",temp);
   \   00000058   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005C   0x.... 0x....      ADR.W    R0,?_6
   \   00000060   0x.... 0x....      BL       printk
   \   00000064   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??dbg_fram_read_2: (+1)
   \   00000068   0x45B8             CMP      R8,R7
   \   0000006A   0xDA23             BGE.N    ??dbg_fram_read_5
   \   0000006C   0xEB08 0x0906      ADD      R9,R8,R6
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0x4649             MOV      R1,R9
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x.... 0x....      BL       ReadArray_i2c
   \   0000007A   0x4605             MOV      R5,R0
   \   0000007C   0xF018 0x0F0F      TST      R8,#0xF
   \   00000080   0xD1E4             BNE.N    ??dbg_fram_read_4
   \   00000082   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000086   0xD0DC             BEQ.N    ??dbg_fram_read_3
   \   00000088   0xF04F 0x0A00      MOV      R10,#+0
   \   0000008C   0xE004             B.N      ??dbg_fram_read_6
   \                     ??dbg_fram_read_7: (+1)
   \   0000008E   0x....             ADR.N    R0,??DataTable24_1  ;; "."
   \   00000090   0x.... 0x....      BL       printk
   \                     ??dbg_fram_read_8: (+1)
   \   00000094   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??dbg_fram_read_6: (+1)
   \   00000098   0xF1BA 0x0F10      CMP      R10,#+16
   \   0000009C   0xDAD1             BGE.N    ??dbg_fram_read_3
   \   0000009E   0xA801             ADD      R0,SP,#+4
   \   000000A0   0xF810 0x100A      LDRB     R1,[R0, R10]
   \   000000A4   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   000000A8   0x285F             CMP      R0,#+95
   \   000000AA   0xD2F0             BCS.N    ??dbg_fram_read_7
   \   000000AC   0x....             ADR.N    R0,??DataTable24_2  ;; 0x25, 0x63, 0x00, 0x00
   \   000000AE   0x.... 0x....      BL       printk
   \   000000B2   0xE7EF             B.N      ??dbg_fram_read_8
    646          	}
    647          
    648          	for(j=0; j<0x10; j++){
   \                     ??dbg_fram_read_5: (+1)
   \   000000B4   0x2600             MOVS     R6,#+0
   \   000000B6   0xE003             B.N      ??dbg_fram_read_9
    649          		if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
    650          			printk("%c",buf[j]);
    651          		}
    652          		else{
    653          			printk(".");
   \                     ??dbg_fram_read_10: (+1)
   \   000000B8   0x....             ADR.N    R0,??DataTable24_1  ;; "."
   \   000000BA   0x.... 0x....      BL       printk
    654          		}
   \                     ??dbg_fram_read_11: (+1)
   \   000000BE   0x1C76             ADDS     R6,R6,#+1
   \                     ??dbg_fram_read_9: (+1)
   \   000000C0   0x2E10             CMP      R6,#+16
   \   000000C2   0xDA09             BGE.N    ??dbg_fram_read_12
   \   000000C4   0xA801             ADD      R0,SP,#+4
   \   000000C6   0x5D81             LDRB     R1,[R0, R6]
   \   000000C8   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   000000CC   0x285F             CMP      R0,#+95
   \   000000CE   0xD2F3             BCS.N    ??dbg_fram_read_10
   \   000000D0   0x....             ADR.N    R0,??DataTable24_2  ;; 0x25, 0x63, 0x00, 0x00
   \   000000D2   0x.... 0x....      BL       printk
   \   000000D6   0xE7F2             B.N      ??dbg_fram_read_11
    655          	}
    656          	printk("[...%s...]\n",ret == OK ? "OK":"ERROR");
   \                     ??dbg_fram_read_12: (+1)
   \   000000D8   0x2D01             CMP      R5,#+1
   \   000000DA   0xD101             BNE.N    ??dbg_fram_read_13
   \   000000DC   0x....             ADR.N    R1,??DataTable24_3  ;; 0x4F, 0x4B, 0x00, 0x00
   \   000000DE   0xE001             B.N      ??dbg_fram_read_14
   \                     ??dbg_fram_read_13: (+1)
   \   000000E0   0x.... 0x....      ADR.W    R1,?_9
   \                     ??dbg_fram_read_14: (+1)
   \   000000E4   0x.... 0x....      ADR.W    R0,?_7
   \   000000E8   0x.... 0x....      BL       printk
    657          	printk("\n");	  
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x.... 0x....      BL       printk
    658          	
    659          	return NO_DISPLAY;
   \   000000F2   0x20C9             MOVS     R0,#+201
   \                     ??dbg_fram_read_1: (+1)
   \   000000F4   0xB006             ADD      SP,SP,#+24
   \   000000F6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    660          }
    661          
    662          /*
    663          ********************************************************************************
    664          * Description : dbg_fram_write
    665          * Arguments   : none
    666          * Return      : state
    667          * Note        : 
    668          ******************************************************************************** 
    669          */

   \                                 In section .text, align 2, keep-with-next
    670          INT16U dbg_fram_write(void)				
    671          {
   \                     dbg_fram_write: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    672          	INT8U ret=0,wdata = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    673          	int addr = 0;
    674          	INT8U buf = 0xff;
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    675          	
    676          	if(CLI_GetArgCnt() < 2) return INV_PRM;
   \   00000010   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD201             BCS.N    ??dbg_fram_write_0
   \   00000018   0x20CA             MOVS     R0,#+202
   \   0000001A   0xBD16             POP      {R1,R2,R4,PC}
    677          	
    678          	addr = comparison_num((char *)P_ARG(1));
   \                     ??dbg_fram_write_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       Argument
   \   00000022   0x.... 0x....      BL       comparison_num
   \   00000026   0x4604             MOV      R4,R0
    679          	wdata = comparison_num((char *)P_ARG(2));
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       Argument
   \   0000002E   0x.... 0x....      BL       comparison_num
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
    680          	ret = WriteArray_i2c(addr, &wdata ,1);
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       WriteArray_i2c
    681          	printk("\nFRAM write [%s] [0x%02X]\n",ret == OK ? "OK":"ERROR",wdata);
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE.N    ??dbg_fram_write_1
   \   00000046   0x....             ADR.N    R1,??DataTable24_3  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000048   0xE001             B.N      ??dbg_fram_write_2
   \                     ??dbg_fram_write_1: (+1)
   \   0000004A   0x.... 0x....      ADR.W    R1,?_9
   \                     ??dbg_fram_write_2: (+1)
   \   0000004E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000052   0x.... 0x....      ADR.W    R0,?_10
   \   00000056   0x.... 0x....      BL       printk
    682          	ret = ReadArray_i2c(&buf,addr,1);
   \   0000005A   0x2201             MOVS     R2,#+1
   \   0000005C   0x4621             MOV      R1,R4
   \   0000005E   0xF10D 0x0001      ADD      R0,SP,#+1
   \   00000062   0x.... 0x....      BL       ReadArray_i2c
    683          	printk("\nFRAM read [%s] [0x%02X]\n",ret == OK ? "OK":"ERROR",buf);
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD101             BNE.N    ??dbg_fram_write_3
   \   0000006C   0x....             ADR.N    R1,??DataTable24_3  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000006E   0xE001             B.N      ??dbg_fram_write_4
   \                     ??dbg_fram_write_3: (+1)
   \   00000070   0x.... 0x....      ADR.W    R1,?_9
   \                     ??dbg_fram_write_4: (+1)
   \   00000074   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000078   0x.... 0x....      ADR.W    R0,?_11
   \   0000007C   0x.... 0x....      BL       printk
    684          
    685          	return NO_DISPLAY;
   \   00000080   0x20C9             MOVS     R0,#+201
   \   00000082   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    686          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x25 0x63          DC8      0x25, 0x63, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     BSP_I2C1Sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x........         DC32     I2C_DIR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     FRAM_WaitFlag

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_2:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x25 0x63          DC8 "%c"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_4:
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x4F 0x4B          DC8 "OK"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x66 0x72          DC8 "fram checksum error!!\012"
   \              0x61 0x6D    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x73 0x75    
   \              0x6D 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x21    
   \              0x21 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x0A 0x25          DC8 "\012%05X : "
   \              0x30 0x35    
   \              0x58 0x20    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x5B 0x2E          DC8 "[...%s...]\012"
   \              0x2E 0x2E    
   \              0x25 0x73    
   \              0x2E 0x2E    
   \              0x2E 0x5D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x45 0x52          DC8 "ERROR"
   \              0x52 0x4F    
   \              0x52 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x0A 0x46          DC8 "\012FRAM write [%s] [0x%02X]\012"
   \              0x52 0x41    
   \              0x4D 0x20    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x5B 0x25    
   \              0x73 0x5D    
   \              0x20 0x5B    
   \              0x30 0x78    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x5D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x0A 0x46          DC8 "\012FRAM read [%s] [0x%02X]\012"
   \              0x52 0x41    
   \              0x4D 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x20    
   \              0x5B 0x30    
   \              0x78 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   BKRAM_Write_ChkSum
       8   FRAMByteRead
         8   -> i2c_read
       8   FRAMByteWrite
         8   -> i2c_write
      24   FRAMMultiRead
        24   -> FRAM_Wait
        24   -> eepread_multi
      24   FRAMMultiWrite
        24   -> FRAM_Wait
        24   -> eepwrite_multi
       4   FRAM_Checksum
      16   FRAM_Read_ChkSum
        16   -> ReadArray_i2c
        16   -> printk
       8   FRAM_Wait
         8   -> vTaskDelay
      16   FRAM_Write_ChkSum
         0   -> WriteArray_i2c
      24   ReadArray_i2c
        24   -> FRAM_Wait
        24   -> eepread_multi
      24   WriteArray_i2c
        24   -> FRAM_Wait
        24   -> eepwrite_multi
      56   dbg_fram_read
        56   -> Argument
        56   -> CLI_GetArgCnt
        56   -> ReadArray_i2c
        56   -> __aeabi_memset4
        56   -> comparison_num
        56   -> printk
      16   dbg_fram_write
        16   -> Argument
        16   -> CLI_GetArgCnt
        16   -> ReadArray_i2c
        16   -> WriteArray_i2c
        16   -> comparison_num
        16   -> printk
      32   eepread_multi
        32   -> i2c_read
      72   eepwrite_multi
        72   -> __aeabi_memcpy
        72   -> i2c_write
       8   framSemaphore_Init
         8   -> xQueueCreateMutex
         8   -> xQueueGenericCreate
         0   -> xQueueGenericSend
       0   i2c_is_busy
      32   i2c_read
        32   -> I2C_AcknowledgeConfig
        32   -> I2C_GenerateSTART
        32   -> I2C_ITConfig
        32   -> printk
        32   -> systick_uptime
        32   -> xQueueGenericReceive
        32   -> xQueueGenericSend
      24   i2c_write
        24   -> I2C_AcknowledgeConfig
        24   -> I2C_GenerateSTART
        24   -> I2C_ITConfig
        24   -> printk
        24   -> systick_uptime
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       8  ?_0
      24  ?_1
      28  ?_10
      28  ?_11
       2  ?_2
       4  ?_3
       2  ?_4
      12  ?_5
       8  ?_6
      12  ?_7
       4  ?_8
       8  ?_9
      34  BKRAM_Write_ChkSum
      30  FRAMByteRead
      30  FRAMByteWrite
      44  FRAMMultiRead
      46  FRAMMultiWrite
      26  FRAM_Checksum
      60  FRAM_Read_ChkSum
      36  FRAM_Wait
       1  FRAM_WaitFlag
      42  FRAM_Write_ChkSum
    1036  I2C_DIR
          I2C_BLOCKED
          I2CADDRESS
          rx_buffer_len
          tx_buffer_len
          tx_buffer_ix
          rx_buffer_ix
          rx_buffer_ptr
          tx_buffer
      44  ReadArray_i2c
      46  WriteArray_i2c
     250  dbg_fram_read
     132  dbg_fram_write
     124  eepread_multi
     256  eepwrite_multi
      46  framSemaphore_Init
       8  i2c_is_busy
     244  i2c_read
     232  i2c_write
      24  -- Other

 
 1 037 bytes in section .bss
    12 bytes in section .rodata
 1 914 bytes in section .text
 
 1 914 bytes of CODE  memory
    12 bytes of CONST memory
 1 037 bytes of DATA  memory

Errors: none
Warnings: none
