###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\system_stm32f2xx.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\system_stm32f2xx.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\system_stm32f2xx.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\system_stm32f2xx.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\system_stm32f2xx.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f2xx.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    02-April-2015
      7            * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
      8            *          This file contains the system clock configuration for STM32F2xx devices,
      9            *          and is generated by the clock configuration tool
     10            *          STM32f2xx_Clock_Configuration_V1.1.0.xls
     11            *             
     12            * 1.  This file provides two functions and one global variable to be called from 
     13            *     user application:
     14            *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
     15            *                      and Divider factors, AHB/APBx prescalers and Flash settings),
     16            *                      depending on the configuration made in the clock xls tool. 
     17            *                      This function is called at startup just after reset and 
     18            *                      before branch to main program. This call is made inside
     19            *                      the "startup_stm32f2xx.s" file.
     20            *
     21            *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
     22            *                                  by the user application to setup the SysTick 
     23            *                                  timer or configure other parameters.
     24            *                                     
     25            *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
     26            *                                 be called whenever the core clock is changed
     27            *                                 during program execution.
     28            *
     29            * 2. After each device reset the HSI (16 MHz) is used as system clock source.
     30            *    Then SystemInit() function is called, in "startup_stm32f2xx.s" file, to
     31            *    configure the system clock before to branch to main program.
     32            *
     33            * 3. If the system clock source selected by user fails to startup, the SystemInit()
     34            *    function will do nothing and HSI still used as system clock source. User can 
     35            *    add some code to deal with this issue inside the SetSysClock() function.
     36            *
     37            * 4. The default value of HSE crystal is set to 25MHz, refer to "HSE_VALUE" define
     38            *    in "stm32f2xx.h" file. When HSE is used as system clock source, directly or
     39            *    through PLL, and you are using different crystal you have to adapt the HSE
     40            *    value to your own configuration.
     41            *
     42            * 5. This file configures the system clock as follows:
     43            *=============================================================================
     44            *=============================================================================
     45            *        Supported STM32F2xx device revision    | Rev B and Y
     46            *-----------------------------------------------------------------------------
     47            *        System Clock source                    | PLL (HSE)
     48            *-----------------------------------------------------------------------------
     49            *        SYSCLK(Hz)                             | 120000000
     50            *-----------------------------------------------------------------------------
     51            *        HCLK(Hz)                               | 120000000
     52            *-----------------------------------------------------------------------------
     53            *        AHB Prescaler                          | 1
     54            *-----------------------------------------------------------------------------
     55            *        APB1 Prescaler                         | 4
     56            *-----------------------------------------------------------------------------
     57            *        APB2 Prescaler                         | 2
     58            *-----------------------------------------------------------------------------
     59            *        HSE Frequency(Hz)                      | 8000000
     60            *-----------------------------------------------------------------------------
     61            *        PLL_M                                  | 8
     62            *-----------------------------------------------------------------------------
     63            *        PLL_N                                  | 240
     64            *-----------------------------------------------------------------------------
     65            *        PLL_P                                  | 2
     66            *-----------------------------------------------------------------------------
     67            *        PLL_Q                                  | 5
     68            *-----------------------------------------------------------------------------
     69            *        PLLI2S_N                               | NA
     70            *-----------------------------------------------------------------------------
     71            *        PLLI2S_R                               | NA
     72            *-----------------------------------------------------------------------------
     73            *        I2S input clock                        | NA
     74            *-----------------------------------------------------------------------------
     75            *        VDD(V)                                 | 3.3
     76            *-----------------------------------------------------------------------------
     77            *        Flash Latency(WS)                      | 3
     78            *-----------------------------------------------------------------------------
     79            *        Prefetch Buffer                        | ON
     80            *-----------------------------------------------------------------------------
     81            *        Instruction cache                      | ON
     82            *-----------------------------------------------------------------------------
     83            *        Data cache                             | ON
     84            *-----------------------------------------------------------------------------
     85            *=============================================================================
     86            ****************************************************************************** 
     87            * @attention
     88            *
     89            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     90            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     91            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     92            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     93            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     94            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     95            *
     96            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     97            ******************************************************************************
     98            */
     99          
    100          /** @addtogroup CMSIS
    101            * @{
    102            */
    103          
    104          /** @addtogroup stm32f2xx_system
    105            * @{
    106            */  
    107            
    108          /** @addtogroup STM32F2xx_System_Private_Includes
    109            * @{
    110            */
    111          
    112          #include "stm32f2xx.h"
    113          
    114          /**
    115            * @}
    116            */
    117          
    118          /** @addtogroup STM32F2xx_System_Private_TypesDefinitions
    119            * @{
    120            */
    121          
    122          /**
    123            * @}
    124            */
    125          
    126          /** @addtogroup STM32F2xx_System_Private_Defines
    127            * @{
    128            */
    129          
    130          /*!< Uncomment the following line if you need to use external SRAM mounted
    131               on STM322xG_EVALboard as data memory  */
    132          /* #define DATA_IN_ExtSRAM */
    133          
    134          /*!< Uncomment the following line if you need to relocate your vector Table in
    135               Internal SRAM. */
    136          /* #define VECT_TAB_SRAM */
    137          #define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field. 
    138                                             This value must be a multiple of 0x200. */
    139          
    140          
    141          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */
    142          #define PLL_M      8
    143          #define PLL_N      240
    144          
    145          /* SYSCLK = PLL_VCO / PLL_P */
    146          #define PLL_P      2
    147          
    148          /* USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ */
    149          #define PLL_Q      5
    150          
    151          /**
    152            * @}
    153            */
    154          
    155          /** @addtogroup STM32F2xx_System_Private_Macros
    156            * @{
    157            */
    158          
    159          /**
    160            * @}
    161            */
    162          
    163          /** @addtogroup STM32F2xx_System_Private_Variables
    164            * @{
    165            */
    166          

   \                                 In section .data, align 4
    167            uint32_t SystemCoreClock = 120000000;
    168          
    169            __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     AHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
   \                     SystemCoreClock:
   \   00000010   0x07270E00         DC32 120000000
    170          
    171          /**
    172            * @}
    173            */
    174          
    175          /** @addtogroup STM32F2xx_System_Private_FunctionPrototypes
    176            * @{
    177            */
    178          
    179          static void SetSysClock(void);
    180          #ifdef DATA_IN_ExtSRAM
    181            static void SystemInit_ExtMemCtl(void); 
    182          #endif /* DATA_IN_ExtSRAM */
    183          
    184          /**
    185            * @}
    186            */
    187          
    188          /** @addtogroup STM32F2xx_System_Private_Functions
    189            * @{
    190            */
    191          
    192          /**
    193            * @brief  Setup the microcontroller system
    194            *         Initialize the Embedded Flash Interface, the PLL and update the 
    195            *         SystemFrequency variable.
    196            * @param  None
    197            * @retval None
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void SystemInit(void)
    200          {
   \                     SystemInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    201            /* Reset the RCC clock configuration to the default reset state ------------*/
    202            /* Set HSION bit */
    203            RCC->CR |= (uint32_t)0x00000001;
   \   00000002   0x....             LDR.N    R0,??DataTable2  ;; 0x40023800
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    204          
    205            /* Reset CFGR register */
    206            RCC->CFGR = 0x00000000;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    207          
    208            /* Reset HSEON, CSSON and PLLON bits */
    209            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x....             LDR.N    R2,??DataTable2_1  ;; 0xfef6ffff
   \   00000014   0x4011             ANDS     R1,R2,R1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    210          
    211            /* Reset PLLCFGR register */
    212            RCC->PLLCFGR = 0x24003010;
   \   00000018   0x....             LDR.N    R1,??DataTable2_2  ;; 0x24003010
   \   0000001A   0x6041             STR      R1,[R0, #+4]
    213          
    214            /* Reset HSEBYP bit */
    215            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   00000022   0x6001             STR      R1,[R0, #+0]
    216          
    217            /* Disable all interrupts */
    218            RCC->CIR = 0x00000000;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x60C1             STR      R1,[R0, #+12]
    219          
    220          #ifdef DATA_IN_ExtSRAM
    221            SystemInit_ExtMemCtl(); 
    222          #endif /* DATA_IN_ExtSRAM */
    223                   
    224            /* Configure the System clock source, PLL Multiplier and Divider factors, 
    225               AHB/APBx prescalers and Flash settings ----------------------------------*/
    226            SetSysClock();
   \   00000028   0x.... 0x....      BL       SetSysClock
    227          
    228            /* Configure the Vector Table location add offset address ------------------*/
    229          #ifdef VECT_TAB_SRAM
    230            SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
    231          #else
    232            SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
   \   0000002C   0xF04F 0x6000      MOV      R0,#+134217728
   \   00000030   0x....             LDR.N    R1,??DataTable2_3  ;; 0xe000ed08
   \   00000032   0x6008             STR      R0,[R1, #+0]
    233          #endif
    234          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    235          
    236          /**
    237             * @brief  Update SystemCoreClock variable according to Clock Register Values.
    238            *         The SystemCoreClock variable contains the core clock (HCLK), it can
    239            *         be used by the user application to setup the SysTick timer or configure
    240            *         other parameters.
    241            *           
    242            * @note   Each time the core clock (HCLK) changes, this function must be called
    243            *         to update SystemCoreClock variable value. Otherwise, any configuration
    244            *         based on this variable will be incorrect.         
    245            *     
    246            * @note   - The system frequency computed by this function is not the real 
    247            *           frequency in the chip. It is calculated based on the predefined 
    248            *           constant and the selected clock source:
    249            *             
    250            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    251            *                                              
    252            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    253            *                          
    254            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    255            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    256            *         
    257            *         (*) HSI_VALUE is a constant defined in stm32f2xx.h file (default value
    258            *             16 MHz) but the real value may vary depending on the variations
    259            *             in voltage and temperature.   
    260            *    
    261            *         (**) HSE_VALUE is a constant defined in stm32f2xx.h file (default value
    262            *              25 MHz), user has to ensure that HSE_VALUE is same as the real
    263            *              frequency of the crystal used. Otherwise, this function may
    264            *              have wrong result.
    265            *                
    266            *         - The result of this function could be not correct when using fractional
    267            *           value for HSE crystal.
    268            *     
    269            * @param  None
    270            * @retval None
    271            */

   \                                 In section .text, align 2, keep-with-next
    272          void SystemCoreClockUpdate(void)
    273          {
    274            uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
    275            
    276            /* Get SYSCLK source -------------------------------------------------------*/
    277            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \                     SystemCoreClockUpdate: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023804
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0xF001 0x010C      AND      R1,R1,#0xC
    278          
    279            switch (tmp)
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD002             BEQ.N    ??SystemCoreClockUpdate_0
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD004             BEQ.N    ??SystemCoreClockUpdate_1
   \   00000010   0xE024             B.N      ??SystemCoreClockUpdate_2
    280            {
    281              case 0x00:  /* HSI used as system clock source */
    282                SystemCoreClock = HSI_VALUE;
    283                break;
    284              case 0x04:  /* HSE used as system clock source */
    285                SystemCoreClock = HSE_VALUE;
   \                     ??SystemCoreClockUpdate_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable2_5  ;; 0x7a1200
   \   00000014   0x....             LDR.N    R2,??DataTable2_6
   \   00000016   0x6111             STR      R1,[R2, #+16]
    286                break;
   \   00000018   0xE023             B.N      ??SystemCoreClockUpdate_3
    287              case 0x08:  /* PLL used as system clock source */
    288          
    289                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    290                   SYSCLK = PLL_VCO / PLL_P
    291                   */    
    292                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??SystemCoreClockUpdate_1: (+1)
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF3C1 0x5180      UBFX     R1,R1,#+22,#+1
    293                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0xF002 0x023F      AND      R2,R2,#0x3F
    294                
    295                if (pllsource != 0)
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD007             BEQ.N    ??SystemCoreClockUpdate_4
    296                {
    297                  /* HSE used as PLL clock source */
    298                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   0000002A   0x....             LDR.N    R1,??DataTable2_5  ;; 0x7a1200
   \   0000002C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000030   0x6802             LDR      R2,[R0, #+0]
   \   00000032   0xF3C2 0x1288      UBFX     R2,R2,#+6,#+9
   \   00000036   0x4351             MULS     R1,R2,R1
   \   00000038   0xE006             B.N      ??SystemCoreClockUpdate_5
    299                }
    300                else
    301                {
    302                  /* HSI used as PLL clock source */
    303                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   \                     ??SystemCoreClockUpdate_4: (+1)
   \   0000003A   0x....             LDR.N    R1,??DataTable2_7  ;; 0xf42400
   \   0000003C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0xF3C2 0x1288      UBFX     R2,R2,#+6,#+9
   \   00000046   0x4351             MULS     R1,R2,R1
    304                }
    305          
    306                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \                     ??SystemCoreClockUpdate_5: (+1)
   \   00000048   0x6802             LDR      R2,[R0, #+0]
   \   0000004A   0xF3C2 0x4201      UBFX     R2,R2,#+16,#+2
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
   \   00000050   0x0052             LSLS     R2,R2,#+1
    307                SystemCoreClock = pllvco/pllp;
   \   00000052   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000056   0x....             LDR.N    R2,??DataTable2_6
   \   00000058   0x6111             STR      R1,[R2, #+16]
    308                break;
   \   0000005A   0xE002             B.N      ??SystemCoreClockUpdate_3
    309              default:
    310                SystemCoreClock = HSI_VALUE;
   \                     ??SystemCoreClockUpdate_2: (+1)
   \   0000005C   0x....             LDR.N    R1,??DataTable2_7  ;; 0xf42400
   \   0000005E   0x....             LDR.N    R2,??DataTable2_6
   \   00000060   0x6111             STR      R1,[R2, #+16]
    311                break;
    312            }
    313            /* Compute HCLK frequency --------------------------------------------------*/
    314            /* Get HCLK prescaler */
    315            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
   \                     ??SystemCoreClockUpdate_3: (+1)
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x4611             MOV      R1,R2
   \   00000066   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   0000006A   0x5C08             LDRB     R0,[R1, R0]
    316            /* HCLK frequency */
    317            SystemCoreClock >>= tmp;
   \   0000006C   0x690A             LDR      R2,[R1, #+16]
   \   0000006E   0x40C2             LSRS     R2,R2,R0
   \   00000070   0x610A             STR      R2,[R1, #+16]
    318          }
   \   00000072   0x4770             BX       LR               ;; return
    319          
    320          /**
    321            * @brief  Configures the System clock source, PLL Multiplier and Divider factors, 
    322            *         AHB/APBx prescalers and Flash settings
    323            * @Note   This function should be called only once the RCC clock configuration  
    324            *         is reset to the default reset state (done in SystemInit() function).   
    325            * @param  None
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          static void SetSysClock(void)
    329          {
   \                     SetSysClock: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
    330          /******************************************************************************/
    331          /*            PLL (clocked by HSE) used as System clock source                */
    332          /******************************************************************************/
    333            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9001             STR      R0,[SP, #+4]
   \   00000006   0x9000             STR      R0,[SP, #+0]
    334            
    335            /* Enable HSE */
    336            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
   \   00000008   0x....             LDR.N    R0,??DataTable2  ;; 0x40023800
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000010   0x6001             STR      R1,[R0, #+0]
    337           
    338            /* Wait till HSE is ready and if Time out is reached exit */
    339            do
    340            {
    341              HSEStatus = RCC->CR & RCC_CR_HSERDY;
   \                     ??SetSysClock_0: (+1)
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF401 0x3100      AND      R1,R1,#0x20000
   \   00000018   0x9100             STR      R1,[SP, #+0]
    342              StartUpCounter++;
   \   0000001A   0x9901             LDR      R1,[SP, #+4]
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x9101             STR      R1,[SP, #+4]
    343            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD103             BNE.N    ??SetSysClock_1
   \   00000026   0x9901             LDR      R1,[SP, #+4]
   \   00000028   0xF5B1 0x6FA0      CMP      R1,#+1280
   \   0000002C   0xD1F1             BNE.N    ??SetSysClock_0
    344          
    345            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
   \                     ??SetSysClock_1: (+1)
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
    346            {
    347              HSEStatus = (uint32_t)0x01;
    348            }
    349            else
    350            {
    351              HSEStatus = (uint32_t)0x00;
   \   00000030   0x0C49             LSRS     R1,R1,#+17
   \   00000032   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000036   0x9100             STR      R1,[SP, #+0]
    352            }
    353          
    354            if (HSEStatus == (uint32_t)0x01)
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x2901             CMP      R1,#+1
   \   0000003C   0xD123             BNE.N    ??SetSysClock_2
    355            {
    356              /* HCLK = SYSCLK / 1*/
    357              RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
   \   0000003E   0x6881             LDR      R1,[R0, #+8]
   \   00000040   0x6081             STR      R1,[R0, #+8]
    358                
    359              /* PCLK2 = HCLK / 2*/
    360              RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
   \   00000042   0x6881             LDR      R1,[R0, #+8]
   \   00000044   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000048   0x6081             STR      R1,[R0, #+8]
    361              
    362              /* PCLK1 = HCLK / 4*/
    363              RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
   \   0000004A   0x6881             LDR      R1,[R0, #+8]
   \   0000004C   0xF441 0x51A0      ORR      R1,R1,#0x1400
   \   00000050   0x6081             STR      R1,[R0, #+8]
    364          
    365              /* Configure the main PLL */
    366              RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
    367                             (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);
   \   00000052   0x....             LDR.N    R1,??DataTable2_8  ;; 0x5403c08
   \   00000054   0x6041             STR      R1,[R0, #+4]
    368          
    369              /* Enable the main PLL */
    370              RCC->CR |= RCC_CR_PLLON;
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    371          
    372              /* Wait till the main PLL is ready */
    373              while((RCC->CR & RCC_CR_PLLRDY) == 0)
   \                     ??SetSysClock_3: (+1)
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0x0189             LSLS     R1,R1,#+6
   \   00000062   0xD5FC             BPL.N    ??SetSysClock_3
    374              {
    375              }
    376             
    377              /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    378              FLASH->ACR = FLASH_ACR_PRFTEN |FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_3WS;
   \   00000064   0xF240 0x7103      MOVW     R1,#+1795
   \   00000068   0x....             LDR.N    R2,??DataTable2_9  ;; 0x40023c00
   \   0000006A   0x6011             STR      R1,[R2, #+0]
    379          
    380              /* Select the main PLL as system clock source */
    381              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
   \   0000006C   0x6881             LDR      R1,[R0, #+8]
   \   0000006E   0x0889             LSRS     R1,R1,#+2
   \   00000070   0x0089             LSLS     R1,R1,#+2
   \   00000072   0x6081             STR      R1,[R0, #+8]
    382              RCC->CFGR |= RCC_CFGR_SW_PLL;
   \   00000074   0x6881             LDR      R1,[R0, #+8]
   \   00000076   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000007A   0x6081             STR      R1,[R0, #+8]
    383          
    384              /* Wait till the main PLL is used as system clock source */
    385              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
   \                     ??SetSysClock_4: (+1)
   \   0000007C   0x6881             LDR      R1,[R0, #+8]
   \   0000007E   0xF001 0x010C      AND      R1,R1,#0xC
   \   00000082   0x2908             CMP      R1,#+8
   \   00000084   0xD1FA             BNE.N    ??SetSysClock_4
    386              {
    387              }
    388            }
    389            else
    390            { /* If HSE fails to start-up, the application will have wrong clock
    391                   configuration. User can add here some code to deal with this error */
    392            }
    393          
    394          }
   \                     ??SetSysClock_2: (+1)
   \   00000086   0xB002             ADD      SP,SP,#+8
   \   00000088   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x24003010         DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x05403C08         DC32     0x5403c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x40023C00         DC32     0x40023c00
    395          
    396          /**
    397            * @brief  Setup the external memory controller. Called in startup_stm32f2xx.s 
    398            *          before jump to __main
    399            * @param  None
    400            * @retval None
    401            */ 
    402          #ifdef DATA_IN_ExtSRAM
    403          /**
    404            * @brief  Setup the external memory controller.
    405            *         Called in startup_stm32f2xx.s before jump to main.
    406            *         This function configures the external SRAM mounted on STM322xG_EVAL board
    407            *         This SRAM will be used as program data memory (including heap and stack).
    408            * @param  None
    409            * @retval None
    410            */
    411          void SystemInit_ExtMemCtl(void)
    412          {
    413          /*-- GPIOs Configuration -----------------------------------------------------*/
    414          /*
    415           +-------------------+--------------------+------------------+------------------+
    416           +                       SRAM pins assignment                                  +
    417           +-------------------+--------------------+------------------+------------------+
    418           | PD0  <-> FSMC_D2  | PE0  <-> FSMC_NBL0 | PF0  <-> FSMC_A0 | PG0 <-> FSMC_A10 |
    419           | PD1  <-> FSMC_D3  | PE1  <-> FSMC_NBL1 | PF1  <-> FSMC_A1 | PG1 <-> FSMC_A11 |
    420           | PD4  <-> FSMC_NOE | PE7  <-> FSMC_D4   | PF2  <-> FSMC_A2 | PG2 <-> FSMC_A12 |
    421           | PD5  <-> FSMC_NWE | PE8  <-> FSMC_D5   | PF3  <-> FSMC_A3 | PG3 <-> FSMC_A13 |
    422           | PD8  <-> FSMC_D13 | PE9  <-> FSMC_D6   | PF4  <-> FSMC_A4 | PG4 <-> FSMC_A14 |
    423           | PD9  <-> FSMC_D14 | PE10 <-> FSMC_D7   | PF5  <-> FSMC_A5 | PG5 <-> FSMC_A15 |
    424           | PD10 <-> FSMC_D15 | PE11 <-> FSMC_D8   | PF12 <-> FSMC_A6 | PG9 <-> FSMC_NE2 |
    425           | PD11 <-> FSMC_A16 | PE12 <-> FSMC_D9   | PF13 <-> FSMC_A7 |------------------+
    426           | PD12 <-> FSMC_A17 | PE13 <-> FSMC_D10  | PF14 <-> FSMC_A8 | 
    427           | PD14 <-> FSMC_D0  | PE14 <-> FSMC_D11  | PF15 <-> FSMC_A9 | 
    428           | PD15 <-> FSMC_D1  | PE15 <-> FSMC_D12  |------------------+
    429           +-------------------+--------------------+
    430          */
    431             /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
    432            RCC->AHB1ENR   = 0x00000078;
    433            
    434            /* Connect PDx pins to FSMC Alternate function */
    435            GPIOD->AFR[0]  = 0x00cc00cc;
    436            GPIOD->AFR[1]  = 0xcc0ccccc;
    437            /* Configure PDx pins in Alternate function mode */  
    438            GPIOD->MODER   = 0xa2aa0a0a;
    439            /* Configure PDx pins speed to 100 MHz */  
    440            GPIOD->OSPEEDR = 0xf3ff0f0f;
    441            /* Configure PDx pins Output type to push-pull */  
    442            GPIOD->OTYPER  = 0x00000000;
    443            /* No pull-up, pull-down for PDx pins */ 
    444            GPIOD->PUPDR   = 0x00000000;
    445          
    446            /* Connect PEx pins to FSMC Alternate function */
    447            GPIOE->AFR[0]  = 0xc00000cc;
    448            GPIOE->AFR[1]  = 0xcccccccc;
    449            /* Configure PEx pins in Alternate function mode */ 
    450            GPIOE->MODER   = 0xaaaa800a;
    451            /* Configure PEx pins speed to 100 MHz */ 
    452            GPIOE->OSPEEDR = 0xffffc00f;
    453            /* Configure PEx pins Output type to push-pull */  
    454            GPIOE->OTYPER  = 0x00000000;
    455            /* No pull-up, pull-down for PEx pins */ 
    456            GPIOE->PUPDR   = 0x00000000;
    457          
    458            /* Connect PFx pins to FSMC Alternate function */
    459            GPIOF->AFR[0]  = 0x00cccccc;
    460            GPIOF->AFR[1]  = 0xcccc0000;
    461            /* Configure PFx pins in Alternate function mode */   
    462            GPIOF->MODER   = 0xaa000aaa;
    463            /* Configure PFx pins speed to 100 MHz */ 
    464            GPIOF->OSPEEDR = 0xff000fff;
    465            /* Configure PFx pins Output type to push-pull */  
    466            GPIOF->OTYPER  = 0x00000000;
    467            /* No pull-up, pull-down for PFx pins */ 
    468            GPIOF->PUPDR   = 0x00000000;
    469          
    470            /* Connect PGx pins to FSMC Alternate function */
    471            GPIOG->AFR[0]  = 0x00cccccc;
    472            GPIOG->AFR[1]  = 0x000000c0;
    473            /* Configure PGx pins in Alternate function mode */ 
    474            GPIOG->MODER   = 0x00080aaa;
    475            /* Configure PGx pins speed to 100 MHz */ 
    476            GPIOG->OSPEEDR = 0x000c0fff;
    477            /* Configure PGx pins Output type to push-pull */  
    478            GPIOG->OTYPER  = 0x00000000;
    479            /* No pull-up, pull-down for PGx pins */ 
    480            GPIOG->PUPDR   = 0x00000000;
    481            
    482          /*-- FSMC Configuration ------------------------------------------------------*/
    483            /* Enable the FSMC interface clock */
    484            RCC->AHB3ENR         = 0x00000001;
    485          
    486            /* Configure and enable Bank1_SRAM2 */
    487            FSMC_Bank1->BTCR[2]  = 0x00001015;
    488            FSMC_Bank1->BTCR[3]  = 0x00010400;
    489            FSMC_Bank1E->BWTR[2] = 0x0fffffff;
    490          /*
    491            Bank1_SRAM2 is configured as follow:
    492          
    493            p.FSMC_AddressSetupTime = 0;
    494            p.FSMC_AddressHoldTime = 0;
    495            p.FSMC_DataSetupTime = 4;
    496            p.FSMC_BusTurnAroundDuration = 1;
    497            p.FSMC_CLKDivision = 0;
    498            p.FSMC_DataLatency = 0;
    499            p.FSMC_AccessMode = FSMC_AccessMode_A;
    500          
    501            FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
    502            FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
    503            FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_PSRAM;
    504            FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
    505            FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
    506            FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  
    507            FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
    508            FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
    509            FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
    510            FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
    511            FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
    512            FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
    513            FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
    514            FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
    515            FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
    516          */
    517            
    518          }
    519          #endif /* DATA_IN_ExtSRAM */
    520          
    521          
    522          /**
    523            * @}
    524            */
    525          
    526          /**
    527            * @}
    528            */
    529            
    530          /**
    531            * @}
    532            */    
    533          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
    534          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SetSysClock
       0   SystemCoreClockUpdate
       8   SystemInit
         8   -> SetSysClock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      20  AHBPrescTable
          SystemCoreClock
     138  SetSysClock
     116  SystemCoreClockUpdate
      54  SystemInit

 
  20 bytes in section .data
 348 bytes in section .text
 
 348 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
