###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Drv\tmr.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Drv\tmr.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\tmr.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\tmr.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Drv\tmr.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2014 Loop *************************************
      3          *
      4          * File Name          : tmr.c
      5          *
      6          * Author             : Digital Development Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 07/05/2014
     11          *
     12          * Description        : tmr configuration
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          
     18          /*
     19          *********************************************************************************************************
     20          *                                             INCLUDE FILES
     21          *********************************************************************************************************
     22          */
     23          
     24          #define TMR_GLOBALS
     25          #include "includes.h"

   \                                 In section .bss, align 4
   \   __absolute TMR TmrTbl[7]
   \                     TmrTbl:
   \   00000000                      DS8 140
     26          
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                             LOCAL DEFINES
     31          *********************************************************************************************************
     32          */
     33          
     34          //static OS_EVENT *TmrSemTenths;
     35          //static OS_STK TmrTaskStk[TMR_TASK_STK_SIZE];

   \                                 In section .bss, align 1
     36          static INT8U TmrTickCtr;
   \                     TmrTickCtr:
   \   00000000                      DS8 1
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                        LOCAL FUNCTION PROTOTYPES 
     42          *********************************************************************************************************
     43          */
     44          
     45          
     46          /*
     47          *********************************************************************************************************
     48          *                                               FUNCTIONS 
     49          *********************************************************************************************************
     50          */
     51          
     52          

   \                                 In section .text, align 2, keep-with-next
     53          void TmrCfgFnct(INT32U n, void(*fnct)(void *), void *arg)
     54          {
   \                     TmrCfgFnct: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     55              TMR *ptmr;
     56          
     57              if(n < TMR_MAX_TMR){
   \   00000008   0x2C07             CMP      R4,#+7
   \   0000000A   0xD20C             BCS.N    ??TmrCfgFnct_0
     58          		ptmr = &TmrTbl[n];
     59          		portENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       vPortEnterCritical
     60          		ptmr->TmrFnct = fnct;              /* 타이머에 사용자 함수 포인터를 저장한다             */
   \   00000010   0x....             LDR.N    R0,??DataTable9
   \   00000012   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   00000016   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000001A   0x60C5             STR      R5,[R0, #+12]
     61          		ptmr->TmrFnctArg = arg;            /* 사용자 함수에 대한 전달인자의 포인터를 저장한다    */
   \   0000001C   0x6106             STR      R6,[R0, #+16]
     62          		portEXIT_CRITICAL();
   \   0000001E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000022   0x.... 0x....      B.W      vPortExitCritical
     63              }
     64          }
   \                     ??TmrCfgFnct_0: (+1)
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
     65          
     66          
     67          

   \                                 In section .text, align 2, keep-with-next
     68          INT32U TmrChk(INT32U n)
     69          {
   \                     TmrChk: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     70              INT32U val;
     71          
     72              val = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     73          	
     74              if (n < TMR_MAX_TMR) {
   \   00000006   0x2C07             CMP      R4,#+7
   \   00000008   0xD209             BCS.N    ??TmrChk_0
     75                  portENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       vPortEnterCritical
     76                  val = TmrTbl[n].TmrCtr;
   \   0000000E   0x....             LDR.N    R0,??DataTable9
   \   00000010   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   00000014   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000018   0x6845             LDR      R5,[R0, #+4]
     77                  portEXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       vPortExitCritical
     78              }
     79              return (val);
   \                     ??TmrChk_0: (+1)
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     80          }
     81          
     82          
     83          

   \                                 In section .text, align 2, keep-with-next
     84          void TmrFormat(INT32U n, char *s)
     85          {
   \                     TmrFormat: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
     86              INT32U min;
     87              INT32U sec;
     88              INT32U tenths;
     89              INT32U val;
     90          
     91              if(n < TMR_MAX_TMR){
   \   00000006   0x2D07             CMP      R5,#+7
   \   00000008   0xD23E             BCS.N    ??TmrFormat_0
     92                  portENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       vPortEnterCritical
     93                  val    = TmrTbl[n].TmrCtr;             /* 변환을 위해 타이머의 값을 복사한다            */
   \   0000000E   0x....             LDR.N    R0,??DataTable9
   \   00000010   0xEB05 0x0185      ADD      R1,R5,R5, LSL #+2
   \   00000014   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000018   0x6845             LDR      R5,[R0, #+4]
     94                  portEXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       vPortExitCritical
     95                  min    = (INT32U)(val / 60000);
   \   0000001E   0xF64E 0x2060      MOVW     R0,#+60000
   \   00000022   0xFBB5 0xF3F0      UDIV     R3,R5,R0
     96                  sec    = (INT32U)((val - min * 60000) / 1000);
   \   00000026   0xFB00 0x5013      MLS      R0,R0,R3,R5
   \   0000002A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000002E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
     97                  tenths = (INT32U)(val % 10);
   \   00000032   0x210A             MOVS     R1,#+10
   \   00000034   0x460A             MOV      R2,R1
   \   00000036   0xFBB5 0xF2F2      UDIV     R2,R5,R2
   \   0000003A   0xFB01 0x5212      MLS      R2,R1,R2,R5
     98                  s[0]   = min / 10 + '0';               /* TIMER를 ASCII로 변환한다                      */
   \   0000003E   0x460D             MOV      R5,R1
   \   00000040   0xFBB3 0xF5F5      UDIV     R5,R3,R5
   \   00000044   0xF105 0x0630      ADD      R6,R5,#+48
   \   00000048   0x7026             STRB     R6,[R4, #+0]
     99                  s[1]   = min % 10 + '0';
   \   0000004A   0xFB01 0x3315      MLS      R3,R1,R5,R3
   \   0000004E   0x3330             ADDS     R3,R3,#+48
   \   00000050   0x7063             STRB     R3,[R4, #+1]
    100                  s[2]   = ':';
   \   00000052   0x233A             MOVS     R3,#+58
   \   00000054   0x70A3             STRB     R3,[R4, #+2]
    101                  s[3]   = sec / 10 + '0';
   \   00000056   0x460B             MOV      R3,R1
   \   00000058   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \   0000005C   0xF103 0x0530      ADD      R5,R3,#+48
   \   00000060   0x70E5             STRB     R5,[R4, #+3]
    102                  s[4]   = sec % 10 + '0';
   \   00000062   0xFB01 0x0013      MLS      R0,R1,R3,R0
   \   00000066   0x3030             ADDS     R0,R0,#+48
   \   00000068   0x7120             STRB     R0,[R4, #+4]
    103                  s[5]   = '.';
   \   0000006A   0x202E             MOVS     R0,#+46
   \   0000006C   0x7160             STRB     R0,[R4, #+5]
    104                  s[6]   = tenths / 100  + '0';
   \   0000006E   0x2064             MOVS     R0,#+100
   \   00000070   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   00000074   0x3030             ADDS     R0,R0,#+48
   \   00000076   0x71A0             STRB     R0,[R4, #+6]
    105                  s[7]   = tenths / 10   + '0';
   \   00000078   0x4608             MOV      R0,R1
   \   0000007A   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   0000007E   0x3030             ADDS     R0,R0,#+48
   \   00000080   0x71E0             STRB     R0,[R4, #+7]
    106          		s[8]   = tenths        + '0';
   \   00000082   0xF102 0x0030      ADD      R0,R2,#+48
   \   00000086   0x7220             STRB     R0,[R4, #+8]
    107              }
    108          }
   \                     ??TmrFormat_0: (+1)
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void  TmrReset (INT32U n)
    111          {
   \                     TmrReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    112              TMR *ptmr;
    113          
    114              if(n < TMR_MAX_TMR){
   \   00000004   0x2C07             CMP      R4,#+7
   \   00000006   0xD20C             BCS.N    ??TmrReset_0
    115                  ptmr         = &TmrTbl[n];
    116                  portENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       vPortEnterCritical
    117                  ptmr->TmrCtr = ptmr->TmrInit;                       /* 카운터를 리로드 한다              */
   \   0000000C   0x....             LDR.N    R0,??DataTable9
   \   0000000E   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   00000012   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0x6041             STR      R1,[R0, #+4]
    118                  portEXIT_CRITICAL();
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      vPortExitCritical
    119              }
    120          }
   \                     ??TmrReset_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    121          
    122          
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void TmrSetMST(INT32U n, INT32U min, INT32U sec, INT32U tenths)
    125          {
   \                     TmrSetMST: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    126              TMR *ptmr;
    127              INT32U val;
    128          
    129              if(n < TMR_MAX_TMR){
   \   00000004   0x2C07             CMP      R4,#+7
   \   00000006   0xD214             BCS.N    ??TmrSetMST_0
    130                  ptmr          = &TmrTbl[n];
    131                  val           = (INT32U)min * 600 + (INT32U)sec * 10 + (INT32U)tenths;
   \   00000008   0xF44F 0x7016      MOV      R0,#+600
   \   0000000C   0xEB02 0x0582      ADD      R5,R2,R2, LSL #+2
   \   00000010   0x006A             LSLS     R2,R5,#+1
   \   00000012   0xFB00 0x2001      MLA      R0,R0,R1,R2
   \   00000016   0x181D             ADDS     R5,R3,R0
    132                  portENTER_CRITICAL();
   \   00000018   0x.... 0x....      BL       vPortEnterCritical
    133                  ptmr->TmrInit = val;
   \   0000001C   0x....             LDR.N    R0,??DataTable9
   \   0000001E   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   00000022   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000026   0x6085             STR      R5,[R0, #+8]
    134                  ptmr->TmrCtr  = val;
   \   00000028   0x6045             STR      R5,[R0, #+4]
    135                  portEXIT_CRITICAL();
   \   0000002A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000002E   0x.... 0x....      B.W      vPortExitCritical
    136              }
    137          }
   \                     ??TmrSetMST_0: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    138          
    139          

   \                                 In section .text, align 2, keep-with-next
    140          void TmrSetT(INT32U n, INT32U tenths)
    141          {
   \                     TmrSetT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    142              TMR *ptmr;
    143          
    144              if(n < TMR_MAX_TMR){
   \   00000006   0x2C07             CMP      R4,#+7
   \   00000008   0xD20F             BCS.N    ??TmrSetT_0
    145                  ptmr          = &TmrTbl[n];
    146                  portENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       vPortEnterCritical
    147                  ptmr->TmrInit = tenths / (1000 / 100);
   \   0000000E   0x....             LDR.N    R0,??DataTable9
   \   00000010   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   00000014   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000018   0x210A             MOVS     R1,#+10
   \   0000001A   0xFBB5 0xF1F1      UDIV     R1,R5,R1
   \   0000001E   0x6081             STR      R1,[R0, #+8]
    148                  ptmr->TmrCtr  = tenths / (1000 / 100);
   \   00000020   0x6041             STR      R1,[R0, #+4]
    149                  portEXIT_CRITICAL();
   \   00000022   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      vPortExitCritical
    150              }
    151          }
   \                     ??TmrSetT_0: (+1)
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    152          
    153          
    154          

   \                                 In section .text, align 2, keep-with-next
    155          void TmrSignalTmr(void)
    156          {
    157          	TmrTickCtr++;
   \                     TmrSignalTmr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_1
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    158          	if(TmrTickCtr >= 1){
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD001             BEQ.N    ??TmrSignalTmr_0
    159          		TmrTickCtr = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    160          	}
    161          }
   \                     ??TmrSignalTmr_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    162          
    163          
    164          

   \                                 In section .text, align 2, keep-with-next
    165          void TmrStart(INT32U n)
    166          {
   \                     TmrStart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    167          
    168              if(n < TMR_MAX_TMR){
   \   00000004   0x2C07             CMP      R4,#+7
   \   00000006   0xD20B             BCS.N    ??TmrStart_0
    169                  portENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       vPortEnterCritical
    170                  TmrTbl[n].TmrEn = TRUE;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable9
   \   00000010   0xEB04 0x0284      ADD      R2,R4,R4, LSL #+2
   \   00000014   0x0092             LSLS     R2,R2,#+2
   \   00000016   0x5088             STR      R0,[R1, R2]
    171                  portEXIT_CRITICAL();
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      vPortExitCritical
    172              }
    173          }
   \                     ??TmrStart_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    174          
    175          
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void TmrStop(INT32U n)
    178          {
   \                     TmrStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    179          
    180              if(n < TMR_MAX_TMR){
   \   00000004   0x2C07             CMP      R4,#+7
   \   00000006   0xD20B             BCS.N    ??TmrStop_0
    181                  portENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       vPortEnterCritical
    182                  TmrTbl[n].TmrEn = FALSE;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable9
   \   00000010   0xEB04 0x0284      ADD      R2,R4,R4, LSL #+2
   \   00000014   0x0092             LSLS     R2,R2,#+2
   \   00000016   0x5088             STR      R0,[R1, R2]
    183                  portEXIT_CRITICAL();
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      vPortExitCritical
    184              }
    185          }
   \                     ??TmrStop_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    186          
    187          
    188          

   \                                 In section .text, align 2, keep-with-next
    189          void TmrTask(void *data)
    190          {
   \                     TmrTask: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    191          	
    192              TMR *ptmr;
    193          
    194              INT32U i;
    195              void(*pfnct)(void *);                       /* 타이머가 만료될 때 실행될 함수                */
    196              void *parg;                                 /* 위의 함수로 전달되는 인자                     */
    197          
    198          	data  = data;
    199              pfnct = (void (*)(void *))0;                /* 함수 포인터를 리셋한다                        */
   \   00000004   0x2400             MOVS     R4,#+0
    200              parg  = (void *)0;
   \   00000006   0x4625             MOV      R5,R4
    201          
    202          	
    203          	ptmr = &TmrTbl[0];
   \   00000008   0x....             LDR.N    R6,??DataTable9
   \   0000000A   0x4637             MOV      R7,R6
    204              for (i = 0; i < TMR_MAX_TMR; i++) {             /* 모든 타이머를 리셋하고 비활성화한다      */
   \   0000000C   0x46A0             MOV      R8,R4
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE006             B.N      ??TmrTask_0
    205                  ptmr->TmrEn   = FALSE;
   \                     ??TmrTask_1: (+1)
   \   00000012   0x6038             STR      R0,[R7, #+0]
    206                  ptmr->TmrCtr  = 0;
   \   00000014   0x6078             STR      R0,[R7, #+4]
    207                  ptmr->TmrInit = 0;
   \   00000016   0x60B8             STR      R0,[R7, #+8]
    208                  ptmr->TmrFnct = NULL;
   \   00000018   0x60F8             STR      R0,[R7, #+12]
    209                  ptmr++;
   \   0000001A   0x3714             ADDS     R7,R7,#+20
    210              }
   \   0000001C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??TmrTask_0: (+1)
   \   00000020   0xF1B8 0x0F07      CMP      R8,#+7
   \   00000024   0xD3F5             BCC.N    ??TmrTask_1
    211              TmrTickCtr   = 0;
   \   00000026   0x....             LDR.N    R1,??DataTable9_1
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0xE019             B.N      ??TmrTask_2
    212          
    213          	while(DEF_TRUE){
    214          		
    215          		vTaskDelay(10);
    216          
    217          		ptmr = &TmrTbl[0];                      /* 타이머 테이블의 시작 주소로 포인트한다        */
    218          		portENTER_CRITICAL();
    219          		for (i = 0; i < TMR_MAX_TMR; i++) {
    220          			if (ptmr->TmrEn == TRUE) {          /* 타이머가 활성화됐을 경우만 카운터를 감소      */
   \                     ??TmrTask_3: (+1)
   \   0000002C   0x6838             LDR      R0,[R7, #+0]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD109             BNE.N    ??TmrTask_4
    221          				if (ptmr->TmrCtr > 0) {
   \   00000032   0x6878             LDR      R0,[R7, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??TmrTask_4
    222          					ptmr->TmrCtr--;
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x6078             STR      R0,[R7, #+4]
    223          					if (ptmr->TmrCtr == 0) {            /* 타이머가 만료됐는지 확인              */
   \   0000003C   0xD103             BNE.N    ??TmrTask_4
    224          						ptmr->TmrEn = FALSE;            /* 예, 타이머 정지                       */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6038             STR      R0,[R7, #+0]
    225          						pfnct       = ptmr->TmrFnct;    /* 실행할 함수와 그 전달인자의...        */
   \   00000042   0x68FC             LDR      R4,[R7, #+12]
    226          						parg        = ptmr->TmrFnctArg; /* ... 포인터를 얻는다                   */
   \   00000044   0x693D             LDR      R5,[R7, #+16]
    227          					}
    228          				}
    229          			}
    230          			if(pfnct != (void (*)(void *))0){    /* 타이머 만료 함수를 실행해야 하는지 점검한다  */
   \                     ??TmrTask_4: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xD002             BEQ.N    ??TmrTask_5
    231          				(*pfnct)(parg);                       
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x47A0             BLX      R4
    232          				pfnct = (void (*)(void *))0;
   \   0000004E   0x2400             MOVS     R4,#+0
    233          			}
    234          			ptmr++;
   \                     ??TmrTask_5: (+1)
   \   00000050   0x3714             ADDS     R7,R7,#+20
    235          		}
   \   00000052   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??TmrTask_6: (+1)
   \   00000056   0xF1B8 0x0F07      CMP      R8,#+7
   \   0000005A   0xD3E7             BCC.N    ??TmrTask_3
    236          		portEXIT_CRITICAL();
   \   0000005C   0x.... 0x....      BL       vPortExitCritical
   \                     ??TmrTask_2: (+1)
   \   00000060   0x200A             MOVS     R0,#+10
   \   00000062   0x.... 0x....      BL       vTaskDelay
   \   00000066   0x4637             MOV      R7,R6
   \   00000068   0x.... 0x....      BL       vPortEnterCritical
   \   0000006C   0xF04F 0x0800      MOV      R8,#+0
   \   00000070   0xE7F1             B.N      ??TmrTask_6
    237          	}
    238          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     TmrTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     TmrTickCtr
    239          
    240          
    241          
    242          
    243          /*
    244          ********************* (C) COPYRIGHT 2014 Loop ***************END OF FILE*****************************
    245          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TmrCfgFnct
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   TmrChk
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
      16   TmrFormat
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       8   TmrReset
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   TmrSetMST
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   TmrSetT
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       0   TmrSignalTmr
       8   TmrStart
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
       8   TmrStop
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
      24   TmrTask
        24   -- Indirect call
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
      40  TmrCfgFnct
      34  TmrChk
     138  TmrFormat
      36  TmrReset
      52  TmrSetMST
      44  TmrSetT
      20  TmrSignalTmr
      34  TmrStart
      34  TmrStop
     114  TmrTask
     140  TmrTbl
       1  TmrTickCtr

 
 141 bytes in section .bss
 554 bytes in section .text
 
 554 bytes of CODE memory
 141 bytes of DATA memory

Errors: none
Warnings: none
