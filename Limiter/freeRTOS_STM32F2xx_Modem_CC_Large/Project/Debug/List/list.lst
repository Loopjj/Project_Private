###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:17
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\list.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\list.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\list.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\list.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\list.c
      1          /*
      2              FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd. 
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          
     67          #include <stdlib.h>
     68          #include "FreeRTOS.h"
     69          #include "list.h"
     70          
     71          /*-----------------------------------------------------------
     72           * PUBLIC LIST API documented in list.h
     73           *----------------------------------------------------------*/
     74          

   \                                 In section .text, align 2, keep-with-next
     75          void vListInitialise( xList * const pxList )
     76          {
     77          	/* The list structure contains a list item which is used to mark the
     78          	end of the list.  To initialise the list the list end is inserted
     79          	as the only list entry. */
     80          	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \                     vListInitialise: (+1)
   \   00000000   0xF100 0x0108      ADD      R1,R0,#+8
   \   00000004   0x6041             STR      R1,[R0, #+4]
     81          
     82          	/* The list end value is the highest possible value in the list to
     83          	ensure it remains at the end of the list. */
     84          	pxList->xListEnd.xItemValue = portMAX_DELAY;
   \   00000006   0xF04F 0x31FF      MOV      R1,#-1
   \   0000000A   0x6081             STR      R1,[R0, #+8]
     85          
     86          	/* The list end next and previous pointers point to itself so we know
     87          	when the list is empty. */
     88          	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \   0000000C   0xF100 0x0108      ADD      R1,R0,#+8
   \   00000010   0x60C1             STR      R1,[R0, #+12]
     89          	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \   00000012   0x6101             STR      R1,[R0, #+16]
     90          
     91          	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6001             STR      R1,[R0, #+0]
     92          }
   \   00000018   0x4770             BX       LR               ;; return
     93          /*-----------------------------------------------------------*/
     94          

   \                                 In section .text, align 2, keep-with-next
     95          void vListInitialiseItem( xListItem * const pxItem )
     96          {
     97          	/* Make sure the list item is not recorded as being on a list. */
     98          	pxItem->pvContainer = NULL;
   \                     vListInitialiseItem: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6101             STR      R1,[R0, #+16]
     99          }
   \   00000004   0x4770             BX       LR               ;; return
    100          /*-----------------------------------------------------------*/
    101          

   \                                 In section .text, align 2, keep-with-next
    102          void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
    103          {
    104          xListItem * pxIndex;
    105          
    106          	/* Insert a new list item into pxList, but rather than sort the list,
    107          	makes the new list item the last item to be removed by a call to
    108          	pvListGetOwnerOfNextEntry. */
    109          	pxIndex = pxList->pxIndex;
   \                     vListInsertEnd: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
    110          
    111          	pxNewListItem->pxNext = pxIndex;
   \   00000002   0x604A             STR      R2,[R1, #+4]
    112          	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   \   00000004   0x6893             LDR      R3,[R2, #+8]
   \   00000006   0x608B             STR      R3,[R1, #+8]
    113          	pxIndex->pxPrevious->pxNext = pxNewListItem;
   \   00000008   0x6893             LDR      R3,[R2, #+8]
   \   0000000A   0x6059             STR      R1,[R3, #+4]
    114          	pxIndex->pxPrevious = pxNewListItem;
   \   0000000C   0x6091             STR      R1,[R2, #+8]
    115          
    116          	/* Remember which list the item is in. */
    117          	pxNewListItem->pvContainer = ( void * ) pxList;
   \   0000000E   0x6108             STR      R0,[R1, #+16]
    118          
    119          	( pxList->uxNumberOfItems )++;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    120          }
   \   00000016   0x4770             BX       LR               ;; return
    121          /*-----------------------------------------------------------*/
    122          

   \                                 In section .text, align 2, keep-with-next
    123          void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
    124          {
   \                     vListInsert: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    125          xListItem *pxIterator;
    126          portTickType xValueOfInsertion;
    127          
    128          	/* Insert the new list item into the list, sorted in ulListItem order. */
    129          	xValueOfInsertion = pxNewListItem->xItemValue;
   \   00000002   0x680A             LDR      R2,[R1, #+0]
    130          
    131          	/* If the list already contains a list item with the same item value then
    132          	the new list item should be placed after it.  This ensures that TCB's which
    133          	are stored in ready lists (all of which have the same ulListItem value)
    134          	get an equal share of the CPU.  However, if the xItemValue is the same as
    135          	the back marker the iteration loop below will not end.  This means we need
    136          	to guard against this by checking the value first and modifying the
    137          	algorithm slightly if necessary. */
    138          	if( xValueOfInsertion == portMAX_DELAY )
   \   00000004   0xF112 0x0F01      CMN      R2,#+1
   \   00000008   0xD101             BNE.N    ??vListInsert_0
    139          	{
    140          		pxIterator = pxList->xListEnd.pxPrevious;
   \   0000000A   0x6903             LDR      R3,[R0, #+16]
   \   0000000C   0xE007             B.N      ??vListInsert_1
    141          	}
    142          	else
    143          	{
    144          		/* *** NOTE ***********************************************************
    145          		If you find your application is crashing here then likely causes are:
    146          			1) Stack overflow -
    147          			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
    148          			2) Incorrect interrupt priority assignment, especially on Cortex-M3
    149          			   parts where numerically high priority values denote low actual
    150          			   interrupt priories, which can seem counter intuitive.  See
    151          			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
    152          			3) Calling an API function from within a critical section or when
    153          			   the scheduler is suspended, or calling an API function that does
    154          			   not end in "FromISR" from an interrupt.
    155          			4) Using a queue or semaphore before it has been initialised or
    156          			   before the scheduler has been started (are interrupts firing
    157          			   before vTaskStartScheduler() has been called?).
    158          		See http://www.freertos.org/FAQHelp.html for more tips.
    159          		**********************************************************************/
    160          
    161          		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \                     ??vListInsert_0: (+1)
   \   0000000E   0xF100 0x0308      ADD      R3,R0,#+8
   \   00000012   0xE000             B.N      ??vListInsert_2
   \                     ??vListInsert_3: (+1)
   \   00000014   0x4623             MOV      R3,R4
   \                     ??vListInsert_2: (+1)
   \   00000016   0x685C             LDR      R4,[R3, #+4]
   \   00000018   0x6825             LDR      R5,[R4, #+0]
   \   0000001A   0x42AA             CMP      R2,R5
   \   0000001C   0xD2FA             BCS.N    ??vListInsert_3
    162          		{
    163          			/* There is nothing to do here, we are just iterating to the
    164          			wanted insertion position. */
    165          		}
    166          	}
    167          
    168          	pxNewListItem->pxNext = pxIterator->pxNext;
   \                     ??vListInsert_1: (+1)
   \   0000001E   0x685A             LDR      R2,[R3, #+4]
   \   00000020   0x604A             STR      R2,[R1, #+4]
    169          	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   \   00000022   0x6091             STR      R1,[R2, #+8]
    170          	pxNewListItem->pxPrevious = pxIterator;
   \   00000024   0x608B             STR      R3,[R1, #+8]
    171          	pxIterator->pxNext = pxNewListItem;
   \   00000026   0x6059             STR      R1,[R3, #+4]
    172          
    173          	/* Remember which list the item is in.  This allows fast removal of the
    174          	item later. */
    175          	pxNewListItem->pvContainer = ( void * ) pxList;
   \   00000028   0x6108             STR      R0,[R1, #+16]
    176          
    177          	( pxList->uxNumberOfItems )++;
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    178          }
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
    179          /*-----------------------------------------------------------*/
    180          

   \                                 In section .text, align 2, keep-with-next
    181          unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
    182          {
    183          xList * pxList;
    184          
    185          	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   \                     uxListRemove: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0x6091             STR      R1,[R2, #+8]
    186          	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x6882             LDR      R2,[R0, #+8]
   \   0000000A   0x6051             STR      R1,[R2, #+4]
    187          
    188          	/* The list item knows which list it is in.  Obtain the list from the list
    189          	item. */
    190          	pxList = ( xList * ) pxItemToRemove->pvContainer;
   \   0000000C   0x6901             LDR      R1,[R0, #+16]
    191          
    192          	/* Make sure the index is left pointing to a valid item. */
    193          	if( pxList->pxIndex == pxItemToRemove )
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xD101             BNE.N    ??uxListRemove_0
    194          	{
    195          		pxList->pxIndex = pxItemToRemove->pxPrevious;
   \   00000014   0x6882             LDR      R2,[R0, #+8]
   \   00000016   0x604A             STR      R2,[R1, #+4]
    196          	}
    197          
    198          	pxItemToRemove->pvContainer = NULL;
   \                     ??uxListRemove_0: (+1)
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x6102             STR      R2,[R0, #+16]
    199          	( pxList->uxNumberOfItems )--;
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x6008             STR      R0,[R1, #+0]
    200          
    201          	return pxList->uxNumberOfItems;
   \   00000022   0x4770             BX       LR               ;; return
    202          }
    203          /*-----------------------------------------------------------*/
    204          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   uxListRemove
       0   vListInitialise
       0   vListInitialiseItem
       8   vListInsert
       0   vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      36  uxListRemove
      26  vListInitialise
       6  vListInitialiseItem
      52  vListInsert
      24  vListInsertEnd

 
 144 bytes in section .text
 
 144 bytes of CODE memory

Errors: none
Warnings: none
