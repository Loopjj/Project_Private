###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\fsmc_nand.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\fsmc_nand.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\fsmc_nand.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\fsmc_nand.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\fsmc_nand.c
      1          /****************************************Copyright (c)****************************************************
      2          **                                      
      3          **
      4          **--------------File Info---------------------------------------------------------------------------------
      5          ** File name:               fsmc_nand.c
      6          ** Descriptions:            The FSMC Nand application function
      7          **
      8          **--------------------------------------------------------------------------------------------------------
      9          ** Created by:              MKH
     10          ** Created date:            2014-12-30
     11          ** Version:                 v1.0
     12          ** Descriptions:            The original version
     13          **
     14          **--------------------------------------------------------------------------------------------------------
     15          ** Modified by:             
     16          ** Modified date:           
     17          ** Version:                 
     18          ** Descriptions:            
     19          **
     20          *********************************************************************************************************/
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #define NAND_GLOBALS
     24          #include "includes.h"

   \                                 In section .bss, align 4
   \   __absolute st_BadBlockData BadBlockData
   \                     BadBlockData:
   \   00000000                      DS8 104
     25          
     26          #if 1
     27          
     28          /* Private define ------------------------------------------------------------*/
     29          #define NAND_FLASH_START_ADDR     ((uint32_t)0x70000000) 
     30          
     31          #define PROGRAM_TIMEOUT	0xF00000
     32          

   \                                 In section .bss, align 4
     33          NAND_ADDRESS WriteReadAddr;
   \                     WriteReadAddr:
   \   00000000                      DS8 8
     34          
     35          //#define ROW_ADDRESS ( (WriteReadAddr.Page*NAND_PAGE_SIZE) + (WriteReadAddr.Block + (WriteReadAddr.Zone * NAND_ZONE_SIZE)) * NAND_BLOCK_SIZE)
     36          //#define ROW_ADDRESS ( (WriteReadAddr.Page) + (WriteReadAddr.Block + (WriteReadAddr.Zone * NAND_ZONE_SIZE)) * NAND_BLOCK_SIZE)
     37          #define ROW_ADDRESS ( (WriteReadAddr.Page) + (WriteReadAddr.Block + (WriteReadAddr.Zone * NAND_ZONE_SIZE)) * NAND_BLOCK_COUNT)
     38          
     39          
     40          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     41          uint8_t RxBuffer [NAND_PAGE_SIZE];
   \                     RxBuffer:
   \   00000000                      DS8 4096
     42          #if NAND_DEBUG >0
     43          uint8_t TxBuffer [NAND_PAGE_SIZE];
     44          uint8_t RxBuffer [NAND_PAGE_SIZE];
     45          #endif
     46          
     47          

   \                                 In section .text, align 2, keep-with-next
     48          void NandSemaphore_Init(void)
     49          {
   \                     NandSemaphore_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     50          	BSP_NANDSem = xSemaphoreCreateMutex();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable52_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       xQueueCreateMutex
   \   0000000C   0x6020             STR      R0,[R4, #+0]
     51          	vSemaphoreCreateBinary(BSP_NANDSem);
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       xQueueGenericCreate
   \   00000018   0x6020             STR      R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD006             BEQ.N    ??NandSemaphore_Init_0
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x4611             MOV      R1,R2
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      xQueueGenericSend
     52          }
   \                     ??NandSemaphore_Init_0: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
     53          
     54          /*******************************************************************************
     55          * Function Name  : FSMC_NAND_Init
     56          * Description    : Configures the FSMC and GPIOs to interface with the NAND memory.
     57          *                  This function must be called before any write/read operation
     58          *                  on the NAND.
     59          * Input          : None
     60          * Output         : None
     61          * Return         : None
     62          * Attention		 : None
     63          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          void FSMC_NAND_Init(void)
     65          {
   \                     FSMC_NAND_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
     66          	GPIO_InitTypeDef GPIO_InitStructure; 
     67          
     68          	FSMC_NANDInitTypeDef FSMC_NANDInitStructure;
     69          	FSMC_NAND_PCCARDTimingInitTypeDef  p;
     70          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE , ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2018             MOVS     R0,#+24
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     71          
     72          	/*-- GPIO Configuration ------------------------------------------------------*/
     73          	/* CLE, ALE, D0->D3, NOE, NWE and NCE2  NAND pin configuration  */
     74          
     75          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE); 
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     76          	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC,ENABLE);	
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x4608             MOV      R0,R1
   \   0000001A   0x.... 0x....      BL       RCC_AHB3PeriphClockCmd
     77          	
     78          	/*-- GPIO Configuration ------------------------------------------------------*/
     79          	/* CLE, ALE, D0->D3, NOE, NWE and NCE2  NAND pin configuration  */
     80          	GPIO_InitStructure.GPIO_Pin =   GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_4  | GPIO_Pin_5  |
     81                                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_14 | GPIO_Pin_15 |
     82                                            GPIO_Pin_7;
   \   0000001E   0xF64D 0x00B3      MOVW     R0,#+55475
   \   00000022   0x9000             STR      R0,[SP, #+0]
     83          
     84          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF88D 0x0004      STRB     R0,[SP, #+4]
     85          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xF88D 0x0005      STRB     R0,[SP, #+5]
     86          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF88D 0x0006      STRB     R0,[SP, #+6]
     87          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xF88D 0x0007      STRB     R0,[SP, #+7]
     88          	GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000003C   0x.... 0x....      LDR.W    R4,??DataTable52_2  ;; 0x40020c00
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       GPIO_Init
     89          
     90          	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
     91          	//GPIO_Init(GPIOG, &GPIO_InitStructure);
     92          
     93          	/* NWAIT NAND pin configuration */
     94          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;                                                      
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x9000             STR      R0,[SP, #+0]
     95          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xF88D 0x0005      STRB     R0,[SP, #+5]
     96          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xF88D 0x0004      STRB     R0,[SP, #+4]
     97          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     98          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     99          	GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000005E   0x4669             MOV      R1,SP
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       GPIO_Init
    100          
    101          
    102          	/* D4->D7 NAND pin configuration  */  
    103          	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
   \   00000066   0xF44F 0x60F0      MOV      R0,#+1920
   \   0000006A   0x9000             STR      R0,[SP, #+0]
    104          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    105          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0xF88D 0x0005      STRB     R0,[SP, #+5]
    106          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    107          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0xF88D 0x0007      STRB     R0,[SP, #+7]
    108          	GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   00000084   0x.... 0x....      LDR.W    R5,??DataTable52_3  ;; 0x40021000
   \   00000088   0x4669             MOV      R1,SP
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       GPIO_Init
    109          
    110          
    111              GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
   \   00000090   0x220C             MOVS     R2,#+12
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       GPIO_PinAFConfig
    112              GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
   \   0000009A   0x220C             MOVS     R2,#+12
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       GPIO_PinAFConfig
    113              GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
   \   000000A4   0x220C             MOVS     R2,#+12
   \   000000A6   0x2104             MOVS     R1,#+4
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       GPIO_PinAFConfig
    114              GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
   \   000000AE   0x220C             MOVS     R2,#+12
   \   000000B0   0x2105             MOVS     R1,#+5
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       GPIO_PinAFConfig
    115              GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_FSMC); 
   \   000000B8   0x220C             MOVS     R2,#+12
   \   000000BA   0x2106             MOVS     R1,#+6
   \   000000BC   0x4620             MOV      R0,R4
   \   000000BE   0x.... 0x....      BL       GPIO_PinAFConfig
    116              GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_FSMC);
   \   000000C2   0x220C             MOVS     R2,#+12
   \   000000C4   0x2107             MOVS     R1,#+7
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       GPIO_PinAFConfig
    117              GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FSMC);
   \   000000CC   0x220C             MOVS     R2,#+12
   \   000000CE   0x210B             MOVS     R1,#+11
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0x.... 0x....      BL       GPIO_PinAFConfig
    118              GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);
   \   000000D6   0x220C             MOVS     R2,#+12
   \   000000D8   0x4611             MOV      R1,R2
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       GPIO_PinAFConfig
    119              GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
   \   000000E0   0x220C             MOVS     R2,#+12
   \   000000E2   0x210E             MOVS     R1,#+14
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0x.... 0x....      BL       GPIO_PinAFConfig
    120              GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
   \   000000EA   0x220C             MOVS     R2,#+12
   \   000000EC   0x210F             MOVS     R1,#+15
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       GPIO_PinAFConfig
    121              /* D4->D7 NAND pin configuration  */ 
    122              GPIO_PinAFConfig(GPIOE, GPIO_PinSource7, GPIO_AF_FSMC);
   \   000000F4   0x220C             MOVS     R2,#+12
   \   000000F6   0x2107             MOVS     R1,#+7
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       GPIO_PinAFConfig
    123              GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_FSMC);
   \   000000FE   0x220C             MOVS     R2,#+12
   \   00000100   0x2108             MOVS     R1,#+8
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x.... 0x....      BL       GPIO_PinAFConfig
    124              GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_FSMC);
   \   00000108   0x220C             MOVS     R2,#+12
   \   0000010A   0x2109             MOVS     R1,#+9
   \   0000010C   0x4628             MOV      R0,R5
   \   0000010E   0x.... 0x....      BL       GPIO_PinAFConfig
    125              GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
   \   00000112   0x220C             MOVS     R2,#+12
   \   00000114   0x210A             MOVS     R1,#+10
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0x.... 0x....      BL       GPIO_PinAFConfig
    126          
    127          	//GPIO_PinAFConfig(GPIOG, GPIO_PinSource9, GPIO_AF_FSMC);
    128          
    129          
    130          	/*-- FSMC Configuration ------------------------------------------------------*/
    131          #if 1
    132          	p.FSMC_SetupTime = 0xf1;
   \   0000011C   0x20F1             MOVS     R0,#+241
   \   0000011E   0x9002             STR      R0,[SP, #+8]
    133          	p.FSMC_WaitSetupTime = 0xf3;
   \   00000120   0x20F3             MOVS     R0,#+243
   \   00000122   0x9003             STR      R0,[SP, #+12]
    134          	p.FSMC_HoldSetupTime = 0xf2;
   \   00000124   0x20F2             MOVS     R0,#+242
   \   00000126   0x9004             STR      R0,[SP, #+16]
    135          	p.FSMC_HiZSetupTime = 0xf1;
   \   00000128   0x20F1             MOVS     R0,#+241
   \   0000012A   0x9005             STR      R0,[SP, #+20]
    136          #else
    137          	p.FSMC_SetupTime = 0x1;
    138          	p.FSMC_WaitSetupTime = 0x15;
    139          	p.FSMC_HoldSetupTime = 0x2;
    140          	p.FSMC_HiZSetupTime = 0x1;
    141          #endif
    142          
    143          
    144          	FSMC_NANDInitStructure.FSMC_Bank						    = FSMC_Bank2_NAND;
   \   0000012C   0x2010             MOVS     R0,#+16
   \   0000012E   0x9006             STR      R0,[SP, #+24]
    145          	FSMC_NANDInitStructure.FSMC_Waitfeature					= FSMC_Waitfeature_Enable;
   \   00000130   0x2002             MOVS     R0,#+2
   \   00000132   0x9007             STR      R0,[SP, #+28]
    146          	FSMC_NANDInitStructure.FSMC_MemoryDataWidth			= FSMC_MemoryDataWidth_8b;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x9008             STR      R0,[SP, #+32]
    147          	FSMC_NANDInitStructure.FSMC_ECC							    = FSMC_ECC_Disable;//FSMC_ECC_Enable;
   \   00000138   0x9009             STR      R0,[SP, #+36]
    148          	FSMC_NANDInitStructure.FSMC_ECCPageSize					= FSMC_ECCPageSize_512Bytes;
   \   0000013A   0xF44F 0x3000      MOV      R0,#+131072
   \   0000013E   0x900A             STR      R0,[SP, #+40]
    149          #if 1
    150          	FSMC_NANDInitStructure.FSMC_TCLRSetupTime				= 0xF1;//0xA1;
   \   00000140   0x20F1             MOVS     R0,#+241
   \   00000142   0x900B             STR      R0,[SP, #+44]
    151          	FSMC_NANDInitStructure.FSMC_TARSetupTime				= 0xF1;//0x15;
   \   00000144   0x900C             STR      R0,[SP, #+48]
    152          #else
    153          	FSMC_NANDInitStructure.FSMC_TCLRSetupTime				= 0x0;//0xA1;
    154          	FSMC_NANDInitStructure.FSMC_TARSetupTime				= 0x0;//0x15;
    155          #endif
    156          	FSMC_NANDInitStructure.FSMC_CommonSpaceTimingStruct		= &p;
   \   00000146   0xA802             ADD      R0,SP,#+8
   \   00000148   0x900D             STR      R0,[SP, #+52]
    157          	FSMC_NANDInitStructure.FSMC_AttributeSpaceTimingStruct	= &p;
   \   0000014A   0x900E             STR      R0,[SP, #+56]
    158          
    159          	FSMC_NANDInit(&FSMC_NANDInitStructure);
   \   0000014C   0xA806             ADD      R0,SP,#+24
   \   0000014E   0x.... 0x....      BL       FSMC_NANDInit
    160          
    161          	/* FSMC NAND Bank Cmd Test */
    162          	FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);
   \   00000152   0x2101             MOVS     R1,#+1
   \   00000154   0x2010             MOVS     R0,#+16
   \   00000156   0x.... 0x....      BL       FSMC_NANDCmd
    163          
    164          }
   \   0000015A   0xB00F             ADD      SP,SP,#+60
   \   0000015C   0xBD30             POP      {R4,R5,PC}       ;; return
    165          
    166          /******************************************************************************
    167          * Function Name  : FSMC_NAND_WriteSmallPage
    168          * Description    : This routine is for writing one or several 4096 Bytes Page size.
    169          * Input          : - pBuffer: pointer on the Buffer containing data to be written   
    170          *                  - Address: First page address
    171          *                  - NumPageToWrite: Number of page to write  
    172          * Output         : None
    173          * Return         : New status of the NAND operation. This parameter can be:
    174          *                   - NAND_TIMEOUT_ERROR: when the previous operation generate 
    175          *                     a Timeout error
    176          *                   - NAND_READY: when memory is ready for the next operation 
    177          *                  And the new status of the increment address operation. It can be:
    178          *                  - NAND_VALID_ADDRESS: When the new address is valid address
    179          *                  - NAND_INVALID_ADDRESS: When the new address is invalid address
    180          * Attention		 : None
    181          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          uint32_t FSMC_NAND_WriteSmallPage(uint8_t *pBuffer, uint32_t Address, uint32_t size)
    183          {
   \                     FSMC_NAND_WriteSmallPage: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
    184          	uint32_t index = 0x00, numpagewritten = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0xF44F 0x7680      MOV      R6,#+256
    185          	uint32_t status = NAND_READY;//, size = 0x00;
   \   0000000C   0xF04F 0x0B40      MOV      R11,#+64
    186          	uint16_t caddr,paddr,NumPageToWrite = 5;
   \   00000010   0x2705             MOVS     R7,#+5
    187          	
    188          	if(BSP_NANDSem == NULL)
   \   00000012   0x.... 0x....      LDR.W    R8,??DataTable52_1
   \   00000016   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD107             BNE.N    ??FSMC_NAND_WriteSmallPage_0
    189          	{
    190          		printk("%s err\n",__func__);
   \   0000001E   0x.... 0x....      ADR.W    R1,`FSMC_NAND_WriteSmallPage::__func__`
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       printk
    191          		return ERROR;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE04E             B.N      ??FSMC_NAND_WriteSmallPage_1
    192          	}
    193          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_WriteSmallPage_0: (+1)
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x461A             MOV      R2,R3
   \   00000032   0x4611             MOV      R1,R2
   \   00000034   0x.... 0x....      BL       xQueueGenericReceive
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD146             BNE.N    ??FSMC_NAND_WriteSmallPage_2
    194          	{
    195          		caddr = Address%NAND_PAGE_SIZE;
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0xF3C0 0x090B      UBFX     R9,R0,#+0,#+12
    196          		paddr = Address/NAND_PAGE_SIZE;
   \   00000042   0xEA4F 0x3A10      LSR      R10,R0,#+12
   \   00000046   0xFA1F 0xFA8A      UXTH     R10,R10
   \   0000004A   0xE011             B.N      ??FSMC_NAND_WriteSmallPage_3
    197          
    198          		//while((size != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    199          		while((NumPageToWrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    200          		{
    201          			/* Page write command and address */
    202          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_PAGEPROGRAM;
    203          
    204          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( caddr&0xFF     );  
    205          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((caddr>>8)&0x0F );  
    206          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( paddr&0xFF     );  
    207          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>8)&0xFF );
    208          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>16)&0xFF);
    209          
    210          			/* Calculate the size */
    211          			//size = NAND_PAGE_SIZE;// + (NAND_PAGE_SIZE * numpagewritten);
    212          
    213          			/* Write data */
    214          			for(index=0; index < size; index++)
    215          			{
    216          			  *(__IO uint8_t *)(NAND_FLASH_START_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??FSMC_NAND_WriteSmallPage_4: (+1)
   \   0000004C   0x5C62             LDRB     R2,[R4, R1]
   \   0000004E   0x701A             STRB     R2,[R3, #+0]
    217          			}
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \                     ??FSMC_NAND_WriteSmallPage_5: (+1)
   \   00000052   0x42A9             CMP      R1,R5
   \   00000054   0xD3FA             BCC.N    ??FSMC_NAND_WriteSmallPage_4
    218          		    
    219          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_PAGEPROGRAM_TRUE;
   \   00000056   0x2110             MOVS     R1,#+16
   \   00000058   0x7001             STRB     R1,[R0, #+0]
    220          
    221          			/* ¶ÁÃ¦½Å */
    222          		//    while( GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_6) == 0 );
    223          		    
    224          			/* Check status for successful operation */
    225          			status = FSMC_NAND_GetStatus();
   \   0000005A   0x.... 0x....      BL       FSMC_NAND_GetStatus
   \   0000005E   0x4683             MOV      R11,R0
    226          			//printk("FSMC_NAND_WriteSmallPage status = %02X\n",status);
    227          		    
    228          			if(status == NAND_READY)
   \   00000060   0xF1BB 0x0F40      CMP      R11,#+64
   \   00000064   0xD104             BNE.N    ??FSMC_NAND_WriteSmallPage_3
    229          			{
    230          			  numpagewritten++;
    231          
    232          			  NumPageToWrite--;
   \   00000066   0x1E7F             SUBS     R7,R7,#+1
    233          
    234          			  /* Calculate Next small page Address */
    235          			  addressstatus = FSMC_NAND_AddressIncrement(&Address);    
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x.... 0x....      BL       FSMC_NAND_AddressIncrement
   \   0000006E   0x4606             MOV      R6,R0
    236          			  //printk("address status FSMC_NAND_WriteSmallPage status = %02X\n",addressstatus);
    237          			} 
   \                     ??FSMC_NAND_WriteSmallPage_3: (+1)
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0xB280             UXTH     R0,R0
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD01E             BEQ.N    ??FSMC_NAND_WriteSmallPage_6
   \   00000078   0xF5B6 0x7F80      CMP      R6,#+256
   \   0000007C   0xD11B             BNE.N    ??FSMC_NAND_WriteSmallPage_6
   \   0000007E   0xF1BB 0x0F40      CMP      R11,#+64
   \   00000082   0xD118             BNE.N    ??FSMC_NAND_WriteSmallPage_6
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable52_4  ;; 0x70010000
   \   00000088   0x2180             MOVS     R1,#+128
   \   0000008A   0x7001             STRB     R1,[R0, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable52_5  ;; 0x70020000
   \   00000090   0xF881 0x9000      STRB     R9,[R1, #+0]
   \   00000094   0xEA4F 0x2229      ASR      R2,R9,#+8
   \   00000098   0xF002 0x020F      AND      R2,R2,#0xF
   \   0000009C   0x700A             STRB     R2,[R1, #+0]
   \   0000009E   0xF881 0xA000      STRB     R10,[R1, #+0]
   \   000000A2   0xEA4F 0x222A      ASR      R2,R10,#+8
   \   000000A6   0x700A             STRB     R2,[R1, #+0]
   \   000000A8   0xEA4F 0x422A      ASR      R2,R10,#+16
   \   000000AC   0x700A             STRB     R2,[R1, #+0]
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0xF04F 0x43E0      MOV      R3,#+1879048192
   \   000000B4   0xE7CD             B.N      ??FSMC_NAND_WriteSmallPage_5
    238          		}
    239          		xSemaphoreGive(BSP_NANDSem);
   \                     ??FSMC_NAND_WriteSmallPage_6: (+1)
   \   000000B6   0x2300             MOVS     R3,#+0
   \   000000B8   0x461A             MOV      R2,R3
   \   000000BA   0x4611             MOV      R1,R2
   \   000000BC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C0   0x.... 0x....      BL       xQueueGenericSend
    240          		return (status | addressstatus);
   \   000000C4   0xEA46 0x000B      ORR      R0,R6,R11
   \   000000C8   0xE000             B.N      ??FSMC_NAND_WriteSmallPage_1
    241          	}
    242          	return NAND_ERROR;
   \                     ??FSMC_NAND_WriteSmallPage_2: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \                     ??FSMC_NAND_WriteSmallPage_1: (+1)
   \   000000CC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    243          }
    244          
    245          /******************************************************************************
    246          * Function Name  : FSMC_NAND_ReadSmallPage
    247          * Description    : This routine is for sequential read from one or several 
    248          *                  4096 Bytes Page size.
    249          * Input          : - pBuffer: pointer on the Buffer to fill  
    250          *                  - Address: First page address
    251          *                  - NumPageToRead: Number of page to read
    252          * Output         : None
    253          * Return         : New status of the NAND operation. This parameter can be:
    254          *                   - NAND_TIMEOUT_ERROR: when the previous operation generate 
    255          *                     a Timeout error
    256          *                   - NAND_READY: when memory is ready for the next operation 
    257          *                  And the new status of the increment address operation. It can be:
    258          *                  - NAND_VALID_ADDRESS: When the new address is valid address
    259          *                  - NAND_INVALID_ADDRESS: When the new address is invalid address
    260          * Attention		 : None
    261          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    262          uint32_t FSMC_NAND_ReadSmallPage(uint8_t *pBuffer, uint32_t Address, uint32_t size)
    263          {
   \                     FSMC_NAND_ReadSmallPage: (+1)
   \   00000000   0xE92D 0x47F3      PUSH     {R0,R1,R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
    264          	uint32_t index = 0x00, numpageread = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0xF44F 0x7A80      MOV      R10,#+256
    265          	uint32_t status = NAND_READY;//, size = 0x00;
    266          	uint16_t caddr,paddr,NumPageToRead = 10;
   \   0000000C   0xF04F 0x090A      MOV      R9,#+10
    267          	
    268          	if(BSP_NANDSem == NULL)
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable52_1
   \   00000014   0x6830             LDR      R0,[R6, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD107             BNE.N    ??FSMC_NAND_ReadSmallPage_0
    269          	{
    270          		printk("%s err\n",__func__);
   \   0000001A   0x.... 0x....      ADR.W    R1,`FSMC_NAND_ReadSmallPage::__func__`
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       printk
    271          		return ERROR;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE04C             B.N      ??FSMC_NAND_ReadSmallPage_1
    272          	}
    273          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_ReadSmallPage_0: (+1)
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x461A             MOV      R2,R3
   \   0000002E   0x4611             MOV      R1,R2
   \   00000030   0x.... 0x....      BL       xQueueGenericReceive
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD144             BNE.N    ??FSMC_NAND_ReadSmallPage_2
    274          	{
    275          		caddr = Address%NAND_PAGE_SIZE;
   \   00000038   0x9801             LDR      R0,[SP, #+4]
   \   0000003A   0xF3C0 0x070B      UBFX     R7,R0,#+0,#+12
    276          		paddr = Address/NAND_PAGE_SIZE;
   \   0000003E   0xEA4F 0x3810      LSR      R8,R0,#+12
   \   00000042   0xFA1F 0xF888      UXTH     R8,R8
   \   00000046   0xE00C             B.N      ??FSMC_NAND_ReadSmallPage_3
    277          
    278          		while((NumPageToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
    279          		{	   
    280          			/* Page Read command and page address */
    281          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_READ_1; 
    282          		   
    283          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( caddr&0xFF     );  
    284          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((caddr>>8)&0x0F );  
    285          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( paddr&0xFF     );  
    286          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>8)&0xFF );
    287          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>16)&0xFF);
    288          		    
    289          			*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_READ_TRUE; 
    290          		   
    291          		    
    292          			/* Calculate the size */
    293          			//size = NAND_PAGE_SIZE;// + (NAND_PAGE_SIZE * numpageread);
    294          		    
    295          			for(index=0; index < 0x255; index++);
    296          
    297          			/* Get Data into Buffer */    
    298          			for(index=0; index < size; index++)
    299          			{
    300          			  pBuffer[index]= *(__IO uint8_t *)(NAND_FLASH_START_ADDR | DATA_AREA);
   \                     ??FSMC_NAND_ReadSmallPage_4: (+1)
   \   00000048   0xF04F 0x41E0      MOV      R1,#+1879048192
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x5421             STRB     R1,[R4, R0]
    301          			}
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \                     ??FSMC_NAND_ReadSmallPage_5: (+1)
   \   00000052   0x42A8             CMP      R0,R5
   \   00000054   0xD3F8             BCC.N    ??FSMC_NAND_ReadSmallPage_4
    302          
    303          			numpageread++;
    304          		    
    305          			NumPageToRead--;
   \   00000056   0xF1A9 0x0901      SUB      R9,R9,#+1
    306          
    307          			/* Calculate page address */           			 
    308          			addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       FSMC_NAND_AddressIncrement
   \   00000060   0x4682             MOV      R10,R0
   \                     ??FSMC_NAND_ReadSmallPage_3: (+1)
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0xB280             UXTH     R0,R0
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD01F             BEQ.N    ??FSMC_NAND_ReadSmallPage_6
   \   0000006A   0xF5BA 0x7F80      CMP      R10,#+256
   \   0000006E   0xD11C             BNE.N    ??FSMC_NAND_ReadSmallPage_6
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable52_4  ;; 0x70010000
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x7001             STRB     R1,[R0, #+0]
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable52_5  ;; 0x70020000
   \   0000007C   0x700F             STRB     R7,[R1, #+0]
   \   0000007E   0x123A             ASRS     R2,R7,#+8
   \   00000080   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000084   0x700A             STRB     R2,[R1, #+0]
   \   00000086   0xF881 0x8000      STRB     R8,[R1, #+0]
   \   0000008A   0xEA4F 0x2228      ASR      R2,R8,#+8
   \   0000008E   0x700A             STRB     R2,[R1, #+0]
   \   00000090   0xEA4F 0x4228      ASR      R2,R8,#+16
   \   00000094   0x700A             STRB     R2,[R1, #+0]
   \   00000096   0x2130             MOVS     R1,#+48
   \   00000098   0x7001             STRB     R1,[R0, #+0]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??FSMC_NAND_ReadSmallPage_7
   \                     ??FSMC_NAND_ReadSmallPage_8: (+1)
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \                     ??FSMC_NAND_ReadSmallPage_7: (+1)
   \   000000A0   0xF5B0 0x7F15      CMP      R0,#+596
   \   000000A4   0xD9FB             BLS.N    ??FSMC_NAND_ReadSmallPage_8
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE7D3             B.N      ??FSMC_NAND_ReadSmallPage_5
    309          		}
    310          
    311          		status = FSMC_NAND_GetStatus();
   \                     ??FSMC_NAND_ReadSmallPage_6: (+1)
   \   000000AA   0x.... 0x....      BL       FSMC_NAND_GetStatus
   \   000000AE   0x4604             MOV      R4,R0
    312          		xSemaphoreGive(BSP_NANDSem);
   \   000000B0   0x2300             MOVS     R3,#+0
   \   000000B2   0x461A             MOV      R2,R3
   \   000000B4   0x4611             MOV      R1,R2
   \   000000B6   0x6830             LDR      R0,[R6, #+0]
   \   000000B8   0x.... 0x....      BL       xQueueGenericSend
    313          		return (status | addressstatus);
   \   000000BC   0xEA4A 0x0004      ORR      R0,R10,R4
   \   000000C0   0xE000             B.N      ??FSMC_NAND_ReadSmallPage_1
    314          	}
    315          	return NAND_ERROR;
   \                     ??FSMC_NAND_ReadSmallPage_2: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \                     ??FSMC_NAND_ReadSmallPage_1: (+1)
   \   000000C4   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    316          }
    317          
    318          /******************************************************************************
    319          * Function Name  : FSMC_NAND_WriteSpareArea
    320          * Description    : This routine write the spare area information for the specified 
    321          *                  pages addresses.
    322          * Input          : - pBuffer: pointer on the Buffer containing data to be written 
    323          *                  - Address: First page address
    324          *                  - NumSpareAreaTowrite: Number of Spare Area to write
    325          * Output         : None
    326          * Return         : New status of the NAND operation. This parameter can be:
    327          *                   - NAND_TIMEOUT_ERROR: when the previous operation generate 
    328          *                     a Timeout error
    329          *                   - NAND_READY: when memory is ready for the next operation 
    330          *                  And the new status of the increment address operation. It can be:
    331          *                  - NAND_VALID_ADDRESS: When the new address is valid address
    332          *                  - NAND_INVALID_ADDRESS: When the new address is invalid address
    333          * Attention		 : None
    334          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    335          uint32_t FSMC_NAND_WriteSpareArea(uint8_t *pBuffer, uint32_t Address, uint32_t size)
    336          {
   \                     FSMC_NAND_WriteSpareArea: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
    337          	INT32U index,status = NAND_ERROR;
    338          	INT16U caddr;
    339          	INT16U paddr;
    340          	//INT8U  ret;
    341          	uint32_t add = Address;
    342          
    343          	if(BSP_NANDSem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable52_1
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??FSMC_NAND_WriteSpareArea_0
    344          	{
    345          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`FSMC_NAND_WriteSpareArea::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
    346          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    347          	}
    348          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_WriteSpareArea_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD12E             BNE.N    ??FSMC_NAND_WriteSpareArea_1
    349          	{
    350          
    351          		add = add & (~(NAND_BLOCK_SIZE-1));
    352          		caddr = NAND_PAGE_SIZE;
    353          		paddr = add/NAND_PAGE_SIZE;
   \   00000030   0xF64F 0x70C0      MOVW     R0,#+65472
   \   00000034   0xEA00 0x3117      AND      R1,R0,R7, LSR #+12
    354          		//printk("\nWR add = 0X%08X, caddr = 0X%08X, paddr = 0X%08X \n",add,caddr,paddr);
    355          
    356          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_PAGEPROGRAM;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable52_4  ;; 0x70010000
   \   0000003C   0x2280             MOVS     R2,#+128
   \   0000003E   0x7002             STRB     R2,[R0, #+0]
    357          
    358          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( caddr&0xFF     );  
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable52_5  ;; 0x70020000
   \   00000044   0x2300             MOVS     R3,#+0
   \   00000046   0x7013             STRB     R3,[R2, #+0]
    359          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((caddr>>8)&0x0F );  
   \   00000048   0x7013             STRB     R3,[R2, #+0]
    360          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( paddr&0xFF     );  
   \   0000004A   0x7011             STRB     R1,[R2, #+0]
    361          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>8)&0xFF );
   \   0000004C   0x120B             ASRS     R3,R1,#+8
   \   0000004E   0x7013             STRB     R3,[R2, #+0]
    362          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>16)&0xFF); 
   \   00000050   0x1409             ASRS     R1,R1,#+16
   \   00000052   0x7011             STRB     R1,[R2, #+0]
    363          
    364          		//size = NAND_SPARE_AREA_SIZE;
    365          		/* Write the data */ 
    366          		for(index=0; index < size; index++)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xF04F 0x43E0      MOV      R3,#+1879048192
   \   0000005A   0xE002             B.N      ??FSMC_NAND_WriteSpareArea_2
    367          		{
    368          		  *(__IO uint8_t *)(NAND_FLASH_START_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??FSMC_NAND_WriteSpareArea_3: (+1)
   \   0000005C   0x5C6A             LDRB     R2,[R5, R1]
   \   0000005E   0x701A             STRB     R2,[R3, #+0]
    369          		}
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \                     ??FSMC_NAND_WriteSpareArea_2: (+1)
   \   00000062   0x42B1             CMP      R1,R6
   \   00000064   0xD3FA             BCC.N    ??FSMC_NAND_WriteSpareArea_3
    370          	    
    371          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_PAGEPROGRAM_TRUE;
   \   00000066   0x2110             MOVS     R1,#+16
   \   00000068   0x7001             STRB     R1,[R0, #+0]
    372          		while( GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_6) == 0 );
   \                     ??FSMC_NAND_WriteSpareArea_4: (+1)
   \   0000006A   0x2140             MOVS     R1,#+64
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable52_2  ;; 0x40020c00
   \   00000070   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD0F8             BEQ.N    ??FSMC_NAND_WriteSpareArea_4
    373          
    374          		status = FSMC_NAND_GetStatus();
   \   00000078   0x.... 0x....      BL       FSMC_NAND_GetStatus
   \   0000007C   0x4605             MOV      R5,R0
    375          		xSemaphoreGive(BSP_NANDSem);
   \   0000007E   0x2300             MOVS     R3,#+0
   \   00000080   0x461A             MOV      R2,R3
   \   00000082   0x4611             MOV      R1,R2
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       xQueueGenericSend
    376          		return status;
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}
    377          	}
    378          	return NAND_ERROR;
   \                     ??FSMC_NAND_WriteSpareArea_1: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    379          
    380          }
    381          
    382          /******************************************************************************
    383          * Function Name  : FSMC_NAND_ReadSpareArea
    384          * Description    : This routine read the spare area information from the specified
    385          *                  pages addresses.
    386          * Input          : - pBuffer: pointer on the Buffer to fill  
    387          *                  - Address: First page address
    388          *                  - NumSpareAreaToRead: Number of Spare Area to read
    389          * Output         : None
    390          * Return         : New status of the NAND operation. This parameter can be:
    391          *                   - NAND_TIMEOUT_ERROR: when the previous operation generate 
    392          *                     a Timeout error
    393          *                   - NAND_READY: when memory is ready for the next operation 
    394          *                  And the new status of the increment address operation. It can be:
    395          *                  - NAND_VALID_ADDRESS: When the new address is valid address
    396          *                  - NAND_INVALID_ADDRESS: When the new address is invalid address
    397          * Attention		 : None
    398          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    399          uint32_t FSMC_NAND_ReadSpareArea(uint8_t *pBuffer, uint32_t Address, uint32_t size)
    400          {
   \                     FSMC_NAND_ReadSpareArea: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
    401          	INT32U index,status;
    402          	INT16U caddr;
    403          	INT16U paddr;
    404          	//INT8U  ret;
    405          	uint32_t add = Address;
    406          
    407          	if(BSP_NANDSem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable52_1
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??FSMC_NAND_ReadSpareArea_0
    408          	{
    409          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`FSMC_NAND_ReadSpareArea::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
    410          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    411          	}
    412          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_ReadSpareArea_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD12E             BNE.N    ??FSMC_NAND_ReadSpareArea_1
    413          	{
    414          
    415          		add = add & (~(NAND_BLOCK_SIZE-1));
   \   00000030   0x0CB9             LSRS     R1,R7,#+18
   \   00000032   0x0489             LSLS     R1,R1,#+18
    416          		caddr = NAND_PAGE_SIZE;
    417          		paddr = add/NAND_PAGE_SIZE;
   \   00000034   0x0B0F             LSRS     R7,R1,#+12
   \   00000036   0xB2BF             UXTH     R7,R7
    418          		printk("\nRD add = 0X%08X, caddr = 0X%08X, paddr = 0X%08X \n",add,caddr,paddr);
   \   00000038   0x463B             MOV      R3,R7
   \   0000003A   0xF44F 0x5280      MOV      R2,#+4096
   \   0000003E   0x.... 0x....      ADR.W    R0,?_1
   \   00000042   0x.... 0x....      BL       printk
    419          
    420          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_READ_1;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable52_4  ;; 0x70010000
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x7001             STRB     R1,[R0, #+0]
    421          
    422          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( caddr&0xFF     );  
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable52_5  ;; 0x70020000
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x700A             STRB     R2,[R1, #+0]
    423          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((caddr>>8)&0x0F );  
   \   00000056   0x700A             STRB     R2,[R1, #+0]
    424          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( paddr&0xFF     );  
   \   00000058   0x700F             STRB     R7,[R1, #+0]
    425          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>8)&0xFF );
   \   0000005A   0x123A             ASRS     R2,R7,#+8
   \   0000005C   0x700A             STRB     R2,[R1, #+0]
    426          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ((paddr>>16)&0xFF); 
   \   0000005E   0x143A             ASRS     R2,R7,#+16
   \   00000060   0x700A             STRB     R2,[R1, #+0]
    427          
    428          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_READ_TRUE;
   \   00000062   0x2130             MOVS     R1,#+48
   \   00000064   0x7001             STRB     R1,[R0, #+0]
    429          
    430          		//for(index=0; index < 0x255; index++);
    431          
    432          		/* Data Read */
    433          		//size = NAND_SPARE_AREA_SIZE;
    434          		
    435          		/* Get Data into Buffer */
    436          		for (index=0;index < size; index++)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE004             B.N      ??FSMC_NAND_ReadSpareArea_2
    437          		{
    438          		  pBuffer[index] = *(__IO uint8_t *)(NAND_FLASH_START_ADDR | DATA_AREA);
   \                     ??FSMC_NAND_ReadSpareArea_3: (+1)
   \   0000006A   0xF04F 0x41E0      MOV      R1,#+1879048192
   \   0000006E   0x7809             LDRB     R1,[R1, #+0]
   \   00000070   0x5429             STRB     R1,[R5, R0]
    439          		}
   \   00000072   0x1C40             ADDS     R0,R0,#+1
   \                     ??FSMC_NAND_ReadSpareArea_2: (+1)
   \   00000074   0x42B0             CMP      R0,R6
   \   00000076   0xD3F8             BCC.N    ??FSMC_NAND_ReadSpareArea_3
    440          		
    441          
    442          		status = FSMC_NAND_GetStatus();
   \   00000078   0x.... 0x....      BL       FSMC_NAND_GetStatus
   \   0000007C   0x4605             MOV      R5,R0
    443          		xSemaphoreGive(BSP_NANDSem);
   \   0000007E   0x2300             MOVS     R3,#+0
   \   00000080   0x461A             MOV      R2,R3
   \   00000082   0x4611             MOV      R1,R2
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       xQueueGenericSend
    444          		//printk("  %d[%X]\n",ret,*err);
    445          	  
    446          		return status;
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}
    447          	}
    448          	return NAND_ERROR;
   \                     ??FSMC_NAND_ReadSpareArea_1: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    449          
    450          }
    451          
    452          /******************************************************************************
    453          * Function Name  : FSMC_NAND_EraseBlock
    454          * Description    : This routine erase complete block from NAND FLASH
    455          * Input          : - Address: Any address into block to be erased
    456          * Output         : None
    457          * Return         : New status of the NAND operation. This parameter can be:
    458          *                   - NAND_TIMEOUT_ERROR: when the previous operation generate 
    459          *                     a Timeout error
    460          *                   - NAND_READY: when memory is ready for the next operation 
    461          * Attention		 : None
    462          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    463          uint32_t FSMC_NAND_EraseBlock( uint32_t Address)
    464          {
   \                     FSMC_NAND_EraseBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    465          	INT32U status = NAND_ERROR;
    466          	uint8_t addr1,addr2,addr3;
    467          	printk("\n Erase block = %04X\n",Address);
   \   00000004   0x4629             MOV      R1,R5
   \   00000006   0x.... 0x....      ADR.W    R0,?_2
   \   0000000A   0x.... 0x....      BL       printk
    468          
    469          	if(BSP_NANDSem == NULL)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable52_1
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD107             BNE.N    ??FSMC_NAND_EraseBlock_0
    470          	{
    471          		printk("%s err\n",__func__);
   \   00000018   0x.... 0x....      ADR.W    R1,`FSMC_NAND_EraseBlock::__func__`
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       printk
    472          		return ERROR;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    473          	}
    474          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_EraseBlock_0: (+1)
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x461A             MOV      R2,R3
   \   0000002C   0x4611             MOV      R1,R2
   \   0000002E   0x.... 0x....      BL       xQueueGenericReceive
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD117             BNE.N    ??FSMC_NAND_EraseBlock_1
    475          	{
    476          		addr1 = Address;
    477          		addr2 = Address >> 8;
    478          		addr3 = Address >> 16;
    479          
    480          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_ERASE0;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable52_4  ;; 0x70010000
   \   0000003A   0x2160             MOVS     R1,#+96
   \   0000003C   0x7001             STRB     R1,[R0, #+0]
    481          	  
    482          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = addr1;  
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable52_5  ;; 0x70020000
   \   00000042   0x700D             STRB     R5,[R1, #+0]
    483          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = addr2;
   \   00000044   0x0A2A             LSRS     R2,R5,#+8
   \   00000046   0x700A             STRB     R2,[R1, #+0]
    484          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = addr3;
   \   00000048   0x0C2A             LSRS     R2,R5,#+16
   \   0000004A   0x700A             STRB     R2,[R1, #+0]
    485          			
    486          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_ERASE1; 
   \   0000004C   0x21D0             MOVS     R1,#+208
   \   0000004E   0x7001             STRB     R1,[R0, #+0]
    487          
    488          		status = FSMC_NAND_GetStatus();
   \   00000050   0x.... 0x....      BL       FSMC_NAND_GetStatus
   \   00000054   0x4605             MOV      R5,R0
    489          		xSemaphoreGive(BSP_NANDSem);
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x461A             MOV      R2,R3
   \   0000005A   0x4611             MOV      R1,R2
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       xQueueGenericSend
    490          		return status;
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}
    491          	}
    492          	return NAND_ERROR;
   \                     ??FSMC_NAND_EraseBlock_1: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    493          }
    494          
    495          /******************************************************************************
    496          * Function Name  : FSMC_NAND_Reset
    497          * Description    : This routine reset the NAND FLASH
    498          * Input          : None
    499          * Output         : None
    500          * Return         : NAND_READY
    501          * Attention		 : None
    502          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    503          uint32_t FSMC_NAND_Reset(void)
    504          {
   \                     FSMC_NAND_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    505          	if(BSP_NANDSem == NULL)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable52_1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD107             BNE.N    ??FSMC_NAND_Reset_0
    506          	{
    507          		printk("%s err\n",__func__);
   \   0000000C   0x.... 0x....      ADR.W    R1,`FSMC_NAND_Reset::__func__`
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       printk
    508          		return ERROR;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}
    509          	}
    510          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_Reset_0: (+1)
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0x.... 0x....      BL       xQueueGenericReceive
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD10B             BNE.N    ??FSMC_NAND_Reset_1
    511          	{
    512          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_RESET;
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable52_4  ;; 0x70010000
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    513          		xSemaphoreGive(BSP_NANDSem);
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x461A             MOV      R2,R3
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       xQueueGenericSend
    514          		return (NAND_READY);
   \   0000003E   0x2040             MOVS     R0,#+64
   \   00000040   0xBD10             POP      {R4,PC}
    515          	}
    516          	return NAND_ERROR;
   \                     ??FSMC_NAND_Reset_1: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    517          }
    518          
    519          /******************************************************************************
    520          * Function Name  : FSMC_NAND_GetStatus
    521          * Description    : Get the NAND operation status
    522          * Input          : None
    523          * Output         : None
    524          * Return         : New status of the NAND operation. This parameter can be:
    525          *                   - NAND_TIMEOUT_ERROR: when the previous operation generate 
    526          *                     a Timeout error
    527          *                   - NAND_READY: when memory is ready for the next operation  
    528          * Attention		 : None  
    529          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    530          uint32_t FSMC_NAND_GetStatus(void)
    531          {
   \                     FSMC_NAND_GetStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    532            uint32_t timeout = PROGRAM_TIMEOUT, status = NAND_READY;
   \   00000002   0xF44F 0x0470      MOV      R4,#+15728640
    533          
    534            status = FSMC_NAND_ReadStatus(); 
   \   00000006   0x.... 0x....      BL       FSMC_NAND_ReadStatus
   \   0000000A   0xE002             B.N      ??FSMC_NAND_GetStatus_0
    535          
    536            /* Wait for a NAND operation to complete or a TIMEOUT to occur */
    537            while ((status != NAND_READY) &&( timeout != 0x00))
    538            {
    539               status = FSMC_NAND_ReadStatus();
   \                     ??FSMC_NAND_GetStatus_1: (+1)
   \   0000000C   0x.... 0x....      BL       FSMC_NAND_ReadStatus
    540               timeout --;      
   \   00000010   0x1E64             SUBS     R4,R4,#+1
    541            }
   \                     ??FSMC_NAND_GetStatus_0: (+1)
   \   00000012   0x2840             CMP      R0,#+64
   \   00000014   0xD001             BEQ.N    ??FSMC_NAND_GetStatus_2
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD1F8             BNE.N    ??FSMC_NAND_GetStatus_1
    542          
    543            if(timeout == 0x00)
   \                     ??FSMC_NAND_GetStatus_2: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD101             BNE.N    ??FSMC_NAND_GetStatus_3
    544            {          
    545              status =  NAND_TIMEOUT_ERROR;      
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
    546            } 
    547          
    548            /* Return the operation status */
    549            return (status);      
   \                     ??FSMC_NAND_GetStatus_3: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    550          }
    551          /******************************************************************************
    552          * Function Name  : FSMC_NAND_ReadStatus
    553          * Description    : Reads the NAND memory status using the Read status command 
    554          * Input          : None
    555          * Output         : None
    556          * Return         : The status of the NAND memory. This parameter can be:
    557          *                   - NAND_BUSY: when memory is busy
    558          *                   - NAND_READY: when memory is ready for the next operation    
    559          *                   - NAND_ERROR: when the previous operation gererates error  
    560          * Attention		 : None 
    561          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    562          uint32_t FSMC_NAND_ReadStatus(void)
    563          {
    564            uint32_t data = 0x00, status = NAND_BUSY;
   \                     FSMC_NAND_ReadStatus: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    565          
    566            /* Read status operation ------------------------------------ */
    567            *(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_STATUS; 
   \   00000002   0x2170             MOVS     R1,#+112
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable52_4  ;; 0x70010000
   \   00000008   0x7011             STRB     R1,[R2, #+0]
    568            data = *(__IO uint8_t *)(NAND_FLASH_START_ADDR); 
   \   0000000A   0xF04F 0x41E0      MOV      R1,#+1879048192
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
    569          
    570            if((data & NAND_ERROR) == NAND_ERROR)
   \   00000010   0x07CA             LSLS     R2,R1,#+31
   \   00000012   0xD501             BPL.N    ??FSMC_NAND_ReadStatus_0
    571            {
    572              status = NAND_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR
    573            } 
    574            else if((data & NAND_READY) == NAND_READY)
   \                     ??FSMC_NAND_ReadStatus_0: (+1)
   \   00000018   0x0649             LSLS     R1,R1,#+25
   \   0000001A   0xD500             BPL.N    ??FSMC_NAND_ReadStatus_1
    575            {
    576              status = NAND_READY;
   \   0000001C   0x2040             MOVS     R0,#+64
    577            }
    578            else
    579            {
    580              status = NAND_BUSY; 
    581            }
    582            
    583            return (status);
   \                     ??FSMC_NAND_ReadStatus_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    584          }
    585          
    586          /******************************************************************************
    587          * Function Name  : NAND_AddressIncrement
    588          * Description    : Increment the NAND memory address
    589          * Input          : - Address: address to be incremented.
    590          * Output         : None
    591          * Return         : The new status of the increment address operation. It can be:
    592          *                  - NAND_VALID_ADDRESS: When the new address is valid address
    593          *                  - NAND_INVALID_ADDRESS: When the new address is invalid address
    594          * Attention		 : None
    595          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    596          uint32_t FSMC_NAND_AddressIncrement(uint32_t* Address)
    597          {
    598            uint32_t status = NAND_VALID_ADDRESS;
    599          #if 0
    600          
    601          #endif
    602            
    603            return (status);
   \                     FSMC_NAND_AddressIncrement: (+1)
   \   00000000   0xF44F 0x7080      MOV      R0,#+256
   \   00000004   0x4770             BX       LR               ;; return
    604          }
    605          #if 0
    606          u32 FSMC_NAND_AddressIncrement(NAND_ADDRESS* Address) 
    607          { 
    608            u32 status = NAND_VALID_ADDRESS; 
    609            
    610            Address->Page++; 
    611          
    612           
    613            if(Address->Page == NAND_BLOCK_SIZE) 
    614            { 
    615              Address->Page = 0; 
    616              Address->Block++; 
    617               
    618              if(Address->Block == NAND_ZONE_SIZE) 
    619              { 
    620                Address->Block = 0; 
    621                Address->Zone++; 
    622          
    623           
    624                if(Address->Zone == NAND_MAX_ZONE) 
    625                { 
    626                  status = NAND_INVALID_ADDRESS; 
    627                } 
    628              } 
    629            }  
    630             
    631            return (status); 
    632          } 
    633          
    634          #endif

   \                                 In section .text, align 2, keep-with-next
    635          INT8U FSMC_NAND_Badblock(INT32U addr,INT32U *err)
    636          {
   \                     FSMC_NAND_Badblock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
    637          	//INT32U index;
    638          	INT16U caddr;
    639          	INT16U paddr;
    640          	INT8U  ret=0;
    641          
    642          	if(BSP_NANDSem == NULL)
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable52_1
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD107             BNE.N    ??FSMC_NAND_Badblock_0
    643          	{
    644          		printk("%s err\n",__func__);
   \   00000010   0x.... 0x....      ADR.W    R1,`FSMC_NAND_Badblock::__func__`
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       printk
    645          		return ERROR;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    646          	}
    647          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_Badblock_0: (+1)
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x461A             MOV      R2,R3
   \   00000024   0x4611             MOV      R1,R2
   \   00000026   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD123             BNE.N    ??FSMC_NAND_Badblock_1
    648          	{
    649          
    650          		addr = addr & (~(NAND_BLOCK_SIZE-1));
    651          		caddr = NAND_PAGE_SIZE;
    652          		paddr = addr/NAND_PAGE_SIZE;
   \   0000002E   0xF64F 0x70C0      MOVW     R0,#+65472
   \   00000032   0xEA00 0x3016      AND      R0,R0,R6, LSR #+12
    653          		//printk("add = 0X%08X, caddr = 0X%08X, paddr = 0X%08X ",addr,caddr,paddr);
    654          
    655          		 *(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_READ_1;
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable52_4  ;; 0x70010000
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x700A             STRB     R2,[R1, #+0]
    656          
    657          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( caddr&0xFF      );  
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable52_5  ;; 0x70020000
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0x7013             STRB     R3,[R2, #+0]
    658          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( (caddr>>8)&0x0F ); 
   \   00000046   0x7013             STRB     R3,[R2, #+0]
    659          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( paddr&0xFF      );  
   \   00000048   0x7010             STRB     R0,[R2, #+0]
    660          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( (paddr>>8)&0xFF );
   \   0000004A   0x1203             ASRS     R3,R0,#+8
   \   0000004C   0x7013             STRB     R3,[R2, #+0]
    661          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = (uint8_t) ( (paddr>>16)&0x03);  
   \   0000004E   0x1400             ASRS     R0,R0,#+16
   \   00000050   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000054   0x7010             STRB     R0,[R2, #+0]
    662          
    663          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = NAND_CMD_READ_TRUE;
   \   00000056   0x2030             MOVS     R0,#+48
   \   00000058   0x7008             STRB     R0,[R1, #+0]
    664          
    665          		//for(index=0; index < 0x255; index++);
    666          
    667          		/* Get Data into Buffer */    
    668          		ret= *(__IO uint8_t *)(NAND_FLASH_START_ADDR | DATA_AREA);
   \   0000005A   0xF04F 0x40E0      MOV      R0,#+1879048192
   \   0000005E   0x7806             LDRB     R6,[R0, #+0]
    669          		
    670          
    671          		*err = FSMC_NAND_GetStatus();
   \   00000060   0x.... 0x....      BL       FSMC_NAND_GetStatus
   \   00000064   0x6020             STR      R0,[R4, #+0]
    672          		//printk("  %d[%X]\n",ret,*err);
    673          		xSemaphoreGive(BSP_NANDSem);
   \   00000066   0x2300             MOVS     R3,#+0
   \   00000068   0x461A             MOV      R2,R3
   \   0000006A   0x4611             MOV      R1,R2
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       xQueueGenericSend
    674          		return ret;
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0xBD70             POP      {R4-R6,PC}
    675          	}
    676          	return ret;
   \                     ??FSMC_NAND_Badblock_1: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    677          
    678          }
    679          

   \                                 In section .text, align 2, keep-with-next
    680          INT8U FSMC_NAND_ReadData(INT8U cmd, INT8U add, INT8U *targer,INT8U size)
    681          {
   \                     FSMC_NAND_ReadData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
    682          	//uint32_t data = 0;
    683          	uint32_t i=0;
   \   0000000C   0x2600             MOVS     R6,#+0
    684          	//uint8_t pBuffer[20];
    685          	if(BSP_NANDSem == NULL)
   \   0000000E   0x.... 0x....      LDR.W    R7,??DataTable52_1
   \   00000012   0x6838             LDR      R0,[R7, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD107             BNE.N    ??FSMC_NAND_ReadData_0
    686          	{
    687          		printk("%s err\n",__func__);
   \   00000018   0x.... 0x....      ADR.W    R1,`FSMC_NAND_ReadData::__func__`
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       printk
    688          		return ERROR;
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0xE01D             B.N      ??FSMC_NAND_ReadData_1
    689          	}
    690          	if(xSemaphoreTake(BSP_NANDSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??FSMC_NAND_ReadData_0: (+1)
   \   00000028   0x4633             MOV      R3,R6
   \   0000002A   0x461A             MOV      R2,R3
   \   0000002C   0x4611             MOV      R1,R2
   \   0000002E   0x.... 0x....      BL       xQueueGenericReceive
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD115             BNE.N    ??FSMC_NAND_ReadData_2
    691          	{
    692          
    693          		/* Send Command to the command area */ 	
    694          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | CMD_AREA) = cmd;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable52_4  ;; 0x70010000
   \   0000003A   0xF880 0x8000      STRB     R8,[R0, #+0]
    695          		*(__IO uint8_t *)(NAND_FLASH_START_ADDR | ADDR_AREA) = add;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable52_5  ;; 0x70020000
   \   00000042   0xF880 0x9000      STRB     R9,[R0, #+0]
    696          
    697          		for(i=0;i<size;i++)
   \   00000046   0xE004             B.N      ??FSMC_NAND_ReadData_3
    698          		{
    699          			targer[i]= *(__IO uint8_t *)(NAND_FLASH_START_ADDR | DATA_AREA);
   \                     ??FSMC_NAND_ReadData_4: (+1)
   \   00000048   0xF04F 0x40E0      MOV      R0,#+1879048192
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x55A0             STRB     R0,[R4, R6]
    700          		}
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \                     ??FSMC_NAND_ReadData_3: (+1)
   \   00000052   0x42AE             CMP      R6,R5
   \   00000054   0xD3F8             BCC.N    ??FSMC_NAND_ReadData_4
    701          		xSemaphoreGive(BSP_NANDSem);
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x461A             MOV      R2,R3
   \   0000005A   0x4611             MOV      R1,R2
   \   0000005C   0x6838             LDR      R0,[R7, #+0]
   \   0000005E   0x.... 0x....      BL       xQueueGenericSend
    702          	}
    703          	return ERROR;
   \                     ??FSMC_NAND_ReadData_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??FSMC_NAND_ReadData_1: (+1)
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          void Nand_Make_Badblock_Table(void)
    707          {
   \                     Nand_Make_Badblock_Table: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB09C             SUB      SP,SP,#+112
    708          	INT16U i;    
    709              INT32U addr,err;
    710          	INT32U baseAddr=NAND_BADBLOCK_BASE;
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable52_6  ;; 0x1ffc0000
   \   00000008   0x4634             MOV      R4,R6
    711              INT8U status = 0;
    712          	st_BadBlockData badblock;
    713          	INT8U checksum;         
    714          
    715             for(i = 0; i < 10; i++)
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE001             B.N      ??Nand_Make_Badblock_Table_0
   \                     ??Nand_Make_Badblock_Table_1: (+1)
   \   0000000E   0x1C6D             ADDS     R5,R5,#+1
   \   00000010   0xB2AD             UXTH     R5,R5
   \                     ??Nand_Make_Badblock_Table_0: (+1)
   \   00000012   0x2D0A             CMP      R5,#+10
   \   00000014   0xDA09             BGE.N    ??Nand_Make_Badblock_Table_2
    716             {
    717          	   addr = NAND_BADBLOCK_BASE-i*NAND_BLOCK_SIZE+NAND_PAGE_SIZE;
    718          		//status = Nand_Read_bb(addr);
    719          		status = FSMC_NAND_Badblock(addr, &err);
    720          		if(status != 0)
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable52_7  ;; 0x1ffc1000
   \   0000001A   0xEBB0 0x4085      SUBS     R0,R0,R5, LSL #+18
   \   0000001E   0x.... 0x....      BL       FSMC_NAND_Badblock
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F3             BEQ.N    ??Nand_Make_Badblock_Table_1
    721          		{
    722          			baseAddr = NAND_BADBLOCK_BASE-i*NAND_BLOCK_SIZE;
   \   00000026   0xEBB6 0x4485      SUBS     R4,R6,R5, LSL #+18
    723          			break;
    724          		}
    725          	}
    726          	if(i == 10) return;
   \                     ??Nand_Make_Badblock_Table_2: (+1)
   \   0000002A   0x2D0A             CMP      R5,#+10
   \   0000002C   0xD06A             BEQ.N    ??Nand_Make_Badblock_Table_3
    727          	Nand_Read_Buffer((u8*)&badblock, baseAddr, sizeof(st_BadBlockData));
   \   0000002E   0x2266             MOVS     R2,#+102
   \   00000030   0x4621             MOV      R1,R4
   \   00000032   0xA801             ADD      R0,SP,#+4
   \   00000034   0x.... 0x....      BL       Nand_Read_Buffer
    728          	if(badblock.BadBlockCount < 50)
   \   00000038   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000003C   0x2932             CMP      R1,#+50
   \   0000003E   0xDA1A             BGE.N    ??Nand_Make_Badblock_Table_4
    729          	{
    730          		checksum = badblock.BadBlockCount;
   \   00000040   0x460A             MOV      R2,R1
    731          		for(i = 0; i < badblock.BadBlockCount; i++)
   \   00000042   0x2500             MOVS     R5,#+0
   \   00000044   0xE00A             B.N      ??Nand_Make_Badblock_Table_5
   \                     ??Nand_Make_Badblock_Table_6: (+1)
   \   00000046   0xA801             ADD      R0,SP,#+4
   \   00000048   0xEB00 0x0045      ADD      R0,R0,R5, LSL #+1
   \   0000004C   0xF8B0 0x3001      LDRH     R3,[R0, #+1]
   \   00000050   0x4618             MOV      R0,R3
   \   00000052   0xEB13 0x2010      ADDS     R0,R3,R0, LSR #+8
   \   00000056   0x1882             ADDS     R2,R0,R2
    732          		{
    733          			checksum += badblock.BadBlockAddr[i]&0xff;
    734          			checksum += (badblock.BadBlockAddr[i]>>8)&0xff;
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \   0000005A   0xB2AD             UXTH     R5,R5
   \                     ??Nand_Make_Badblock_Table_5: (+1)
   \   0000005C   0x428D             CMP      R5,R1
   \   0000005E   0xDBF2             BLT.N    ??Nand_Make_Badblock_Table_6
    735          		}
    736          		if(checksum == badblock.BadBlockCheckSum)
   \   00000060   0xF89D 0x0069      LDRB     R0,[SP, #+105]
   \   00000064   0xB2D2             UXTB     R2,R2
   \   00000066   0x4282             CMP      R2,R0
   \   00000068   0xD105             BNE.N    ??Nand_Make_Badblock_Table_4
    737          		{ 
    738          			BadBlockData = badblock;
   \   0000006A   0x....             LDR.N    R0,??DataTable52_8
   \   0000006C   0xA901             ADD      R1,SP,#+4
   \   0000006E   0x2268             MOVS     R2,#+104
   \   00000070   0x.... 0x....      BL       __aeabi_memcpy4
    739          			return;
   \   00000074   0xE046             B.N      ??Nand_Make_Badblock_Table_3
    740          		}
    741          	}
    742            
    743          	memset((u8*)&badblock,0,sizeof(st_BadBlockData));
   \                     ??Nand_Make_Badblock_Table_4: (+1)
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2166             MOVS     R1,#+102
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x.... 0x....      BL       __aeabi_memset4
    744          	for(i = 0; i < NAND_BLOCK_NUM; i++)
   \   00000080   0x2500             MOVS     R5,#+0
   \   00000082   0xE016             B.N      ??Nand_Make_Badblock_Table_7
    745          	{
    746          		addr = i*NAND_BLOCK_SIZE+NAND_PAGE_SIZE;
    747          		status = FSMC_NAND_Badblock(addr, &err);
    748          		if(status == 0)
   \                     ??Nand_Make_Badblock_Table_8: (+1)
   \   00000084   0x4669             MOV      R1,SP
   \   00000086   0x04A8             LSLS     R0,R5,#+18
   \   00000088   0xF500 0x5080      ADD      R0,R0,#+4096
   \   0000008C   0x.... 0x....      BL       FSMC_NAND_Badblock
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD10D             BNE.N    ??Nand_Make_Badblock_Table_9
    749          		{
    750          			if(badblock.BadBlockCount < 40)
   \   00000094   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000098   0x2828             CMP      R0,#+40
   \   0000009A   0xDA09             BGE.N    ??Nand_Make_Badblock_Table_9
    751          				badblock.BadBlockAddr[badblock.BadBlockCount++] = i;   
   \   0000009C   0xA901             ADD      R1,SP,#+4
   \   0000009E   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   000000A2   0xF8A0 0x5001      STRH     R5,[R0, #+1]
   \   000000A6   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    752          		}
    753          	}
   \                     ??Nand_Make_Badblock_Table_9: (+1)
   \   000000B0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Nand_Make_Badblock_Table_7: (+1)
   \   000000B2   0xF5B5 0x6F00      CMP      R5,#+2048
   \   000000B6   0xDBE5             BLT.N    ??Nand_Make_Badblock_Table_8
    754          	badblock.BadBlockCheckSum = badblock.BadBlockCount;
   \   000000B8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000BC   0xF88D 0x0069      STRB     R0,[SP, #+105]
    755          	for(i = 0; i < badblock.BadBlockCount; i++)
   \   000000C0   0x2500             MOVS     R5,#+0
   \   000000C2   0xE011             B.N      ??Nand_Make_Badblock_Table_10
    756          	{
    757          		badblock.BadBlockCheckSum += badblock.BadBlockAddr[i]&0xff;
   \                     ??Nand_Make_Badblock_Table_11: (+1)
   \   000000C4   0xA801             ADD      R0,SP,#+4
   \   000000C6   0xEB00 0x0045      ADD      R0,R0,R5, LSL #+1
   \   000000CA   0xF89D 0x1069      LDRB     R1,[SP, #+105]
   \   000000CE   0xF8B0 0x2001      LDRH     R2,[R0, #+1]
   \   000000D2   0x1851             ADDS     R1,R2,R1
   \   000000D4   0xF88D 0x1069      STRB     R1,[SP, #+105]
    758          		badblock.BadBlockCheckSum += (badblock.BadBlockAddr[i]>>8)&0xff;
   \   000000D8   0xF8B0 0x0001      LDRH     R0,[R0, #+1]
   \   000000DC   0xEB11 0x2010      ADDS     R0,R1,R0, LSR #+8
   \   000000E0   0xF88D 0x0069      STRB     R0,[SP, #+105]
    759          	}
   \   000000E4   0x1C6D             ADDS     R5,R5,#+1
   \   000000E6   0xB2AD             UXTH     R5,R5
   \                     ??Nand_Make_Badblock_Table_10: (+1)
   \   000000E8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000EC   0x4285             CMP      R5,R0
   \   000000EE   0xDBE9             BLT.N    ??Nand_Make_Badblock_Table_11
    760          	Nand_Write_Buffer((INT8U*)&badblock, baseAddr, sizeof(st_BadBlockData));
   \   000000F0   0x2266             MOVS     R2,#+102
   \   000000F2   0x4621             MOV      R1,R4
   \   000000F4   0xA801             ADD      R0,SP,#+4
   \   000000F6   0x.... 0x....      BL       Nand_Write_Buffer
    761          	BadBlockData = badblock;
   \   000000FA   0x....             LDR.N    R0,??DataTable52_8
   \   000000FC   0xA901             ADD      R1,SP,#+4
   \   000000FE   0x2268             MOVS     R2,#+104
   \   00000100   0x.... 0x....      BL       __aeabi_memcpy4
    762          }
   \                     ??Nand_Make_Badblock_Table_3: (+1)
   \   00000104   0xB01C             ADD      SP,SP,#+112
   \   00000106   0xBD70             POP      {R4-R6,PC}       ;; return
    763          
    764          

   \                                 In section .text, align 2, keep-with-next
    765          void Nand_Read_BadblockData(void)
    766          {
   \                     Nand_Read_BadblockData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB09C             SUB      SP,SP,#+112
    767          	INT16U i;
    768          	st_BadBlockData badblock;
    769          	INT8U checksum;
    770          	INT32U baseAddr=NAND_BADBLOCK_BASE,err;  
   \   00000004   0x....             LDR.N    R5,??DataTable52_6  ;; 0x1ffc0000
   \   00000006   0x462E             MOV      R6,R5
    771          	INT8U status;
    772          	INT32U addr;
    773          
    774          	for(i = 0; i < 10; i++) 
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0xE001             B.N      ??Nand_Read_BadblockData_0
   \                     ??Nand_Read_BadblockData_1: (+1)
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \   0000000E   0xB2A4             UXTH     R4,R4
   \                     ??Nand_Read_BadblockData_0: (+1)
   \   00000010   0x2C0A             CMP      R4,#+10
   \   00000012   0xDA09             BGE.N    ??Nand_Read_BadblockData_2
    775          	{
    776          		addr = NAND_BADBLOCK_BASE-i*NAND_BLOCK_SIZE+NAND_PAGE_SIZE;
    777          		status = FSMC_NAND_Badblock(addr, &err);
    778          		if(status != 0) 
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x....             LDR.N    R0,??DataTable52_7  ;; 0x1ffc1000
   \   00000018   0xEBB0 0x4084      SUBS     R0,R0,R4, LSL #+18
   \   0000001C   0x.... 0x....      BL       FSMC_NAND_Badblock
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0F3             BEQ.N    ??Nand_Read_BadblockData_1
    779          		{
    780          			baseAddr = NAND_BADBLOCK_BASE-i*NAND_BLOCK_SIZE;
   \   00000024   0xEBB5 0x4684      SUBS     R6,R5,R4, LSL #+18
    781          			break;
    782          		}
    783          	}	
    784          
    785          	if(i == 10) {
   \                     ??Nand_Read_BadblockData_2: (+1)
   \   00000028   0x2C0A             CMP      R4,#+10
   \   0000002A   0xD104             BNE.N    ??Nand_Read_BadblockData_3
    786          		printd("\n===Bad block table not found===\n");
   \   0000002C   0x.... 0x....      ADR.W    R0,?_3
   \   00000030   0x.... 0x....      BL       printd
    787          		return;
   \   00000034   0xE04E             B.N      ??Nand_Read_BadblockData_4
    788          	}
    789          	
    790          	Nand_Read_Buffer((u8*)&badblock, baseAddr, sizeof(st_BadBlockData));
   \                     ??Nand_Read_BadblockData_3: (+1)
   \   00000036   0x2266             MOVS     R2,#+102
   \   00000038   0x4631             MOV      R1,R6
   \   0000003A   0xA801             ADD      R0,SP,#+4
   \   0000003C   0x.... 0x....      BL       Nand_Read_Buffer
    791          	if(badblock.BadBlockCount < 50) 
   \   00000040   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   00000044   0x2A32             CMP      R2,#+50
   \   00000046   0xDA41             BGE.N    ??Nand_Read_BadblockData_5
    792          	{
    793          		checksum = badblock.BadBlockCount;
   \   00000048   0x4611             MOV      R1,R2
    794          		for(i = 0; i < badblock.BadBlockCount; i++) 
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0xE00A             B.N      ??Nand_Read_BadblockData_6
   \                     ??Nand_Read_BadblockData_7: (+1)
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0xEB00 0x0044      ADD      R0,R0,R4, LSL #+1
   \   00000054   0xF8B0 0x3001      LDRH     R3,[R0, #+1]
   \   00000058   0x4618             MOV      R0,R3
   \   0000005A   0xEB13 0x2010      ADDS     R0,R3,R0, LSR #+8
   \   0000005E   0x1841             ADDS     R1,R0,R1
    795          		{
    796          			checksum += badblock.BadBlockAddr[i]&0xff;
    797          			checksum += (badblock.BadBlockAddr[i]>>8)&0xff;
   \   00000060   0x1C64             ADDS     R4,R4,#+1
   \   00000062   0xB2A4             UXTH     R4,R4
   \                     ??Nand_Read_BadblockData_6: (+1)
   \   00000064   0x4294             CMP      R4,R2
   \   00000066   0xDBF2             BLT.N    ??Nand_Read_BadblockData_7
    798          		}
    799          		if(checksum == badblock.BadBlockCheckSum)
   \   00000068   0xF89D 0x2069      LDRB     R2,[SP, #+105]
   \   0000006C   0x4608             MOV      R0,R1
   \   0000006E   0x4613             MOV      R3,R2
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0x4298             CMP      R0,R3
   \   00000074   0xD124             BNE.N    ??Nand_Read_BadblockData_8
    800          		{ 
    801          			BadBlockData = badblock;
   \   00000076   0x....             LDR.N    R5,??DataTable52_8
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0xA901             ADD      R1,SP,#+4
   \   0000007C   0x2268             MOVS     R2,#+104
   \   0000007E   0x.... 0x....      BL       __aeabi_memcpy4
    802          
    803          			printd("\n\n===Bad block table found===\n");
   \   00000082   0x.... 0x....      ADR.W    R0,?_4
   \   00000086   0x.... 0x....      BL       printd
    804          			printd("Cnt:%d\n",BadBlockData.BadBlockCount);
   \   0000008A   0x7829             LDRB     R1,[R5, #+0]
   \   0000008C   0x.... 0x....      ADR.W    R0,?_5
   \   00000090   0x.... 0x....      BL       printd
    805          			for(i=0;i<BadBlockData.BadBlockCount;i++)	
   \   00000094   0x2400             MOVS     R4,#+0
   \   00000096   0xE009             B.N      ??Nand_Read_BadblockData_9
    806          			{
    807          				printd("BadBlockindex : %d\n",BadBlockData.BadBlockAddr[i]);
   \                     ??Nand_Read_BadblockData_10: (+1)
   \   00000098   0xEB05 0x0044      ADD      R0,R5,R4, LSL #+1
   \   0000009C   0xF8B0 0x1001      LDRH     R1,[R0, #+1]
   \   000000A0   0x.... 0x....      ADR.W    R0,?_6
   \   000000A4   0x.... 0x....      BL       printd
    808          			}
   \   000000A8   0x1C64             ADDS     R4,R4,#+1
   \   000000AA   0xB2A4             UXTH     R4,R4
   \                     ??Nand_Read_BadblockData_9: (+1)
   \   000000AC   0x7828             LDRB     R0,[R5, #+0]
   \   000000AE   0x4284             CMP      R4,R0
   \   000000B0   0xDBF2             BLT.N    ??Nand_Read_BadblockData_10
    809          			printd("ChkSUM:0x%02X\n",BadBlockData.BadBlockCheckSum);
   \   000000B2   0xF895 0x1065      LDRB     R1,[R5, #+101]
   \   000000B6   0x.... 0x....      ADR.W    R0,?_7
   \   000000BA   0x.... 0x....      BL       printd
   \   000000BE   0xE009             B.N      ??Nand_Read_BadblockData_4
    810          			
    811          		}
    812          		else
    813          		{
    814          			printd("===Checksum error. %02X:%02X ===\n",checksum,badblock.BadBlockCheckSum);
   \                     ??Nand_Read_BadblockData_8: (+1)
   \   000000C0   0xB2C9             UXTB     R1,R1
   \   000000C2   0x.... 0x....      ADR.W    R0,?_8
   \   000000C6   0x.... 0x....      BL       printd
   \   000000CA   0xE003             B.N      ??Nand_Read_BadblockData_4
    815          		}
    816          	}
    817          	else
    818          	{
    819          		printd("===Bad block not found===\n");
   \                     ??Nand_Read_BadblockData_5: (+1)
   \   000000CC   0x.... 0x....      ADR.W    R0,?_9
   \   000000D0   0x.... 0x....      BL       printd
    820          	}
    821          }
   \                     ??Nand_Read_BadblockData_4: (+1)
   \   000000D4   0xB01C             ADD      SP,SP,#+112
   \   000000D6   0xBD70             POP      {R4-R6,PC}       ;; return
    822          

   \                                 In section .text, align 2, keep-with-next
    823          INT32U Nand_Check_Badblock(INT32U addr)
    824          {
    825          	INT16U i, block_index = 0;
    826          	INT32U new_addr;
    827            
    828          	if(BadBlockData.BadBlockCount > 0 &&BadBlockData.BadBlockCount < 50) 
   \                     Nand_Check_Badblock: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable52_8
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x0013             MOVS     R3,R2
   \   00000006   0xD100             BNE.N    ??Nand_Check_Badblock_0
   \   00000008   0x4770             BX       LR
   \                     ??Nand_Check_Badblock_0: (+1)
   \   0000000A   0xB470             PUSH     {R4-R6}
   \   0000000C   0x2A32             CMP      R2,#+50
   \   0000000E   0xDA14             BGE.N    ??Nand_Check_Badblock_1
    829          	{
    830          		block_index = addr/NAND_BLOCK_SIZE;
   \   00000010   0x0C83             LSRS     R3,R0,#+18
    831          		for(i = 0; i < BadBlockData.BadBlockCount; i++)
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0xE00F             B.N      ??Nand_Check_Badblock_2
    832          		{
    833          			if(BadBlockData.BadBlockAddr[i] == block_index) 
   \                     ??Nand_Check_Badblock_3: (+1)
   \   00000016   0xEB01 0x0544      ADD      R5,R1,R4, LSL #+1
   \   0000001A   0xF8B5 0x5001      LDRH     R5,[R5, #+1]
   \   0000001E   0x461E             MOV      R6,R3
   \   00000020   0x42B5             CMP      R5,R6
   \   00000022   0xD106             BNE.N    ??Nand_Check_Badblock_4
    834          			{
    835          				new_addr = NAND_BADBLOCK_DATA_ADDR + i*NAND_BLOCK_SIZE+(addr%NAND_BLOCK_SIZE);
    836          				addr = new_addr; 
   \   00000024   0xF3C0 0x0011      UBFX     R0,R0,#+0,#+18
   \   00000028   0xEB00 0x4084      ADD      R0,R0,R4, LSL #+18
   \   0000002C   0x....             LDR.N    R3,??DataTable52_9  ;; 0x1f300000
   \   0000002E   0x1818             ADDS     R0,R3,R0
    837          				block_index = addr/NAND_BLOCK_SIZE;
   \   00000030   0x0C83             LSRS     R3,R0,#+18
    838          			}	
    839          		}
   \                     ??Nand_Check_Badblock_4: (+1)
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \   00000034   0xB2A4             UXTH     R4,R4
   \                     ??Nand_Check_Badblock_2: (+1)
   \   00000036   0x4294             CMP      R4,R2
   \   00000038   0xDBED             BLT.N    ??Nand_Check_Badblock_3
    840          	}
    841          	return addr;
   \                     ??Nand_Check_Badblock_1: (+1)
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
    842          }
    843          
    844          

   \                                 In section .text, align 2, keep-with-next
    845          INT32U Nand_Write_Buffer(INT8U *pBuffer, INT32U addr, INT16U len)
    846          {
   \                     Nand_Write_Buffer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    847            //u16 count;
    848            //u16 caddr;
    849            INT32U status = NAND_READY, eaddr;
    850             
    851            if(len == 0) {
   \   00000008   0xD101             BNE.N    ??Nand_Write_Buffer_0
    852              return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBDF2             POP      {R1,R4-R7,PC}
    853            }
    854            addr = Nand_Check_Badblock(addr);
   \                     ??Nand_Write_Buffer_0: (+1)
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       Nand_Check_Badblock
   \   00000014   0x4605             MOV      R5,R0
    855            //caddr = addr%NAND_PAGE_SIZE;
    856           // paddr = addr/NAND_PAGE_SIZE;
    857            eaddr = addr+len;
   \   00000016   0x1971             ADDS     R1,R6,R5
    858           
    859            if(addr%NAND_BLOCK_SIZE == 0) {//0x40000 = one block size
   \   00000018   0x03A8             LSLS     R0,R5,#+14
   \   0000001A   0xD10C             BNE.N    ??Nand_Write_Buffer_1
    860          	  printk("\n 00 Erase block addr = %04X, NAND_PAGE_SIZE = %04X, erase addr = [%04X]\n",addr,NAND_PAGE_SIZE, addr/NAND_PAGE_SIZE);
   \   0000001C   0x0B2F             LSRS     R7,R5,#+12
   \   0000001E   0x463B             MOV      R3,R7
   \   00000020   0xF44F 0x5280      MOV      R2,#+4096
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x.... 0x....      ADR.W    R0,?_10
   \   0000002A   0x.... 0x....      BL       printk
    861          	  status = FSMC_NAND_EraseBlock(addr/NAND_PAGE_SIZE); 
   \   0000002E   0x4638             MOV      R0,R7
   \   00000030   0x.... 0x....      BL       FSMC_NAND_EraseBlock
   \   00000034   0xE010             B.N      ??Nand_Write_Buffer_2
    862            }
    863            else if((addr%NAND_BLOCK_SIZE)+len > NAND_BLOCK_SIZE) {//0x40000 = one block size
   \                     ??Nand_Write_Buffer_1: (+1)
   \   00000036   0xF3C5 0x0011      UBFX     R0,R5,#+0,#+18
   \   0000003A   0x1830             ADDS     R0,R6,R0
   \   0000003C   0xF5B0 0x2F80      CMP      R0,#+262144
   \   00000040   0xD90A             BLS.N    ??Nand_Write_Buffer_2
    864          	  printk("\n 11 Erase block addr = %04X, NAND_PAGE_SIZE = %04X, erase addr = [%04X]\n",eaddr,NAND_PAGE_SIZE, eaddr/NAND_PAGE_SIZE);
   \   00000042   0x0B0F             LSRS     R7,R1,#+12
   \   00000044   0x463B             MOV      R3,R7
   \   00000046   0xF44F 0x5280      MOV      R2,#+4096
   \   0000004A   0x.... 0x....      ADR.W    R0,?_11
   \   0000004E   0x.... 0x....      BL       printk
    865          	  status = FSMC_NAND_EraseBlock(eaddr/NAND_PAGE_SIZE); 
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0x.... 0x....      BL       FSMC_NAND_EraseBlock
    866            }
    867          
    868            status = FSMC_NAND_WriteSmallPage(pBuffer,addr,len);
    869            
    870            return status;
   \                     ??Nand_Write_Buffer_2: (+1)
   \   00000058   0x4632             MOV      R2,R6
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000062   0x....             B.N      FSMC_NAND_WriteSmallPage
    871          }
    872          

   \                                 In section .text, align 2, keep-with-next
    873          INT32U Nand_Read_Buffer(INT8U *pBuffer, INT32U addr, INT16U len)
    874          {
   \                     Nand_Read_Buffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4615             MOV      R5,R2
    875          	INT32U status;
    876          
    877          	addr = Nand_Check_Badblock(addr);
   \   00000008   0x.... 0x....      BL       Nand_Check_Badblock
    878          	status = FSMC_NAND_ReadSmallPage(pBuffer,addr, len);
    879            
    880          	return status;
   \   0000000C   0x462A             MOV      R2,R5
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000016   0x....             B.N      FSMC_NAND_ReadSmallPage
    881          }
    882          
    883          
    884          #if NAND_DEBUG >0
    885          ////////////////NAND Memory Test///////////////////////////////////////////////////////////////////////////////////////////
    886          void TestMemory(void)
    887          {
    888          	INT32U rstatus=0,wstatus=0;
    889          	u8 i,index=0;
    890          	INT32U addr;
    891          	
    892          	for(i = 0; i < 10; i++) 
    893          	{
    894          		memset(TxBuffer,0x0,20);
    895          		memset(RxBuffer,0x0,20);
    896          		for (index = 0; index < 10; index++ )
    897          		{
    898          			TxBuffer[index] = i;
    899          		}
    900          		addr = NAND_MEMORY_TEST_ADDR + NAND_PAGE_SIZE * i;
    901          		wstatus = Nand_Write_Buffer(TxBuffer, addr, 10);
    902          		rstatus = Nand_Read_Buffer( RxBuffer, addr, 10);
    903          		MemoryDisplay((u32)RxBuffer,10);
    904          		printk("address = %04X,  write status= %04X, read status = %04X\n", addr,wstatus,rstatus);
    905          	}    
    906          }
    907          
    908          /******************************************************************************
    909          * Function Name  : NAND Debug Function
    910          * Attention		 : None
    911          *******************************************************************************/
    912          
    913          INT16U dbg_nandWriteRead_test(void)
    914          {
    915          	INT32U addr,index,ret;
    916          	INT8U data;
    917          
    918          	if(CLI_GetArgCnt() < 2) return INV_PRM;
    919          	addr = comparison_num((char *)P_ARG(1));
    920          	data = comparison_num((char *)P_ARG(2));
    921          
    922          
    923          	memset(TxBuffer,0x0,sizeof(TxBuffer));
    924          	memset(RxBuffer,0x0,sizeof(RxBuffer));
    925          	for (index = 0; index < NAND_PAGE_SIZE; index++ )
    926          	{
    927          		TxBuffer[index] = data;
    928          	}
    929          	ret = FSMC_NAND_EraseBlock(addr/NAND_PAGE_SIZE);
    930          	printk("\n[%02X]NAND Erase Block 0x%08X\n",ret,addr/NAND_PAGE_SIZE);
    931          
    932          	ret = FSMC_NAND_WriteSmallPage(TxBuffer, addr, NAND_PAGE_SIZE);
    933          	printk("[%02X]NAND Written data = 0x%02X\n",ret,data);
    934          
    935          	ret = FSMC_NAND_ReadSmallPage (RxBuffer, addr, NAND_PAGE_SIZE);
    936          	MemoryDisplay((u32)RxBuffer,NAND_PAGE_SIZE);
    937          	printk("....NAND Read return = %02X\n",ret);
    938          
    939          	return NO_DISPLAY;
    940          }
    941          
    942          INT16U dbg_nandWrite_test(void)
    943          {
    944          	INT32U addr,ret,index;
    945          	INT8U data;
    946          
    947          	if(CLI_GetArgCnt() < 2) return INV_PRM;
    948          	addr = comparison_num((char *)P_ARG(1));
    949          	data = comparison_num((char *)P_ARG(2));
    950          
    951          	memset(TxBuffer,0x0,sizeof(TxBuffer));
    952          	for (index = 0; index < NAND_PAGE_SIZE; index++ )
    953          	{
    954          		TxBuffer[index] = data;
    955          	}
    956          
    957          	ret = FSMC_NAND_WriteSmallPage(TxBuffer,addr,NAND_PAGE_SIZE);
    958          	printk("\n[%02X]NAND write addr 0x%08X\n",ret,addr);
    959          	return NO_DISPLAY;
    960          }
    961          
    962          
    963          INT16U dbg_nandblockread_test(void)
    964          {
    965          	INT32U cmd,addr,size;
    966          	//uint8_t RxBuffer [NAND_PAGE_SIZE];
    967          
    968          
    969          	if(CLI_GetArgCnt() < 1) return INV_PRM;
    970          	addr = comparison_num((char *)P_ARG(1));
    971          
    972          	FSMC_NAND_ReadSmallPage (RxBuffer, addr, NAND_PAGE_SIZE);
    973          	printk("\nNAND Page Read address = 0x%04X\n",addr);
    974          	MemoryDisplay((u32)RxBuffer,NAND_PAGE_SIZE);
    975          
    976          	return NO_DISPLAY;
    977          }
    978          
    979          INT16U dbg_nandspareread_test(void)
    980          {
    981          	INT32U cmd,addr,size;
    982          
    983          	if(CLI_GetArgCnt() < 1) return INV_PRM;
    984          	addr = comparison_num((char *)P_ARG(1));
    985          
    986          	FSMC_NAND_ReadSpareArea (RxBuffer, addr, 1);
    987          	printk("\nNAND Spare Read address = 0x%04X\n",addr);
    988          	MemoryDisplay((u32)RxBuffer,NAND_SPARE_AREA_SIZE);
    989          
    990          	return NO_DISPLAY;
    991          }
    992          INT16U dbg_nandsparewrite_test(void)
    993          {
    994          	INT32U cmd,addr,size,ret,index;
    995          	INT8U data=0;
    996          	//uint8_t TxBuffer [NAND_PAGE_SIZE];
    997          
    998          
    999          	if(CLI_GetArgCnt() < 2) return INV_PRM;
   1000          	addr = comparison_num((char *)P_ARG(1));
   1001          	data = comparison_num((char *)P_ARG(2));
   1002          
   1003          
   1004          	ret = FSMC_NAND_EraseBlock(addr);
   1005          	printk("\nNAND Erase block address = [%X]0x%04X\n",ret,addr);
   1006          	
   1007          	for (index = 0; index < NAND_SPARE_AREA_SIZE; index++ )
   1008          	{
   1009          		TxBuffer[index] = data;
   1010          	}
   1011          
   1012          	FSMC_NAND_WriteSpareArea (TxBuffer, addr, 1);
   1013          	printk("\nNAND Spare write address = 0x%04X\n",addr);
   1014          
   1015          	return NO_DISPLAY;
   1016          }
   1017          //////////////////////////////////////////////////////////////////////////////////////////////////
   1018          #endif
   1019          

   \                                 In section .text, align 2, keep-with-next
   1020          INT16U dbg_nandErase_test(void)
   1021          {
   \                     dbg_nandErase_test: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1022          	INT32U addr,ret;
   1023          	if(CLI_GetArgCnt() < 1) return INV_PRM;
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??dbg_nandErase_test_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD10             POP      {R4,PC}
   1024          	addr = comparison_num((char *)P_ARG(1));
   \                     ??dbg_nandErase_test_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
   1025          
   1026          	ret = FSMC_NAND_EraseBlock(addr/NAND_PAGE_SIZE);
   \   00000018   0x0B04             LSRS     R4,R0,#+12
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       FSMC_NAND_EraseBlock
   1027          	printk("\n[%02X]NAND Erase Block 0x%08X\n",ret,addr/NAND_PAGE_SIZE);
   \   00000020   0x4622             MOV      R2,R4
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0x.... 0x....      ADR.W    R0,?_12
   \   00000028   0x.... 0x....      BL       printk
   1028          	return NO_DISPLAY;
   \   0000002C   0x20C9             MOVS     R0,#+201
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1029          
   1030          }
   1031          

   \                                 In section .text, align 2, keep-with-next
   1032          INT16U dbg_nandread_test(void)
   1033          {
   \                     dbg_nandread_test: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1034          	INT32U addr,size;
   1035          
   1036          	if(CLI_GetArgCnt() < 2) return INV_PRM;
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD201             BCS.N    ??dbg_nandread_test_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD70             POP      {R4-R6,PC}
   1037          	addr = comparison_num((char *)P_ARG(1));
   \                     ??dbg_nandread_test_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
   \   00000018   0x4604             MOV      R4,R0
   1038          	size = comparison_num((char *)P_ARG(2));
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       Argument
   \   00000020   0x.... 0x....      BL       comparison_num
   \   00000024   0x4605             MOV      R5,R0
   1039          	if( size > NAND_PAGE_SIZE ) size = NAND_PAGE_SIZE;
   \   00000026   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000002A   0xD901             BLS.N    ??dbg_nandread_test_1
   \   0000002C   0xF44F 0x5580      MOV      R5,#+4096
   1040          
   1041          	//FSMC_NAND_ReadData(cmd,addr,tmp,size);
   1042            Nand_Read_Buffer( RxBuffer, addr, size);
   \                     ??dbg_nandread_test_1: (+1)
   \   00000030   0x....             LDR.N    R6,??DataTable52_10
   \   00000032   0x462A             MOV      R2,R5
   \   00000034   0xB292             UXTH     R2,R2
   \   00000036   0x4621             MOV      R1,R4
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       Nand_Read_Buffer
   1043          	MemoryDisplay((INT32U)RxBuffer, size);
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0x.... 0x....      BL       MemoryDisplay
   1044          		
   1045          	return NO_DISPLAY;
   \   00000046   0x20C9             MOVS     R0,#+201
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
   1046          }
   1047          
   1048          

   \                                 In section .text, align 2, keep-with-next
   1049          INT16U CMD_NAND_checkbb(void)
   1050          {
   \                     CMD_NAND_checkbb: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   1051          	INT32U i, bbcnt=0,err;
   \   00000004   0x2400             MOVS     R4,#+0
   1052          	INT8U bbstat;
   1053          
   1054          	printk("\n");
   \   00000006   0x....             ADR.N    R5,??DataTable52  ;; "\n"
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       printk
   1055          	for(i=0;i<NAND_SIZE/NAND_BLOCK_SIZE;i++)
   \   0000000E   0x4626             MOV      R6,R4
   \   00000010   0xE003             B.N      ??CMD_NAND_checkbb_0
   1056          	{
   1057          		//printk("[%04d] ",i);
   1058          		bbstat = FSMC_NAND_Badblock(NAND_BLOCK_SIZE*i, &err);
   1059          		if ( bbstat != 255 ) {
   1060          			printk("[%X]ADDR[%04X]:0x%08X : %d",err,i,NAND_BLOCK_SIZE*i,bbstat);
   1061          			if ( bbstat == 0 ) {
   1062          				printk(" ==>> BAD!!!!\n");
   1063          				bbcnt++;
   1064          			}
   1065          			else{
   1066          				printk("\n");
   \                     ??CMD_NAND_checkbb_1: (+1)
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       printk
   1067          			}
   \                     ??CMD_NAND_checkbb_2: (+1)
   \   00000018   0x1C76             ADDS     R6,R6,#+1
   \                     ??CMD_NAND_checkbb_0: (+1)
   \   0000001A   0xF5B6 0x6F00      CMP      R6,#+2048
   \   0000001E   0xD21A             BCS.N    ??CMD_NAND_checkbb_3
   \   00000020   0x04B7             LSLS     R7,R6,#+18
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0x4638             MOV      R0,R7
   \   00000026   0x.... 0x....      BL       FSMC_NAND_Badblock
   \   0000002A   0x4680             MOV      R8,R0
   \   0000002C   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000030   0xD0F2             BEQ.N    ??CMD_NAND_checkbb_2
   \   00000032   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000036   0x463B             MOV      R3,R7
   \   00000038   0x4632             MOV      R2,R6
   \   0000003A   0x9901             LDR      R1,[SP, #+4]
   \   0000003C   0x.... 0x....      ADR.W    R0,?_14
   \   00000040   0x.... 0x....      BL       printk
   \   00000044   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000048   0xD1E3             BNE.N    ??CMD_NAND_checkbb_1
   \   0000004A   0x.... 0x....      ADR.W    R0,?_15
   \   0000004E   0x.... 0x....      BL       printk
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   \   00000054   0xE7E0             B.N      ??CMD_NAND_checkbb_2
   1068          		}
   1069          	}
   1070          
   1071          	printk("Bad Block Count : %d\n",bbcnt);
   \                     ??CMD_NAND_checkbb_3: (+1)
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0x.... 0x....      ADR.W    R0,?_16
   \   0000005C   0x.... 0x....      BL       printk
   1072          	   
   1073            return NO_DISPLAY;
   \   00000060   0x20C9             MOVS     R0,#+201
   \   00000062   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1074          }
   1075          

   \                                 In section .text, align 2, keep-with-next
   1076          INT16U CMD_NAND_id(void)
   1077          {
   \                     CMD_NAND_id: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   1078          	u8 rdata[10]={0};
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x460B             MOV      R3,R1
   \   0000000A   0xC00E             STM      R0!,{R1-R3}
   1079          
   1080          	FSMC_NAND_ReadData(0x90,0,rdata,5);
   \   0000000C   0x2305             MOVS     R3,#+5
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x2090             MOVS     R0,#+144
   \   00000012   0x.... 0x....      BL       FSMC_NAND_ReadData
   1081          
   1082          	printk("\nID 0 read\n");
   \   00000016   0x.... 0x....      ADR.W    R0,?_18
   \   0000001A   0x.... 0x....      BL       printk
   1083          	MemoryDisplay((u32)rdata,5);
   \   0000001E   0x466C             MOV      R4,SP
   \   00000020   0x2105             MOVS     R1,#+5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       MemoryDisplay
   1084          
   1085          	printk("Manufacturer ID : ");
   \   00000028   0x.... 0x....      ADR.W    R0,?_19
   \   0000002C   0x.... 0x....      BL       printk
   1086          	if( rdata[0] == 0x2C ){
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x282C             CMP      R0,#+44
   \   00000036   0xD104             BNE.N    ??CMD_NAND_id_0
   1087          		 printk("Micron\n");
   \   00000038   0x.... 0x....      ADR.W    R0,?_20
   \   0000003C   0x.... 0x....      BL       printk
   \   00000040   0xE003             B.N      ??CMD_NAND_id_1
   1088          	}
   1089          	else{
   1090          		 printk("Unknown\n");
   \                     ??CMD_NAND_id_0: (+1)
   \   00000042   0x.... 0x....      ADR.W    R0,?_21
   \   00000046   0x.... 0x....      BL       printk
   1091          	}
   1092          
   1093          	printk("Device ID [%02X]  : ",rdata[1]);
   \                     ??CMD_NAND_id_1: (+1)
   \   0000004A   0x466D             MOV      R5,SP
   \   0000004C   0x7869             LDRB     R1,[R5, #+1]
   \   0000004E   0x.... 0x....      ADR.W    R0,?_22
   \   00000052   0x.... 0x....      BL       printk
   1094          	switch(rdata[1]){
   \   00000056   0x7868             LDRB     R0,[R5, #+1]
   \   00000058   0x28AC             CMP      R0,#+172
   \   0000005A   0xD006             BEQ.N    ??CMD_NAND_id_2
   \   0000005C   0x28BC             CMP      R0,#+188
   \   0000005E   0xD009             BEQ.N    ??CMD_NAND_id_3
   \   00000060   0x28CC             CMP      R0,#+204
   \   00000062   0xD011             BEQ.N    ??CMD_NAND_id_4
   \   00000064   0x28DC             CMP      R0,#+220
   \   00000066   0xD00A             BEQ.N    ??CMD_NAND_id_5
   \   00000068   0xE013             B.N      ??CMD_NAND_id_6
   1095          		case 0xAC:printk("MT29F4G08ABBEA 4Gb, x8, 1.8V\n");
   \                     ??CMD_NAND_id_2: (+1)
   \   0000006A   0x.... 0x....      ADR.W    R0,?_23
   \   0000006E   0x.... 0x....      BL       printk
   1096          			break;
   \   00000072   0xE012             B.N      ??CMD_NAND_id_7
   1097          		case 0xBC:printk("MT29F4G16ABBEA 4Gb, x16, 1.8V\n");
   \                     ??CMD_NAND_id_3: (+1)
   \   00000074   0x.... 0x....      ADR.W    R0,?_24
   \   00000078   0x.... 0x....      BL       printk
   1098          			break;
   \   0000007C   0xE00D             B.N      ??CMD_NAND_id_7
   1099          		case 0xDC:printk("MT29F4G08ABAEA 4Gb, x8, 3.3V\n");
   \                     ??CMD_NAND_id_5: (+1)
   \   0000007E   0x.... 0x....      ADR.W    R0,?_25
   \   00000082   0x.... 0x....      BL       printk
   1100          			break;
   \   00000086   0xE008             B.N      ??CMD_NAND_id_7
   1101          		case 0xCC:printk("MT29F4G16ABAEA 4Gb, x16, 3.3V\n");
   \                     ??CMD_NAND_id_4: (+1)
   \   00000088   0x.... 0x....      ADR.W    R0,?_26
   \   0000008C   0x.... 0x....      BL       printk
   1102          			break;
   \   00000090   0xE003             B.N      ??CMD_NAND_id_7
   1103          		default:printk("Unknown device ID\n");
   \                     ??CMD_NAND_id_6: (+1)
   \   00000092   0x.... 0x....      ADR.W    R0,?_27
   \   00000096   0x.... 0x....      BL       printk
   1104          			break;
   1105          	}
   1106          	
   1107          
   1108          	FSMC_NAND_ReadData(0x90,0x20,rdata,5);
   \                     ??CMD_NAND_id_7: (+1)
   \   0000009A   0x2305             MOVS     R3,#+5
   \   0000009C   0x466A             MOV      R2,SP
   \   0000009E   0x2120             MOVS     R1,#+32
   \   000000A0   0x2090             MOVS     R0,#+144
   \   000000A2   0x.... 0x....      BL       FSMC_NAND_ReadData
   1109          	printk("\nID 0x20 read\n");
   \   000000A6   0x.... 0x....      ADR.W    R0,?_28
   \   000000AA   0x.... 0x....      BL       printk
   1110          	MemoryDisplay((u32)rdata,5);
   \   000000AE   0x2105             MOVS     R1,#+5
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       MemoryDisplay
   1111          	
   1112          	   
   1113            return NO_DISPLAY;
   \   000000B6   0x20C9             MOVS     R0,#+201
   \   000000B8   0xBD3E             POP      {R1-R5,PC}       ;; return
   1114          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_1:
   \   00000000   0x........         DC32     BSP_NANDSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_2:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_3:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_4:
   \   00000000   0x70010000         DC32     0x70010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_5:
   \   00000000   0x70020000         DC32     0x70020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_6:
   \   00000000   0x1FFC0000         DC32     0x1ffc0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_7:
   \   00000000   0x1FFC1000         DC32     0x1ffc1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_8:
   \   00000000   0x........         DC32     BadBlockData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_9:
   \   00000000   0x1F300000         DC32     0x1f300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_10:
   \   00000000   0x........         DC32     RxBuffer

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_13:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x0A 0x52          DC8 0AH, 52H, 44H, 20H, 61H, 64H, 64H, 20H
   \              0x44 0x20    
   \              0x61 0x64    
   \              0x64 0x20    
   \   00000008   0x3D 0x20          DC8 3DH, 20H, 30H, 58H, 25H, 30H, 38H, 58H
   \              0x30 0x58    
   \              0x25 0x30    
   \              0x38 0x58    
   \   00000010   0x2C 0x20          DC8 2CH, 20H, 63H, 61H, 64H, 64H, 72H, 20H
   \              0x63 0x61    
   \              0x64 0x64    
   \              0x72 0x20    
   \   00000018   0x3D 0x20          DC8 3DH, 20H, 30H, 58H, 25H, 30H, 38H, 58H
   \              0x30 0x58    
   \              0x25 0x30    
   \              0x38 0x58    
   \   00000020   0x2C 0x20          DC8 2CH, 20H, 70H, 61H, 64H, 64H, 72H, 20H
   \              0x70 0x61    
   \              0x64 0x64    
   \              0x72 0x20    
   \   00000028   0x3D 0x20          DC8 3DH, 20H, 30H, 58H, 25H, 30H, 38H, 58H
   \              0x30 0x58    
   \              0x25 0x30    
   \              0x38 0x58    
   \   00000030   0x20 0x0A          DC8 20H, 0AH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0A 0x20          DC8 "\012 Erase block = %04X\012"
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x3D 0x20    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x0A 0x3D          DC8 "\012===Bad block table not found===\012"
   \              0x3D 0x3D    
   \              0x42 0x61    
   \              0x64 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x74 0x61    
   \              0x62 0x6C    
   \              0x65 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x66 0x6F    
   \              0x75 0x6E    
   \              0x64 0x3D    
   \              0x3D 0x3D    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0A 0x0A          DC8 "\012\012===Bad block table found===\012"
   \              0x3D 0x3D    
   \              0x3D 0x42    
   \              0x61 0x64    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x74    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x66    
   \              0x6F 0x75    
   \              0x6E 0x64    
   \              0x3D 0x3D    
   \              0x3D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x43 0x6E          DC8 "Cnt:%d\012"
   \              0x74 0x3A    
   \              0x25 0x64    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x42 0x61          DC8 "BadBlockindex : %d\012"
   \              0x64 0x42    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x69 0x6E    
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x43 0x68          DC8 "ChkSUM:0x%02X\012"
   \              0x6B 0x53    
   \              0x55 0x4D    
   \              0x3A 0x30    
   \              0x78 0x25    
   \              0x30 0x32    
   \              0x58 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x3D 0x3D          DC8 "===Checksum error. %02X:%02X ===\012"
   \              0x3D 0x43    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x73 0x75    
   \              0x6D 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x58 0x3A    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x20 0x3D    
   \              0x3D 0x3D    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x3D 0x3D          DC8 "===Bad block not found===\012"
   \              0x3D 0x42    
   \              0x61 0x64    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x66    
   \              0x6F 0x75    
   \              0x6E 0x64    
   \              0x3D 0x3D    
   \              0x3D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x0A 0x20          DC8 0AH, 20H, 30H, 30H, 20H, 45H, 72H, 61H
   \              0x30 0x30    
   \              0x20 0x45    
   \              0x72 0x61    
   \   00000008   0x73 0x65          DC8 73H, 65H, 20H, 62H, 6CH, 6FH, 63H, 6BH
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000010   0x20 0x61          DC8 20H, 61H, 64H, 64H, 72H, 20H, 3DH, 20H
   \              0x64 0x64    
   \              0x72 0x20    
   \              0x3D 0x20    
   \   00000018   0x25 0x30          DC8 25H, 30H, 34H, 58H, 2CH, 20H, 4EH, 41H
   \              0x34 0x58    
   \              0x2C 0x20    
   \              0x4E 0x41    
   \   00000020   0x4E 0x44          DC8 4EH, 44H, 5FH, 50H, 41H, 47H, 45H, 5FH
   \              0x5F 0x50    
   \              0x41 0x47    
   \              0x45 0x5F    
   \   00000028   0x53 0x49          DC8 53H, 49H, 5AH, 45H, 20H, 3DH, 20H, 25H
   \              0x5A 0x45    
   \              0x20 0x3D    
   \              0x20 0x25    
   \   00000030   0x30 0x34          DC8 30H, 34H, 58H, 2CH, 20H, 65H, 72H, 61H
   \              0x58 0x2C    
   \              0x20 0x65    
   \              0x72 0x61    
   \   00000038   0x73 0x65          DC8 73H, 65H, 20H, 61H, 64H, 64H, 72H, 20H
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x20    
   \   00000040   0x3D 0x20          DC8 3DH, 20H, 5BH, 25H, 30H, 34H, 58H, 5DH
   \              0x5B 0x25    
   \              0x30 0x34    
   \              0x58 0x5D    
   \   00000048   0x0A 0x00          DC8 0AH, 0
   \   0000004A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x0A 0x20          DC8 0AH, 20H, 31H, 31H, 20H, 45H, 72H, 61H
   \              0x31 0x31    
   \              0x20 0x45    
   \              0x72 0x61    
   \   00000008   0x73 0x65          DC8 73H, 65H, 20H, 62H, 6CH, 6FH, 63H, 6BH
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000010   0x20 0x61          DC8 20H, 61H, 64H, 64H, 72H, 20H, 3DH, 20H
   \              0x64 0x64    
   \              0x72 0x20    
   \              0x3D 0x20    
   \   00000018   0x25 0x30          DC8 25H, 30H, 34H, 58H, 2CH, 20H, 4EH, 41H
   \              0x34 0x58    
   \              0x2C 0x20    
   \              0x4E 0x41    
   \   00000020   0x4E 0x44          DC8 4EH, 44H, 5FH, 50H, 41H, 47H, 45H, 5FH
   \              0x5F 0x50    
   \              0x41 0x47    
   \              0x45 0x5F    
   \   00000028   0x53 0x49          DC8 53H, 49H, 5AH, 45H, 20H, 3DH, 20H, 25H
   \              0x5A 0x45    
   \              0x20 0x3D    
   \              0x20 0x25    
   \   00000030   0x30 0x34          DC8 30H, 34H, 58H, 2CH, 20H, 65H, 72H, 61H
   \              0x58 0x2C    
   \              0x20 0x65    
   \              0x72 0x61    
   \   00000038   0x73 0x65          DC8 73H, 65H, 20H, 61H, 64H, 64H, 72H, 20H
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x20    
   \   00000040   0x3D 0x20          DC8 3DH, 20H, 5BH, 25H, 30H, 34H, 58H, 5DH
   \              0x5B 0x25    
   \              0x30 0x34    
   \              0x58 0x5D    
   \   00000048   0x0A 0x00          DC8 0AH, 0
   \   0000004A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x0A 0x5B          DC8 "\012[%02X]NAND Erase Block 0x%08X\012"
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x5D 0x4E    
   \              0x41 0x4E    
   \              0x44 0x20    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x30 0x78    
   \              0x25 0x30    
   \              0x38 0x58    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x5B 0x25          DC8 "[%X]ADDR[%04X]:0x%08X : %d"
   \              0x58 0x5D    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x5B 0x25    
   \              0x30 0x34    
   \              0x58 0x5D    
   \              0x3A 0x30    
   \              0x78 0x25    
   \              0x30 0x38    
   \              0x58 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x20 0x3D          DC8 " ==>> BAD!!!!\012"
   \              0x3D 0x3E    
   \              0x3E 0x20    
   \              0x42 0x41    
   \              0x44 0x21    
   \              0x21 0x21    
   \              0x21 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x42 0x61          DC8 "Bad Block Count : %d\012"
   \              0x64 0x20    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x0A 0x49          DC8 "\012ID 0 read\012"
   \              0x44 0x20    
   \              0x30 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x4D 0x61          DC8 "Manufacturer ID : "
   \              0x6E 0x75    
   \              0x66 0x61    
   \              0x63 0x74    
   \              0x75 0x72    
   \              0x65 0x72    
   \              0x20 0x49    
   \              0x44 0x20    
   \              0x3A 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \   00000000   0x4D 0x69          DC8 "Micron\012"
   \              0x63 0x72    
   \              0x6F 0x6E    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x55 0x6E          DC8 "Unknown\012"
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x44 0x65          DC8 "Device ID [%02X]  : "
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x49    
   \              0x44 0x20    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x4D 0x54          DC8 "MT29F4G08ABBEA 4Gb, x8, 1.8V\012"
   \              0x32 0x39    
   \              0x46 0x34    
   \              0x47 0x30    
   \              0x38 0x41    
   \              0x42 0x42    
   \              0x45 0x41    
   \              0x20 0x34    
   \              0x47 0x62    
   \              0x2C 0x20    
   \              0x78 0x38    
   \              0x2C 0x20    
   \              0x31 0x2E    
   \              0x38 0x56    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \   00000000   0x4D 0x54          DC8 "MT29F4G16ABBEA 4Gb, x16, 1.8V\012"
   \              0x32 0x39    
   \              0x46 0x34    
   \              0x47 0x31    
   \              0x36 0x41    
   \              0x42 0x42    
   \              0x45 0x41    
   \              0x20 0x34    
   \              0x47 0x62    
   \              0x2C 0x20    
   \              0x78 0x31    
   \              0x36 0x2C    
   \              0x20 0x31    
   \              0x2E 0x38    
   \              0x56 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \   00000000   0x4D 0x54          DC8 "MT29F4G08ABAEA 4Gb, x8, 3.3V\012"
   \              0x32 0x39    
   \              0x46 0x34    
   \              0x47 0x30    
   \              0x38 0x41    
   \              0x42 0x41    
   \              0x45 0x41    
   \              0x20 0x34    
   \              0x47 0x62    
   \              0x2C 0x20    
   \              0x78 0x38    
   \              0x2C 0x20    
   \              0x33 0x2E    
   \              0x33 0x56    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \   00000000   0x4D 0x54          DC8 "MT29F4G16ABAEA 4Gb, x16, 3.3V\012"
   \              0x32 0x39    
   \              0x46 0x34    
   \              0x47 0x31    
   \              0x36 0x41    
   \              0x42 0x41    
   \              0x45 0x41    
   \              0x20 0x34    
   \              0x47 0x62    
   \              0x2C 0x20    
   \              0x78 0x31    
   \              0x36 0x2C    
   \              0x20 0x33    
   \              0x2E 0x33    
   \              0x56 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \   00000000   0x55 0x6E          DC8 "Unknown device ID\012"
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x64 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x49    
   \              0x44 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \   00000000   0x0A 0x49          DC8 "\012ID 0x20 read\012"
   \              0x44 0x20    
   \              0x30 0x78    
   \              0x32 0x30    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0
   1115          
   1116          
   1117          
   1118          #endif /* #if SCR_USE_NAND > 0*/
   1119          
   1120          /*********************************************************************************************************
   1121                END FILE
   1122          *********************************************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   CMD_NAND_checkbb
        32   -> FSMC_NAND_Badblock
        32   -> printk
      24   CMD_NAND_id
        24   -> FSMC_NAND_ReadData
        24   -> MemoryDisplay
        24   -> printk
       0   FSMC_NAND_AddressIncrement
      16   FSMC_NAND_Badblock
        16   -> FSMC_NAND_GetStatus
        16   -> printk
        16   -> xQueueGenericReceive
        16   -> xQueueGenericSend
      16   FSMC_NAND_EraseBlock
        16   -> FSMC_NAND_GetStatus
        16   -> printk
        16   -> xQueueGenericReceive
        16   -> xQueueGenericSend
       8   FSMC_NAND_GetStatus
         8   -> FSMC_NAND_ReadStatus
      72   FSMC_NAND_Init
        72   -> FSMC_NANDCmd
        72   -> FSMC_NANDInit
        72   -> GPIO_Init
        72   -> GPIO_PinAFConfig
        72   -> RCC_AHB1PeriphClockCmd
        72   -> RCC_AHB3PeriphClockCmd
        72   -> RCC_APB2PeriphClockCmd
      32   FSMC_NAND_ReadData
        32   -> printk
        32   -> xQueueGenericReceive
        32   -> xQueueGenericSend
      40   FSMC_NAND_ReadSmallPage
        40   -> FSMC_NAND_AddressIncrement
        40   -> FSMC_NAND_GetStatus
        40   -> printk
        40   -> xQueueGenericReceive
        40   -> xQueueGenericSend
      24   FSMC_NAND_ReadSpareArea
        24   -> FSMC_NAND_GetStatus
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
       0   FSMC_NAND_ReadStatus
       8   FSMC_NAND_Reset
         8   -> printk
         8   -> xQueueGenericReceive
         8   -> xQueueGenericSend
      40   FSMC_NAND_WriteSmallPage
        40   -> FSMC_NAND_AddressIncrement
        40   -> FSMC_NAND_GetStatus
        40   -> printk
        40   -> xQueueGenericReceive
        40   -> xQueueGenericSend
      24   FSMC_NAND_WriteSpareArea
        24   -> FSMC_NAND_GetStatus
        24   -> GPIO_ReadInputDataBit
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
       8   NandSemaphore_Init
         8   -> xQueueCreateMutex
         8   -> xQueueGenericCreate
         0   -> xQueueGenericSend
      12   Nand_Check_Badblock
     128   Nand_Make_Badblock_Table
       128   -> FSMC_NAND_Badblock
       128   -> Nand_Read_Buffer
       128   -> Nand_Write_Buffer
       128   -> __aeabi_memcpy4
       128   -> __aeabi_memset4
     128   Nand_Read_BadblockData
       128   -> FSMC_NAND_Badblock
       128   -> Nand_Read_Buffer
       128   -> __aeabi_memcpy4
       128   -> printd
      16   Nand_Read_Buffer
         0   -> FSMC_NAND_ReadSmallPage
        16   -> Nand_Check_Badblock
      24   Nand_Write_Buffer
        24   -> FSMC_NAND_EraseBlock
         0   -> FSMC_NAND_WriteSmallPage
        24   -> Nand_Check_Badblock
        24   -> printk
       8   dbg_nandErase_test
         8   -> Argument
         8   -> CLI_GetArgCnt
         8   -> FSMC_NAND_EraseBlock
         8   -> comparison_num
         8   -> printk
      16   dbg_nandread_test
        16   -> Argument
        16   -> CLI_GetArgCnt
        16   -> MemoryDisplay
        16   -> Nand_Read_Buffer
        16   -> comparison_num


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable52_10
       4  ??DataTable52_2
       4  ??DataTable52_3
       4  ??DataTable52_4
       4  ??DataTable52_5
       4  ??DataTable52_6
       4  ??DataTable52_7
       4  ??DataTable52_8
       4  ??DataTable52_9
       8  ?_0
      52  ?_1
      76  ?_10
      76  ?_11
      32  ?_12
       2  ?_13
      28  ?_14
      16  ?_15
      24  ?_16
      12  ?_17
      12  ?_18
      20  ?_19
      24  ?_2
       8  ?_20
      12  ?_21
      24  ?_22
      32  ?_23
      32  ?_24
      32  ?_25
      32  ?_26
      20  ?_27
      16  ?_28
      36  ?_3
      32  ?_4
       8  ?_5
      20  ?_6
      16  ?_7
      36  ?_8
      28  ?_9
     104  BadBlockData
     102  CMD_NAND_checkbb
     186  CMD_NAND_id
       6  FSMC_NAND_AddressIncrement
     122  FSMC_NAND_Badblock
     106  FSMC_NAND_EraseBlock
      36  FSMC_NAND_GetStatus
     350  FSMC_NAND_Init
     104  FSMC_NAND_ReadData
     200  FSMC_NAND_ReadSmallPage
     146  FSMC_NAND_ReadSpareArea
      32  FSMC_NAND_ReadStatus
      70  FSMC_NAND_Reset
     208  FSMC_NAND_WriteSmallPage
     146  FSMC_NAND_WriteSpareArea
      46  NandSemaphore_Init
      62  Nand_Check_Badblock
     264  Nand_Make_Badblock_Table
     216  Nand_Read_BadblockData
      24  Nand_Read_Buffer
     100  Nand_Write_Buffer
    4096  RxBuffer
       8  WriteReadAddr
      48  dbg_nandErase_test
      74  dbg_nandread_test
     184  -- Other

 
 4 208 bytes in section .bss
    14 bytes in section .rodata
 3 628 bytes in section .text
 
 3 628 bytes of CODE  memory
    14 bytes of CONST memory
 4 208 bytes of DATA  memory

Errors: none
Warnings: none
