###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\tasks.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\tasks.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\tasks.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\tasks.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\tasks.c
      1          /*
      2              FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          /* Standard includes. */
     67          #include <stdlib.h>
     68          #include <string.h>
     69          
     70          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     71          all the API functions to use the MPU wrappers.  That should only be done when
     72          task.h is included from an application file. */
     73          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     74          
     75          /* FreeRTOS includes. */
     76          #include "FreeRTOS.h"
     77          #include "task.h"
     78          #include "Rtimers.h"
     79          #include "StackMacros.h"
     80          
     81          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     82          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     83          header files above, but not in this file, in order to generate the correct
     84          privileged Vs unprivileged linkage and placement. */
     85          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     86          
     87          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     88          	/* At the bottom of this file are two optional functions that can be used
     89          	to generate human readable text from the raw data generated by the
     90          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     91          	for convenience only, and are NOT considered part of the kernel. */
     92          	#include <stdio.h>
     93          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
     94          
     95          /* Sanity check the configuration. */
     96          #if configUSE_TICKLESS_IDLE != 0
     97          	#if INCLUDE_vTaskSuspend != 1
     98          		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
     99          	#endif /* INCLUDE_vTaskSuspend */
    100          #endif /* configUSE_TICKLESS_IDLE */
    101          
    102          /*
    103           * Defines the size, in words, of the stack allocated to the idle task.
    104           */
    105          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
    106          
    107          #if( configUSE_PREEMPTION == 0 )
    108          	/* If the cooperative scheduler is being used then a yield should not be
    109          	performed just because a higher priority task has been woken. */
    110          	#define taskYIELD_IF_USING_PREEMPTION()
    111          #else
    112          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    113          #endif
    114          
    115          /*
    116           * Task control block.  A task control block (TCB) is allocated for each task,
    117           * and stores task state information, including a pointer to the task's context
    118           * (the task's run time environment, including register values)
    119           */
    120          typedef struct tskTaskControlBlock
    121          {
    122          	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    123          
    124          	#if ( portUSING_MPU_WRAPPERS == 1 )
    125          		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    126          	#endif
    127          
    128          	xListItem				xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    129          	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
    130          	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    131          	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
    132          	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */
    133          
    134          	#if ( portSTACK_GROWTH > 0 )
    135          		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    136          	#endif
    137          
    138          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    139          		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    140          	#endif
    141          
    142          	#if ( configUSE_TRACE_FACILITY == 1 )
    143          		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    144          		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party trace code. */
    145          	#endif
    146          
    147          	#if ( configUSE_MUTEXES == 1 )
    148          		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    149          	#endif
    150          
    151          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    152          		pdTASK_HOOK_CODE pxTaskTag;
    153          	#endif
    154          
    155          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    156          		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running state. */
    157          	#endif
    158          
    159          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    160          		/* Allocate a Newlib reent structure that is specific to this task.
    161          		Note Newlib support has been included by popular demand, but is not
    162          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    163          		responsible for resulting newlib operation.  User must be familiar with
    164          		newlib and must provide system-wide implementations of the necessary
    165          		stubs. Be warned that (at the time of writing) the current newlib design
    166          		implements a system-wide malloc() that must be provided with locks. */
    167          		struct _reent xNewLib_reent;
    168          	#endif
    169          
    170          } tskTCB;
    171          
    172          
    173          /*
    174           * Some kernel aware debuggers require the data the debugger needs access to to
    175           * be global, rather than file scope.
    176           */
    177          #ifdef portREMOVE_STATIC_QUALIFIER
    178          	#define static
    179          #endif
    180          
    181          /*lint -e956 A manual analysis and inspection has been used to determine which
    182          static variables must be declared volatile. */
    183          
    184          PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
    185          
    186          /* Lists for ready and blocked tasks. --------------------*/

   \                                 In section .bss, align 4
    187          PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks. */
   \                     pxReadyTasksLists:
   \   00000000                      DS8 240

   \                                 In section .data, align 4
    188          PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
    189          PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    190          PRIVILEGED_DATA static xList * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    191          PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    192          PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
   \                     xPendingReadyList:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     pxCurrentTCB:
   \   00000028   0x00000000         DC32 0H
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000034   0x00000000         DC32 0
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000004C   0x00000000         DC32 0
   \   00000050   0x00000000         DC32 0
   \   00000054   0x00000000         DC32 0
   \   00000058   0x00000000         DC32 0
   \   0000005C   0x00000000         DC32 0
   \   00000060   0x00000000         DC32 0
   \   00000064   0x00000000         DC32 0
   \   00000068   0x00000000         DC32 0
   \   0000006C   0x00000000         DC32 0
   \   00000070   0xFFFFFFFF         DC32 4294967295
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000088   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    193          
    194          #if ( INCLUDE_vTaskDelete == 1 )
    195          
    196          	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but the their memory not yet freed. */
    197          	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE ) 0U;
    198          
    199          #endif
    200          
    201          #if ( INCLUDE_vTaskSuspend == 1 )
    202          
    203          	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    204          
    205          #endif
    206          
    207          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    208          
    209          	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    210          
    211          #endif
    212          
    213          /* Other file private variables. --------------------------------*/
    214          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBASE_TYPE ) 0U;
    215          PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
    216          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
    217          PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
    218          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE_TYPE ) pdFALSE;
    219          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxPendedTicks 			= ( unsigned portBASE_TYPE ) 0U;
    220          PRIVILEGED_DATA static volatile portBASE_TYPE xYieldPending 					= pdFALSE;
    221          PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
    222          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
    223          PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= portMAX_DELAY;
    224          
    225          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    226          
    227          	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    228          	PRIVILEGED_DATA static unsigned long ulTotalRunTime = 0UL;			/*< Holds the total amount of execution time as defined by the run time counter clock. */
    229          
    230          #endif
    231          
    232          /*lint +e956 */
    233          
    234          /* Debugging and trace facilities private variables and macros. ------------*/
    235          
    236          /*
    237           * The value used to fill the stack of a task when the task is created.  This
    238           * is used purely for checking the high water mark for tasks.
    239           */
    240          #define tskSTACK_FILL_BYTE	( 0xa5U )
    241          
    242          /*
    243           * Macros used by vListTask to indicate which state a task is in.
    244           */
    245          #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
    246          #define tskREADY_CHAR		( ( signed char ) 'R' )
    247          #define tskDELETED_CHAR		( ( signed char ) 'D' )
    248          #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
    249          
    250          /*-----------------------------------------------------------*/
    251          
    252          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    253          
    254          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    255          	performed in a generic way that is not optimised to any particular
    256          	microcontroller architecture. */
    257          
    258          	/* uxTopReadyPriority holds the priority of the highest priority ready
    259          	state task. */
    260          	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
    261          	{																													\
    262          		if( ( uxPriority ) > uxTopReadyPriority )																		\
    263          		{																												\
    264          			uxTopReadyPriority = ( uxPriority );																		\
    265          		}																												\
    266          	} /* taskRECORD_READY_PRIORITY */
    267          
    268          	/*-----------------------------------------------------------*/
    269          
    270          	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
    271          	{																													\
    272          		/* Find the highest priority queue that contains ready tasks. */												\
    273          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
    274          		{																												\
    275          			configASSERT( uxTopReadyPriority );																			\
    276          			--uxTopReadyPriority;																						\
    277          		}																												\
    278          																														\
    279          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
    280          		the	same priority get an equal share of the processor time. */													\
    281          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
    282          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    283          
    284          	/*-----------------------------------------------------------*/
    285          
    286          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    287          	they are only required when a port optimised method of task selection is
    288          	being used. */
    289          	#define taskRESET_READY_PRIORITY( uxPriority )
    290          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    291          
    292          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    293          
    294          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    295          	performed in a way that is tailored to the particular microcontroller
    296          	architecture being used. */
    297          
    298          	/* A port optimised version is provided.  Call the port defined macros. */
    299          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    300          
    301          	/*-----------------------------------------------------------*/
    302          
    303          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    304          	{																								\
    305          	unsigned portBASE_TYPE uxTopPriority;															\
    306          																									\
    307          		/* Find the highest priority queue that contains ready tasks. */							\
    308          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    309          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    310          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    311          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    312          
    313          	/*-----------------------------------------------------------*/
    314          
    315          	/* A port optimised version is provided, call it only if the TCB being reset
    316          	is being referenced from a ready list.  If it is referenced from a delayed
    317          	or suspended list then it won't be in a ready list. */
    318          	#define taskRESET_READY_PRIORITY( uxPriority )													\
    319          	{																								\
    320          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
    321          		{																							\
    322          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
    323          		}																							\
    324          	}
    325          
    326          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    327          
    328          /*-----------------------------------------------------------*/
    329          
    330          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    331          count overflows. */
    332          #define taskSWITCH_DELAYED_LISTS()																	\
    333          {																									\
    334          	xList *pxTemp;																					\
    335          																									\
    336          	/* The delayed tasks list should be empty when the lists are switched. */						\
    337          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    338          																									\
    339          	pxTemp = pxDelayedTaskList;																		\
    340          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    341          	pxOverflowDelayedTaskList = pxTemp;																\
    342          	xNumOfOverflows++;																				\
    343          																									\
    344          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )											\
    345          	{																								\
    346          		/* The new current delayed list is empty.  Set												\
    347          		xNextTaskUnblockTime to the maximum possible value so it is									\
    348          		extremely unlikely that the																	\
    349          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until								\
    350          		there is an item in the delayed list. */													\
    351          		xNextTaskUnblockTime = portMAX_DELAY;														\
    352          	}																								\
    353          	else																							\
    354          	{																								\
    355          		/* The new current delayed list is not empty, get the value of								\
    356          		the item at the head of the delayed list.  This is the time at								\
    357          		which the task at the head of the delayed list should be removed							\
    358          		from the Blocked state. */																	\
    359          		pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );						\
    360          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );				\
    361          	}																								\
    362          }
    363          
    364          /*-----------------------------------------------------------*/
    365          
    366          /*
    367           * Place the task represented by pxTCB into the appropriate ready list for
    368           * the task.  It is inserted at the end of the list.
    369           */
    370          #define prvAddTaskToReadyList( pxTCB )																				\
    371          	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
    372          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
    373          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    374          /*-----------------------------------------------------------*/
    375          
    376          /*
    377           * Several functions take an xTaskHandle parameter that can optionally be NULL,
    378           * where NULL is used to indicate that the handle of the currently executing
    379           * task should be used in place of the parameter.  This macro simply checks to
    380           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    381           */
    382          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) ( pxHandle ) )
    383          
    384          /* Callback function prototypes. --------------------------*/
    385          extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
    386          extern void vApplicationTickHook( void );
    387          
    388          /* File private functions. --------------------------------*/
    389          
    390          /*
    391           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    392           * into the TCB structure.
    393           */
    394          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
    395          
    396          /*
    397           * Utility to ready all the lists used by the scheduler.  This is called
    398           * automatically upon the creation of the first task.
    399           */
    400          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    401          
    402          /*
    403           * The idle task, which as all tasks is implemented as a never ending loop.
    404           * The idle task is automatically created and added to the ready lists upon
    405           * creation of the first user task.
    406           *
    407           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    408           * language extensions.  The equivalent prototype for this function is:
    409           *
    410           * void prvIdleTask( void *pvParameters );
    411           *
    412           */
    413          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    414          
    415          /*
    416           * Utility to free all memory allocated by the scheduler to hold a TCB,
    417           * including the stack pointed to by the TCB.
    418           *
    419           * This does not free memory allocated by the task itself (i.e. memory
    420           * allocated by calls to pvPortMalloc from within the tasks application code).
    421           */
    422          #if ( INCLUDE_vTaskDelete == 1 )
    423          
    424          	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
    425          
    426          #endif
    427          
    428          /*
    429           * Used only by the idle task.  This checks to see if anything has been placed
    430           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    431           * and its TCB deleted.
    432           */
    433          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    434          
    435          /*
    436           * The currently executing task is entering the Blocked state.  Add the task to
    437           * either the current or the overflow delayed task list.
    438           */
    439          static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
    440          
    441          /*
    442           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    443           * allocation was successful.
    444           */
    445          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer ) PRIVILEGED_FUNCTION;
    446          
    447          /*
    448           * Fills an xTaskStatusType structure with information on each task that is
    449           * referenced from the pxList list (which may be a ready list, a delayed list,
    450           * a suspended list, etc.).
    451           *
    452           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    453           * NORMAL APPLICATION CODE.
    454           */
    455          #if ( configUSE_TRACE_FACILITY == 1 )
    456          
    457          	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xList *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    458          
    459          #endif
    460          
    461          /*
    462           * When a task is created, the stack of the task is filled with a known value.
    463           * This function determines the 'high water mark' of the task stack by
    464           * determining how much of the stack remains at the original preset value.
    465           */
    466          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    467          
    468          	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_FUNCTION;
    469          
    470          #endif
    471          
    472          /*
    473           * Return the amount of time, in ticks, that will pass before the kernel will
    474           * next move a task from the Blocked state to the Running state.
    475           *
    476           * This conditional compilation should use inequality to 0, not equality to 1.
    477           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    478           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    479           * set to a value other than 1.
    480           */
    481          #if ( configUSE_TICKLESS_IDLE != 0 )
    482          
    483          	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    484          
    485          #endif
    486          

   \                                 In section .text, align 2, keep-with-next
    487          signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
    488          {
   \                     xTaskGenericCreate: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
    489          signed portBASE_TYPE xReturn;
    490          tskTCB * pxNewTCB;
    491          
    492          	configASSERT( pxTaskCode );
    493          	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    494          
    495          	/* Allocate the memory required by the TCB and stack for the new task,
    496          	checking that the allocation was successful. */
    497          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   \   0000000E   0x990C             LDR      R1,[SP, #+48]
   \   00000010   0x4640             MOV      R0,R8
   \   00000012   0x.... 0x....      BL       prvAllocateTCBAndStack
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0x9D0A             LDR      R5,[SP, #+40]
    498          
    499          	if( pxNewTCB != NULL )
   \   0000001A   0xD047             BEQ.N    ??xTaskGenericCreate_0
    500          	{
    501          		portSTACK_TYPE *pxTopOfStack;
    502          
    503          		#if( portUSING_MPU_WRAPPERS == 1 )
    504          			/* Should the task be created in privileged mode? */
    505          			portBASE_TYPE xRunPrivileged;
    506          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    507          			{
    508          				xRunPrivileged = pdTRUE;
    509          			}
    510          			else
    511          			{
    512          				xRunPrivileged = pdFALSE;
    513          			}
    514          			uxPriority &= ~portPRIVILEGE_BIT;
    515          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    516          
    517          		/* Calculate the top of stack address.  This depends on whether the
    518          		stack grows from high memory to low (as per the 80x86) or visa versa.
    519          		portSTACK_GROWTH is used to make the result positive or negative as
    520          		required by the port. */
    521          		#if( portSTACK_GROWTH < 0 )
    522          		{
    523          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
   \   0000001C   0x6B20             LDR      R0,[R4, #+48]
   \   0000001E   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   00000022   0xF1A0 0x0A04      SUB      R10,R0,#+4
    524          			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    525          
    526          			/* Check the alignment of the calculated top of stack is correct. */
    527          			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    528          		}
    529          		#else /* portSTACK_GROWTH */
    530          		{
    531          			pxTopOfStack = pxNewTCB->pxStack;
    532          
    533          			/* Check the alignment of the stack buffer is correct. */
    534          			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    535          
    536          			/* If we want to use stack checking on architectures that use
    537          			a positive stack growth direction then we also need to store the
    538          			other extreme of the stack space. */
    539          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    540          		}
    541          		#endif /* portSTACK_GROWTH */
    542          
    543          		/* Setup the newly allocated TCB with the initial state of the task. */
    544          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   \   00000026   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000002A   0x9B0D             LDR      R3,[SP, #+52]
   \   0000002C   0x462A             MOV      R2,R5
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       prvInitialiseTCBVariables
    545          
    546          		/* Initialize the TCB stack to look as if the task was already running,
    547          		but had been interrupted by the scheduler.  The return address is set
    548          		to the start of the task function. Once the stack has been initialised
    549          		the	top of stack variable is updated. */
    550          		#if( portUSING_MPU_WRAPPERS == 1 )
    551          		{
    552          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    553          		}
    554          		#else /* portUSING_MPU_WRAPPERS */
    555          		{
    556          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   \   00000036   0x464A             MOV      R2,R9
   \   00000038   0x4631             MOV      R1,R6
   \   0000003A   0xEA4F 0x00DA      LSR      R0,R10,#+3
   \   0000003E   0x00C0             LSLS     R0,R0,#+3
   \   00000040   0x.... 0x....      BL       pxPortInitialiseStack
   \   00000044   0x6020             STR      R0,[R4, #+0]
   \   00000046   0x980B             LDR      R0,[SP, #+44]
    557          		}
    558          		#endif /* portUSING_MPU_WRAPPERS */
    559          
    560          		if( ( void * ) pxCreatedTask != NULL )
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD000             BEQ.N    ??xTaskGenericCreate_1
    561          		{
    562          			/* Pass the TCB out - in an anonymous way.  The calling function/
    563          			task can use this as a handle to delete the task later if
    564          			required.*/
    565          			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   \   0000004C   0x6004             STR      R4,[R0, #+0]
    566          		}
    567          
    568          		/* Ensure interrupts don't access the task lists while they are being
    569          		updated. */
    570          		taskENTER_CRITICAL();
   \                     ??xTaskGenericCreate_1: (+1)
   \   0000004E   0x.... 0x....      BL       vPortEnterCritical
    571          		{
    572          			uxCurrentNumberOfTasks++;
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable37
   \   00000056   0x6CF0             LDR      R0,[R6, #+76]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x64F0             STR      R0,[R6, #+76]
    573          			if( pxCurrentTCB == NULL )
   \   0000005C   0x6AB0             LDR      R0,[R6, #+40]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD106             BNE.N    ??xTaskGenericCreate_2
    574          			{
    575          				/* There are no other tasks, or all the other tasks are in
    576          				the suspended state - make this the current task. */
    577          				pxCurrentTCB =  pxNewTCB;
   \   00000062   0x62B4             STR      R4,[R6, #+40]
    578          
    579          				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   \   00000064   0x6CF0             LDR      R0,[R6, #+76]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD10A             BNE.N    ??xTaskGenericCreate_3
    580          				{
    581          					/* This is the first task to be created so do the preliminary
    582          					initialisation required.  We will not recover if this call
    583          					fails, but we will report the failure. */
    584          					prvInitialiseTaskLists();
   \   0000006A   0x.... 0x....      BL       prvInitialiseTaskLists
   \   0000006E   0xE007             B.N      ??xTaskGenericCreate_3
    585          				}
    586          			}
    587          			else
    588          			{
    589          				/* If the scheduler is not already running, make this task the
    590          				current task if it is the highest priority task to be created
    591          				so far. */
    592          				if( xSchedulerRunning == pdFALSE )
   \                     ??xTaskGenericCreate_2: (+1)
   \   00000070   0x6DB0             LDR      R0,[R6, #+88]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD104             BNE.N    ??xTaskGenericCreate_3
    593          				{
    594          					if( pxCurrentTCB->uxPriority <= uxPriority )
   \   00000076   0x6AB0             LDR      R0,[R6, #+40]
   \   00000078   0x6AC0             LDR      R0,[R0, #+44]
   \   0000007A   0x4285             CMP      R5,R0
   \   0000007C   0xD300             BCC.N    ??xTaskGenericCreate_3
    595          					{
    596          						pxCurrentTCB = pxNewTCB;
   \   0000007E   0x62B4             STR      R4,[R6, #+40]
    597          					}
    598          				}
    599          			}
    600          
    601          			uxTaskNumber++;
   \                     ??xTaskGenericCreate_3: (+1)
   \   00000080   0x6EF0             LDR      R0,[R6, #+108]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x66F0             STR      R0,[R6, #+108]
    602          
    603          			#if ( configUSE_TRACE_FACILITY == 1 )
    604          			{
    605          				/* Add a counter into the TCB for tracing only. */
    606          				pxNewTCB->uxTCBNumber = uxTaskNumber;
   \   00000086   0x6460             STR      R0,[R4, #+68]
    607          			}
    608          			#endif /* configUSE_TRACE_FACILITY */
    609          			traceTASK_CREATE( pxNewTCB );
    610          
    611          			prvAddTaskToReadyList( pxNewTCB );
   \   00000088   0x6AE0             LDR      R0,[R4, #+44]
   \   0000008A   0x6D71             LDR      R1,[R6, #+84]
   \   0000008C   0x4281             CMP      R1,R0
   \   0000008E   0xD200             BCS.N    ??xTaskGenericCreate_4
   \   00000090   0x6570             STR      R0,[R6, #+84]
   \                     ??xTaskGenericCreate_4: (+1)
   \   00000092   0x1D21             ADDS     R1,R4,#+4
   \   00000094   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   00000098   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   0000009C   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   000000A0   0x.... 0x....      BL       vListInsertEnd
    612          
    613          			xReturn = pdPASS;
   \   000000A4   0x2401             MOVS     R4,#+1
    614          			portSETUP_TCB( pxNewTCB );
    615          		}
    616          		taskEXIT_CRITICAL();
   \   000000A6   0x.... 0x....      BL       vPortExitCritical
   \   000000AA   0xE001             B.N      ??xTaskGenericCreate_5
    617          	}
    618          	else
    619          	{
    620          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   \                     ??xTaskGenericCreate_0: (+1)
   \   000000AC   0xF04F 0x34FF      MOV      R4,#-1
    621          		traceTASK_CREATE_FAILED();
    622          	}
    623          
    624          	if( xReturn == pdPASS )
   \                     ??xTaskGenericCreate_5: (+1)
   \   000000B0   0x2C01             CMP      R4,#+1
   \   000000B2   0xD10A             BNE.N    ??xTaskGenericCreate_6
    625          	{
    626          		if( xSchedulerRunning != pdFALSE )
   \   000000B4   0x.... 0x....      LDR.W    R6,??DataTable37
   \   000000B8   0x6DB0             LDR      R0,[R6, #+88]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD005             BEQ.N    ??xTaskGenericCreate_6
    627          		{
    628          			/* If the created task is of a higher priority than the current task
    629          			then it should run now. */
    630          			if( pxCurrentTCB->uxPriority < uxPriority )
   \   000000BE   0x6AB0             LDR      R0,[R6, #+40]
   \   000000C0   0x6AC0             LDR      R0,[R0, #+44]
   \   000000C2   0x42A8             CMP      R0,R5
   \   000000C4   0xD201             BCS.N    ??xTaskGenericCreate_6
    631          			{
    632          				taskYIELD_IF_USING_PREEMPTION();
   \   000000C6   0x.... 0x....      BL       vPortYield
    633          			}
    634          		}
    635          	}
    636          
    637          	return xReturn;
   \                     ??xTaskGenericCreate_6: (+1)
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    638          }
    639          /*-----------------------------------------------------------*/
    640          
    641          #if ( INCLUDE_vTaskDelete == 1 )
    642          

   \                                 In section .text, align 2, keep-with-next
    643          	void vTaskDelete( xTaskHandle xTaskToDelete )
    644          	{
   \                     vTaskDelete: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    645          	tskTCB *pxTCB;
    646          
    647          		taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    648          		{
    649          			/* If null is passed in here then we are deleting ourselves. */
    650          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD102             BNE.N    ??vTaskDelete_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000010   0x6A84             LDR      R4,[R0, #+40]
    651          
    652          			/* Remove task from the ready list and place in the	termination list.
    653          			This will stop the task from be scheduled.  The idle task will check
    654          			the termination list and free up any memory allocated by the
    655          			scheduler for the TCB and stack. */
    656          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \                     ??vTaskDelete_0: (+1)
   \   00000012   0x1D20             ADDS     R0,R4,#+4
   \   00000014   0x.... 0x....      BL       uxListRemove
    657          			{
    658          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    659          			}
    660          
    661          			/* Is the task waiting on an event also? */
    662          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \   00000018   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??vTaskDelete_1
    663          			{
    664          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   0000001E   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000022   0x.... 0x....      BL       uxListRemove
    665          			}
    666          
    667          			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
   \                     ??vTaskDelete_1: (+1)
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable37
   \   0000002A   0x1D21             ADDS     R1,R4,#+4
   \   0000002C   0xF105 0x0014      ADD      R0,R5,#+20
   \   00000030   0x.... 0x....      BL       vListInsertEnd
    668          
    669          			/* Increment the ucTasksDeleted variable so the idle task knows
    670          			there is a task that has been deleted and that it should therefore
    671          			check the xTasksWaitingTermination list. */
    672          			++uxTasksDeleted;
   \   00000034   0x6B68             LDR      R0,[R5, #+52]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0x6368             STR      R0,[R5, #+52]
    673          
    674          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    675          			can detect that the task lists need re-generating. */
    676          			uxTaskNumber++;
   \   0000003A   0x6EE8             LDR      R0,[R5, #+108]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x66E8             STR      R0,[R5, #+108]
    677          
    678          			traceTASK_DELETE( pxTCB );
    679          		}
    680          		taskEXIT_CRITICAL();
   \   00000040   0x.... 0x....      BL       vPortExitCritical
    681          
    682          		/* Force a reschedule if we have just deleted the current task. */
    683          		if( xSchedulerRunning != pdFALSE )
   \   00000044   0x6DA8             LDR      R0,[R5, #+88]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD006             BEQ.N    ??vTaskDelete_2
    684          		{
    685          			if( pxTCB == pxCurrentTCB )
   \   0000004A   0x6AA8             LDR      R0,[R5, #+40]
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD103             BNE.N    ??vTaskDelete_2
    686          			{
    687          				portYIELD_WITHIN_API();
   \   00000050   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000054   0x.... 0x....      B.W      vPortYield
    688          			}
    689          		}
    690          	}
   \                     ??vTaskDelete_2: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    691          
    692          #endif /* INCLUDE_vTaskDelete */
    693          /*-----------------------------------------------------------*/
    694          
    695          #if ( INCLUDE_vTaskDelayUntil == 1 )
    696          

   \                                 In section .text, align 2, keep-with-next
    697          	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
    698          	{
   \                     vTaskDelayUntil: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    699          	portTickType xTimeToWake;
    700          	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   \   00000006   0x2600             MOVS     R6,#+0
    701          
    702          		configASSERT( pxPreviousWakeTime );
    703          		configASSERT( ( xTimeIncrement > 0U ) );
    704          
    705          		vTaskSuspendAll();
   \   00000008   0x.... 0x....      BL       vTaskSuspendAll
    706          		{
    707          			/* Minor optimisation.  The tick count cannot change in this
    708          			block. */
    709          			const portTickType xConstTickCount = xTickCount;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000010   0x6D01             LDR      R1,[R0, #+80]
    710          
    711          			/* Generate the tick time at which the task wants to wake. */
    712          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   \   00000012   0x6822             LDR      R2,[R4, #+0]
   \   00000014   0x18AD             ADDS     R5,R5,R2
    713          
    714          			if( xConstTickCount < *pxPreviousWakeTime )
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD205             BCS.N    ??vTaskDelayUntil_0
    715          			{
    716          				/* The tick count has overflowed since this function was
    717          				lasted called.  In this case the only time we should ever
    718          				actually delay is if the wake time has also	overflowed,
    719          				and the wake time is greater than the tick time.  When this
    720          				is the case it is as if neither time had overflowed. */
    721          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   \   0000001A   0x4295             CMP      R5,R2
   \   0000001C   0xD208             BCS.N    ??vTaskDelayUntil_1
   \   0000001E   0x42A9             CMP      R1,R5
   \   00000020   0xD206             BCS.N    ??vTaskDelayUntil_1
    722          				{
    723          					xShouldDelay = pdTRUE;
   \   00000022   0x2601             MOVS     R6,#+1
   \   00000024   0xE004             B.N      ??vTaskDelayUntil_1
    724          				}
    725          			}
    726          			else
    727          			{
    728          				/* The tick time has not overflowed.  In this case we will
    729          				delay if either the wake time has overflowed, and/or the
    730          				tick time is less than the wake time. */
    731          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   \                     ??vTaskDelayUntil_0: (+1)
   \   00000026   0x4295             CMP      R5,R2
   \   00000028   0xD301             BCC.N    ??vTaskDelayUntil_2
   \   0000002A   0x42A9             CMP      R1,R5
   \   0000002C   0xD200             BCS.N    ??vTaskDelayUntil_1
    732          				{
    733          					xShouldDelay = pdTRUE;
   \                     ??vTaskDelayUntil_2: (+1)
   \   0000002E   0x2601             MOVS     R6,#+1
    734          				}
    735          			}
    736          
    737          			/* Update the wake time ready for the next call. */
    738          			*pxPreviousWakeTime = xTimeToWake;
   \                     ??vTaskDelayUntil_1: (+1)
   \   00000030   0x6025             STR      R5,[R4, #+0]
    739          
    740          			if( xShouldDelay != pdFALSE )
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD006             BEQ.N    ??vTaskDelayUntil_3
    741          			{
    742          				traceTASK_DELAY_UNTIL();
    743          
    744          				/* We must remove ourselves from the ready list before adding
    745          				ourselves to the blocked list as the same list item is used for
    746          				both lists. */
    747          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   00000036   0x6A80             LDR      R0,[R0, #+40]
   \   00000038   0x1D00             ADDS     R0,R0,#+4
   \   0000003A   0x.... 0x....      BL       uxListRemove
    748          				{
    749          					/* The current task must be in a ready list, so there is
    750          					no need to check, and the port reset macro can be called
    751          					directly. */
    752          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    753          				}
    754          
    755          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
    756          			}
    757          		}
    758          		xAlreadyYielded = xTaskResumeAll();
    759          
    760          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    761          		have put ourselves to sleep. */
    762          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelayUntil_3: (+1)
   \   00000044   0x.... 0x....      BL       xTaskResumeAll
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD103             BNE.N    ??vTaskDelayUntil_4
    763          		{
    764          			portYIELD_WITHIN_API();
   \   0000004C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000050   0x.... 0x....      B.W      vPortYield
    765          		}
    766          	}
   \                     ??vTaskDelayUntil_4: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    767          
    768          #endif /* INCLUDE_vTaskDelayUntil */
    769          /*-----------------------------------------------------------*/
    770          
    771          #if ( INCLUDE_vTaskDelay == 1 )
    772          

   \                                 In section .text, align 2, keep-with-next
    773          	void vTaskDelay( portTickType xTicksToDelay )
    774          	{
   \                     vTaskDelay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    775          	portTickType xTimeToWake;
    776          	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   \   00000004   0x2000             MOVS     R0,#+0
    777          
    778          		/* A delay time of zero just forces a reschedule. */
    779          		if( xTicksToDelay > ( portTickType ) 0U )
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??vTaskDelay_0
    780          		{
    781          			vTaskSuspendAll();
   \   0000000A   0x.... 0x....      BL       vTaskSuspendAll
    782          			{
    783          				traceTASK_DELAY();
    784          
    785          				/* A task that is removed from the event list while the
    786          				scheduler is suspended will not get placed in the ready
    787          				list or removed from the blocked list until the scheduler
    788          				is resumed.
    789          
    790          				This task cannot be in an event list as it is the currently
    791          				executing task. */
    792          
    793          				/* Calculate the time to wake - this may overflow but this is
    794          				not a problem. */
    795          				xTimeToWake = xTickCount + xTicksToDelay;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000012   0x6D01             LDR      R1,[R0, #+80]
   \   00000014   0x1864             ADDS     R4,R4,R1
    796          
    797          				/* We must remove ourselves from the ready list before adding
    798          				ourselves to the blocked list as the same list item is used for
    799          				both lists. */
    800          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   00000016   0x6A80             LDR      R0,[R0, #+40]
   \   00000018   0x1D00             ADDS     R0,R0,#+4
   \   0000001A   0x.... 0x....      BL       uxListRemove
    801          				{
    802          					/* The current task must be in a ready list, so there is
    803          					no need to check, and the port reset macro can be called
    804          					directly. */
    805          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    806          				}
    807          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
    808          			}
    809          			xAlreadyYielded = xTaskResumeAll();
   \   00000024   0x.... 0x....      BL       xTaskResumeAll
    810          		}
    811          
    812          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    813          		have put ourselves to sleep. */
    814          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelay_0: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD103             BNE.N    ??vTaskDelay_1
    815          		{
    816          			portYIELD_WITHIN_API();
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030   0x.... 0x....      B.W      vPortYield
    817          		}
    818          	}
   \                     ??vTaskDelay_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    819          
    820          #endif /* INCLUDE_vTaskDelay */
    821          /*-----------------------------------------------------------*/
    822          
    823          #if ( INCLUDE_eTaskGetState == 1 )
    824          
    825          	eTaskState eTaskGetState( xTaskHandle xTask )
    826          	{
    827          	eTaskState eReturn;
    828          	xList *pxStateList;
    829          	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    830          
    831          		if( pxTCB == pxCurrentTCB )
    832          		{
    833          			/* The task calling this function is querying its own state. */
    834          			eReturn = eRunning;
    835          		}
    836          		else
    837          		{
    838          			taskENTER_CRITICAL();
    839          			{
    840          				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
    841          			}
    842          			taskEXIT_CRITICAL();
    843          
    844          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
    845          			{
    846          				/* The task being queried is referenced from one of the Blocked
    847          				lists. */
    848          				eReturn = eBlocked;
    849          			}
    850          
    851          			#if ( INCLUDE_vTaskSuspend == 1 )
    852          				else if( pxStateList == &xSuspendedTaskList )
    853          				{
    854          					/* The task being queried is referenced from the suspended
    855          					list.  Is it genuinely suspended or is it block
    856          					indefinitely? */
    857          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
    858          					{
    859          						eReturn = eSuspended;
    860          					}
    861          					else
    862          					{
    863          						eReturn = eBlocked;
    864          					}
    865          				}
    866          			#endif
    867          
    868          			#if ( INCLUDE_vTaskDelete == 1 )
    869          				else if( pxStateList == &xTasksWaitingTermination )
    870          				{
    871          					/* The task being queried is referenced from the deleted
    872          					tasks list. */
    873          					eReturn = eDeleted;
    874          				}
    875          			#endif
    876          
    877          			else
    878          			{
    879          				/* If the task is not in any other state, it must be in the
    880          				Ready (including pending ready) state. */
    881          				eReturn = eReady;
    882          			}
    883          		}
    884          
    885          		return eReturn;
    886          	}
    887          
    888          #endif /* INCLUDE_eTaskGetState */
    889          /*-----------------------------------------------------------*/
    890          
    891          #if ( INCLUDE_uxTaskPriorityGet == 1 )
    892          

   \                                 In section .text, align 2, keep-with-next
    893          	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
    894          	{
   \                     uxTaskPriorityGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    895          	tskTCB *pxTCB;
    896          	unsigned portBASE_TYPE uxReturn;
    897          
    898          		taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    899          		{
    900          			/* If null is passed in here then we are changing the
    901          			priority of the calling function. */
    902          			pxTCB = prvGetTCBFromHandle( xTask );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD102             BNE.N    ??uxTaskPriorityGet_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000010   0x6A84             LDR      R4,[R0, #+40]
    903          			uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGet_0: (+1)
   \   00000012   0x6AE4             LDR      R4,[R4, #+44]
    904          		}
    905          		taskEXIT_CRITICAL();
   \   00000014   0x.... 0x....      BL       vPortExitCritical
    906          
    907          		return uxReturn;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    908          	}
    909          
    910          #endif /* INCLUDE_uxTaskPriorityGet */
    911          /*-----------------------------------------------------------*/
    912          
    913          #if ( INCLUDE_vTaskPrioritySet == 1 )
    914          

   \                                 In section .text, align 2, keep-with-next
    915          	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
    916          	{
   \                     vTaskPrioritySet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
    917          	tskTCB *pxTCB;
    918          	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
    919          	portBASE_TYPE xYieldRequired = pdFALSE;
   \   00000008   0x2500             MOVS     R5,#+0
    920          
    921          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    922          
    923          		/* Ensure the new priority is valid. */
    924          		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
   \   0000000A   0x2F0C             CMP      R7,#+12
   \   0000000C   0xD300             BCC.N    ??vTaskPrioritySet_0
    925          		{
    926          			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   \   0000000E   0x270B             MOVS     R7,#+11
    927          		}
    928          
    929          		taskENTER_CRITICAL();
   \                     ??vTaskPrioritySet_0: (+1)
   \   00000010   0x.... 0x....      BL       vPortEnterCritical
    930          		{
    931          			/* If null is passed in here then it is the priority of the calling
    932          			task that is being changed. */
    933          			pxTCB = prvGetTCBFromHandle( xTask );
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD102             BNE.N    ??vTaskPrioritySet_1
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable37
   \   0000001C   0x6A86             LDR      R6,[R0, #+40]
    934          
    935          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
    936          
    937          			#if ( configUSE_MUTEXES == 1 )
    938          			{
    939          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   \                     ??vTaskPrioritySet_1: (+1)
   \   0000001E   0x6CF0             LDR      R0,[R6, #+76]
   \   00000020   0x4601             MOV      R1,R0
    940          			}
    941          			#else
    942          			{
    943          				uxCurrentBasePriority = pxTCB->uxPriority;
    944          			}
    945          			#endif
    946          
    947          			if( uxCurrentBasePriority != uxNewPriority )
   \   00000022   0x42B9             CMP      R1,R7
   \   00000024   0xD032             BEQ.N    ??vTaskPrioritySet_2
    948          			{
    949          				/* The priority change may have readied a task of higher
    950          				priority than the calling task. */
    951          				if( uxNewPriority > uxCurrentBasePriority )
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable37
   \   0000002A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000002C   0xD207             BCS.N    ??vTaskPrioritySet_3
    952          				{
    953          					if( pxTCB != pxCurrentTCB )
   \   0000002E   0x428E             CMP      R6,R1
   \   00000030   0xD008             BEQ.N    ??vTaskPrioritySet_4
    954          					{
    955          						/* The priority of a task other than the currently
    956          						running task is being raised.  Is the priority being
    957          						raised above that of the running task? */
    958          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   \   00000032   0x6AA1             LDR      R1,[R4, #+40]
   \   00000034   0x6AC9             LDR      R1,[R1, #+44]
   \   00000036   0x428F             CMP      R7,R1
   \   00000038   0xD304             BCC.N    ??vTaskPrioritySet_4
    959          						{
    960          							xYieldRequired = pdTRUE;
   \   0000003A   0x2501             MOVS     R5,#+1
   \   0000003C   0xE002             B.N      ??vTaskPrioritySet_4
    961          						}
    962          					}
    963          					else
    964          					{
    965          						/* The priority of the running task is being raised,
    966          						but the running task must already be the highest
    967          						priority task able to run so no yield is required. */
    968          					}
    969          				}
    970          				else if( pxTCB == pxCurrentTCB )
   \                     ??vTaskPrioritySet_3: (+1)
   \   0000003E   0x428E             CMP      R6,R1
   \   00000040   0xD100             BNE.N    ??vTaskPrioritySet_4
    971          				{
    972          					/* Setting the priority of the running task down means
    973          					there may now be another task of higher priority that
    974          					is ready to execute. */
    975          					xYieldRequired = pdTRUE;
   \   00000042   0x2501             MOVS     R5,#+1
    976          				}
    977          				else
    978          				{
    979          					/* Setting the priority of any other task down does not
    980          					require a yield as the running task must be above the
    981          					new priority of the task being modified. */
    982          				}
    983          
    984          				/* Remember the ready list the task might be referenced from
    985          				before its uxPriority member is changed so the
    986          				taskRESET_READY_PRIORITY() macro can function correctly. */
    987          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   \                     ??vTaskPrioritySet_4: (+1)
   \   00000044   0x6AF1             LDR      R1,[R6, #+44]
    988          
    989          				#if ( configUSE_MUTEXES == 1 )
    990          				{
    991          					/* Only change the priority being used if the task is not
    992          					currently using an inherited priority. */
    993          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD100             BNE.N    ??vTaskPrioritySet_5
    994          					{
    995          						pxTCB->uxPriority = uxNewPriority;
   \   0000004A   0x62F7             STR      R7,[R6, #+44]
    996          					}
    997          
    998          					/* The base priority gets set whatever. */
    999          					pxTCB->uxBasePriority = uxNewPriority;
   \                     ??vTaskPrioritySet_5: (+1)
   \   0000004C   0x64F7             STR      R7,[R6, #+76]
   1000          				}
   1001          				#else
   1002          				{
   1003          					pxTCB->uxPriority = uxNewPriority;
   1004          				}
   1005          				#endif
   1006          
   1007          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   0000004E   0xF1C7 0x000C      RSB      R0,R7,#+12
   \   00000052   0x61B0             STR      R0,[R6, #+24]
   1008          
   1009          				/* If the task is in the blocked or suspended list we need do
   1010          				nothing more than change it's priority variable. However, if
   1011          				the task is in a ready list it needs to be removed and placed
   1012          				in the list appropriate to its new priority. */
   1013          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \   00000054   0x.... 0x....      LDR.W    R7,??DataTable37_1
   \   00000058   0xF04F 0x0814      MOV      R8,#+20
   \   0000005C   0x6970             LDR      R0,[R6, #+20]
   \   0000005E   0xFB08 0xF101      MUL      R1,R8,R1
   \   00000062   0x4439             ADD      R1,R7,R1
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD10D             BNE.N    ??vTaskPrioritySet_6
   1014          				{
   1015          					/* The task is currently in its ready list - remove before adding
   1016          					it to it's new ready list.  As we are in a critical section we
   1017          					can do this even if the scheduler is suspended. */
   1018          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   00000068   0x1D30             ADDS     R0,R6,#+4
   \   0000006A   0x.... 0x....      BL       uxListRemove
   1019          					{
   1020          						/* It is known that the task is in its ready list so
   1021          						there is no need to check again and the port level
   1022          						reset macro can be called directly. */
   1023          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1024          					}
   1025          					prvAddTaskToReadyList( pxTCB );
   \   0000006E   0x6AF0             LDR      R0,[R6, #+44]
   \   00000070   0x6D61             LDR      R1,[R4, #+84]
   \   00000072   0x4281             CMP      R1,R0
   \   00000074   0xD200             BCS.N    ??vTaskPrioritySet_7
   \   00000076   0x6560             STR      R0,[R4, #+84]
   \                     ??vTaskPrioritySet_7: (+1)
   \   00000078   0x1D31             ADDS     R1,R6,#+4
   \   0000007A   0xFB08 0xF000      MUL      R0,R8,R0
   \   0000007E   0x4438             ADD      R0,R7,R0
   \   00000080   0x.... 0x....      BL       vListInsertEnd
   1026          				}
   1027          
   1028          				if( xYieldRequired == pdTRUE )
   \                     ??vTaskPrioritySet_6: (+1)
   \   00000084   0x2D01             CMP      R5,#+1
   \   00000086   0xD101             BNE.N    ??vTaskPrioritySet_2
   1029          				{
   1030          					taskYIELD_IF_USING_PREEMPTION();
   \   00000088   0x.... 0x....      BL       vPortYield
   1031          				}
   1032          
   1033          				/* Remove compiler warning about unused variables when the port
   1034          				optimised task selection is not being used. */
   1035          				( void ) uxPriorityUsedOnEntry;
   1036          			}
   1037          		}
   1038          		taskEXIT_CRITICAL();
   \                     ??vTaskPrioritySet_2: (+1)
   \   0000008C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000090   0x.... 0x....      B.W      vPortExitCritical
   1039          	}
   1040          
   1041          #endif /* INCLUDE_vTaskPrioritySet */
   1042          /*-----------------------------------------------------------*/
   1043          
   1044          #if ( INCLUDE_vTaskSuspend == 1 )
   1045          

   \                                 In section .text, align 2, keep-with-next
   1046          	void vTaskSuspend( xTaskHandle xTaskToSuspend )
   1047          	{
   \                     vTaskSuspend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1048          	tskTCB *pxTCB;
   1049          
   1050          		taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1051          		{
   1052          			/* If null is passed in here then it is the running task that is
   1053          			being suspended. */
   1054          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable37
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD100             BNE.N    ??vTaskSuspend_0
   \   00000010   0x6AAC             LDR      R4,[R5, #+40]
   1055          
   1056          			traceTASK_SUSPEND( pxTCB );
   1057          
   1058          			/* Remove task from the ready/delayed list and place in the	suspended list. */
   1059          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \                     ??vTaskSuspend_0: (+1)
   \   00000012   0x1D20             ADDS     R0,R4,#+4
   \   00000014   0x.... 0x....      BL       uxListRemove
   1060          			{
   1061          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1062          			}
   1063          
   1064          			/* Is the task waiting on an event also? */
   1065          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \   00000018   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??vTaskSuspend_1
   1066          			{
   1067          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   0000001E   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000022   0x.... 0x....      BL       uxListRemove
   1068          			}
   1069          
   1070          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   \                     ??vTaskSuspend_1: (+1)
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0xF105 0x0038      ADD      R0,R5,#+56
   \   0000002C   0x.... 0x....      BL       vListInsertEnd
   1071          		}
   1072          		taskEXIT_CRITICAL();
   \   00000030   0x.... 0x....      BL       vPortExitCritical
   1073          
   1074          		if( pxTCB == pxCurrentTCB )
   \   00000034   0x6AA8             LDR      R0,[R5, #+40]
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD110             BNE.N    ??vTaskSuspend_2
   1075          		{
   1076          			if( xSchedulerRunning != pdFALSE )
   \   0000003A   0x6DA8             LDR      R0,[R5, #+88]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??vTaskSuspend_3
   1077          			{
   1078          				/* The current task has just been suspended. */
   1079          				portYIELD_WITHIN_API();
   \   00000040   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000044   0x.... 0x....      B.W      vPortYield
   1080          			}
   1081          			else
   1082          			{
   1083          				/* The scheduler is not running, but the task that was pointed
   1084          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1085          				must be adjusted to point to a different task. */
   1086          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   \                     ??vTaskSuspend_3: (+1)
   \   00000048   0x6BA8             LDR      R0,[R5, #+56]
   \   0000004A   0x6CE9             LDR      R1,[R5, #+76]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD102             BNE.N    ??vTaskSuspend_4
   1087          				{
   1088          					/* No other tasks are ready, so set pxCurrentTCB back to
   1089          					NULL so when the next task is created pxCurrentTCB will
   1090          					be set to point to it no matter what its relative priority
   1091          					is. */
   1092          					pxCurrentTCB = NULL;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x62A8             STR      R0,[R5, #+40]
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}
   1093          				}
   1094          				else
   1095          				{
   1096          					vTaskSwitchContext();
   \                     ??vTaskSuspend_4: (+1)
   \   00000056   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000005A   0x....             B.N      vTaskSwitchContext
   1097          				}
   1098          			}
   1099          		}
   1100          	}
   \                     ??vTaskSuspend_2: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1101          
   1102          #endif /* INCLUDE_vTaskSuspend */
   1103          /*-----------------------------------------------------------*/
   1104          
   1105          #if ( INCLUDE_vTaskSuspend == 1 )
   1106          

   \                                 In section .text, align 2, keep-with-next
   1107          	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
   1108          	{
   \                     xTaskIsTaskSuspended: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1109          	portBASE_TYPE xReturn = pdFALSE;
   \   00000002   0x2100             MOVS     R1,#+0
   1110          	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
   1111          
   1112          		/* It does not make sense to check if the calling task is suspended. */
   1113          		configASSERT( xTask );
   1114          
   1115          		/* Is the task we are attempting to resume actually in the
   1116          		suspended list? */
   1117          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable37
   \   00000008   0x6943             LDR      R3,[R0, #+20]
   \   0000000A   0xF102 0x0438      ADD      R4,R2,#+56
   \   0000000E   0x42A3             CMP      R3,R4
   \   00000010   0xD105             BNE.N    ??xTaskIsTaskSuspended_0
   1118          		{
   1119          			/* Has the task already been resumed from within an ISR? */
   1120          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   \   00000012   0x6A80             LDR      R0,[R0, #+40]
   \   00000014   0x4290             CMP      R0,R2
   \   00000016   0xD002             BEQ.N    ??xTaskIsTaskSuspended_0
   1121          			{
   1122          				/* Is it in the suspended list because it is in the
   1123          				Suspended state?  It is possible to be in the suspended
   1124          				list because it is blocked on a task with no timeout
   1125          				specified. */
   1126          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD100             BNE.N    ??xTaskIsTaskSuspended_0
   1127          				{
   1128          					xReturn = pdTRUE;
   \   0000001C   0x2101             MOVS     R1,#+1
   1129          				}
   1130          			}
   1131          		}
   1132          
   1133          		return xReturn;
   \                     ??xTaskIsTaskSuspended_0: (+1)
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
   1134          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1135          
   1136          #endif /* INCLUDE_vTaskSuspend */
   1137          /*-----------------------------------------------------------*/
   1138          
   1139          #if ( INCLUDE_vTaskSuspend == 1 )
   1140          

   \                                 In section .text, align 2, keep-with-next
   1141          	void vTaskResume( xTaskHandle xTaskToResume )
   1142          	{
   \                     vTaskResume: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   1143          	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
   1144          
   1145          		/* It does not make sense to resume the calling task. */
   1146          		configASSERT( xTaskToResume );
   1147          
   1148          		/* The parameter cannot be NULL as it is impossible to resume the
   1149          		currently executing task. */
   1150          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   \   00000004   0xD027             BEQ.N    ??vTaskResume_0
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable37
   \   0000000A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD022             BEQ.N    ??vTaskResume_0
   1151          		{
   1152          			taskENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       vPortEnterCritical
   1153          			{
   1154          				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       xTaskIsTaskSuspended
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD117             BNE.N    ??vTaskResume_1
   1155          				{
   1156          					traceTASK_RESUME( pxTCB );
   1157          
   1158          					/* As we are in a critical section we can access the ready
   1159          					lists even if the scheduler is suspended. */
   1160          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   \   0000001E   0x1D28             ADDS     R0,R5,#+4
   \   00000020   0x.... 0x....      BL       uxListRemove
   1161          					prvAddTaskToReadyList( pxTCB );
   \   00000024   0x6AE8             LDR      R0,[R5, #+44]
   \   00000026   0x6D61             LDR      R1,[R4, #+84]
   \   00000028   0x4281             CMP      R1,R0
   \   0000002A   0xD200             BCS.N    ??vTaskResume_2
   \   0000002C   0x6560             STR      R0,[R4, #+84]
   \                     ??vTaskResume_2: (+1)
   \   0000002E   0x1D29             ADDS     R1,R5,#+4
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   00000034   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   00000038   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   0000003C   0x.... 0x....      BL       vListInsertEnd
   1162          
   1163          					/* We may have just resumed a higher priority task. */
   1164          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   00000040   0x6AE8             LDR      R0,[R5, #+44]
   \   00000042   0x6AA1             LDR      R1,[R4, #+40]
   \   00000044   0x6AC9             LDR      R1,[R1, #+44]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD301             BCC.N    ??vTaskResume_1
   1165          					{
   1166          						/* This yield may not cause the task just resumed to run,
   1167          						but will leave the lists in the correct state for the
   1168          						next yield. */
   1169          						taskYIELD_IF_USING_PREEMPTION();
   \   0000004A   0x.... 0x....      BL       vPortYield
   1170          					}
   1171          				}
   1172          			}
   1173          			taskEXIT_CRITICAL();
   \                     ??vTaskResume_1: (+1)
   \   0000004E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000052   0x.... 0x....      B.W      vPortExitCritical
   1174          		}
   1175          	}
   \                     ??vTaskResume_0: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1176          
   1177          #endif /* INCLUDE_vTaskSuspend */
   1178          
   1179          /*-----------------------------------------------------------*/
   1180          
   1181          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1182          

   \                                 In section .text, align 2, keep-with-next
   1183          	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
   1184          	{
   \                     xTaskResumeFromISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1185          	portBASE_TYPE xYieldRequired = pdFALSE;
   \   00000004   0x2500             MOVS     R5,#+0
   1186          	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
   1187          	unsigned portBASE_TYPE uxSavedInterruptStatus;
   1188          
   1189          		configASSERT( xTaskToResume );
   1190          
   1191          		/* RTOS ports that support interrupt nesting have the concept of a
   1192          		maximum	system call (or maximum API call) interrupt priority.
   1193          		Interrupts that are	above the maximum system call priority are keep
   1194          		permanently enabled, even when the RTOS kernel is in a critical section,
   1195          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1196          		is defined in FreeRTOSConfig.h then
   1197          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1198          		failure if a FreeRTOS API function is called from an interrupt that has
   1199          		been assigned a priority above the configured maximum system call
   1200          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1201          		from interrupts	that have been assigned a priority at or (logically)
   1202          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1203          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1204          		simple as possible.  More information (albeit Cortex-M specific) is
   1205          		provided on the following link:
   1206          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1207          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1208          
   1209          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000006   0x.... 0x....      BL       ulPortSetInterruptMask
   \   0000000A   0x4606             MOV      R6,R0
   1210          		{
   1211          			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       xTaskIsTaskSuspended
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD121             BNE.N    ??xTaskResumeFromISR_0
   1212          			{
   1213          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1214          
   1215          				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable37
   \   0000001A   0x6DF8             LDR      R0,[R7, #+92]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD117             BNE.N    ??xTaskResumeFromISR_1
   1216          				{
   1217          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   00000020   0x6AE0             LDR      R0,[R4, #+44]
   \   00000022   0x6AB9             LDR      R1,[R7, #+40]
   \   00000024   0x6AC9             LDR      R1,[R1, #+44]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD300             BCC.N    ??xTaskResumeFromISR_2
   1218          					{
   1219          						xYieldRequired = pdTRUE;
   \   0000002A   0x2501             MOVS     R5,#+1
   1220          					}
   1221          
   1222          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   \                     ??xTaskResumeFromISR_2: (+1)
   \   0000002C   0x1D20             ADDS     R0,R4,#+4
   \   0000002E   0x.... 0x....      BL       uxListRemove
   1223          					prvAddTaskToReadyList( pxTCB );
   \   00000032   0x6AE0             LDR      R0,[R4, #+44]
   \   00000034   0x6D79             LDR      R1,[R7, #+84]
   \   00000036   0x4281             CMP      R1,R0
   \   00000038   0xD200             BCS.N    ??xTaskResumeFromISR_3
   \   0000003A   0x6578             STR      R0,[R7, #+84]
   \                     ??xTaskResumeFromISR_3: (+1)
   \   0000003C   0x1D21             ADDS     R1,R4,#+4
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   00000042   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   00000046   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   0000004A   0x.... 0x....      BL       vListInsertEnd
   \   0000004E   0xE004             B.N      ??xTaskResumeFromISR_0
   1224          				}
   1225          				else
   1226          				{
   1227          					/* We cannot access the delayed or ready lists, so will hold this
   1228          					task pending until the scheduler is resumed, at which point a
   1229          					yield will be performed if necessary. */
   1230          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeFromISR_1: (+1)
   \   00000050   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       vListInsertEnd
   1231          				}
   1232          			}
   1233          		}
   1234          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskResumeFromISR_0: (+1)
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       vPortClearInterruptMask
   1235          
   1236          		return xYieldRequired;
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1237          	}
   1238          
   1239          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1240          /*-----------------------------------------------------------*/
   1241          

   \                                 In section .text, align 2, keep-with-next
   1242          void vTaskStartScheduler( void )
   1243          {
   \                     vTaskStartScheduler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1244          portBASE_TYPE xReturn;
   1245          
   1246          	/* Add the idle task at the lowest priority. */
   1247          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1248          	{
   1249          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1250          		be returned by the xTaskGetIdleTaskHandle() function. */
   1251          		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1252          	}
   1253          	#else
   1254          	{
   1255          		/* Create the idle task without storing its handle. */
   1256          		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9003             STR      R0,[SP, #+12]
   \   00000008   0x9002             STR      R0,[SP, #+8]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x4603             MOV      R3,R0
   \   00000010   0x2280             MOVS     R2,#+128
   \   00000012   0x.... 0x....      ADR.W    R1,?_0
   \   00000016   0x.... 0x....      ADR.W    R0,prvIdleTask
   \   0000001A   0x.... 0x....      BL       xTaskGenericCreate
   1257          	}
   1258          	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1259          
   1260          	#if ( configUSE_TIMERS == 1 )
   1261          	{
   1262          		if( xReturn == pdPASS )
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??vTaskStartScheduler_0
   1263          		{
   1264          			xReturn = xTimerCreateTimerTask();
   \   00000022   0x.... 0x....      BL       xTimerCreateTimerTask
   1265          		}
   1266          	}
   1267          	#endif /* configUSE_TIMERS */
   1268          
   1269          	if( xReturn == pdPASS )
   \                     ??vTaskStartScheduler_0: (+1)
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD10C             BNE.N    ??vTaskStartScheduler_1
   1270          	{
   1271          		/* Interrupts are turned off here, to ensure a tick does not occur
   1272          		before or during the call to xPortStartScheduler().  The stacks of
   1273          		the created tasks contain a status word with interrupts switched on
   1274          		so interrupts will automatically get re-enabled when the first task
   1275          		starts to run. */
   1276          		portDISABLE_INTERRUPTS();
   \   0000002A   0x.... 0x....      BL       ulPortSetInterruptMask
   1277          
   1278          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1279          		{
   1280          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1281          			structure specific to the task that will run first. */
   1282          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1283          		}
   1284          		#endif /* configUSE_NEWLIB_REENTRANT */
   1285          
   1286          		xSchedulerRunning = pdTRUE;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x6581             STR      R1,[R0, #+88]
   1287          		xTickCount = ( portTickType ) 0U;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6501             STR      R1,[R0, #+80]
   1288          
   1289          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1290          		macro must be defined to configure the timer/counter used to generate
   1291          		the run time counter time base. */
   1292          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1293          
   1294          		/* Setting up the timer tick is hardware specific and thus in the
   1295          		portable interface. */
   1296          		if( xPortStartScheduler() != pdFALSE )
   \   0000003A   0xB005             ADD      SP,SP,#+20
   \   0000003C   0xF85D 0xEB04      POP      {LR}
   \   00000040   0x.... 0x....      B.W      xPortStartScheduler
   1297          		{
   1298          			/* Should not reach here as if the scheduler is running the
   1299          			function will not return. */
   1300          		}
   1301          		else
   1302          		{
   1303          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1304          		}
   1305          	}
   1306          	else
   1307          	{
   1308          		/* This line will only be reached if the kernel could not be started,
   1309          		because there was not enough FreeRTOS heap to create the idle task
   1310          		or the timer task. */
   1311          		configASSERT( xReturn );
   1312          	}
   1313          }
   \                     ??vTaskStartScheduler_1: (+1)
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xBD00             POP      {PC}             ;; return
   1314          /*-----------------------------------------------------------*/
   1315          

   \                                 In section .text, align 2, keep-with-next
   1316          void vTaskEndScheduler( void )
   1317          {
   \                     vTaskEndScheduler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1318          	/* Stop the scheduler interrupts and call the portable scheduler end
   1319          	routine so the original ISRs can be restored if necessary.  The port
   1320          	layer must ensure interrupts enable	bit is left in the correct state. */
   1321          	portDISABLE_INTERRUPTS();
   \   00000002   0x.... 0x....      BL       ulPortSetInterruptMask
   1322          	xSchedulerRunning = pdFALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable37
   \   0000000C   0x6588             STR      R0,[R1, #+88]
   1323          	vPortEndScheduler();
   \   0000000E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000012   0x.... 0x....      B.W      vPortEndScheduler
   1324          }
   1325          /*----------------------------------------------------------*/
   1326          

   \                                 In section .text, align 2, keep-with-next
   1327          void vTaskSuspendAll( void )
   1328          {
   1329          	/* A critical section is not required as the variable is of type
   1330          	portBASE_TYPE. */
   1331          	++uxSchedulerSuspended;
   \                     vTaskSuspendAll: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000004   0x6DC1             LDR      R1,[R0, #+92]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x65C1             STR      R1,[R0, #+92]
   1332          }
   \   0000000A   0x4770             BX       LR               ;; return
   1333          /*----------------------------------------------------------*/
   1334          
   1335          #if ( configUSE_TICKLESS_IDLE != 0 )
   1336          
   1337          	static portTickType prvGetExpectedIdleTime( void )
   1338          	{
   1339          	portTickType xReturn;
   1340          
   1341          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1342          		{
   1343          			xReturn = 0;
   1344          		}
   1345          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1346          		{
   1347          			/* There are other idle priority tasks in the ready state.  If
   1348          			time slicing is used then the very next tick interrupt must be
   1349          			processed. */
   1350          			xReturn = 0;
   1351          		}
   1352          		else
   1353          		{
   1354          			xReturn = xNextTaskUnblockTime - xTickCount;
   1355          		}
   1356          
   1357          		return xReturn;
   1358          	}
   1359          
   1360          #endif /* configUSE_TICKLESS_IDLE */
   1361          /*----------------------------------------------------------*/
   1362          

   \                                 In section .text, align 2, keep-with-next
   1363          signed portBASE_TYPE xTaskResumeAll( void )
   1364          {
   \                     xTaskResumeAll: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1365          tskTCB *pxTCB;
   1366          portBASE_TYPE xAlreadyYielded = pdFALSE;
   \   00000002   0x2400             MOVS     R4,#+0
   1367          
   1368          	/* If uxSchedulerSuspended is zero then this function does not match a
   1369          	previous call to vTaskSuspendAll(). */
   1370          	configASSERT( uxSchedulerSuspended );
   1371          
   1372          	/* It is possible that an ISR caused a task to be removed from an event
   1373          	list while the scheduler was suspended.  If this was the case then the
   1374          	removed task will have been added to the xPendingReadyList.  Once the
   1375          	scheduler has been resumed it is safe to move all the pending ready
   1376          	tasks from this list into their appropriate ready list. */
   1377          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1378          	{
   1379          		--uxSchedulerSuspended;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable37
   \   0000000C   0x6DE8             LDR      R0,[R5, #+92]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x65E8             STR      R0,[R5, #+92]
   1380          
   1381          		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000012   0x6DE8             LDR      R0,[R5, #+92]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD13A             BNE.N    ??xTaskResumeAll_0
   1382          		{
   1383          			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   \   00000018   0x6CE8             LDR      R0,[R5, #+76]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD11E             BNE.N    ??xTaskResumeAll_1
   \   0000001E   0xE036             B.N      ??xTaskResumeAll_0
   1384          			{
   1385          				/* Move any readied tasks from the pending list into the
   1386          				appropriate ready list. */
   1387          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1388          				{
   1389          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   \                     ??xTaskResumeAll_2: (+1)
   \   00000020   0x68E8             LDR      R0,[R5, #+12]
   \   00000022   0x68C6             LDR      R6,[R0, #+12]
   1390          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   00000024   0xF106 0x0018      ADD      R0,R6,#+24
   \   00000028   0x.... 0x....      BL       uxListRemove
   1391          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \   0000002C   0x1D30             ADDS     R0,R6,#+4
   \   0000002E   0x.... 0x....      BL       uxListRemove
   1392          					prvAddTaskToReadyList( pxTCB );
   \   00000032   0x6AF0             LDR      R0,[R6, #+44]
   \   00000034   0x6D69             LDR      R1,[R5, #+84]
   \   00000036   0x4281             CMP      R1,R0
   \   00000038   0xD200             BCS.N    ??xTaskResumeAll_3
   \   0000003A   0x6568             STR      R0,[R5, #+84]
   \                     ??xTaskResumeAll_3: (+1)
   \   0000003C   0x1D31             ADDS     R1,R6,#+4
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   00000042   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   00000046   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   0000004A   0x.... 0x....      BL       vListInsertEnd
   1393          
   1394          					/* If we have moved a task that has a priority higher than
   1395          					the current task then we should yield. */
   1396          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   0000004E   0x6AF0             LDR      R0,[R6, #+44]
   \   00000050   0x6AA9             LDR      R1,[R5, #+40]
   \   00000052   0x6AC9             LDR      R1,[R1, #+44]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD301             BCC.N    ??xTaskResumeAll_1
   1397          					{
   1398          						xYieldPending = pdTRUE;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x6668             STR      R0,[R5, #+100]
   1399          					}
   1400          				}
   \                     ??xTaskResumeAll_1: (+1)
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1DE             BNE.N    ??xTaskResumeAll_2
   1401          
   1402          				/* If any ticks occurred while the scheduler was suspended then
   1403          				they should be processed now.  This ensures the tick count does not
   1404          				slip, and that any delayed tasks are resumed at the correct time. */
   1405          				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
   \   00000062   0x6E28             LDR      R0,[R5, #+96]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD109             BNE.N    ??xTaskResumeAll_4
   \   00000068   0xE00B             B.N      ??xTaskResumeAll_5
   1406          				{
   1407          					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
   1408          					{
   1409          						if( xTaskIncrementTick() != pdFALSE )
   \                     ??xTaskResumeAll_6: (+1)
   \   0000006A   0x.... 0x....      BL       xTaskIncrementTick
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD001             BEQ.N    ??xTaskResumeAll_7
   1410          						{
   1411          							xYieldPending = pdTRUE;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x6668             STR      R0,[R5, #+100]
   1412          						}
   1413          						--uxPendedTicks;
   \                     ??xTaskResumeAll_7: (+1)
   \   00000076   0x6E28             LDR      R0,[R5, #+96]
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x6628             STR      R0,[R5, #+96]
   1414          					}
   \                     ??xTaskResumeAll_4: (+1)
   \   0000007C   0x6E28             LDR      R0,[R5, #+96]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD1F3             BNE.N    ??xTaskResumeAll_6
   1415          				}
   1416          
   1417          				if( xYieldPending == pdTRUE )
   \                     ??xTaskResumeAll_5: (+1)
   \   00000082   0x6E68             LDR      R0,[R5, #+100]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD102             BNE.N    ??xTaskResumeAll_0
   1418          				{
   1419          					#if( configUSE_PREEMPTION != 0 )
   1420          					{
   1421          						xAlreadyYielded = pdTRUE;
   \   00000088   0x2401             MOVS     R4,#+1
   1422          					}
   1423          					#endif
   1424          					taskYIELD_IF_USING_PREEMPTION();
   \   0000008A   0x.... 0x....      BL       vPortYield
   1425          				}
   1426          			}
   1427          		}
   1428          	}
   1429          	taskEXIT_CRITICAL();
   \                     ??xTaskResumeAll_0: (+1)
   \   0000008E   0x.... 0x....      BL       vPortExitCritical
   1430          
   1431          	return xAlreadyYielded;
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0xBD70             POP      {R4-R6,PC}       ;; return
   1432          }
   1433          /*-----------------------------------------------------------*/
   1434          

   \                                 In section .text, align 2, keep-with-next
   1435          portTickType xTaskGetTickCount( void )
   1436          {
   \                     xTaskGetTickCount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1437          portTickType xTicks;
   1438          
   1439          	/* Critical section required if running on a 16 bit processor. */
   1440          	taskENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       vPortEnterCritical
   1441          	{
   1442          		xTicks = xTickCount;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable37
   \   0000000A   0x6D04             LDR      R4,[R0, #+80]
   1443          	}
   1444          	taskEXIT_CRITICAL();
   \   0000000C   0x.... 0x....      BL       vPortExitCritical
   1445          
   1446          	return xTicks;
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1447          }
   1448          /*-----------------------------------------------------------*/
   1449          

   \                                 In section .text, align 2, keep-with-next
   1450          portTickType xTaskGetTickCountFromISR( void )
   1451          {
   \                     xTaskGetTickCountFromISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1452          portTickType xReturn;
   1453          unsigned portBASE_TYPE uxSavedInterruptStatus;
   1454          
   1455          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1456          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1457          	above the maximum system call priority are keep permanently enabled, even
   1458          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1459          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1460          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1461          	failure if a FreeRTOS API function is called from an interrupt that has been
   1462          	assigned a priority above the configured maximum system call priority.
   1463          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1464          	that have been assigned a priority at or (logically) below the maximum
   1465          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1466          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1467          	More information (albeit Cortex-M specific) is provided on the following
   1468          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1469          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1470          
   1471          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000002   0x.... 0x....      BL       ulPortSetInterruptMask
   1472          	xReturn = xTickCount;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable37
   \   0000000A   0x6D0C             LDR      R4,[R1, #+80]
   1473          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \   0000000C   0x.... 0x....      BL       vPortClearInterruptMask
   1474          
   1475          	return xReturn;
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1476          }
   1477          /*-----------------------------------------------------------*/
   1478          

   \                                 In section .text, align 2, keep-with-next
   1479          unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
   1480          {
   1481          	/* A critical section is not required because the variables are of type
   1482          	portBASE_TYPE. */
   1483          	return uxCurrentNumberOfTasks;
   \                     uxTaskGetNumberOfTasks: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable37
   \   00000004   0x6CC0             LDR      R0,[R0, #+76]
   \   00000006   0x4770             BX       LR               ;; return
   1484          }
   1485          /*-----------------------------------------------------------*/
   1486          
   1487          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1488          
   1489          	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
   1490          	{
   1491          	tskTCB *pxTCB;
   1492          
   1493          		/* If null is passed in here then the name of the calling task is being queried. */
   1494          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1495          		configASSERT( pxTCB );
   1496          		return &( pxTCB->pcTaskName[ 0 ] );
   1497          	}
   1498          
   1499          #endif /* INCLUDE_pcTaskGetTaskName */
   1500          /*-----------------------------------------------------------*/
   1501          
   1502          #if ( configUSE_TRACE_FACILITY == 1 )
   1503          

   \                                 In section .text, align 2, keep-with-next
   1504          	unsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE_TYPE uxArraySize, unsigned long *pulTotalRunTime )
   1505          	{
   \                     uxTaskGetSystemState: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4615             MOV      R5,R2
   1506          	unsigned portBASE_TYPE uxTask = 0, uxQueue = configMAX_PRIORITIES;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF04F 0x080C      MOV      R8,#+12
   1507          
   1508          		vTaskSuspendAll();
   \   00000010   0x.... 0x....      BL       vTaskSuspendAll
   1509          		{
   1510          			/* Is there a space in the array for each task in the system? */
   1511          			if( uxArraySize >= uxCurrentNumberOfTasks )
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable37
   \   00000018   0x6CF0             LDR      R0,[R6, #+76]
   \   0000001A   0x4581             CMP      R9,R0
   \   0000001C   0xD332             BCC.N    ??uxTaskGetSystemState_0
   1512          			{
   1513          				/* Fill in an xTaskStatusType structure with information on each
   1514          				task in the Ready state. */
   1515          				do
   1516          				{
   1517          					uxQueue--;
   \                     ??uxTaskGetSystemState_1: (+1)
   \   0000001E   0xF1A8 0x0801      SUB      R8,R8,#+1
   1518          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   00000028   0xEB08 0x0188      ADD      R1,R8,R8, LSL #+2
   \   0000002C   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \   00000030   0xEB04 0x1047      ADD      R0,R4,R7, LSL #+5
   \   00000034   0x.... 0x....      BL       prvListTaskWithinSingleList
   \   00000038   0x19C7             ADDS     R7,R0,R7
   1519          
   1520          				} while( uxQueue > ( unsigned portBASE_TYPE ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   0000003A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003E   0xD1EE             BNE.N    ??uxTaskGetSystemState_1
   1521          
   1522          				/* Fill in an xTaskStatusType structure with information on each
   1523          				task in the Blocked state. */
   1524          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxDelayedTaskList, eBlocked );
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0x6AF1             LDR      R1,[R6, #+44]
   \   00000044   0xEB04 0x1047      ADD      R0,R4,R7, LSL #+5
   \   00000048   0x.... 0x....      BL       prvListTaskWithinSingleList
   \   0000004C   0x19C7             ADDS     R7,R0,R7
   1525          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxOverflowDelayedTaskList, eBlocked );
   \   0000004E   0x2202             MOVS     R2,#+2
   \   00000050   0x6B31             LDR      R1,[R6, #+48]
   \   00000052   0xEB04 0x1047      ADD      R0,R4,R7, LSL #+5
   \   00000056   0x.... 0x....      BL       prvListTaskWithinSingleList
   \   0000005A   0x19C7             ADDS     R7,R0,R7
   1526          
   1527          				#if( INCLUDE_vTaskDelete == 1 )
   1528          				{
   1529          					/* Fill in an xTaskStatusType structure with information on
   1530          					each task that has been deleted but not yet cleaned up. */
   1531          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   \   0000005C   0x2204             MOVS     R2,#+4
   \   0000005E   0xF106 0x0114      ADD      R1,R6,#+20
   \   00000062   0xEB04 0x1047      ADD      R0,R4,R7, LSL #+5
   \   00000066   0x.... 0x....      BL       prvListTaskWithinSingleList
   \   0000006A   0x19C7             ADDS     R7,R0,R7
   1532          				}
   1533          				#endif
   1534          
   1535          				#if ( INCLUDE_vTaskSuspend == 1 )
   1536          				{
   1537          					/* Fill in an xTaskStatusType structure with information on
   1538          					each task in the Suspended state. */
   1539          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   \   0000006C   0x2203             MOVS     R2,#+3
   \   0000006E   0xF106 0x0138      ADD      R1,R6,#+56
   \   00000072   0xEB04 0x1047      ADD      R0,R4,R7, LSL #+5
   \   00000076   0x.... 0x....      BL       prvListTaskWithinSingleList
   \   0000007A   0x19C7             ADDS     R7,R0,R7
   1540          				}
   1541          				#endif
   1542          
   1543          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   1544          				{
   1545          					if( pulTotalRunTime != NULL )
   1546          					{
   1547          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1548          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   1549          						#else
   1550          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1551          						#endif
   1552          					}
   1553          				}
   1554          				#else
   1555          				{
   1556          					if( pulTotalRunTime != NULL )
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD001             BEQ.N    ??uxTaskGetSystemState_0
   1557          					{
   1558          						*pulTotalRunTime = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x6028             STR      R0,[R5, #+0]
   1559          					}
   1560          				}
   1561          				#endif
   1562          			}
   1563          		}
   1564          		( void ) xTaskResumeAll();
   \                     ??uxTaskGetSystemState_0: (+1)
   \   00000084   0x.... 0x....      BL       xTaskResumeAll
   1565          
   1566          		return uxTask;
   \   00000088   0x4638             MOV      R0,R7
   \   0000008A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1567          	}
   1568          
   1569          #endif /* configUSE_TRACE_FACILITY */
   1570          /*----------------------------------------------------------*/
   1571          
   1572          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1573          
   1574          	xTaskHandle xTaskGetIdleTaskHandle( void )
   1575          	{
   1576          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1577          		started, then xIdleTaskHandle will be NULL. */
   1578          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1579          		return xIdleTaskHandle;
   1580          	}
   1581          
   1582          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1583          /*----------------------------------------------------------*/
   1584          
   1585          /* This conditional compilation should use inequality to 0, not equality to 1.
   1586          This is to ensure vTaskStepTick() is available when user defined low power mode
   1587          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1588          1. */
   1589          #if ( configUSE_TICKLESS_IDLE != 0 )
   1590          
   1591          	void vTaskStepTick( portTickType xTicksToJump )
   1592          	{
   1593          		/* Correct the tick count value after a period during which the tick
   1594          		was suppressed.  Note this does *not* call the tick hook function for
   1595          		each stepped tick. */
   1596          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   1597          		xTickCount += xTicksToJump;
   1598          		traceINCREASE_TICK_COUNT( xTicksToJump );
   1599          	}
   1600          
   1601          #endif /* configUSE_TICKLESS_IDLE */
   1602          /*----------------------------------------------------------*/
   1603          

   \                                 In section .text, align 2, keep-with-next
   1604          portBASE_TYPE xTaskIncrementTick( void )
   1605          {
   \                     xTaskIncrementTick: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1606          tskTCB * pxTCB;
   1607          portTickType xItemValue;
   1608          portBASE_TYPE xSwitchRequired = pdFALSE;
   \   00000002   0x2400             MOVS     R4,#+0
   1609          
   1610          	/* Called by the portable layer each time a tick interrupt occurs.
   1611          	Increments the tick then checks to see if the new tick value will cause any
   1612          	tasks to be unblocked. */
   1613          	traceTASK_INCREMENT_TICK( xTickCount );
   1614          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable37
   \   00000008   0x6DE8             LDR      R0,[R5, #+92]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD156             BNE.N    ??xTaskIncrementTick_0
   1615          	{
   1616          		/* Increment the RTOS tick, switching the delayed and overflowed
   1617          		delayed lists if it wraps to 0. */
   1618          		++xTickCount;
   \   0000000E   0x6D28             LDR      R0,[R5, #+80]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x6528             STR      R0,[R5, #+80]
   1619          
   1620          		{
   1621          			/* Minor optimisation.  The tick count cannot change in this
   1622          			block. */
   1623          			const portTickType xConstTickCount = xTickCount;
   \   00000014   0x6D2E             LDR      R6,[R5, #+80]
   1624          
   1625          			if( xConstTickCount == ( portTickType ) 0U )
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD113             BNE.N    ??xTaskIncrementTick_1
   1626          			{
   1627          				taskSWITCH_DELAYED_LISTS();
   \   0000001A   0x6AE8             LDR      R0,[R5, #+44]
   \   0000001C   0x6B29             LDR      R1,[R5, #+48]
   \   0000001E   0x62E9             STR      R1,[R5, #+44]
   \   00000020   0x6328             STR      R0,[R5, #+48]
   \   00000022   0x6EA8             LDR      R0,[R5, #+104]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x66A8             STR      R0,[R5, #+104]
   \   00000028   0x6AE8             LDR      R0,[R5, #+44]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??xTaskIncrementTick_2
   \   00000030   0xF04F 0x30FF      MOV      R0,#-1
   \   00000034   0x6728             STR      R0,[R5, #+112]
   \   00000036   0xE004             B.N      ??xTaskIncrementTick_1
   \                     ??xTaskIncrementTick_2: (+1)
   \   00000038   0x6AE8             LDR      R0,[R5, #+44]
   \   0000003A   0x68C0             LDR      R0,[R0, #+12]
   \   0000003C   0x68C7             LDR      R7,[R0, #+12]
   \   0000003E   0x6878             LDR      R0,[R7, #+4]
   \   00000040   0x6728             STR      R0,[R5, #+112]
   1628          			}
   1629          
   1630          			/* See if this tick has made a timeout expire.  Tasks are stored in the
   1631          			queue in the order of their wake time - meaning once one tasks has been
   1632          			found whose block time has not expired there is no need not look any
   1633          			further	down the list. */
   1634          			if( xConstTickCount >= xNextTaskUnblockTime )
   \                     ??xTaskIncrementTick_1: (+1)
   \   00000042   0x6F28             LDR      R0,[R5, #+112]
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xD32D             BCC.N    ??xTaskIncrementTick_3
   \   00000048   0xE01D             B.N      ??xTaskIncrementTick_4
   1635          			{
   1636          				for( ;; )
   1637          				{
   1638          					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1639          					{
   1640          						/* The delayed list is empty.  Set xNextTaskUnblockTime to
   1641          						the	maximum possible value so it is extremely unlikely that
   1642          						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
   1643          						next time through. */
   1644          						xNextTaskUnblockTime = portMAX_DELAY;
   1645          						break;
   1646          					}
   1647          					else
   1648          					{
   1649          						/* The delayed list is not empty, get the value of the item
   1650          						at the head of the delayed list.  This is the time at which
   1651          						the task at the head of the delayed list must be removed
   1652          						from the Blocked state. */
   1653          						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   1654          						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   1655          
   1656          						if( xConstTickCount < xItemValue )
   1657          						{
   1658          							/* It is not time to unblock this item yet, but the item
   1659          							value is the time at which the task at the head of the
   1660          							blocked list must be removed from the Blocked state -
   1661          							so record the item value in xNextTaskUnblockTime. */
   1662          							xNextTaskUnblockTime = xItemValue;
   1663          							break;
   1664          						}
   1665          
   1666          						/* It is time to remove the item from the Blocked state. */
   1667          						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \                     ??xTaskIncrementTick_5: (+1)
   \   0000004A   0x1D38             ADDS     R0,R7,#+4
   \   0000004C   0x.... 0x....      BL       uxListRemove
   1668          
   1669          						/* Is the task waiting on an event also?  If so remove it
   1670          						from the event list. */
   1671          						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \   00000050   0x6AB8             LDR      R0,[R7, #+40]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD003             BEQ.N    ??xTaskIncrementTick_6
   1672          						{
   1673          							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   00000056   0xF107 0x0018      ADD      R0,R7,#+24
   \   0000005A   0x.... 0x....      BL       uxListRemove
   1674          						}
   1675          
   1676          						/* Place the unblocked task into the appropriate ready
   1677          						list. */
   1678          						prvAddTaskToReadyList( pxTCB );
   \                     ??xTaskIncrementTick_6: (+1)
   \   0000005E   0x6AF8             LDR      R0,[R7, #+44]
   \   00000060   0x6D69             LDR      R1,[R5, #+84]
   \   00000062   0x4281             CMP      R1,R0
   \   00000064   0xD200             BCS.N    ??xTaskIncrementTick_7
   \   00000066   0x6568             STR      R0,[R5, #+84]
   \                     ??xTaskIncrementTick_7: (+1)
   \   00000068   0x1D39             ADDS     R1,R7,#+4
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   0000006E   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   00000072   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   00000076   0x.... 0x....      BL       vListInsertEnd
   1679          
   1680          						/* A task being unblocked cannot cause an immediate context
   1681          						switch if preemption is turned off. */
   1682          						#if (  configUSE_PREEMPTION == 1 )
   1683          						{
   1684          							/* Preemption is on, but a context switch should only
   1685          							be performed if the unblocked task has a priority that
   1686          							is equal to or higher than the currently executing
   1687          							task. */
   1688          							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   0000007A   0x6AF8             LDR      R0,[R7, #+44]
   \   0000007C   0x6AA9             LDR      R1,[R5, #+40]
   \   0000007E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD300             BCC.N    ??xTaskIncrementTick_4
   1689          							{
   1690          								xSwitchRequired = pdTRUE;
   \   00000084   0x2401             MOVS     R4,#+1
   1691          							}
   1692          						}
   \                     ??xTaskIncrementTick_4: (+1)
   \   00000086   0x6AE8             LDR      R0,[R5, #+44]
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD103             BNE.N    ??xTaskIncrementTick_8
   \   0000008E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000092   0x6728             STR      R0,[R5, #+112]
   \   00000094   0xE006             B.N      ??xTaskIncrementTick_3
   \                     ??xTaskIncrementTick_8: (+1)
   \   00000096   0x6AE8             LDR      R0,[R5, #+44]
   \   00000098   0x68C0             LDR      R0,[R0, #+12]
   \   0000009A   0x68C7             LDR      R7,[R0, #+12]
   \   0000009C   0x6878             LDR      R0,[R7, #+4]
   \   0000009E   0x4286             CMP      R6,R0
   \   000000A0   0xD2D3             BCS.N    ??xTaskIncrementTick_5
   \   000000A2   0x6728             STR      R0,[R5, #+112]
   1693          						#endif /* configUSE_PREEMPTION */
   1694          					}
   1695          				}
   1696          			}
   1697          		}
   1698          
   1699          		/* Tasks of equal priority to the currently running task will share
   1700          		processing time (time slice) if preemption is on, and the application
   1701          		writer has not explicitly turned time slicing off. */
   1702          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   1703          		{
   1704          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   \                     ??xTaskIncrementTick_3: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   000000A8   0x6AA9             LDR      R1,[R5, #+40]
   \   000000AA   0x6AC9             LDR      R1,[R1, #+44]
   \   000000AC   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   000000B0   0x0091             LSLS     R1,R2,#+2
   \   000000B2   0x5840             LDR      R0,[R0, R1]
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xD304             BCC.N    ??xTaskIncrementTick_9
   1705          			{
   1706          				xSwitchRequired = pdTRUE;
   \   000000B8   0x2401             MOVS     R4,#+1
   \   000000BA   0xE002             B.N      ??xTaskIncrementTick_9
   1707          			}
   1708          		}
   1709          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   1710          
   1711          		#if ( configUSE_TICK_HOOK == 1 )
   1712          		{
   1713          			/* Guard against the tick hook being called when the pended tick
   1714          			count is being unwound (when the scheduler is being unlocked). */
   1715          			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
   1716          			{
   1717          				vApplicationTickHook();
   1718          			}
   1719          		}
   1720          		#endif /* configUSE_TICK_HOOK */
   1721          	}
   1722          	else
   1723          	{
   1724          		++uxPendedTicks;
   \                     ??xTaskIncrementTick_0: (+1)
   \   000000BC   0x6E28             LDR      R0,[R5, #+96]
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
   \   000000C0   0x6628             STR      R0,[R5, #+96]
   1725          
   1726          		/* The tick hook gets called at regular intervals, even if the
   1727          		scheduler is locked. */
   1728          		#if ( configUSE_TICK_HOOK == 1 )
   1729          		{
   1730          			vApplicationTickHook();
   1731          		}
   1732          		#endif
   1733          	}
   1734          
   1735          	#if ( configUSE_PREEMPTION == 1 )
   1736          	{
   1737          		if( xYieldPending != pdFALSE )
   \                     ??xTaskIncrementTick_9: (+1)
   \   000000C2   0x6E68             LDR      R0,[R5, #+100]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD000             BEQ.N    ??xTaskIncrementTick_10
   1738          		{
   1739          			xSwitchRequired = pdTRUE;
   \   000000C8   0x2401             MOVS     R4,#+1
   1740          		}
   1741          	}
   1742          	#endif /* configUSE_PREEMPTION */
   1743          
   1744          	return xSwitchRequired;
   \                     ??xTaskIncrementTick_10: (+1)
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1745          }
   1746          /*-----------------------------------------------------------*/
   1747          
   1748          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1749          
   1750          	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
   1751          	{
   1752          	tskTCB *xTCB;
   1753          
   1754          		/* If xTask is NULL then we are setting our own task hook. */
   1755          		if( xTask == NULL )
   1756          		{
   1757          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1758          		}
   1759          		else
   1760          		{
   1761          			xTCB = ( tskTCB * ) xTask;
   1762          		}
   1763          
   1764          		/* Save the hook function in the TCB.  A critical section is required as
   1765          		the value can be accessed from an interrupt. */
   1766          		taskENTER_CRITICAL();
   1767          			xTCB->pxTaskTag = pxHookFunction;
   1768          		taskEXIT_CRITICAL();
   1769          	}
   1770          
   1771          #endif /* configUSE_APPLICATION_TASK_TAG */
   1772          /*-----------------------------------------------------------*/
   1773          
   1774          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1775          
   1776          	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
   1777          	{
   1778          	tskTCB *xTCB;
   1779          	pdTASK_HOOK_CODE xReturn;
   1780          
   1781          		/* If xTask is NULL then we are setting our own task hook. */
   1782          		if( xTask == NULL )
   1783          		{
   1784          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1785          		}
   1786          		else
   1787          		{
   1788          			xTCB = ( tskTCB * ) xTask;
   1789          		}
   1790          
   1791          		/* Save the hook function in the TCB.  A critical section is required as
   1792          		the value can be accessed from an interrupt. */
   1793          		taskENTER_CRITICAL();
   1794          			xReturn = xTCB->pxTaskTag;
   1795          		taskEXIT_CRITICAL();
   1796          
   1797          		return xReturn;
   1798          	}
   1799          
   1800          #endif /* configUSE_APPLICATION_TASK_TAG */
   1801          /*-----------------------------------------------------------*/
   1802          
   1803          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1804          
   1805          	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
   1806          	{
   1807          	tskTCB *xTCB;
   1808          	portBASE_TYPE xReturn;
   1809          
   1810          		/* If xTask is NULL then we are calling our own task hook. */
   1811          		if( xTask == NULL )
   1812          		{
   1813          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1814          		}
   1815          		else
   1816          		{
   1817          			xTCB = ( tskTCB * ) xTask;
   1818          		}
   1819          
   1820          		if( xTCB->pxTaskTag != NULL )
   1821          		{
   1822          			xReturn = xTCB->pxTaskTag( pvParameter );
   1823          		}
   1824          		else
   1825          		{
   1826          			xReturn = pdFAIL;
   1827          		}
   1828          
   1829          		return xReturn;
   1830          	}
   1831          
   1832          #endif /* configUSE_APPLICATION_TASK_TAG */
   1833          /*-----------------------------------------------------------*/
   1834          

   \                                 In section .text, align 2, keep-with-next
   1835          void vTaskSwitchContext( void )
   1836          {
   \                     vTaskSwitchContext: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1837          	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable37
   \   00000006   0x6DE0             LDR      R0,[R4, #+92]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??vTaskSwitchContext_0
   1838          	{
   1839          		/* The scheduler is currently suspended - do not allow a context
   1840          		switch. */
   1841          		xYieldPending = pdTRUE;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x6660             STR      R0,[R4, #+100]
   \   00000010   0xBD10             POP      {R4,PC}
   1842          	}
   1843          	else
   1844          	{
   1845          		xYieldPending = pdFALSE;
   \                     ??vTaskSwitchContext_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6660             STR      R0,[R4, #+100]
   1846          		traceTASK_SWITCHED_OUT();
   1847          
   1848          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   1849          		{
   1850          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1851          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   1852          				#else
   1853          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1854          				#endif
   1855          
   1856          				/* Add the amount of time the task has been running to the
   1857          				accumulated	time so far.  The time the task started running was
   1858          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   1859          				protection here	so count values are only valid until the timer
   1860          				overflows.  The guard against negative values is to protect
   1861          				against suspect run time stat counter implementations - which
   1862          				are provided by the application, not the kernel. */
   1863          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   1864          				{
   1865          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   1866          				}
   1867          				ulTaskSwitchedInTime = ulTotalRunTime;
   1868          		}
   1869          		#endif /* configGENERATE_RUN_TIME_STATS */
   1870          
   1871          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   \   00000016   0x6AA0             LDR      R0,[R4, #+40]
   \   00000018   0x6B00             LDR      R0,[R0, #+48]
   \   0000001A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD305             BCC.N    ??vTaskSwitchContext_1
   \   00000022   0x6AA0             LDR      R0,[R4, #+40]
   \   00000024   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000028   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002A   0x.... 0x....      BL       vApplicationStackOverflowHook
   1872          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   \                     ??vTaskSwitchContext_1: (+1)
   \   0000002E   0x2214             MOVS     R2,#+20
   \   00000030   0x.... 0x....      ADR.W    R1,`vTaskSwitchContext{1}{3}{6}::ucExpectedStackBytes`
   \   00000034   0x6AA0             LDR      R0,[R4, #+40]
   \   00000036   0x6B00             LDR      R0,[R0, #+48]
   \   00000038   0x.... 0x....      BL       memcmp
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD009             BEQ.N    ??vTaskSwitchContext_2
   \   00000040   0x6AA0             LDR      R0,[R4, #+40]
   \   00000042   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000046   0x6AA0             LDR      R0,[R4, #+40]
   \   00000048   0x.... 0x....      BL       vApplicationStackOverflowHook
   \   0000004C   0xE002             B.N      ??vTaskSwitchContext_2
   1873          
   1874          		taskSELECT_HIGHEST_PRIORITY_TASK();
   \                     ??vTaskSwitchContext_3: (+1)
   \   0000004E   0x6D60             LDR      R0,[R4, #+84]
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x6560             STR      R0,[R4, #+84]
   \                     ??vTaskSwitchContext_2: (+1)
   \   00000054   0x2014             MOVS     R0,#+20
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable37_1
   \   0000005A   0x6D62             LDR      R2,[R4, #+84]
   \   0000005C   0x4342             MULS     R2,R0,R2
   \   0000005E   0x588A             LDR      R2,[R1, R2]
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xD0F4             BEQ.N    ??vTaskSwitchContext_3
   \   00000064   0x6D62             LDR      R2,[R4, #+84]
   \   00000066   0x4350             MULS     R0,R0,R2
   \   00000068   0x4408             ADD      R0,R1,R0
   \   0000006A   0x6841             LDR      R1,[R0, #+4]
   \   0000006C   0x6849             LDR      R1,[R1, #+4]
   \   0000006E   0x6041             STR      R1,[R0, #+4]
   \   00000070   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xD101             BNE.N    ??vTaskSwitchContext_4
   \   00000078   0x6849             LDR      R1,[R1, #+4]
   \   0000007A   0x6041             STR      R1,[R0, #+4]
   \                     ??vTaskSwitchContext_4: (+1)
   \   0000007C   0x6840             LDR      R0,[R0, #+4]
   \   0000007E   0x68C0             LDR      R0,[R0, #+12]
   \   00000080   0x62A0             STR      R0,[R4, #+40]
   1875          
   1876          		traceTASK_SWITCHED_IN();
   1877          
   1878          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1879          		{
   1880          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1881          			structure specific to this task. */
   1882          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1883          		}
   1884          		#endif /* configUSE_NEWLIB_REENTRANT */
   1885          	}
   1886          }
   \   00000082   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `vTaskSwitchContext{1}{3}{6}::ucExpectedStackBytes`:
   \   00000000   0xA5 0xA5          DC8 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165
   \              0xA5 0xA5    
   \              0xA5 0xA5    
   \              0xA5 0xA5    
   \              0xA5 0xA5    
   \              0xA5 0xA5    
   \              0xA5         
   \   0000000D   0xA5 0xA5          DC8 165, 165, 165, 165, 165, 165, 165
   \              0xA5 0xA5    
   \              0xA5 0xA5    
   \              0xA5         
   1887          /*-----------------------------------------------------------*/
   1888          

   \                                 In section .text, align 2, keep-with-next
   1889          void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
   1890          {
   \                     vTaskPlaceOnEventList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1891          portTickType xTimeToWake;
   1892          
   1893          	configASSERT( pxEventList );
   1894          
   1895          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1896          	SCHEDULER SUSPENDED. */
   1897          
   1898          	/* Place the event list item of the TCB in the appropriate event list.
   1899          	This is placed in the list in priority order so the highest priority task
   1900          	is the first to be woken by the event. */
   1901          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable37
   \   00000008   0x6AA9             LDR      R1,[R5, #+40]
   \   0000000A   0x3118             ADDS     R1,R1,#+24
   \   0000000C   0x.... 0x....      BL       vListInsert
   1902          
   1903          	/* We must remove ourselves from the ready list before adding ourselves
   1904          	to the blocked list as the same list item is used for both lists.  We have
   1905          	exclusive access to the ready lists as the scheduler is locked. */
   1906          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   00000010   0x6AA8             LDR      R0,[R5, #+40]
   \   00000012   0x1D00             ADDS     R0,R0,#+4
   \   00000014   0x.... 0x....      BL       uxListRemove
   1907          	{
   1908          		/* The current task must be in a ready list, so there is no need to
   1909          		check, and the port reset macro can be called directly. */
   1910          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   1911          	}
   1912          
   1913          	#if ( INCLUDE_vTaskSuspend == 1 )
   1914          	{
   1915          		if( xTicksToWait == portMAX_DELAY )
   \   00000018   0xF114 0x0F01      CMN      R4,#+1
   \   0000001C   0xD107             BNE.N    ??vTaskPlaceOnEventList_0
   1916          		{
   1917          			/* Add ourselves to the suspended task list instead of a delayed task
   1918          			list to ensure we are not woken by a timing event.  We will block
   1919          			indefinitely. */
   1920          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \   0000001E   0x6AA8             LDR      R0,[R5, #+40]
   \   00000020   0x1D01             ADDS     R1,R0,#+4
   \   00000022   0xF105 0x0038      ADD      R0,R5,#+56
   \   00000026   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000002A   0x.... 0x....      B.W      vListInsertEnd
   1921          		}
   1922          		else
   1923          		{
   1924          			/* Calculate the time at which the task should be woken if the event does
   1925          			not occur.  This may overflow but this doesn't matter. */
   1926          			xTimeToWake = xTickCount + xTicksToWait;
   \                     ??vTaskPlaceOnEventList_0: (+1)
   \   0000002E   0x6D28             LDR      R0,[R5, #+80]
   \   00000030   0x1820             ADDS     R0,R4,R0
   1927          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x....             B.N      prvAddCurrentTaskToDelayedList
   1928          		}
   1929          	}
   1930          	#else /* INCLUDE_vTaskSuspend */
   1931          	{
   1932          			/* Calculate the time at which the task should be woken if the event does
   1933          			not occur.  This may overflow but this doesn't matter. */
   1934          			xTimeToWake = xTickCount + xTicksToWait;
   1935          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   1936          	}
   1937          	#endif /* INCLUDE_vTaskSuspend */
   1938          }
   1939          /*-----------------------------------------------------------*/
   1940          
   1941          #if configUSE_TIMERS == 1
   1942          

   \                                 In section .text, align 2, keep-with-next
   1943          	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
   1944          	{
   \                     vTaskPlaceOnEventListRestricted: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1945          	portTickType xTimeToWake;
   1946          
   1947          		configASSERT( pxEventList );
   1948          
   1949          		/* This function should not be called by application code hence the
   1950          		'Restricted' in its name.  It is not part of the public API.  It is
   1951          		designed for use by kernel code, and has special calling requirements -
   1952          		it should be called from a critical section. */
   1953          
   1954          
   1955          		/* Place the event list item of the TCB in the appropriate event list.
   1956          		In this case it is assume that this is the only task that is going to
   1957          		be waiting on this event list, so the faster vListInsertEnd() function
   1958          		can be used in place of vListInsert. */
   1959          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable37
   \   00000008   0x6AA9             LDR      R1,[R5, #+40]
   \   0000000A   0x3118             ADDS     R1,R1,#+24
   \   0000000C   0x.... 0x....      BL       vListInsertEnd
   1960          
   1961          		/* We must remove this task from the ready list before adding it to the
   1962          		blocked list as the same list item is used for both lists.  This
   1963          		function is called form a critical section. */
   1964          		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   00000010   0x6AA8             LDR      R0,[R5, #+40]
   \   00000012   0x1D00             ADDS     R0,R0,#+4
   \   00000014   0x.... 0x....      BL       uxListRemove
   1965          		{
   1966          			/* The current task must be in a ready list, so there is no need to
   1967          			check, and the port reset macro can be called directly. */
   1968          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   1969          		}
   1970          
   1971          		/* Calculate the time at which the task should be woken if the event does
   1972          		not occur.  This may overflow but this doesn't matter. */
   1973          		xTimeToWake = xTickCount + xTicksToWait;
   \   00000018   0x6D28             LDR      R0,[R5, #+80]
   \   0000001A   0x1820             ADDS     R0,R4,R0
   1974          
   1975          		traceTASK_DELAY_UNTIL();
   1976          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x....             B.N      prvAddCurrentTaskToDelayedList
   1977          	}
   1978          
   1979          #endif /* configUSE_TIMERS */
   1980          /*-----------------------------------------------------------*/
   1981          

   \                                 In section .text, align 2, keep-with-next
   1982          signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
   1983          {
   \                     xTaskRemoveFromEventList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1984          tskTCB *pxUnblockedTCB;
   1985          portBASE_TYPE xReturn;
   1986          
   1987          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1988          	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
   1989          
   1990          	/* The event list is sorted in priority order, so we can remove the
   1991          	first in the list, remove the TCB from the delayed list, and add
   1992          	it to the ready list.
   1993          
   1994          	If an event is for a queue that is locked then this function will never
   1995          	get called - the lock count on the queue will get modified instead.  This
   1996          	means we can always expect exclusive access to the event list here.
   1997          
   1998          	This function assumes that a check has already been made to ensure that
   1999          	pxEventList is not empty. */
   2000          	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x68C5             LDR      R5,[R0, #+12]
   2001          	configASSERT( pxUnblockedTCB );
   2002          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   \   00000006   0xF105 0x0018      ADD      R0,R5,#+24
   \   0000000A   0x.... 0x....      BL       uxListRemove
   2003          
   2004          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable37
   \   00000012   0x6DE0             LDR      R0,[R4, #+92]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD111             BNE.N    ??xTaskRemoveFromEventList_0
   2005          	{
   2006          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   \   00000018   0x1D28             ADDS     R0,R5,#+4
   \   0000001A   0x.... 0x....      BL       uxListRemove
   2007          		prvAddTaskToReadyList( pxUnblockedTCB );
   \   0000001E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000020   0x6D61             LDR      R1,[R4, #+84]
   \   00000022   0x4281             CMP      R1,R0
   \   00000024   0xD200             BCS.N    ??xTaskRemoveFromEventList_1
   \   00000026   0x6560             STR      R0,[R4, #+84]
   \                     ??xTaskRemoveFromEventList_1: (+1)
   \   00000028   0x1D29             ADDS     R1,R5,#+4
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   0000002E   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   00000032   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   00000036   0x.... 0x....      BL       vListInsertEnd
   \   0000003A   0xE004             B.N      ??xTaskRemoveFromEventList_2
   2008          	}
   2009          	else
   2010          	{
   2011          		/* We cannot access the delayed or ready lists, so will hold this
   2012          		task pending until the scheduler is resumed. */
   2013          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_0: (+1)
   \   0000003C   0xF105 0x0118      ADD      R1,R5,#+24
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       vListInsertEnd
   2014          	}
   2015          
   2016          	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \                     ??xTaskRemoveFromEventList_2: (+1)
   \   00000046   0x6AE8             LDR      R0,[R5, #+44]
   \   00000048   0x6AA1             LDR      R1,[R4, #+40]
   \   0000004A   0x6AC9             LDR      R1,[R1, #+44]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD303             BCC.N    ??xTaskRemoveFromEventList_3
   2017          	{
   2018          		/* Return true if the task removed from the event list has
   2019          		a higher priority than the calling task.  This allows
   2020          		the calling task to know if it should force a context
   2021          		switch now. */
   2022          		xReturn = pdTRUE;
   \   00000050   0x2001             MOVS     R0,#+1
   2023          
   2024          		/* Mark that a yield is pending in case the user is not using the
   2025          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2026          		xYieldPending = pdTRUE;
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0x6661             STR      R1,[R4, #+100]
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}
   2027          	}
   2028          	else
   2029          	{
   2030          		xReturn = pdFALSE;
   \                     ??xTaskRemoveFromEventList_3: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   2031          	}
   2032          
   2033          	return xReturn;
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2034          }
   2035          /*-----------------------------------------------------------*/
   2036          

   \                                 In section .text, align 2, keep-with-next
   2037          void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
   2038          {
   2039          	configASSERT( pxTimeOut );
   2040          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   \                     vTaskSetTimeOutState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable37
   \   00000004   0x6E8A             LDR      R2,[R1, #+104]
   \   00000006   0x6002             STR      R2,[R0, #+0]
   2041          	pxTimeOut->xTimeOnEntering = xTickCount;
   \   00000008   0x6D09             LDR      R1,[R1, #+80]
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   2042          }
   \   0000000C   0x4770             BX       LR               ;; return
   2043          /*-----------------------------------------------------------*/
   2044          

   \                                 In section .text, align 2, keep-with-next
   2045          portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
   2046          {
   \                     xTaskCheckForTimeOut: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2047          portBASE_TYPE xReturn;
   2048          
   2049          	configASSERT( pxTimeOut );
   2050          	configASSERT( pxTicksToWait );
   2051          
   2052          	taskENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
   2053          	{
   2054          		/* Minor optimisation.  The tick count cannot change in this block. */
   2055          		const portTickType xConstTickCount = xTickCount;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable37
   \   0000000E   0x6D01             LDR      R1,[R0, #+80]
   2056          
   2057          		#if ( INCLUDE_vTaskSuspend == 1 )
   2058          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2059          			the maximum block time then the task should block indefinitely, and
   2060          			therefore never time out. */
   2061          			if( *pxTicksToWait == portMAX_DELAY )
   \   00000010   0x682A             LDR      R2,[R5, #+0]
   \   00000012   0xF112 0x0F01      CMN      R2,#+1
   \   00000016   0xD101             BNE.N    ??xTaskCheckForTimeOut_0
   2062          			{
   2063          				xReturn = pdFALSE;
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0xE014             B.N      ??xTaskCheckForTimeOut_1
   2064          			}
   2065          			else /* We are not blocking indefinitely, perform the checks below. */
   2066          		#endif
   2067          
   2068          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   \                     ??xTaskCheckForTimeOut_0: (+1)
   \   0000001C   0x6863             LDR      R3,[R4, #+4]
   \   0000001E   0x6E80             LDR      R0,[R0, #+104]
   \   00000020   0x6826             LDR      R6,[R4, #+0]
   \   00000022   0x42B0             CMP      R0,R6
   \   00000024   0xD003             BEQ.N    ??xTaskCheckForTimeOut_2
   \   00000026   0x4299             CMP      R1,R3
   \   00000028   0xD301             BCC.N    ??xTaskCheckForTimeOut_2
   2069          		{
   2070          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2071          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2072          			It must have wrapped all the way around and gone past us again. This
   2073          			passed since vTaskSetTimeout() was called. */
   2074          			xReturn = pdTRUE;
   \   0000002A   0x2401             MOVS     R4,#+1
   \   0000002C   0xE00B             B.N      ??xTaskCheckForTimeOut_1
   2075          		}
   2076          		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   \                     ??xTaskCheckForTimeOut_2: (+1)
   \   0000002E   0x1AC8             SUBS     R0,R1,R3
   \   00000030   0x4290             CMP      R0,R2
   \   00000032   0xD207             BCS.N    ??xTaskCheckForTimeOut_3
   2077          		{
   2078          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2079          			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   \   00000034   0x1A50             SUBS     R0,R2,R1
   \   00000036   0x1818             ADDS     R0,R3,R0
   \   00000038   0x6028             STR      R0,[R5, #+0]
   2080          			vTaskSetTimeOutState( pxTimeOut );
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       vTaskSetTimeOutState
   2081          			xReturn = pdFALSE;
   \   00000040   0x2400             MOVS     R4,#+0
   \   00000042   0xE000             B.N      ??xTaskCheckForTimeOut_1
   2082          		}
   2083          		else
   2084          		{
   2085          			xReturn = pdTRUE;
   \                     ??xTaskCheckForTimeOut_3: (+1)
   \   00000044   0x2401             MOVS     R4,#+1
   2086          		}
   2087          	}
   2088          	taskEXIT_CRITICAL();
   \                     ??xTaskCheckForTimeOut_1: (+1)
   \   00000046   0x.... 0x....      BL       vPortExitCritical
   2089          
   2090          	return xReturn;
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
   2091          }
   2092          /*-----------------------------------------------------------*/
   2093          

   \                                 In section .text, align 2, keep-with-next
   2094          void vTaskMissedYield( void )
   2095          {
   2096          	xYieldPending = pdTRUE;
   \                     vTaskMissedYield: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable37
   \   00000006   0x6648             STR      R0,[R1, #+100]
   2097          }
   \   00000008   0x4770             BX       LR               ;; return
   2098          /*-----------------------------------------------------------*/
   2099          
   2100          #if ( configUSE_TRACE_FACILITY == 1 )
   2101          

   \                                 In section .text, align 2, keep-with-next
   2102          	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
   2103          	{
   2104          	unsigned portBASE_TYPE uxReturn;
   2105          	tskTCB *pxTCB;
   2106          
   2107          		if( xTask != NULL )
   \                     uxTaskGetTaskNumber: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ.N    ??uxTaskGetTaskNumber_0
   2108          		{
   2109          			pxTCB = ( tskTCB * ) xTask;
   2110          			uxReturn = pxTCB->uxTaskNumber;
   \   00000004   0x6C80             LDR      R0,[R0, #+72]
   \   00000006   0x4770             BX       LR
   2111          		}
   2112          		else
   2113          		{
   2114          			uxReturn = 0U;
   \                     ??uxTaskGetTaskNumber_0: (+1)
   \   00000008   0x2000             MOVS     R0,#+0
   2115          		}
   2116          
   2117          		return uxReturn;
   \   0000000A   0x4770             BX       LR               ;; return
   2118          	}
   2119          
   2120          #endif /* configUSE_TRACE_FACILITY */
   2121          /*-----------------------------------------------------------*/
   2122          
   2123          #if ( configUSE_TRACE_FACILITY == 1 )
   2124          

   \                                 In section .text, align 2, keep-with-next
   2125          	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
   2126          	{
   2127          	tskTCB *pxTCB;
   2128          
   2129          		if( xTask != NULL )
   \                     vTaskSetTaskNumber: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??vTaskSetTaskNumber_0
   2130          		{
   2131          			pxTCB = ( tskTCB * ) xTask;
   2132          			pxTCB->uxTaskNumber = uxHandle;
   \   00000004   0x6481             STR      R1,[R0, #+72]
   2133          		}
   2134          	}
   \                     ??vTaskSetTaskNumber_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
   2135          
   2136          #endif /* configUSE_TRACE_FACILITY */
   2137          
   2138          /*
   2139           * -----------------------------------------------------------
   2140           * The Idle task.
   2141           * ----------------------------------------------------------
   2142           *
   2143           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2144           * language extensions.  The equivalent prototype for this function is:
   2145           *
   2146           * void prvIdleTask( void *pvParameters );
   2147           *
   2148           */

   \                                 In section .text, align 4, keep-with-next
   2149          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2150          {
   \                     prvIdleTask: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2151          	/* Stop warnings. */
   2152          	( void ) pvParameters;
   2153          
   2154          	for( ;; )
   2155          	{
   2156          		/* See if any tasks have been deleted. */
   2157          		prvCheckTasksWaitingTermination();
   \                     ??prvIdleTask_0: (+1)
   \   00000002   0x.... 0x....      BL       prvCheckTasksWaitingTermination
   2158          
   2159          		#if ( configUSE_PREEMPTION == 0 )
   2160          		{
   2161          			/* If we are not using preemption we keep forcing a task switch to
   2162          			see if any other task has become available.  If we are using
   2163          			preemption we don't need to do this as any task becoming available
   2164          			will automatically get the processor anyway. */
   2165          			taskYIELD();
   2166          		}
   2167          		#endif /* configUSE_PREEMPTION */
   2168          
   2169          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2170          		{
   2171          			/* When using preemption tasks of equal priority will be
   2172          			timesliced.  If a task that is sharing the idle priority is ready
   2173          			to run then the idle task should yield before the end of the
   2174          			timeslice.
   2175          
   2176          			A critical region is not required here as we are just reading from
   2177          			the list, and an occasional incorrect value will not matter.  If
   2178          			the ready list at the idle priority contains more than one task
   2179          			then a task other than the idle task is ready to execute. */
   2180          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD3F8             BCC.N    ??prvIdleTask_0
   2181          			{
   2182          				taskYIELD();
   \   00000010   0x.... 0x....      BL       vPortYield
   \   00000014   0xE7F5             B.N      ??prvIdleTask_0
   2183          			}
   2184          		}
   2185          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   2186          
   2187          		#if ( configUSE_IDLE_HOOK == 1 )
   2188          		{
   2189          			extern void vApplicationIdleHook( void );
   2190          
   2191          			/* Call the user defined function from within the idle task.  This
   2192          			allows the application designer to add background functionality
   2193          			without the overhead of a separate task.
   2194          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2195          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2196          			vApplicationIdleHook();
   2197          		}
   2198          		#endif /* configUSE_IDLE_HOOK */
   2199          
   2200          		/* This conditional compilation should use inequality to 0, not equality
   2201          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2202          		user defined low power mode	implementations require
   2203          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2204          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2205          		{
   2206          		portTickType xExpectedIdleTime;
   2207          
   2208          			/* It is not desirable to suspend then resume the scheduler on
   2209          			each iteration of the idle task.  Therefore, a preliminary
   2210          			test of the expected idle time is performed without the
   2211          			scheduler suspended.  The result here is not necessarily
   2212          			valid. */
   2213          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2214          
   2215          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2216          			{
   2217          				vTaskSuspendAll();
   2218          				{
   2219          					/* Now the scheduler is suspended, the expected idle
   2220          					time can be sampled again, and this time its value can
   2221          					be used. */
   2222          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2223          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2224          
   2225          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2226          					{
   2227          						traceLOW_POWER_IDLE_BEGIN();
   2228          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2229          						traceLOW_POWER_IDLE_END();
   2230          					}
   2231          				}
   2232          				( void ) xTaskResumeAll();
   2233          			}
   2234          		}
   2235          		#endif /* configUSE_TICKLESS_IDLE */
   2236          	}
   2237          }
   2238          /*-----------------------------------------------------------*/
   2239          
   2240          #if configUSE_TICKLESS_IDLE != 0
   2241          
   2242          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   2243          	{
   2244          	eSleepModeStatus eReturn = eStandardSleep;
   2245          
   2246          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2247          		{
   2248          			/* A task was made ready while the scheduler was suspended. */
   2249          			eReturn = eAbortSleep;
   2250          		}
   2251          		else if( xYieldPending != pdFALSE )
   2252          		{
   2253          			/* A yield was pended while the scheduler was suspended. */
   2254          			eReturn = eAbortSleep;
   2255          		}
   2256          		else
   2257          		{
   2258          			#if configUSE_TIMERS == 0
   2259          			{
   2260          				/* The idle task exists in addition to the application tasks. */
   2261          				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
   2262          
   2263          				/* If timers are not being used and all the tasks are in the
   2264          				suspended list (which might mean they have an infinite block
   2265          				time rather than actually being suspended) then it is safe to
   2266          				turn all clocks off and just wait for external interrupts. */
   2267          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2268          				{
   2269          					eReturn = eNoTasksWaitingTimeout;
   2270          				}
   2271          			}
   2272          			#endif /* configUSE_TIMERS */
   2273          		}
   2274          
   2275          		return eReturn;
   2276          	}
   2277          #endif /* configUSE_TICKLESS_IDLE */
   2278          /*-----------------------------------------------------------*/
   2279          

   \                                 In section .text, align 2, keep-with-next
   2280          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
   2281          {
   \                     prvInitialiseTCBVariables: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   2282          unsigned portBASE_TYPE x;
   2283          
   2284          	/* Store the task name in the TCB. */
   2285          	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE000             B.N      ??prvInitialiseTCBVariables_0
   \                     ??prvInitialiseTCBVariables_1: (+1)
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \                     ??prvInitialiseTCBVariables_0: (+1)
   \   0000000C   0x2810             CMP      R0,#+16
   \   0000000E   0xD206             BCS.N    ??prvInitialiseTCBVariables_2
   2286          	{
   2287          		pxTCB->pcTaskName[ x ] = pcName[ x ];
   \   00000010   0x5C0A             LDRB     R2,[R1, R0]
   \   00000012   0x1823             ADDS     R3,R4,R0
   \   00000014   0xF883 0x2034      STRB     R2,[R3, #+52]
   2288          
   2289          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
   2290          		configMAX_TASK_NAME_LEN characters just in case the memory after the
   2291          		string is not accessible (extremely unlikely). */
   2292          		if( pcName[ x ] == 0x00 )
   \   00000018   0x560A             LDRSB    R2,[R1, R0]
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD1F5             BNE.N    ??prvInitialiseTCBVariables_1
   2293          		{
   2294          			break;
   2295          		}
   2296          	}
   2297          
   2298          	/* Ensure the name string is terminated in the case that the string length
   2299          	was greater or equal to configMAX_TASK_NAME_LEN. */
   2300          	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
   \                     ??prvInitialiseTCBVariables_2: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x0043      STRB     R0,[R4, #+67]
   2301          
   2302          	/* This is used as an array index so must ensure it's not too large.  First
   2303          	remove the privilege bit if one is present. */
   2304          	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
   \   00000024   0x2D0C             CMP      R5,#+12
   \   00000026   0xD300             BCC.N    ??prvInitialiseTCBVariables_3
   2305          	{
   2306          		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   \   00000028   0x250B             MOVS     R5,#+11
   2307          	}
   2308          
   2309          	pxTCB->uxPriority = uxPriority;
   \                     ??prvInitialiseTCBVariables_3: (+1)
   \   0000002A   0xF104 0x0610      ADD      R6,R4,#+16
   \   0000002E   0x61F5             STR      R5,[R6, #+28]
   2310          	#if ( configUSE_MUTEXES == 1 )
   2311          	{
   2312          		pxTCB->uxBasePriority = uxPriority;
   \   00000030   0x64E5             STR      R5,[R4, #+76]
   2313          	}
   2314          	#endif /* configUSE_MUTEXES */
   2315          
   2316          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   \   00000032   0x1D20             ADDS     R0,R4,#+4
   \   00000034   0x.... 0x....      BL       vListInitialiseItem
   2317          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   \   00000038   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000003C   0x.... 0x....      BL       vListInitialiseItem
   2318          
   2319          	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
   2320          	back to	the containing TCB from a generic item in a list. */
   2321          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   \   00000040   0x6034             STR      R4,[R6, #+0]
   2322          
   2323          	/* Event lists are always in priority order. */
   2324          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   00000042   0xF1C5 0x000C      RSB      R0,R5,#+12
   \   00000046   0x60B0             STR      R0,[R6, #+8]
   2325          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   \   00000048   0x6174             STR      R4,[R6, #+20]
   2326          
   2327          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2328          	{
   2329          		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
   2330          	}
   2331          	#endif /* portCRITICAL_NESTING_IN_TCB */
   2332          
   2333          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2334          	{
   2335          		pxTCB->pxTaskTag = NULL;
   2336          	}
   2337          	#endif /* configUSE_APPLICATION_TASK_TAG */
   2338          
   2339          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2340          	{
   2341          		pxTCB->ulRunTimeCounter = 0UL;
   2342          	}
   2343          	#endif /* configGENERATE_RUN_TIME_STATS */
   2344          
   2345          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2346          	{
   2347          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2348          	}
   2349          	#else /* portUSING_MPU_WRAPPERS */
   2350          	{
   2351          		( void ) xRegions;
   2352          		( void ) usStackDepth;
   2353          	}
   2354          	#endif /* portUSING_MPU_WRAPPERS */
   2355          
   2356          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2357          	{
   2358          		/* Initialise this task's Newlib reent structure. */
   2359          		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
   2360          	}
   2361          	#endif /* configUSE_NEWLIB_REENTRANT */
   2362          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   2363          /*-----------------------------------------------------------*/
   2364          
   2365          #if ( portUSING_MPU_WRAPPERS == 1 )
   2366          
   2367          	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
   2368          	{
   2369          	tskTCB *pxTCB;
   2370          
   2371          		/* If null is passed in here then we are deleting ourselves. */
   2372          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2373          
   2374                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2375          	}
   2376          
   2377          #endif /* portUSING_MPU_WRAPPERS */
   2378          /*-----------------------------------------------------------*/
   2379          

   \                                 In section .text, align 2, keep-with-next
   2380          static void prvInitialiseTaskLists( void )
   2381          {
   \                     prvInitialiseTaskLists: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2382          unsigned portBASE_TYPE uxPriority;
   2383          
   2384          	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE007             B.N      ??prvInitialiseTaskLists_0
   2385          	{
   2386          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   \                     ??prvInitialiseTaskLists_1: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable37_1
   \   00000008   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   0000000C   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000010   0x.... 0x....      BL       vListInitialise
   2387          	}
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \                     ??prvInitialiseTaskLists_0: (+1)
   \   00000016   0x2C0C             CMP      R4,#+12
   \   00000018   0xD3F5             BCC.N    ??prvInitialiseTaskLists_1
   2388          
   2389          	vListInitialise( &xDelayedTaskList1 );
   \   0000001A   0x....             LDR.N    R4,??DataTable37
   \   0000001C   0xF104 0x0074      ADD      R0,R4,#+116
   \   00000020   0x.... 0x....      BL       vListInitialise
   2390          	vListInitialise( &xDelayedTaskList2 );
   \   00000024   0xF104 0x0588      ADD      R5,R4,#+136
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       vListInitialise
   2391          	vListInitialise( &xPendingReadyList );
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       vListInitialise
   2392          
   2393          	#if ( INCLUDE_vTaskDelete == 1 )
   2394          	{
   2395          		vListInitialise( &xTasksWaitingTermination );
   \   00000034   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000038   0x.... 0x....      BL       vListInitialise
   2396          	}
   2397          	#endif /* INCLUDE_vTaskDelete */
   2398          
   2399          	#if ( INCLUDE_vTaskSuspend == 1 )
   2400          	{
   2401          		vListInitialise( &xSuspendedTaskList );
   \   0000003C   0xF104 0x0038      ADD      R0,R4,#+56
   \   00000040   0x.... 0x....      BL       vListInitialise
   2402          	}
   2403          	#endif /* INCLUDE_vTaskSuspend */
   2404          
   2405          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2406          	using list2. */
   2407          	pxDelayedTaskList = &xDelayedTaskList1;
   \   00000044   0xF104 0x0074      ADD      R0,R4,#+116
   \   00000048   0x62E0             STR      R0,[R4, #+44]
   2408          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   \   0000004A   0x6325             STR      R5,[R4, #+48]
   2409          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2410          /*-----------------------------------------------------------*/
   2411          

   \                                 In section .text, align 2, keep-with-next
   2412          static void prvCheckTasksWaitingTermination( void )
   2413          {
   \                     prvCheckTasksWaitingTermination: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable37
   \   00000004   0xE01B             B.N      ??prvCheckTasksWaitingTermination_0
   2414          	#if ( INCLUDE_vTaskDelete == 1 )
   2415          	{
   2416          		portBASE_TYPE xListIsEmpty;
   2417          
   2418          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   2419          		too often in the idle task. */
   2420          		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   2421          		{
   2422          			vTaskSuspendAll();
   \                     ??prvCheckTasksWaitingTermination_1: (+1)
   \   00000006   0x.... 0x....      BL       vTaskSuspendAll
   2423          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   \   0000000A   0x6960             LDR      R0,[R4, #+20]
   \   0000000C   0x1E45             SUBS     R5,R0,#+1
   \   0000000E   0x41AD             SBCS     R5,R5,R5
   \   00000010   0x0FED             LSRS     R5,R5,#+31
   2424          			( void ) xTaskResumeAll();
   \   00000012   0x.... 0x....      BL       xTaskResumeAll
   2425          
   2426          			if( xListIsEmpty == pdFALSE )
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD111             BNE.N    ??prvCheckTasksWaitingTermination_0
   2427          			{
   2428          				tskTCB *pxTCB;
   2429          
   2430          				taskENTER_CRITICAL();
   \   0000001A   0x.... 0x....      BL       vPortEnterCritical
   2431          				{
   2432          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   \   0000001E   0x6A20             LDR      R0,[R4, #+32]
   \   00000020   0x68C5             LDR      R5,[R0, #+12]
   2433          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \   00000022   0x1D28             ADDS     R0,R5,#+4
   \   00000024   0x.... 0x....      BL       uxListRemove
   2434          					--uxCurrentNumberOfTasks;
   \   00000028   0x6CE0             LDR      R0,[R4, #+76]
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0x64E0             STR      R0,[R4, #+76]
   2435          					--uxTasksDeleted;
   \   0000002E   0x6B60             LDR      R0,[R4, #+52]
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x6360             STR      R0,[R4, #+52]
   2436          				}
   2437          				taskEXIT_CRITICAL();
   \   00000034   0x.... 0x....      BL       vPortExitCritical
   2438          
   2439          				prvDeleteTCB( pxTCB );
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       prvDeleteTCB
   2440          			}
   2441          		}
   \                     ??prvCheckTasksWaitingTermination_0: (+1)
   \   0000003E   0x6B60             LDR      R0,[R4, #+52]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD1E0             BNE.N    ??prvCheckTasksWaitingTermination_1
   2442          	}
   2443          	#endif /* vTaskDelete */
   2444          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2445          /*-----------------------------------------------------------*/
   2446          

   \                                 In section .text, align 2, keep-with-next
   2447          static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
   2448          {
   \                     prvAddCurrentTaskToDelayedList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2449          	/* The list item will be inserted in wake time order. */
   2450          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   \   00000004   0x....             LDR.N    R5,??DataTable37
   \   00000006   0x6AA8             LDR      R0,[R5, #+40]
   \   00000008   0x6044             STR      R4,[R0, #+4]
   2451          
   2452          	if( xTimeToWake < xTickCount )
   \   0000000A   0x6D28             LDR      R0,[R5, #+80]
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0x6AA8             LDR      R0,[R5, #+40]
   \   00000010   0xD205             BCS.N    ??prvAddCurrentTaskToDelayedList_0
   2453          	{
   2454          		/* Wake time has overflowed.  Place this item in the overflow list. */
   2455          		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \   00000012   0x1D01             ADDS     R1,R0,#+4
   \   00000014   0x6B28             LDR      R0,[R5, #+48]
   \   00000016   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001A   0x.... 0x....      B.W      vListInsert
   2456          	}
   2457          	else
   2458          	{
   2459          		/* The wake time has not overflowed, so we can use the current block list. */
   2460          		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \                     ??prvAddCurrentTaskToDelayedList_0: (+1)
   \   0000001E   0x1D01             ADDS     R1,R0,#+4
   \   00000020   0x6AE8             LDR      R0,[R5, #+44]
   \   00000022   0x.... 0x....      BL       vListInsert
   2461          
   2462          		/* If the task entering the blocked state was placed at the head of the
   2463          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   2464          		too. */
   2465          		if( xTimeToWake < xNextTaskUnblockTime )
   \   00000026   0x6F28             LDR      R0,[R5, #+112]
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD200             BCS.N    ??prvAddCurrentTaskToDelayedList_1
   2466          		{
   2467          			xNextTaskUnblockTime = xTimeToWake;
   \   0000002C   0x672C             STR      R4,[R5, #+112]
   2468          		}
   2469          	}
   2470          }
   \                     ??prvAddCurrentTaskToDelayedList_1: (+1)
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2471          /*-----------------------------------------------------------*/
   2472          

   \                                 In section .text, align 2, keep-with-next
   2473          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
   2474          {
   \                     prvAllocateTCBAndStack: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2475          tskTCB *pxNewTCB;
   2476          
   2477          	/* Allocate space for the TCB.  Where the memory comes from depends on
   2478          	the implementation of the port malloc function. */
   2479          	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   \   00000006   0x2050             MOVS     R0,#+80
   \   00000008   0x.... 0x....      BL       pvPortMalloc
   \   0000000C   0x0006             MOVS     R6,R0
   2480          
   2481          	if( pxNewTCB != NULL )
   \   0000000E   0xD012             BEQ.N    ??prvAllocateTCBAndStack_0
   2482          	{
   2483          		/* Allocate space for the stack used by the task being created.
   2484          		The base of the stack memory stored in the TCB so the task can
   2485          		be deleted later if required. */
   2486          		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD103             BNE.N    ??prvAllocateTCBAndStack_1
   \   00000014   0x00A0             LSLS     R0,R4,#+2
   \   00000016   0x.... 0x....      BL       pvPortMalloc
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??prvAllocateTCBAndStack_1: (+1)
   \   0000001C   0x6335             STR      R5,[R6, #+48]
   2487          
   2488          		if( pxNewTCB->pxStack == NULL )
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD104             BNE.N    ??prvAllocateTCBAndStack_2
   2489          		{
   2490          			/* Could not allocate the stack.  Delete the allocated TCB. */
   2491          			vPortFree( pxNewTCB );
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       vPortFree
   2492          			pxNewTCB = NULL;
   \   0000002A   0x2600             MOVS     R6,#+0
   \   0000002C   0xE003             B.N      ??prvAllocateTCBAndStack_0
   2493          		}
   2494          		else
   2495          		{
   2496          			/* Just to help debugging. */
   2497          			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   \                     ??prvAllocateTCBAndStack_2: (+1)
   \   0000002E   0x22A5             MOVS     R2,#+165
   \   00000030   0x00A1             LSLS     R1,R4,#+2
   \   00000032   0x.... 0x....      BL       __aeabi_memset4
   2498          		}
   2499          	}
   2500          
   2501          	return pxNewTCB;
   \                     ??prvAllocateTCBAndStack_0: (+1)
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   2502          }
   2503          /*-----------------------------------------------------------*/
   2504          
   2505          #if ( configUSE_TRACE_FACILITY == 1 )
   2506          

   \                                 In section .text, align 2, keep-with-next
   2507          	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xList *pxList, eTaskState eState )
   2508          	{
   \                     prvListTaskWithinSingleList: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   2509          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2510          	unsigned portBASE_TYPE uxTask = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   2511          
   2512          		if( listCURRENT_LIST_LENGTH( pxList ) > ( unsigned portBASE_TYPE ) 0 )
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD039             BEQ.N    ??prvListTaskWithinSingleList_0
   2513          		{
   2514          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   \   00000012   0x6868             LDR      R0,[R5, #+4]
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x6068             STR      R0,[R5, #+4]
   \   00000018   0xF105 0x0108      ADD      R1,R5,#+8
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??prvListTaskWithinSingleList_1
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0x6068             STR      R0,[R5, #+4]
   \                     ??prvListTaskWithinSingleList_1: (+1)
   \   00000024   0x6868             LDR      R0,[R5, #+4]
   \   00000026   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   2515          
   2516          			/* Populate an xTaskStatusType structure within the
   2517          			pxTaskStatusArray array for each task that is referenced from
   2518          			pxList.  See the definition of xTaskStatusType in task.h for the
   2519          			meaning of each xTaskStatusType structure member. */
   2520          			do
   2521          			{
   2522          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   \                     ??prvListTaskWithinSingleList_2: (+1)
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x6068             STR      R0,[R5, #+4]
   \   00000030   0xF105 0x0108      ADD      R1,R5,#+8
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD101             BNE.N    ??prvListTaskWithinSingleList_3
   \   00000038   0x6840             LDR      R0,[R0, #+4]
   \   0000003A   0x6068             STR      R0,[R5, #+4]
   \                     ??prvListTaskWithinSingleList_3: (+1)
   \   0000003C   0x6868             LDR      R0,[R5, #+4]
   \   0000003E   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   2523          
   2524          				pxTaskStatusArray[ uxTask ].xHandle = ( xTaskHandle ) pxNextTCB;
   \   00000042   0xEB04 0x1A47      ADD      R10,R4,R7, LSL #+5
   \   00000046   0xF8CA 0x9000      STR      R9,[R10, #+0]
   2525          				pxTaskStatusArray[ uxTask ].pcTaskName = ( const signed char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   \   0000004A   0xF109 0x0034      ADD      R0,R9,#+52
   \   0000004E   0xF8CA 0x0004      STR      R0,[R10, #+4]
   2526          				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   \   00000052   0xF8D9 0x0044      LDR      R0,[R9, #+68]
   \   00000056   0xF8CA 0x0008      STR      R0,[R10, #+8]
   2527          				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   \   0000005A   0xF88A 0x600C      STRB     R6,[R10, #+12]
   2528          				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   \   0000005E   0xF8D9 0x002C      LDR      R0,[R9, #+44]
   \   00000062   0xF8CA 0x0010      STR      R0,[R10, #+16]
   2529          
   2530          				#if ( configUSE_MUTEXES == 1 )
   2531          				{
   2532          					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   \   00000066   0xF8D9 0x004C      LDR      R0,[R9, #+76]
   \   0000006A   0xF8CA 0x0014      STR      R0,[R10, #+20]
   2533          				}
   2534          				#else
   2535          				{
   2536          					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
   2537          				}
   2538          				#endif
   2539          
   2540          				#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2541          				{
   2542          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
   2543          				}
   2544          				#else
   2545          				{
   2546          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8CA 0x0018      STR      R0,[R10, #+24]
   2547          				}
   2548          				#endif
   2549          
   2550          				#if ( portSTACK_GROWTH > 0 )
   2551          				{
   2552          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
   2553          				}
   2554          				#else
   2555          				{
   2556          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
   \   00000074   0xF8D9 0x0030      LDR      R0,[R9, #+48]
   \   00000078   0x.... 0x....      BL       prvTaskCheckFreeStackSpace
   \   0000007C   0xF8AA 0x001C      STRH     R0,[R10, #+28]
   2557          				}
   2558          				#endif
   2559          
   2560          				uxTask++;
   \   00000080   0x1C7F             ADDS     R7,R7,#+1
   2561          
   2562          			} while( pxNextTCB != pxFirstTCB );
   \   00000082   0x45C1             CMP      R9,R8
   \   00000084   0xD1D1             BNE.N    ??prvListTaskWithinSingleList_2
   2563          		}
   2564          
   2565          		return uxTask;
   \                     ??prvListTaskWithinSingleList_0: (+1)
   \   00000086   0x4638             MOV      R0,R7
   \   00000088   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2566          	}
   2567          
   2568          #endif /* configUSE_TRACE_FACILITY */
   2569          /*-----------------------------------------------------------*/
   2570          
   2571          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   2572          

   \                                 In section .text, align 2, keep-with-next
   2573          	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
   2574          	{
   2575          	unsigned short usCount = 0U;
   \                     prvTaskCheckFreeStackSpace: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??prvTaskCheckFreeStackSpace_0
   2576          
   2577          		while( *pucStackByte == tskSTACK_FILL_BYTE )
   2578          		{
   2579          			pucStackByte -= portSTACK_GROWTH;
   \                     ??prvTaskCheckFreeStackSpace_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   2580          			usCount++;
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   2581          		}
   \                     ??prvTaskCheckFreeStackSpace_0: (+1)
   \   00000008   0x7802             LDRB     R2,[R0, #+0]
   \   0000000A   0x2AA5             CMP      R2,#+165
   \   0000000C   0xD0FA             BEQ.N    ??prvTaskCheckFreeStackSpace_1
   2582          
   2583          		usCount /= sizeof( portSTACK_TYPE );
   2584          
   2585          		return usCount;
   \   0000000E   0xB289             UXTH     R1,R1
   \   00000010   0x0888             LSRS     R0,R1,#+2
   \   00000012   0x4770             BX       LR               ;; return
   2586          	}
   2587          
   2588          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   2589          /*-----------------------------------------------------------*/
   2590          
   2591          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   2592          
   2593          	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
   2594          	{
   2595          	tskTCB *pxTCB;
   2596          	unsigned char *pcEndOfStack;
   2597          	unsigned portBASE_TYPE uxReturn;
   2598          
   2599          		pxTCB = prvGetTCBFromHandle( xTask );
   2600          
   2601          		#if portSTACK_GROWTH < 0
   2602          		{
   2603          			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
   2604          		}
   2605          		#else
   2606          		{
   2607          			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
   2608          		}
   2609          		#endif
   2610          
   2611          		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
   2612          
   2613          		return uxReturn;
   2614          	}
   2615          
   2616          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   2617          /*-----------------------------------------------------------*/
   2618          
   2619          #if ( INCLUDE_vTaskDelete == 1 )
   2620          

   \                                 In section .text, align 2, keep-with-next
   2621          	static void prvDeleteTCB( tskTCB *pxTCB )
   2622          	{
   \                     prvDeleteTCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2623          		/* This call is required specifically for the TriCore port.  It must be
   2624          		above the vPortFree() calls.  The call is also used by ports/demos that
   2625          		want to allocate and clean RAM statically. */
   2626          		portCLEAN_UP_TCB( pxTCB );
   2627          
   2628          		/* Free up the memory allocated by the scheduler for the task.  It is up to
   2629          		the task to free any memory allocated at the application level. */
   2630          		vPortFreeAligned( pxTCB->pxStack );
   \   00000004   0x6B20             LDR      R0,[R4, #+48]
   \   00000006   0x.... 0x....      BL       vPortFree
   2631          		vPortFree( pxTCB );
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      vPortFree
   2632          	}
   2633          
   2634          #endif /* INCLUDE_vTaskDelete */
   2635          /*-----------------------------------------------------------*/
   2636          
   2637          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   2638          

   \                                 In section .text, align 2, keep-with-next
   2639          	xTaskHandle xTaskGetCurrentTaskHandle( void )
   2640          	{
   2641          	xTaskHandle xReturn;
   2642          
   2643          		/* A critical section is not required as this is not called from
   2644          		an interrupt and the current TCB will always be the same for any
   2645          		individual execution thread. */
   2646          		xReturn = pxCurrentTCB;
   \                     xTaskGetCurrentTaskHandle: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable37
   \   00000002   0x6A80             LDR      R0,[R0, #+40]
   2647          
   2648          		return xReturn;
   \   00000004   0x4770             BX       LR               ;; return
   2649          	}
   2650          
   2651          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   2652          /*-----------------------------------------------------------*/
   2653          
   2654          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   2655          

   \                                 In section .text, align 2, keep-with-next
   2656          	portBASE_TYPE xTaskGetSchedulerState( void )
   2657          	{
   2658          	portBASE_TYPE xReturn;
   2659          
   2660          		if( xSchedulerRunning == pdFALSE )
   \                     xTaskGetSchedulerState: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable37
   \   00000002   0x6D81             LDR      R1,[R0, #+88]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD101             BNE.N    ??xTaskGetSchedulerState_0
   2661          		{
   2662          			xReturn = taskSCHEDULER_NOT_STARTED;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR
   2663          		}
   2664          		else
   2665          		{
   2666          			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \                     ??xTaskGetSchedulerState_0: (+1)
   \   0000000C   0x6DC0             LDR      R0,[R0, #+92]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??xTaskGetSchedulerState_1
   2667          			{
   2668          				xReturn = taskSCHEDULER_RUNNING;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR
   2669          			}
   2670          			else
   2671          			{
   2672          				xReturn = taskSCHEDULER_SUSPENDED;
   \                     ??xTaskGetSchedulerState_1: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   2673          			}
   2674          		}
   2675          
   2676          		return xReturn;
   \   00000018   0x4770             BX       LR               ;; return
   2677          	}
   2678          
   2679          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   2680          /*-----------------------------------------------------------*/
   2681          
   2682          #if ( configUSE_MUTEXES == 1 )
   2683          

   \                                 In section .text, align 2, keep-with-next
   2684          	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
   2685          	{
   \                     vTaskPriorityInherit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2686          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2687          
   2688          		/* If the mutex was given back by an interrupt while the queue was
   2689          		locked then the mutex holder might now be NULL. */
   2690          		if( pxMutexHolder != NULL )
   \   00000004   0xD026             BEQ.N    ??vTaskPriorityInherit_0
   2691          		{
   2692          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   \   00000006   0x....             LDR.N    R5,??DataTable37
   \   00000008   0x6AE0             LDR      R0,[R4, #+44]
   \   0000000A   0x6AA9             LDR      R1,[R5, #+40]
   \   0000000C   0x6AC9             LDR      R1,[R1, #+44]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD220             BCS.N    ??vTaskPriorityInherit_0
   2693          			{
   2694          				/* Adjust the mutex holder state to account for its new priority. */
   2695          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   00000012   0x6AA8             LDR      R0,[R5, #+40]
   \   00000014   0x6AC0             LDR      R0,[R0, #+44]
   \   00000016   0xF1C0 0x000C      RSB      R0,R0,#+12
   \   0000001A   0x61A0             STR      R0,[R4, #+24]
   2696          
   2697          				/* If the task being modified is in the ready state it will need to
   2698          				be moved into a new list. */
   2699          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \   0000001C   0x....             LDR.N    R6,??DataTable37_1
   \   0000001E   0x2714             MOVS     R7,#+20
   \   00000020   0x6960             LDR      R0,[R4, #+20]
   \   00000022   0x6AE1             LDR      R1,[R4, #+44]
   \   00000024   0x4379             MULS     R1,R7,R1
   \   00000026   0x4431             ADD      R1,R6,R1
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD110             BNE.N    ??vTaskPriorityInherit_1
   2700          				{
   2701          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   0000002C   0x1D20             ADDS     R0,R4,#+4
   \   0000002E   0x.... 0x....      BL       uxListRemove
   2702          					{
   2703          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   2704          					}
   2705          
   2706          					/* Inherit the priority before being moved into the new list. */
   2707          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   \   00000032   0x6AA8             LDR      R0,[R5, #+40]
   \   00000034   0x6AC0             LDR      R0,[R0, #+44]
   \   00000036   0x62E0             STR      R0,[R4, #+44]
   2708          					prvAddTaskToReadyList( pxTCB );
   \   00000038   0x6D69             LDR      R1,[R5, #+84]
   \   0000003A   0x4281             CMP      R1,R0
   \   0000003C   0xD200             BCS.N    ??vTaskPriorityInherit_2
   \   0000003E   0x6568             STR      R0,[R5, #+84]
   \                     ??vTaskPriorityInherit_2: (+1)
   \   00000040   0x1D21             ADDS     R1,R4,#+4
   \   00000042   0x4378             MULS     R0,R7,R0
   \   00000044   0x4430             ADD      R0,R6,R0
   \   00000046   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000004A   0x.... 0x....      B.W      vListInsertEnd
   2709          				}
   2710          				else
   2711          				{
   2712          					/* Just inherit the priority. */
   2713          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   \                     ??vTaskPriorityInherit_1: (+1)
   \   0000004E   0x6AA8             LDR      R0,[R5, #+40]
   \   00000050   0x6AC0             LDR      R0,[R0, #+44]
   \   00000052   0x62E0             STR      R0,[R4, #+44]
   2714          				}
   2715          
   2716          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   2717          			}
   2718          		}
   2719          	}
   \                     ??vTaskPriorityInherit_0: (+1)
   \   00000054   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2720          
   2721          #endif /* configUSE_MUTEXES */
   2722          /*-----------------------------------------------------------*/
   2723          
   2724          #if ( configUSE_MUTEXES == 1 )
   2725          

   \                                 In section .text, align 2, keep-with-next
   2726          	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
   2727          	{
   \                     vTaskPriorityDisinherit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2728          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2729          
   2730          		if( pxMutexHolder != NULL )
   \   00000004   0xD01B             BEQ.N    ??vTaskPriorityDisinherit_0
   2731          		{
   2732          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   \   00000006   0x6AE0             LDR      R0,[R4, #+44]
   \   00000008   0x6CE1             LDR      R1,[R4, #+76]
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD017             BEQ.N    ??vTaskPriorityDisinherit_0
   2733          			{
   2734          				/* We must be the running task to be able to give the mutex back.
   2735          				Remove ourselves from the ready list we currently appear in. */
   2736          				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
   \   0000000E   0x1D20             ADDS     R0,R4,#+4
   \   00000010   0x.... 0x....      BL       uxListRemove
   2737          				{
   2738          					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   2739          				}
   2740          
   2741          				/* Disinherit the priority before adding the task into the new
   2742          				ready list. */
   2743          				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   2744          				pxTCB->uxPriority = pxTCB->uxBasePriority;
   \   00000014   0x6CE0             LDR      R0,[R4, #+76]
   \   00000016   0x62E0             STR      R0,[R4, #+44]
   2745          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   00000018   0xF1C0 0x000C      RSB      R0,R0,#+12
   \   0000001C   0x61A0             STR      R0,[R4, #+24]
   2746          				prvAddTaskToReadyList( pxTCB );
   \   0000001E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000020   0x....             LDR.N    R1,??DataTable37
   \   00000022   0x6D4A             LDR      R2,[R1, #+84]
   \   00000024   0x4282             CMP      R2,R0
   \   00000026   0xD200             BCS.N    ??vTaskPriorityDisinherit_1
   \   00000028   0x6548             STR      R0,[R1, #+84]
   \                     ??vTaskPriorityDisinherit_1: (+1)
   \   0000002A   0x1D21             ADDS     R1,R4,#+4
   \   0000002C   0x....             LDR.N    R2,??DataTable37_1
   \   0000002E   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   00000032   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   00000036   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003A   0x.... 0x....      B.W      vListInsertEnd
   2747          			}
   2748          		}
   2749          	}
   \                     ??vTaskPriorityDisinherit_0: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   2750          
   2751          #endif /* configUSE_MUTEXES */
   2752          /*-----------------------------------------------------------*/
   2753          
   2754          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2755          
   2756          	void vTaskEnterCritical( void )
   2757          	{
   2758          		portDISABLE_INTERRUPTS();
   2759          
   2760          		if( xSchedulerRunning != pdFALSE )
   2761          		{
   2762          			( pxCurrentTCB->uxCriticalNesting )++;
   2763          		}
   2764          	}
   2765          
   2766          #endif /* portCRITICAL_NESTING_IN_TCB */
   2767          /*-----------------------------------------------------------*/
   2768          
   2769          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2770          
   2771          	void vTaskExitCritical( void )
   2772          	{
   2773          		if( xSchedulerRunning != pdFALSE )
   2774          		{
   2775          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   2776          			{
   2777          				( pxCurrentTCB->uxCriticalNesting )--;
   2778          
   2779          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   2780          				{
   2781          					portENABLE_INTERRUPTS();
   2782          				}
   2783          			}
   2784          		}
   2785          	}
   2786          
   2787          #endif /* portCRITICAL_NESTING_IN_TCB */
   2788          /*-----------------------------------------------------------*/
   2789          
   2790          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
   2791          

   \                                 In section .text, align 4, keep-with-next
   2792          	void vTaskList( signed char *pcWriteBuffer )
   2793          	{
   \                     vTaskList: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   2794          	xTaskStatusType *pxTaskStatusArray;
   2795          	volatile unsigned portBASE_TYPE uxArraySize, x;
   2796          	char cStatus;
   2797          
   2798          		/*
   2799          		 * PLEASE NOTE:
   2800          		 *
   2801          		 * This function is provided for convenience only, and is used by many
   2802          		 * of the demo applications.  Do not consider it to be part of the
   2803          		 * scheduler.
   2804          		 *
   2805          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   2806          		 * uxTaskGetSystemState() output into a human readable table that
   2807          		 * displays task names, states and stack usage.
   2808          		 *
   2809          		 * vTaskList() has a dependency on the sprintf() C library function that
   2810          		 * might bloat the code size, use a lot of stack, and provide different
   2811          		 * results on different platforms.  An alternative, tiny, third party,
   2812          		 * and limited functionality implementation of sprintf() is provided in
   2813          		 * many of the FreeRTOS/Demo sub-directories in a file called
   2814          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   2815          		 * snprintf() implementation!).
   2816          		 *
   2817          		 * It is recommended that production systems call uxTaskGetSystemState()
   2818          		 * directly to get access to raw stats data, rather than indirectly
   2819          		 * through a call to vTaskList().
   2820          		 */
   2821          
   2822          
   2823          		/* Make sure the write buffer does not contain a string. */
   2824          		*pcWriteBuffer = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7020             STRB     R0,[R4, #+0]
   2825          
   2826          		/* Take a snapshot of the number of tasks in case it changes while this
   2827          		function is executing. */
   2828          		uxArraySize = uxCurrentNumberOfTasks;
   \   0000000A   0x....             LDR.N    R0,??DataTable37
   \   0000000C   0x6CC1             LDR      R1,[R0, #+76]
   \   0000000E   0x9104             STR      R1,[SP, #+16]
   2829          
   2830          		/* Allocate an array index for each task. */
   2831          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( xTaskStatusType ) );
   \   00000010   0x6CC0             LDR      R0,[R0, #+76]
   \   00000012   0x0140             LSLS     R0,R0,#+5
   \   00000014   0x.... 0x....      BL       pvPortMalloc
   \   00000018   0x0005             MOVS     R5,R0
   2832          
   2833          		if( pxTaskStatusArray != NULL )
   \   0000001A   0xD045             BEQ.N    ??vTaskList_1
   2834          		{
   2835          			/* Generate the (binary) data. */
   2836          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x9904             LDR      R1,[SP, #+16]
   \   00000020   0x.... 0x....      BL       uxTaskGetSystemState
   \   00000024   0x9004             STR      R0,[SP, #+16]
   2837          
   2838          			/* Create a human readable table from the binary data. */
   2839          			for( x = 0; x < uxArraySize; x++ )
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9003             STR      R0,[SP, #+12]
   \   0000002A   0xE01F             B.N      ??vTaskList_2
   2840          			{
   2841          				switch( pxTaskStatusArray[ x ].eCurrentState )
   2842          				{
   2843          				case eReady:		cStatus = tskREADY_CHAR;
   2844          									break;
   2845          
   2846          				case eBlocked:		cStatus = tskBLOCKED_CHAR;
   2847          									break;
   2848          
   2849          				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   2850          									break;
   2851          
   2852          				case eDeleted:		cStatus = tskDELETED_CHAR;
   2853          									break;
   2854          
   2855          				default:			/* Should not get here, but it is included
   2856          									to prevent static checking errors. */
   2857          									cStatus = 0x00;
   \                     ??vTaskList_3: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   2858          									break;
   2859          				}
   2860          
   2861          				sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   \                     ??vTaskList_4: (+1)
   \   0000002E   0x9803             LDR      R0,[SP, #+12]
   \   00000030   0x9903             LDR      R1,[SP, #+12]
   \   00000032   0x9A03             LDR      R2,[SP, #+12]
   \   00000034   0xEB05 0x1040      ADD      R0,R5,R0, LSL #+5
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x9002             STR      R0,[SP, #+8]
   \   0000003C   0xEB05 0x1041      ADD      R0,R5,R1, LSL #+5
   \   00000040   0x8B80             LDRH     R0,[R0, #+28]
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0xEB05 0x1042      ADD      R0,R5,R2, LSL #+5
   \   00000048   0x6900             LDR      R0,[R0, #+16]
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0xEB05 0x1040      ADD      R0,R5,R0, LSL #+5
   \   00000052   0x6842             LDR      R2,[R0, #+4]
   \   00000054   0x.... 0x....      ADR.W    R1,?_1
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       sprintf
   2862          				pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       strlen
   \   00000064   0x4404             ADD      R4,R4,R0
   \   00000066   0x9803             LDR      R0,[SP, #+12]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x9003             STR      R0,[SP, #+12]
   \                     ??vTaskList_2: (+1)
   \   0000006C   0x9803             LDR      R0,[SP, #+12]
   \   0000006E   0x9904             LDR      R1,[SP, #+16]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD213             BCS.N    ??vTaskList_5
   \   00000074   0x9803             LDR      R0,[SP, #+12]
   \   00000076   0xEB05 0x1040      ADD      R0,R5,R0, LSL #+5
   \   0000007A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x2803             CMP      R0,#+3
   \   00000080   0xD8D4             BHI.N    ??vTaskList_3
   \   00000082   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??vTaskList_0:
   \   00000086   0x03 0x05          DC8      0x3,0x5,0x7,0x9
   \              0x07 0x09    
   \                     ??vTaskList_6: (+1)
   \   0000008A   0xE7CF             B.N      ??vTaskList_3
   \                     ??vTaskList_7: (+1)
   \   0000008C   0x2352             MOVS     R3,#+82
   \   0000008E   0xE7CE             B.N      ??vTaskList_4
   \                     ??vTaskList_8: (+1)
   \   00000090   0x2342             MOVS     R3,#+66
   \   00000092   0xE7CC             B.N      ??vTaskList_4
   \                     ??vTaskList_9: (+1)
   \   00000094   0x2353             MOVS     R3,#+83
   \   00000096   0xE7CA             B.N      ??vTaskList_4
   \                     ??vTaskList_10: (+1)
   \   00000098   0x2344             MOVS     R3,#+68
   \   0000009A   0xE7C8             B.N      ??vTaskList_4
   2863          			}
   2864          
   2865          			/* Free the array again. */
   2866          			vPortFree( pxTaskStatusArray );
   \                     ??vTaskList_5: (+1)
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0xB005             ADD      SP,SP,#+20
   \   000000A0   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   000000A4   0x.... 0x....      B.W      vPortFree
   2867          		}
   2868          	}
   \                     ??vTaskList_1: (+1)
   \   000000A8   0xB005             ADD      SP,SP,#+20
   \   000000AA   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x........         DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x49 0x44          DC8 "IDLE"
   \              0x4C 0x45    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x25 0x73          DC8 "%s\t\t%c\t%u\t%u\t%u\015\012"
   \              0x09 0x09    
   \              0x25 0x63    
   \              0x09 0x25    
   \              0x75 0x09    
   \              0x25 0x75    
   \              0x09 0x25    
   \              0x75 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
   2869          
   2870          #endif /* configUSE_TRACE_FACILITY */
   2871          /*----------------------------------------------------------*/
   2872          
   2873          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
   2874          
   2875          	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
   2876          	{
   2877          	xTaskStatusType *pxTaskStatusArray;
   2878          	volatile unsigned portBASE_TYPE uxArraySize, x;
   2879          	unsigned long ulTotalTime, ulStatsAsPercentage;
   2880          
   2881          		/*
   2882          		 * PLEASE NOTE:
   2883          		 *
   2884          		 * This function is provided for convenience only, and is used by many
   2885          		 * of the demo applications.  Do not consider it to be part of the
   2886          		 * scheduler.
   2887          		 *
   2888          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   2889          		 * of the uxTaskGetSystemState() output into a human readable table that
   2890          		 * displays the amount of time each task has spent in the Running state
   2891          		 * in both absolute and percentage terms.
   2892          		 *
   2893          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   2894          		 * function that might bloat the code size, use a lot of stack, and
   2895          		 * provide different results on different platforms.  An alternative,
   2896          		 * tiny, third party, and limited functionality implementation of
   2897          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   2898          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   2899          		 * a full snprintf() implementation!).
   2900          		 *
   2901          		 * It is recommended that production systems call uxTaskGetSystemState()
   2902          		 * directly to get access to raw stats data, rather than indirectly
   2903          		 * through a call to vTaskGetRunTimeStats().
   2904          		 */
   2905          
   2906          		/* Make sure the write buffer does not contain a string. */
   2907          		*pcWriteBuffer = 0x00;
   2908          
   2909          		/* Take a snapshot of the number of tasks in case it changes while this
   2910          		function is executing. */
   2911          		uxArraySize = uxCurrentNumberOfTasks;
   2912          
   2913          		/* Allocate an array index for each task. */
   2914          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( xTaskStatusType ) );
   2915          
   2916          		if( pxTaskStatusArray != NULL )
   2917          		{
   2918          			/* Generate the (binary) data. */
   2919          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   2920          
   2921          			/* For percentage calculations. */
   2922          			ulTotalTime /= 100UL;
   2923          
   2924          			/* Avoid divide by zero errors. */
   2925          			if( ulTotalTime > 0 )
   2926          			{
   2927          				/* Create a human readable table from the binary data. */
   2928          				for( x = 0; x < uxArraySize; x++ )
   2929          				{
   2930          					/* What percentage of the total run time has the task used?
   2931          					This will always be rounded down to the nearest integer.
   2932          					ulTotalRunTimeDiv100 has already been divided by 100. */
   2933          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   2934          
   2935          					if( ulStatsAsPercentage > 0UL )
   2936          					{
   2937          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   2938          						{
   2939          							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   2940          						}
   2941          						#else
   2942          						{
   2943          							/* sizeof( int ) == sizeof( long ) so a smaller
   2944          							printf() library can be used. */
   2945          							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   2946          						}
   2947          						#endif
   2948          					}
   2949          					else
   2950          					{
   2951          						/* If the percentage is zero here then the task has
   2952          						consumed less than 1% of the total run time. */
   2953          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   2954          						{
   2955          							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
   2956          						}
   2957          						#else
   2958          						{
   2959          							/* sizeof( int ) == sizeof( long ) so a smaller
   2960          							printf() library can be used. */
   2961          							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   2962          						}
   2963          						#endif
   2964          					}
   2965          
   2966          					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
   2967          				}
   2968          			}
   2969          
   2970          			/* Free the array again. */
   2971          			vPortFree( pxTaskStatusArray );
   2972          		}
   2973          	}
   2974          
   2975          #endif /* configGENERATE_RUN_TIME_STATS */
   2976          
   2977          
   2978          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   prvAddCurrentTaskToDelayedList
         0   -> vListInsert
        16   -> vListInsert
      16   prvAllocateTCBAndStack
        16   -> __aeabi_memset4
        16   -> pvPortMalloc
        16   -> vPortFree
      16   prvCheckTasksWaitingTermination
        16   -> prvDeleteTCB
        16   -> uxListRemove
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       8   prvDeleteTCB
         0   -> vPortFree
         8   -> vPortFree
       8   prvIdleTask
         8   -> prvCheckTasksWaitingTermination
         8   -> vPortYield
      16   prvInitialiseTCBVariables
        16   -> vListInitialiseItem
      16   prvInitialiseTaskLists
        16   -> vListInitialise
      32   prvListTaskWithinSingleList
        32   -> prvTaskCheckFreeStackSpace
       0   prvTaskCheckFreeStackSpace
       0   uxTaskGetNumberOfTasks
      32   uxTaskGetSystemState
        32   -> prvListTaskWithinSingleList
        32   -> vTaskSuspendAll
        32   -> xTaskResumeAll
       0   uxTaskGetTaskNumber
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   vTaskDelay
         8   -> prvAddCurrentTaskToDelayedList
         8   -> uxListRemove
         0   -> vPortYield
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
      16   vTaskDelayUntil
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
         0   -> vPortYield
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
      16   vTaskDelete
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
         0   -> vPortYield
       8   vTaskEndScheduler
         8   -> ulPortSetInterruptMask
         0   -> vPortEndScheduler
      32   vTaskList
        32   -> pvPortMalloc
        32   -> sprintf
        32   -> strlen
        32   -> uxTaskGetSystemState
         0   -> vPortFree
       0   vTaskMissedYield
      16   vTaskPlaceOnEventList
         0   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsert
         0   -> vListInsertEnd
      16   vTaskPlaceOnEventListRestricted
         0   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsertEnd
       8   vTaskPriorityDisinherit
         8   -> uxListRemove
         0   -> vListInsertEnd
      24   vTaskPriorityInherit
        24   -> uxListRemove
         0   -> vListInsertEnd
      24   vTaskPrioritySet
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
         0   -> vPortExitCritical
        24   -> vPortYield
      16   vTaskResume
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vPortYield
        16   -> xTaskIsTaskSuspended
       0   vTaskSetTaskNumber
       0   vTaskSetTimeOutState
      24   vTaskStartScheduler
        24   -> ulPortSetInterruptMask
         0   -> xPortStartScheduler
        24   -> xTaskGenericCreate
        24   -> xTimerCreateTimerTask
      16   vTaskSuspend
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
         0   -> vPortYield
         0   -> vTaskSwitchContext
       0   vTaskSuspendAll
       8   vTaskSwitchContext
         8   -> memcmp
         8   -> vApplicationStackOverflowHook
      16   xTaskCheckForTimeOut
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSetTimeOutState
      40   xTaskGenericCreate
        40   -> prvAllocateTCBAndStack
        40   -> prvInitialiseTCBVariables
        40   -> prvInitialiseTaskLists
        40   -> pxPortInitialiseStack
        40   -> vListInsertEnd
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYield
       0   xTaskGetCurrentTaskHandle
       0   xTaskGetSchedulerState
       8   xTaskGetTickCount
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   xTaskGetTickCountFromISR
         8   -> ulPortSetInterruptMask
         8   -> vPortClearInterruptMask
      24   xTaskIncrementTick
        24   -> uxListRemove
        24   -> vListInsertEnd
       4   xTaskIsTaskSuspended
      16   xTaskRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskResumeAll
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
        16   -> xTaskIncrementTick
      24   xTaskResumeFromISR
        24   -> ulPortSetInterruptMask
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortClearInterruptMask
        24   -> xTaskIsTaskSuspended


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable37
       4  ??DataTable37_1
       8  ?_0
      20  ?_1
      48  prvAddCurrentTaskToDelayedList
      58  prvAllocateTCBAndStack
      70  prvCheckTasksWaitingTermination
      20  prvDeleteTCB
      22  prvIdleTask
      76  prvInitialiseTCBVariables
      78  prvInitialiseTaskLists
     140  prvListTaskWithinSingleList
      20  prvTaskCheckFreeStackSpace
     240  pxReadyTasksLists
      20  ucExpectedStackBytes
       8  uxTaskGetNumberOfTasks
     142  uxTaskGetSystemState
      12  uxTaskGetTaskNumber
      28  uxTaskPriorityGet
      54  vTaskDelay
      86  vTaskDelayUntil
      90  vTaskDelete
      22  vTaskEndScheduler
     172  vTaskList
      10  vTaskMissedYield
      56  vTaskPlaceOnEventList
      34  vTaskPlaceOnEventListRestricted
      64  vTaskPriorityDisinherit
      86  vTaskPriorityInherit
     148  vTaskPrioritySet
      88  vTaskResume
       8  vTaskSetTaskNumber
      14  vTaskSetTimeOutState
      72  vTaskStartScheduler
      94  vTaskSuspend
      12  vTaskSuspendAll
     132  vTaskSwitchContext
     156  xPendingReadyList
          xTasksWaitingTermination
          pxCurrentTCB
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          uxTasksDeleted
          xSuspendedTaskList
          uxCurrentNumberOfTasks
          xTickCount
          uxTopReadyPriority
          xSchedulerRunning
          uxSchedulerSuspended
          uxPendedTicks
          xYieldPending
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          xDelayedTaskList1
          xDelayedTaskList2
      78  xTaskCheckForTimeOut
     208  xTaskGenericCreate
       6  xTaskGetCurrentTaskHandle
      26  xTaskGetSchedulerState
      20  xTaskGetTickCount
      20  xTaskGetTickCountFromISR
     206  xTaskIncrementTick
      36  xTaskIsTaskSuspended
      92  xTaskRemoveFromEventList
     150  xTaskResumeAll
     100  xTaskResumeFromISR

 
   240 bytes in section .bss
   156 bytes in section .data
 2 962 bytes in section .text
 
 2 962 bytes of CODE memory
   396 bytes of DATA memory

Errors: none
Warnings: none
