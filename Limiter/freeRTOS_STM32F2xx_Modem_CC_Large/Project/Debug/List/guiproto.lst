###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\guiproto.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\guiproto.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\guiproto.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\guiproto.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\guiproto.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2015 LOOP *************************************
      3          *
      4          * File Name          : guiproto.c
      5          *
      6          * Author             : Reserch & Developing 1 Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 07/29/2015
     11          *
     12          * Description        : gui protocol
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                             INCLUDE FILES
     20          *********************************************************************************************************
     21          */
     22          
     23          #define GUIPROTOCOL_GLOBALS
     24          #include "includes.h"
     25          
     26          
     27          typedef union {
     28            char self;
     29            struct {  
     30              char simcard  :1;
     31              char modem    :1;
     32              char din1     :1;
     33              char din2     :1;
     34              char keyon    :1;
     35              char flash    :1;
     36              char fram     :1;
     37              char gps      :1;
     38            };
     39          } resSelfTest;
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                        LOCAL GLOBAL VARIABLES
     44          *********************************************************************************************************
     45          */
     46          
     47          static char guiTxbuff[GUI_BUFFSZ];
     48          static char guiRxbuff[GUI_BUFFSZ];
     49          
     50          static commProcess_t GUIProto;
     51          
     52          /*
     53          ********************************************************************************
     54          * Description : Init_GUIcommRxProc
     55          * Arguments   : port
     56          * Return      : 
     57          * Note        : GUI communication initialize
     58          ******************************************************************************** 
     59          */

   \                                 In section .text, align 2, keep-with-next
     60          void Init_GUIcommRxProc(int port)
     61          {
   \                     Init_GUIcommRxProc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     62          	portENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
     63          	GUIProto.nPort = port;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000000C   0x6004             STR      R4,[R0, #+0]
     64          	GUIProto.nTmr = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6101             STR      R1,[R0, #+16]
     65          	GUIProto.lastPacketlen = 0;
   \   00000012   0xF600 0x0018      ADDW     R0,R0,#+2072
   \   00000016   0x6001             STR      R1,[R0, #+0]
     66          	GUIProto.last_CRC16 = 0;
   \   00000018   0x8081             STRH     R1,[R0, #+4]
     67          	portEXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       vPortExitCritical
     68          
     69          	CommReInit(port);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      CommReInit
     70          }
     71          
     72          /*
     73          ********************************************************************************
     74          * Description : RTC_ValSet
     75          * Arguments   : char *data
     76          * Return      : 
     77          * Note        : RTC set
     78          ******************************************************************************** 
     79          */

   \                                 In section .text, align 2, keep-with-next
     80          void RTC_ValSet(INT8U *data)
     81          {
   \                     RTC_ValSet: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     82            Time_t tmp_local;
     83          	sysinfo_t *tmp_s = &_sysinfo 	;
     84          	INT32U tmp_data;
     85          
     86          	memcpy(&tmp_data, data, sizeof(tmp_data));
   \   00000002   0x2204             MOVS     R2,#+4
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0xA802             ADD      R0,SP,#+8
   \   00000008   0x.... 0x....      BL       __aeabi_memcpy
     87            
     88            tmp_local = gmtime_conv(tmp_data);
   \   0000000C   0x9902             LDR      R1,[SP, #+8]
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       gmtime_conv
     89            tmp_s->tm_ptr.tm_sec  = tmp_local.tm_sec;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000018   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
     90            tmp_s->tm_ptr.tm_min  = tmp_local.tm_min;
   \   0000001E   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000022   0x6201             STR      R1,[R0, #+32]
     91            tmp_s->tm_ptr.tm_hour = tmp_local.tm_hour;
   \   00000024   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000028   0x6241             STR      R1,[R0, #+36]
     92            tmp_s->tm_ptr.tm_mday = tmp_local.tm_mday;
   \   0000002A   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   0000002E   0x6281             STR      R1,[R0, #+40]
     93            tmp_s->tm_ptr.tm_mon  = tmp_local.tm_mon;
   \   00000030   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000034   0x62C1             STR      R1,[R0, #+44]
     94            tmp_s->tm_ptr.tm_year = tmp_local.tm_year;
   \   00000036   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   0000003A   0x6301             STR      R1,[R0, #+48]
     95            SetRTCTime(&tmp_s->tm_ptr);
   \   0000003C   0x301C             ADDS     R0,R0,#+28
   \   0000003E   0x.... 0x....      BL       SetRTCTime
     96          }
   \   00000042   0xBD07             POP      {R0-R2,PC}       ;; return
     97          
     98          /*
     99          ********************************************************************************
    100          * Description : RTC_ValGet
    101          * Arguments   : INT8U *pbuf
    102          * Return      : 
    103          * Note        : RTC get
    104          ******************************************************************************** 
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          int RTC_ValGet(INT8U *pbuf)
    107          {
    108          	int	nCnt=0;  	
    109            sysinfo_t *s = &_sysinfo 	;  
    110            
    111            pbuf[0] = s->tm_ptr.tm_year;
   \                     RTC_ValGet: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000004   0x6B0A             LDR      R2,[R1, #+48]
   \   00000006   0x7002             STRB     R2,[R0, #+0]
    112            pbuf[1] = s->tm_ptr.tm_mon;
   \   00000008   0x6ACA             LDR      R2,[R1, #+44]
   \   0000000A   0x7042             STRB     R2,[R0, #+1]
    113            pbuf[2] = s->tm_ptr.tm_mday;
   \   0000000C   0x6A8A             LDR      R2,[R1, #+40]
   \   0000000E   0x7082             STRB     R2,[R0, #+2]
    114            pbuf[3] = s->tm_ptr.tm_hour;
   \   00000010   0x6A4A             LDR      R2,[R1, #+36]
   \   00000012   0x70C2             STRB     R2,[R0, #+3]
    115            pbuf[4] = s->tm_ptr.tm_min;
   \   00000014   0x6A0A             LDR      R2,[R1, #+32]
   \   00000016   0x7102             STRB     R2,[R0, #+4]
    116            pbuf[5] = s->tm_ptr.tm_sec;
   \   00000018   0x69CA             LDR      R2,[R1, #+28]
   \   0000001A   0x7142             STRB     R2,[R0, #+5]
    117            pbuf[6] = s->tm_ptr.tm_wday;    
   \   0000001C   0x6B49             LDR      R1,[R1, #+52]
   \   0000001E   0x7181             STRB     R1,[R0, #+6]
    118            nCnt = 7;
    119            
    120            return 	nCnt;
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0x4770             BX       LR               ;; return
    121          }
    122          
    123          /*
    124          ********************************************************************************
    125          * Description : ADC_OnOff
    126          * Arguments   : INT8U *pbuf, INT8U *data, int length
    127          * Return      : 
    128          * Note        : RTC get
    129          ******************************************************************************** 
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          int ADC_OnOff(INT8U *data)
    132          {
    133            if(!data[0]) Flags.GUIADCFlag = 0;
   \                     ADC_OnOff: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE.N    ??ADC_OnOff_0
   \   0000000C   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000010   0x4010             ANDS     R0,R0,R2
   \   00000012   0x8008             STRH     R0,[R1, #+0]
   \   00000014   0xE002             B.N      ??ADC_OnOff_1
    134            else Flags.GUIADCFlag = 1;
   \                     ??ADC_OnOff_0: (+1)
   \   00000016   0xF442 0x4080      ORR      R0,R2,#0x4000
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    135            
    136            return 	1;
   \                     ??ADC_OnOff_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR               ;; return
    137          }
    138          
    139          /*
    140          ********************************************************************************
    141          * Description : Data_ValGet
    142          * Arguments   : INT8U *pbuf, INT8U *data, int length
    143          * Return      : 
    144          * Note        : RTC get
    145          ******************************************************************************** 
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          int Data_ValGet(INT8U *pbuf, INT8U *data, int len)
    148          {
   \                     Data_ValGet: (+1)
   \   00000000   0xB410             PUSH     {R4}
    149          	int	nCnt;  	
    150            
    151            for(nCnt=0; nCnt<len; nCnt++) pbuf[0] = data[0];
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE002             B.N      ??Data_ValGet_0
   \                     ??Data_ValGet_1: (+1)
   \   00000006   0x780C             LDRB     R4,[R1, #+0]
   \   00000008   0x7004             STRB     R4,[R0, #+0]
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Data_ValGet_0: (+1)
   \   0000000C   0x4293             CMP      R3,R2
   \   0000000E   0xDBFA             BLT.N    ??Data_ValGet_1
    152            
    153            return 	nCnt;
   \   00000010   0x4618             MOV      R0,R3
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    154          }
    155          
    156          /*
    157          ********************************************************************************
    158          * Description : cal_checksum
    159          * Arguments   : data, length
    160          * Return      : 
    161          * Note        : check sum
    162          ******************************************************************************** 
    163          */

   \                                 In section .text, align 2, keep-with-next
    164          INT8U cal_checksum(INT8U *pdata, int len)
    165          {
   \                     cal_checksum: (+1)
   \   00000000   0xB410             PUSH     {R4}
    166          	INT8U retSum=0;
   \   00000002   0x2200             MOVS     R2,#+0
    167          	int nCount=0;
   \   00000004   0x4613             MOV      R3,R2
    168          
    169          	for(nCount = 0; nCount < len; nCount++){
   \   00000006   0xE003             B.N      ??cal_checksum_0
    170          		retSum += pdata[nCount];
   \                     ??cal_checksum_1: (+1)
   \   00000008   0x5CC4             LDRB     R4,[R0, R3]
   \   0000000A   0x18A2             ADDS     R2,R4,R2
   \   0000000C   0xB2D2             UXTB     R2,R2
    171          	}
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??cal_checksum_0: (+1)
   \   00000010   0x428B             CMP      R3,R1
   \   00000012   0xDBF9             BLT.N    ??cal_checksum_1
    172          
    173          	return retSum;
   \   00000014   0x4610             MOV      R0,R2
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    174          }
    175          
    176          /*
    177          ********************************************************************************
    178          * Description : DecodePacket
    179          * Arguments   : *pbuff, *pTarget
    180          * Return      : 
    181          * Note        : decode packet
    182          ******************************************************************************** 
    183          */

   \                                 In section .text, align 2, keep-with-next
    184          int DecodePacket(char *pbuff, char *pTarget)
    185          {
   \                     DecodePacket: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    186          	INT8U checksum=0;
    187          
    188          	int nLength=0;
    189          	
    190          	portENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       vPortEnterCritical
    191          
    192          	nLength = pbuff[1];
    193          	nLength |= pbuff[2]<< 8;
   \   0000000C   0x7868             LDRB     R0,[R5, #+1]
   \   0000000E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000010   0xEA40 0x2601      ORR      R6,R0,R1, LSL #+8
    194          	memcpy(pTarget, pbuff, nLength+5);
   \   00000014   0x1D72             ADDS     R2,R6,#+5
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy
    195          
    196          	checksum = cal_checksum((INT8U *)&pTarget[1],nLength +2);
   \   0000001E   0x1CB1             ADDS     R1,R6,#+2
   \   00000020   0x1C60             ADDS     R0,R4,#+1
   \   00000022   0x.... 0x....      BL       cal_checksum
   \   00000026   0x4605             MOV      R5,R0
    197          
    198          	portEXIT_CRITICAL();
   \   00000028   0x.... 0x....      BL       vPortExitCritical
    199          
    200          	if((char)checksum != (char)pTarget[nLength+3]){
   \   0000002C   0x19A0             ADDS     R0,R4,R6
   \   0000002E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD00D             BEQ.N    ??DecodePacket_0
    201          		printk("Check sum error (%s) CMD:%02X me:%02X,you:%02X \n",__func__, \
    202                pTarget[4], (INT8U)checksum,(INT8U)pTarget[nLength-5]);
   \   00000034   0x19A0             ADDS     R0,R4,R6
   \   00000036   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x462B             MOV      R3,R5
   \   0000003E   0x7922             LDRB     R2,[R4, #+4]
   \   00000040   0x.... 0x....      ADR.W    R1,`DecodePacket::__func__`
   \   00000044   0x.... 0x....      ADR.W    R0,?_0
   \   00000048   0x.... 0x....      BL       printk
    203          		return CHKSUM_ERR;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xBD76             POP      {R1,R2,R4-R6,PC}
    204          	}
    205          	return 0;
   \                     ??DecodePacket_0: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    206          }
    207          
    208          
    209          /*
    210          ********************************************************************************
    211          * Description : MakePacket
    212          * Arguments   : cmd, type,	systype, *ptarget, *psource, dataLen
    213          * Return      : 
    214          * Note        : make packet
    215          ******************************************************************************** 
    216          */

   \                                 In section .text, align 2, keep-with-next
    217          int MakePacket(char cmd, char type,	char systype, char *ptarget, char *psource, int dataLen)
    218          {
   \                     MakePacket: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C05             LDR      R4,[SP, #+20]
    219          	char checksum=0,tmp=0;
    220          	int nCount=0,i,packlen=dataLen + 3;
   \   00000004   0x1CE5             ADDS     R5,R4,#+3
    221          
    222          	ptarget[nCount++] = START_PACKET;							// 0x7E
   \   00000006   0x267E             MOVS     R6,#+126
   \   00000008   0x701E             STRB     R6,[R3, #+0]
    223          	
    224          	tmp = packlen & 0xFF ;			// len
   \   0000000A   0x462E             MOV      R6,R5
    225          	ptarget[nCount++] = tmp ;
   \   0000000C   0x705E             STRB     R6,[R3, #+1]
    226          	checksum += tmp;
   \   0000000E   0xB2F6             UXTB     R6,R6
    227          
    228          	tmp = (packlen >> 8) & 0xFF ;	// len
   \   00000010   0x122F             ASRS     R7,R5,#+8
    229          	ptarget[nCount++] = tmp;
   \   00000012   0x709F             STRB     R7,[R3, #+2]
    230          	checksum += tmp;
    231          
    232          	ptarget[nCount++] = cmd;
   \   00000014   0x70D8             STRB     R0,[R3, #+3]
    233          	checksum += cmd;
    234          
    235          	ptarget[nCount++] = type;
   \   00000016   0x7119             STRB     R1,[R3, #+4]
    236          	checksum += type;
    237          
    238          	ptarget[nCount++] = systype;
   \   00000018   0x715A             STRB     R2,[R3, #+5]
   \   0000001A   0x2506             MOVS     R5,#+6
    239          	checksum += systype;
   \   0000001C   0x19BE             ADDS     R6,R7,R6
   \   0000001E   0x1980             ADDS     R0,R0,R6
   \   00000020   0x1808             ADDS     R0,R1,R0
   \   00000022   0x1811             ADDS     R1,R2,R0
   \   00000024   0xB2C9             UXTB     R1,R1
    240          
    241          	for(i=0; i< dataLen; i++)
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x9804             LDR      R0,[SP, #+16]
   \   0000002A   0xE006             B.N      ??MakePacket_0
    242          	{
    243          		ptarget[nCount++] = psource[i];
   \                     ??MakePacket_1: (+1)
   \   0000002C   0x5C87             LDRB     R7,[R0, R2]
   \   0000002E   0x555F             STRB     R7,[R3, R5]
   \   00000030   0x4635             MOV      R5,R6
    244          		checksum +=psource[i];
   \   00000032   0x5C86             LDRB     R6,[R0, R2]
   \   00000034   0x1871             ADDS     R1,R6,R1
   \   00000036   0xB2C9             UXTB     R1,R1
    245          	}
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \                     ??MakePacket_0: (+1)
   \   0000003A   0x1C6E             ADDS     R6,R5,#+1
   \   0000003C   0x42A2             CMP      R2,R4
   \   0000003E   0xDBF5             BLT.N    ??MakePacket_1
    246          	ptarget[nCount++] = checksum;
   \   00000040   0x5559             STRB     R1,[R3, R5]
    247          	ptarget[nCount++] = END_PACKET;								// 0x7F
   \   00000042   0x207F             MOVS     R0,#+127
   \   00000044   0x5598             STRB     R0,[R3, R6]
    248          
    249          	return nCount;
   \   00000046   0x1C70             ADDS     R0,R6,#+1
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
    250          }
    251          
    252          /*
    253          ********************************************************************************
    254          * Description : commRxProcGui
    255          * Arguments   : *pdev
    256          * Return      : 
    257          * Note        : External uart communication process
    258          ******************************************************************************** 
    259          */

   \                                 In section .text, align 2, keep-with-next
    260          static commProcess_t *commRxProcGui(commProcess_t *pdev)
    261          {
   \                     commRxProcGui: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    262          	static INT8U	data;
    263          	INT8U err,ret=0;
    264          	int SendCount;
    265          	static INT16U packlen = 0;
    266          	char tempbuff[4]={0};
   \   00000006   0xA803             ADD      R0,SP,#+12
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    267            
    268          	data = CommGetChar(pdev->nPort, 10, &err);
   \   0000000C   0xAA02             ADD      R2,SP,#+8
   \   0000000E   0x210A             MOVS     R1,#+10
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x.... 0x....      BL       CommGetChar
   \   00000018   0x.... 0x....      LDR.W    R5,??DataTable9_3
   \   0000001C   0x7028             STRB     R0,[R5, #+0]
    269          	if(err == COMM_NO_ERR)
   \   0000001E   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD135             BNE.N    ??commRxProcGui_0
    270          	{
    271          		if(data == 0x7E && pdev->bStart_flag==0){						// DecodePacket 전이기 때문에 무조건 7E는 start flag 이다.
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x297E             CMP      R1,#+126
   \   0000002A   0xD10B             BNE.N    ??commRxProcGui_1
   \   0000002C   0x6862             LDR      R2,[R4, #+4]
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD108             BNE.N    ??commRxProcGui_1
    272          
    273          			pdev->bStart_flag = 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x6060             STR      R0,[R4, #+4]
    274          			pdev->bEnd_flag   = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x60A0             STR      R0,[R4, #+8]
    275          			pdev->nPacketCnt  = 0;
   \   0000003A   0x60E0             STR      R0,[R4, #+12]
    276          			vTaskDelay(1);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       vTaskDelay
   \   00000042   0xE014             B.N      ??commRxProcGui_2
    277          
    278          		}
    279          		else if(pdev->nPacketCnt ==1)
   \                     ??commRxProcGui_1: (+1)
   \   00000044   0x68E2             LDR      R2,[R4, #+12]
   \   00000046   0x2A01             CMP      R2,#+1
   \   00000048   0xD101             BNE.N    ??commRxProcGui_3
    280          			packlen = data;
   \   0000004A   0x8068             STRH     R0,[R5, #+2]
   \   0000004C   0xE00F             B.N      ??commRxProcGui_2
    281          		else if(pdev->nPacketCnt ==2 )
   \                     ??commRxProcGui_3: (+1)
   \   0000004E   0x886B             LDRH     R3,[R5, #+2]
   \   00000050   0x2A02             CMP      R2,#+2
   \   00000052   0xD103             BNE.N    ??commRxProcGui_4
    282          			packlen |= data<< 8;
   \   00000054   0xEA43 0x2000      ORR      R0,R3,R0, LSL #+8
   \   00000058   0x8068             STRH     R0,[R5, #+2]
   \   0000005A   0xE008             B.N      ??commRxProcGui_2
    283          		else if( pdev->nPacketCnt >= (packlen +4) && (data == 0x7F) )
   \                     ??commRxProcGui_4: (+1)
   \   0000005C   0x1D18             ADDS     R0,R3,#+4
   \   0000005E   0x4282             CMP      R2,R0
   \   00000060   0xDB05             BLT.N    ??commRxProcGui_2
   \   00000062   0x297F             CMP      R1,#+127
   \   00000064   0xD103             BNE.N    ??commRxProcGui_2
    284          		{
    285          			pdev->bEnd_flag = 1;								              // 끝 플레그를 1로 만든다.
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x60A0             STR      R0,[R4, #+8]
    286          			vTaskDelay(1);
   \   0000006A   0x.... 0x....      BL       vTaskDelay
    287          		}
    288          		if ( pdev->nPacketCnt >= GUI_BUFFSZ )
   \                     ??commRxProcGui_2: (+1)
   \   0000006E   0x68E3             LDR      R3,[R4, #+12]
   \   00000070   0x2B80             CMP      R3,#+128
   \   00000072   0xDB07             BLT.N    ??commRxProcGui_5
    289          		{
    290          			printk("start = %d, end = %d, packcount = %d\n",pdev->bStart_flag,pdev->bEnd_flag,pdev->nPacketCnt);
   \   00000074   0x68A2             LDR      R2,[R4, #+8]
   \   00000076   0x6861             LDR      R1,[R4, #+4]
   \   00000078   0x.... 0x....      ADR.W    R0,?_2
   \   0000007C   0x.... 0x....      BL       printk
    291          			pdev->nPacketCnt = 0;	//방어코드	  
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x60E0             STR      R0,[R4, #+12]
    292          		}
    293          		pdev->pRxBuf[pdev->nPacketCnt++] = data;
   \                     ??commRxProcGui_5: (+1)
   \   00000084   0x68E0             LDR      R0,[R4, #+12]
   \   00000086   0x1C41             ADDS     R1,R0,#+1
   \   00000088   0x60E1             STR      R1,[R4, #+12]
   \   0000008A   0x7829             LDRB     R1,[R5, #+0]
   \   0000008C   0x4420             ADD      R0,R4,R0
   \   0000008E   0x7501             STRB     R1,[R0, #+20]
   \   00000090   0xE005             B.N      ??commRxProcGui_6
    294          	}
    295          	else
    296          	{
    297          		if( !pdev->bEnd_flag )
   \                     ??commRxProcGui_0: (+1)
   \   00000092   0x68A0             LDR      R0,[R4, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD102             BNE.N    ??commRxProcGui_6
    298          			vTaskDelay(1);
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      BL       vTaskDelay
    299          	}
    300          
    301          	if(pdev->bStart_flag && pdev->bEnd_flag && pdev->nPacketCnt)
   \                     ??commRxProcGui_6: (+1)
   \   0000009E   0x6860             LDR      R0,[R4, #+4]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD043             BEQ.N    ??commRxProcGui_7
   \   000000A4   0x68A0             LDR      R0,[R4, #+8]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD040             BEQ.N    ??commRxProcGui_7
   \   000000AA   0x68E0             LDR      R0,[R4, #+12]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD03D             BEQ.N    ??commRxProcGui_7
    302          	{
    303          		vTaskDelay(10);
   \   000000B0   0x200A             MOVS     R0,#+10
   \   000000B2   0x.... 0x....      BL       vTaskDelay
    304          		ret = DecodePacket(pdev->pRxBuf, pdev->pRxBuf_dec);
   \   000000B6   0xF204 0x4114      ADDW     R1,R4,#+1044
   \   000000BA   0xF104 0x0014      ADD      R0,R4,#+20
   \   000000BE   0x.... 0x....      BL       DecodePacket
   \   000000C2   0xB2C0             UXTB     R0,R0
    305          		if(ret)
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD02C             BEQ.N    ??commRxProcGui_8
    306          		{
    307          			pdev->bStart_flag = 0;
   \   000000C8   0x2100             MOVS     R1,#+0
   \   000000CA   0x6061             STR      R1,[R4, #+4]
    308          			pdev->bEnd_flag = 0;
   \   000000CC   0x60A1             STR      R1,[R4, #+8]
    309          			pdev->nPacketCnt = 0;
   \   000000CE   0x60E1             STR      R1,[R4, #+12]
    310          			if(ret == CHKSUM_ERR)
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD109             BNE.N    ??commRxProcGui_9
    311          			{
    312          				tempbuff[0] = 0x00;
   \   000000D4   0x4608             MOV      R0,R1
   \   000000D6   0xF88D 0x000C      STRB     R0,[SP, #+12]
    313          				tempbuff[1] = 0x01; 								        // check sum error
   \   000000DA   0xA803             ADD      R0,SP,#+12
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x7041             STRB     R1,[R0, #+1]
    314          				tempbuff[2] = pdev->pRxBuf_dec[1];					// receive command
   \   000000E0   0xF894 0x1415      LDRB     R1,[R4, #+1045]
   \   000000E4   0x7081             STRB     R1,[R0, #+2]
   \   000000E6   0xE00A             B.N      ??commRxProcGui_10
    315          			}
    316          			else if(ret == SYS_TYPE_ERR)
   \                     ??commRxProcGui_9: (+1)
   \   000000E8   0x2802             CMP      R0,#+2
   \   000000EA   0xD108             BNE.N    ??commRxProcGui_10
    317          			{
    318          				tempbuff[0] = 0x00;
   \   000000EC   0x4608             MOV      R0,R1
   \   000000EE   0xF88D 0x000C      STRB     R0,[SP, #+12]
    319          				tempbuff[1] = 0x04; 								        // check sum error
   \   000000F2   0xA803             ADD      R0,SP,#+12
   \   000000F4   0x2104             MOVS     R1,#+4
   \   000000F6   0x7041             STRB     R1,[R0, #+1]
    320          				tempbuff[2] = pdev->pRxBuf_dec[1];					// receive command
   \   000000F8   0xF894 0x1415      LDRB     R1,[R4, #+1045]
   \   000000FC   0x7081             STRB     R1,[R0, #+2]
    321          			}
    322          			SendCount = MakePacket(0xF0, 0x11, 0x04, (char *)guiTxbuff, (char *)tempbuff, 3);
   \                     ??commRxProcGui_10: (+1)
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0x9001             STR      R0,[SP, #+4]
   \   00000102   0xA803             ADD      R0,SP,#+12
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x1D2B             ADDS     R3,R5,#+4
   \   00000108   0x2204             MOVS     R2,#+4
   \   0000010A   0x2111             MOVS     R1,#+17
   \   0000010C   0x20F0             MOVS     R0,#+240
   \   0000010E   0x.... 0x....      BL       MakePacket
   \   00000112   0x4602             MOV      R2,R0
    323          			CommPutCharStr(pdev->nPort, (INT8U *)guiTxbuff, SendCount);
   \   00000114   0x1D29             ADDS     R1,R5,#+4
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0xB2C0             UXTB     R0,R0
   \   0000011A   0x.... 0x....      BL       CommPutCharStr
    324          			return NULL;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xE005             B.N      ??commRxProcGui_11
    325          		}
    326          		else
    327          		{
    328          			pdev->bStart_flag = 0;
   \                     ??commRxProcGui_8: (+1)
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x6060             STR      R0,[R4, #+4]
    329          			pdev->bEnd_flag = 0;
   \   00000126   0x60A0             STR      R0,[R4, #+8]
    330          			return pdev;
   \   00000128   0x4620             MOV      R0,R4
   \   0000012A   0xE000             B.N      ??commRxProcGui_11
    331          		}
    332          	}
    333          	return 0;	
   \                     ??commRxProcGui_7: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \                     ??commRxProcGui_11: (+1)
   \   0000012E   0xB005             ADD      SP,SP,#+20
   \   00000130   0xBD30             POP      {R4,R5,PC}       ;; return
    334          
    335          }

   \                                 In section .bss, align 4
   \                     `commRxProcGui::data`:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 128
    336          
    337          /*
    338          ********************************************************************************
    339          * Description : GUI_task
    340          * Arguments   : int port, INT8U wui, char *wui_data, int wui_len, INT8U *seq
    341          * Return      : 
    342          * Note        : GUI task process
    343          ******************************************************************************** 
    344          */

   \                                 In section .text, align 2, keep-with-next
    345          int GUI_parse_proc(void)
    346          {
   \                     GUI_parse_proc: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    347          	commProcess_t *pDev=NULL;
    348          	protocol_t *ptPacket=NULL;
    349          	
    350          	INT8U nMsgType=0;
    351          	static INT16U SendCount=0;
    352          
    353          /*-----------------------------------------------------------------------------------------------------*/	
    354            if(Flags.GUIDataFlag) {//2초 데이터
   \   00000004   0x....             LDR.N    R4,??DataTable9_4
   \   00000006   0x....             LDR.N    R5,??DataTable9_2
   \   00000008   0x8828             LDRH     R0,[R5, #+0]
   \   0000000A   0xF3C0 0x3040      UBFX     R0,R0,#+13,#+1
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD032             BEQ.N    ??GUI_parse_proc_0
    355              memcpy((INT8U*)&guiRxbuff, (INT8U*)&ReadValue, sizeof(stREAD_VALUE));
   \   00000012   0x2280             MOVS     R2,#+128
   \   00000014   0x....             LDR.N    R1,??DataTable9_5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy
    356              SendCount = sizeof(stREAD_VALUE);
    357              SendCount = MakePacket(0x41, 0x22, 0X01, (char *)guiTxbuff, (char *)guiRxbuff, SendCount);
   \   0000001C   0x....             LDR.N    R6,??DataTable9_3
   \   0000001E   0x2080             MOVS     R0,#+128
   \   00000020   0x9001             STR      R0,[SP, #+4]
   \   00000022   0x9400             STR      R4,[SP, #+0]
   \   00000024   0x1D33             ADDS     R3,R6,#+4
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2122             MOVS     R1,#+34
   \   0000002A   0x2041             MOVS     R0,#+65
   \   0000002C   0x.... 0x....      BL       MakePacket
   \   00000030   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    358          		CommPutCharStr(GPS_PORT,(INT8U *)guiTxbuff,SendCount);
   \   00000034   0xF8B4 0x2080      LDRH     R2,[R4, #+128]
   \   00000038   0x1D31             ADDS     R1,R6,#+4
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       CommPutCharStr
    359              if(Flags.GUIADCFlag) {//압력 ADC
   \   00000040   0x8828             LDRH     R0,[R5, #+0]
   \   00000042   0xF3C0 0x3080      UBFX     R0,R0,#+14,#+1
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD011             BEQ.N    ??GUI_parse_proc_1
    360                SendCount = MakePacket(0x47, 0x22, 0X01, (char *)guiTxbuff, (char *)&adcdata[ADC_AVR_P0], 2);
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x....             LDR.N    R0,??DataTable9_6
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x1D33             ADDS     R3,R6,#+4
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0x2122             MOVS     R1,#+34
   \   00000058   0x2047             MOVS     R0,#+71
   \   0000005A   0x.... 0x....      BL       MakePacket
   \   0000005E   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    361                CommPutCharStr(GPS_PORT,(INT8U *)guiTxbuff,SendCount);
   \   00000062   0xF8B4 0x2080      LDRH     R2,[R4, #+128]
   \   00000066   0x1D31             ADDS     R1,R6,#+4
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      BL       CommPutCharStr
    362              }
    363              Flags.GUIDataFlag = 0;
   \                     ??GUI_parse_proc_1: (+1)
   \   0000006E   0x8828             LDRH     R0,[R5, #+0]
   \   00000070   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000074   0x4008             ANDS     R0,R1,R0
   \   00000076   0x8028             STRH     R0,[R5, #+0]
    364            }
    365              
    366          	pDev = commRxProcGui(&GUIProto);
   \                     ??GUI_parse_proc_0: (+1)
   \   00000078   0x....             LDR.N    R0,??DataTable9
   \   0000007A   0x.... 0x....      BL       commRxProcGui
   \   0000007E   0x0006             MOVS     R6,R0
    367          	if(!pDev) {
   \   00000080   0xD101             BNE.N    ??GUI_parse_proc_2
    368          		return 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE0F1             B.N      ??GUI_parse_proc_3
    369          	}
    370          	else{
    371          		CommReInit(pDev->nPort);
   \                     ??GUI_parse_proc_2: (+1)
   \   00000086   0x6830             LDR      R0,[R6, #+0]
   \   00000088   0x.... 0x....      BL       CommReInit
    372          		// 시작 + 커멘드 + 타입 + system + 몸통 + 체크섬 + 끝 ==> 몸통을 제외한 6바이트만큼 빼면 실제받은 데이터의 사이즈
    373          		//vTaskDelay(1);
    374          		pDev->nPacketCnt -= 8;
   \   0000008C   0x68F0             LDR      R0,[R6, #+12]
   \   0000008E   0x3808             SUBS     R0,R0,#+8
   \   00000090   0x60F0             STR      R0,[R6, #+12]
    375          		// 여기까지 오면 정상. 패킷커멘드 분석시작.
    376          		ptPacket = (protocol_t *)&pDev->pRxBuf_dec[3];
    377          	}
    378          
    379          /*-----------------------------------------------------------------------------------------------------*/	
    380          
    381          	if(ptPacket->type == (TYPE_HREPORT | TYPE_LREQUEST))
   \   00000092   0xF44F 0x6083      MOV      R0,#+1048
   \   00000096   0x1837             ADDS     R7,R6,R0
   \   00000098   0x7838             LDRB     R0,[R7, #+0]
   \   0000009A   0x2811             CMP      R0,#+17
   \   0000009C   0xD102             BNE.N    ??GUI_parse_proc_4
    382          		nMsgType = (TYPE_HREPORT | TYPE_LRESPONSE);
   \   0000009E   0xF04F 0x0812      MOV      R8,#+18
   \   000000A2   0xE001             B.N      ??GUI_parse_proc_5
    383          	else
    384          		nMsgType = (TYPE_HSET | TYPE_LRESPONSE);
   \                     ??GUI_parse_proc_4: (+1)
   \   000000A4   0xF04F 0x0822      MOV      R8,#+34
    385          	
    386          
    387          	switch(ptPacket->cmd)
   \                     ??GUI_parse_proc_5: (+1)
   \   000000A8   0xF896 0x1417      LDRB     R1,[R6, #+1047]
   \   000000AC   0x2935             CMP      R1,#+53
   \   000000AE   0xD010             BEQ.N    ??GUI_parse_proc_6
   \   000000B0   0x2936             CMP      R1,#+54
   \   000000B2   0xD028             BEQ.N    ??GUI_parse_proc_7
   \   000000B4   0x2940             CMP      R1,#+64
   \   000000B6   0xD038             BEQ.N    ??GUI_parse_proc_8
   \   000000B8   0x2942             CMP      R1,#+66
   \   000000BA   0xD045             BEQ.N    ??GUI_parse_proc_9
   \   000000BC   0x2945             CMP      R1,#+69
   \   000000BE   0xD05E             BEQ.N    ??GUI_parse_proc_10
   \   000000C0   0x2946             CMP      R1,#+70
   \   000000C2   0xD06E             BEQ.N    ??GUI_parse_proc_11
   \   000000C4   0x2948             CMP      R1,#+72
   \   000000C6   0xF000 0x808F      BEQ.W    ??GUI_parse_proc_12
   \   000000CA   0x2949             CMP      R1,#+73
   \   000000CC   0xF000 0x809E      BEQ.W    ??GUI_parse_proc_13
   \   000000D0   0xE0C1             B.N      ??GUI_parse_proc_14
    388          	{
    389          	case 0x35:        // RTC Set
    390          		if(ptPacket->type == (TYPE_HSET | TYPE_LREQUEST)){
   \                     ??GUI_parse_proc_6: (+1)
   \   000000D2   0x2821             CMP      R0,#+33
   \   000000D4   0xD103             BNE.N    ??GUI_parse_proc_15
    391                RTC_ValSet((INT8U *)&(ptPacket->msg));
   \   000000D6   0xF206 0x401A      ADDW     R0,R6,#+1050
   \   000000DA   0x.... 0x....      BL       RTC_ValSet
    392          		}               // RTC Get
    393              memcpy(guiRxbuff, &RTC_LVal, sizeof(RTC_LVal)); 
   \                     ??GUI_parse_proc_15: (+1)
   \   000000DE   0x2204             MOVS     R2,#+4
   \   000000E0   0x....             LDR.N    R1,??DataTable9_7
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x.... 0x....      BL       __aeabi_memcpy4
    394          		SendCount = MakePacket(ptPacket->cmd+1, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(RTC_LVal));      
   \   000000E8   0x2004             MOVS     R0,#+4
   \   000000EA   0x9001             STR      R0,[SP, #+4]
   \   000000EC   0x9400             STR      R4,[SP, #+0]
   \   000000EE   0x....             LDR.N    R3,??DataTable9_8
   \   000000F0   0x787A             LDRB     R2,[R7, #+1]
   \   000000F2   0x4641             MOV      R1,R8
   \   000000F4   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   000000F8   0x1C40             ADDS     R0,R0,#+1
   \   000000FA   0xB2C0             UXTB     R0,R0
   \   000000FC   0x.... 0x....      BL       MakePacket
   \   00000100   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    395          		break;
   \   00000104   0xE0A7             B.N      ??GUI_parse_proc_14
    396          	case 0x36:        // RTC Get
    397              memcpy(guiRxbuff, &RTC_LVal, sizeof(RTC_LVal)); 
   \                     ??GUI_parse_proc_7: (+1)
   \   00000106   0x2204             MOVS     R2,#+4
   \   00000108   0x....             LDR.N    R1,??DataTable9_7
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       __aeabi_memcpy4
    398          		SendCount = MakePacket(ptPacket->cmd, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(RTC_LVal));	    
   \   00000110   0x2004             MOVS     R0,#+4
   \   00000112   0x9001             STR      R0,[SP, #+4]
   \   00000114   0x9400             STR      R4,[SP, #+0]
   \   00000116   0x....             LDR.N    R3,??DataTable9_8
   \   00000118   0x787A             LDRB     R2,[R7, #+1]
   \   0000011A   0x4641             MOV      R1,R8
   \   0000011C   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   00000120   0x.... 0x....      BL       MakePacket
   \   00000124   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    399          		break;
   \   00000128   0xE095             B.N      ??GUI_parse_proc_14
    400          	case 0x40:        // Factory Reset
    401              DefaultSet();
   \                     ??GUI_parse_proc_8: (+1)
   \   0000012A   0x.... 0x....      BL       DefaultSet
    402          		SendCount = 0;
    403          		SendCount = MakePacket(ptPacket->cmd, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, SendCount);	     
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x9001             STR      R0,[SP, #+4]
   \   00000132   0x9400             STR      R4,[SP, #+0]
   \   00000134   0x....             LDR.N    R3,??DataTable9_8
   \   00000136   0x787A             LDRB     R2,[R7, #+1]
   \   00000138   0x4641             MOV      R1,R8
   \   0000013A   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   0000013E   0x.... 0x....      BL       MakePacket
   \   00000142   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    404          		break;
   \   00000146   0xE086             B.N      ??GUI_parse_proc_14
    405          	case 0x42:        // ADC ON/OFF
    406          		if(ptPacket->type == (TYPE_HSET | TYPE_LREQUEST)){
   \                     ??GUI_parse_proc_9: (+1)
   \   00000148   0x2821             CMP      R0,#+33
   \   0000014A   0xD10A             BNE.N    ??GUI_parse_proc_16
    407                SendCount = ADC_OnOff((INT8U *)&(ptPacket->msg));
   \   0000014C   0xF206 0x401A      ADDW     R0,R6,#+1050
   \   00000150   0x.... 0x....      BL       ADC_OnOff
   \   00000154   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    408                guiRxbuff[0] = (char)Flags.GUIADCFlag;
   \   00000158   0x8828             LDRH     R0,[R5, #+0]
   \   0000015A   0x0B80             LSRS     R0,R0,#+14
   \   0000015C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000160   0x7020             STRB     R0,[R4, #+0]
    409          		}
    410          		SendCount = MakePacket(ptPacket->cmd, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, SendCount);	
   \                     ??GUI_parse_proc_16: (+1)
   \   00000162   0xF8B4 0x0080      LDRH     R0,[R4, #+128]
   \   00000166   0x9001             STR      R0,[SP, #+4]
   \   00000168   0x9400             STR      R4,[SP, #+0]
   \   0000016A   0x....             LDR.N    R3,??DataTable9_8
   \   0000016C   0x787A             LDRB     R2,[R7, #+1]
   \   0000016E   0x4641             MOV      R1,R8
   \   00000170   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   00000174   0x.... 0x....      BL       MakePacket
   \   00000178   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    411          		break;
   \   0000017C   0xE06B             B.N      ??GUI_parse_proc_14
    412          //	case 0x43:        // P0 Cal Get
    413          //    memcpy(guiRxbuff, &Fram.ScrCalib, sizeof(stScrCalib)); 
    414          //		SendCount = MakePacket(ptPacket->cmd, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(stScrCalib));	    
    415          //		break;
    416          //	case 0x44:        // P0 Cal Set
    417          //		if(ptPacket->type == (TYPE_HSET | TYPE_LREQUEST)){
    418          //      memcpy(&Fram.ScrCalib, &(ptPacket->msg), sizeof(stScrCalib));
    419          //      FRAM_Addr_ReadWrite(SCRCALIB_SAVE, SAVE);
    420          //		}
    421          //    memcpy(guiRxbuff, &Fram.ScrCalib, sizeof(stScrCalib)); 
    422          //		SendCount = MakePacket(ptPacket->cmd-1, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(stScrCalib));	
    423          //		break;
    424          	case 0x45:        // IP&PORT Get
    425              memcpy(guiRxbuff, &ModemInfo.SrvIP, sizeof(ModemInfo.SrvIP) + sizeof(ModemInfo.SrvPort)); 
   \                     ??GUI_parse_proc_10: (+1)
   \   0000017E   0x2206             MOVS     R2,#+6
   \   00000180   0x....             LDR.N    R1,??DataTable9_9
   \   00000182   0x4620             MOV      R0,R4
   \   00000184   0x.... 0x....      BL       __aeabi_memcpy
    426          		SendCount = MakePacket(ptPacket->cmd, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(ModemInfo.SrvIP) + sizeof(ModemInfo.SrvPort));	      
   \   00000188   0x2006             MOVS     R0,#+6
   \   0000018A   0x9001             STR      R0,[SP, #+4]
   \   0000018C   0x9400             STR      R4,[SP, #+0]
   \   0000018E   0x....             LDR.N    R3,??DataTable9_8
   \   00000190   0x787A             LDRB     R2,[R7, #+1]
   \   00000192   0x4641             MOV      R1,R8
   \   00000194   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   00000198   0x.... 0x....      BL       MakePacket
   \   0000019C   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    427          		break;
   \   000001A0   0xE059             B.N      ??GUI_parse_proc_14
    428          	case 0x46:        // IP&PORT Set
    429          		if(ptPacket->type == (TYPE_HSET | TYPE_LREQUEST)){
   \                     ??GUI_parse_proc_11: (+1)
   \   000001A2   0x....             LDR.N    R5,??DataTable9_9
   \   000001A4   0x2821             CMP      R0,#+33
   \   000001A6   0xD10B             BNE.N    ??GUI_parse_proc_17
    430                memcpy(&ModemInfo.SrvIP, &(ptPacket->msg), sizeof(ModemInfo.SrvIP) + sizeof(ModemInfo.SrvPort));
   \   000001A8   0x2206             MOVS     R2,#+6
   \   000001AA   0xF206 0x411A      ADDW     R1,R6,#+1050
   \   000001AE   0x4628             MOV      R0,R5
   \   000001B0   0x.... 0x....      BL       __aeabi_memcpy
    431                FRAMMultiWrite((u8 *)&ModemInfo.SrvIP, MODEM_INFO + (u8 *)&ModemInfo.SrvIP - (u8 *)&ModemInfo, sizeof(ModemInfo.SrvIP)+sizeof(ModemInfo.SrvPort));
   \   000001B4   0x2206             MOVS     R2,#+6
   \   000001B6   0xF44F 0x7110      MOV      R1,#+576
   \   000001BA   0x4628             MOV      R0,R5
   \   000001BC   0x.... 0x....      BL       FRAMMultiWrite
    432          		}
    433              memcpy(guiRxbuff, &ModemInfo.SrvIP, sizeof(ModemInfo.SrvIP) + sizeof(ModemInfo.SrvPort));
   \                     ??GUI_parse_proc_17: (+1)
   \   000001C0   0x2206             MOVS     R2,#+6
   \   000001C2   0x4629             MOV      R1,R5
   \   000001C4   0x4620             MOV      R0,R4
   \   000001C6   0x.... 0x....      BL       __aeabi_memcpy
    434          		SendCount = MakePacket(ptPacket->cmd-1, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(ModemInfo.SrvIP) + sizeof(ModemInfo.SrvPort));
   \   000001CA   0x2006             MOVS     R0,#+6
   \   000001CC   0x9001             STR      R0,[SP, #+4]
   \   000001CE   0x9400             STR      R4,[SP, #+0]
   \   000001D0   0x....             LDR.N    R3,??DataTable9_8
   \   000001D2   0x787A             LDRB     R2,[R7, #+1]
   \   000001D4   0x4641             MOV      R1,R8
   \   000001D6   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   000001DA   0x1E40             SUBS     R0,R0,#+1
   \   000001DC   0xB2C0             UXTB     R0,R0
   \   000001DE   0x.... 0x....      BL       MakePacket
   \   000001E2   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    435          		break;
   \   000001E6   0xE036             B.N      ??GUI_parse_proc_14
    436          	case 0x47:        // P0 Data Send
    437              break;
    438          	case 0x48:        // Modem Data Save Time Get
    439              memcpy(guiRxbuff, &ModemInfo.DataServerInterval, sizeof(ModemInfo.DataServerInterval)); 
   \                     ??GUI_parse_proc_12: (+1)
   \   000001E8   0x2202             MOVS     R2,#+2
   \   000001EA   0x....             LDR.N    R1,??DataTable9_10
   \   000001EC   0x4620             MOV      R0,R4
   \   000001EE   0x.... 0x....      BL       __aeabi_memcpy
    440          		SendCount = MakePacket(ptPacket->cmd, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(ModemInfo.DataServerInterval));	      
   \   000001F2   0x2002             MOVS     R0,#+2
   \   000001F4   0x9001             STR      R0,[SP, #+4]
   \   000001F6   0x9400             STR      R4,[SP, #+0]
   \   000001F8   0x....             LDR.N    R3,??DataTable9_8
   \   000001FA   0x787A             LDRB     R2,[R7, #+1]
   \   000001FC   0x4641             MOV      R1,R8
   \   000001FE   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   00000202   0x.... 0x....      BL       MakePacket
   \   00000206   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    441          		break;
   \   0000020A   0xE024             B.N      ??GUI_parse_proc_14
    442          	case 0x49:        // Modem Data Save Time Set
    443          		if(ptPacket->type == (TYPE_HSET | TYPE_LREQUEST)){
   \                     ??GUI_parse_proc_13: (+1)
   \   0000020C   0x....             LDR.N    R5,??DataTable9_9
   \   0000020E   0x2821             CMP      R0,#+33
   \   00000210   0xD10D             BNE.N    ??GUI_parse_proc_18
    444                memcpy(&ModemInfo.DataServerInterval, &(ptPacket->msg), sizeof(ModemInfo.DataServerInterval));
   \   00000212   0x2202             MOVS     R2,#+2
   \   00000214   0xF206 0x411A      ADDW     R1,R6,#+1050
   \   00000218   0xF105 0x001A      ADD      R0,R5,#+26
   \   0000021C   0x.... 0x....      BL       __aeabi_memcpy
    445                FRAMMultiWrite((u8 *)&ModemInfo.DataServerInterval, MODEM_INFO + (u8 *)&ModemInfo.DataServerInterval - (u8 *)&ModemInfo, sizeof(ModemInfo.DataServerInterval)); 
   \   00000220   0x2202             MOVS     R2,#+2
   \   00000222   0xF240 0x215A      MOVW     R1,#+602
   \   00000226   0xF105 0x001A      ADD      R0,R5,#+26
   \   0000022A   0x.... 0x....      BL       FRAMMultiWrite
    446          		}
    447              memcpy(guiRxbuff, &ModemInfo.DataServerInterval, sizeof(ModemInfo.DataServerInterval)); 
   \                     ??GUI_parse_proc_18: (+1)
   \   0000022E   0x2202             MOVS     R2,#+2
   \   00000230   0xF105 0x011A      ADD      R1,R5,#+26
   \   00000234   0x4620             MOV      R0,R4
   \   00000236   0x.... 0x....      BL       __aeabi_memcpy
    448          		SendCount = MakePacket(ptPacket->cmd-1, nMsgType, ptPacket->systype, (char *)guiTxbuff, (char *)guiRxbuff, sizeof(ModemInfo.DataServerInterval));	      
   \   0000023A   0x2002             MOVS     R0,#+2
   \   0000023C   0x9001             STR      R0,[SP, #+4]
   \   0000023E   0x9400             STR      R4,[SP, #+0]
   \   00000240   0x....             LDR.N    R3,??DataTable9_8
   \   00000242   0x787A             LDRB     R2,[R7, #+1]
   \   00000244   0x4641             MOV      R1,R8
   \   00000246   0xF896 0x0417      LDRB     R0,[R6, #+1047]
   \   0000024A   0x1E40             SUBS     R0,R0,#+1
   \   0000024C   0xB2C0             UXTB     R0,R0
   \   0000024E   0x.... 0x....      BL       MakePacket
   \   00000252   0xF8A4 0x0080      STRH     R0,[R4, #+128]
    449          		break;
    450          	}
    451          /*-----------------------------------------------------------------------------------------------------*/	
    452          	if(SendCount){
   \                     ??GUI_parse_proc_14: (+1)
   \   00000256   0xF8B4 0x2080      LDRH     R2,[R4, #+128]
   \   0000025A   0x0010             MOVS     R0,R2
   \   0000025C   0xD003             BEQ.N    ??GUI_parse_proc_19
    453          		CommPutCharStr(GPS_PORT,(INT8U *)guiTxbuff,SendCount);
   \   0000025E   0x....             LDR.N    R1,??DataTable9_8
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0x.... 0x....      BL       CommPutCharStr
    454          	}
    455          /*-----------------------------------------------------------------------------------------------------*/	
    456          	return SendCount;
   \                     ??GUI_parse_proc_19: (+1)
   \   00000266   0xF8B4 0x0080      LDRH     R0,[R4, #+128]
   \                     ??GUI_parse_proc_3: (+1)
   \   0000026A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    457          }

   \                                 In section .bss, align 4
   \                     guiRxbuff:
   \   00000000                      DS8 128
   \   00000080                      DS8 2

   \                                 In section .bss, align 4
   \                     GUIProto:
   \   00000000                      DS8 2080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     GUIProto

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     _sysinfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     `commRxProcGui::data`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     guiRxbuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ReadValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     adcdata+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     RTC_LVal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     `commRxProcGui::data`+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     ModemInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     ModemInfo+0x1A

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x43 0x68          DC8 "Check sum error (%s) CMD:%02X me:%02X,you:%02X \012"
   \              0x65 0x63    
   \              0x6B 0x20    
   \              0x73 0x75    
   \              0x6D 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x28 0x25    
   \              0x73 0x29    
   \              0x20 0x43    
   \              0x4D 0x44    
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x58 0x20    
   \              0x6D 0x65    
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x58 0x2C    
   \              0x79 0x6F    
   \              0x75 0x3A    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x20 0x0A    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x73 0x74          DC8 "start = %d, end = %d, packcount = %d\012"
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x65 0x6E    
   \              0x64 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x70 0x61    
   \              0x63 0x6B    
   \              0x63 0x6F    
   \              0x75 0x6E    
   \              0x74 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x0A 0x00    
   \   00000026   0x00 0x00          DC8 0, 0
    458          /*
    459          ********************* (C) COPYRIGHT 2015 LOOP ***************END OF FILE*****************************
    460          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_OnOff
       4   Data_ValGet
      24   DecodePacket
        24   -> __aeabi_memcpy
        24   -> cal_checksum
        24   -> printk
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      32   GUI_parse_proc
        32   -> ADC_OnOff
        32   -> CommPutCharStr
        32   -> CommReInit
        32   -> DefaultSet
        32   -> FRAMMultiWrite
        32   -> MakePacket
        32   -> RTC_ValSet
        32   -> __aeabi_memcpy
        32   -> __aeabi_memcpy4
        32   -> commRxProcGui
       8   Init_GUIcommRxProc
         0   -> CommReInit
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   MakePacket
       0   RTC_ValGet
      16   RTC_ValSet
        16   -> SetRTCTime
        16   -> __aeabi_memcpy
        16   -> gmtime_conv
       4   cal_checksum
      32   commRxProcGui
        32   -> CommGetChar
        32   -> CommPutCharStr
        32   -> DecodePacket
        32   -> MakePacket
        32   -> printk
        32   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      52  ?_0
       4  ?_1
      40  ?_2
      32  ADC_OnOff
      22  Data_ValGet
      84  DecodePacket
    2080  GUIProto
     622  GUI_parse_proc
      40  Init_GUIcommRxProc
      76  MakePacket
      36  RTC_ValGet
      68  RTC_ValSet
      26  cal_checksum
     306  commRxProcGui
     132  data
          packlen
          guiTxbuff
     130  guiRxbuff
          SendCount
      16  -- Other

 
 2 342 bytes in section .bss
     4 bytes in section .rodata
 1 464 bytes in section .text
 
 1 464 bytes of CODE  memory
     4 bytes of CONST memory
 2 342 bytes of DATA  memory

Errors: none
Warnings: none
