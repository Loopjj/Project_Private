###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\spiflash_W25Q64BV.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\spiflash_W25Q64BV.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\spiflash_W25Q64BV.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\spiflash_W25Q64BV.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Dev\spiflash_W25Q64BV.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2015 LOOP *************************************
      3          *
      4          * File Name          : i2cfram_FM24CL64B.c
      5          *
      6          * Author             : Reserch & Developing 1 Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 07/29/2015
     11          *
     12          * Description        : This file provides a set of functions needed to manage the
     13          *                      communication between SPI peripheral and SPI M25P64 FLASH.
     14          *
     15          *********************************************************************************************************
     16          */
     17          
     18          
     19          /* Includes ------------------------------------------------------------------*/
     20          #define SPI_FLASH_GLOBALS
     21          #include "includes.h"
     22          
     23          /* Private define ------------------------------------------------------------*/
     24          #define WRITE       0x02  /* Main Memory Page Program Through Buffer 1 */
     25          #define READ        0x03  /* Read from Memory instruction */
     26          #define RDSR1       0x05  /* Read Status Register instruction  */
     27          #define RDSR2       0x35  /* Read Status Register instruction  */
     28          #define RDID        0x90  /* Read identification */
     29          #define BE32        0x52  /* Page Erase instruction */
     30          #define BE64        0xD8  /* Block Erase instruction */
     31          #define SE          0x20  /* Sector Erase instruction */
     32          #define CE          0xC7  /* Chip Erase instruction */
     33          
     34          
     35          #define BUSY_Flag   0x01  /* Status Register Busy bit flag */
     36          #define WEL_Flag    0x02  /* Status Register Write Enable Latch(WEL) bit flag */
     37          
     38          
     39          #define Dummy_Byte  0xA5
     40          
     41          
     42          /* Private macro -------------------------------------------------------------*/
     43          /* Private variables ---------------------------------------------------------*/
     44          /* Private function prototypes -----------------------------------------------*/
     45          /* Private functions ---------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     46          void flashSemaphore_Init(void)
     47          {
   \                     flashSemaphore_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     48          	SPI_FLASH_CS_HIGH();
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40020000
   \   00000008   0x.... 0x....      BL       GPIO_SetBits
     49          	SpiFlashDevSem = xSemaphoreCreateMutex();
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable23_1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       xQueueCreateMutex
   \   00000016   0x6020             STR      R0,[R4, #+0]
     50          	vSemaphoreCreateBinary(SpiFlashDevSem);
   \   00000018   0x2203             MOVS     R2,#+3
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       xQueueGenericCreate
   \   00000022   0x6020             STR      R0,[R4, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD006             BEQ.N    ??flashSemaphore_Init_0
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x461A             MOV      R2,R3
   \   0000002C   0x4611             MOV      R1,R2
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x.... 0x....      B.W      xQueueGenericSend
     51          }
   \                     ??flashSemaphore_Init_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
     52          
     53          /*******************************************************************************
     54          * Function Name  : SPI_FLASH_WriteEnableLatch
     55          * Description    : Polls the status of the Write In Progress (WIP) flag in the
     56          *                  FLASH's status  register  and  loop  until write  opertaion
     57          *                  has completed.
     58          * Input          : None
     59          * Output         : None
     60          * Return         : None
     61          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     62          void SPI_FLASH_WriteEnable(void)
     63          {
   \                     SPI_FLASH_WriteEnable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     64          	/* Write Enalbe Latch */
     65          	/* Select the FLASH: Chip Select low */
     66          	SPI_FLASH_CS_LOW();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable23  ;; 0x40020000
   \   00000006   0x2110             MOVS     R1,#+16
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       GPIO_ResetBits
     67          	/* Send Bulk Erase instruction	*/
     68          	SPI_FLASH_SendByte(0x06);
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
     69          	/* Deselect the FLASH: Chip Select high */
     70          	SPI_FLASH_CS_HIGH();
   \   00000014   0x2110             MOVS     R1,#+16
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       GPIO_SetBits
     71          
     72          	/* Wait the end of Flash writing */
     73          	SPI_FLASH_WaitForWEL(SET);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x....             B.N      SPI_FLASH_WaitForWEL
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          void SPI_FLASH_WriteDisable(void)
     77          {
   \                     SPI_FLASH_WriteDisable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     78          	/* Write Enalbe Latch */
     79          	/* Select the FLASH: Chip Select low */
     80          	SPI_FLASH_CS_LOW();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable23  ;; 0x40020000
   \   00000006   0x2110             MOVS     R1,#+16
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       GPIO_ResetBits
     81          	/* Send Bulk Erase instruction	*/
     82          	SPI_FLASH_SendByte(0x04);
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
     83          	/* Deselect the FLASH: Chip Select high */
     84          	SPI_FLASH_CS_HIGH();
   \   00000014   0x2110             MOVS     R1,#+16
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       GPIO_SetBits
     85          
     86          	/* Wait the end of Flash writing */
     87          	SPI_FLASH_WaitForWEL(RESET);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x....             B.N      SPI_FLASH_WaitForWEL
     88          }
     89          
     90          
     91          /*******************************************************************************
     92          * Function Name  : SPI_FLASH_SectorErase
     93          * Description    : Erases the specified FLASH sector.
     94          * Input          : SectorAddr: address of the sector to erase.
     95          * Output         : None
     96          * Return         : None
     97          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     98          void SPI_FLASH_SectorErase(INT32U SectorAddr)
     99          {
   \                     SPI_FLASH_SectorErase: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    100          	if(SpiFlashDevSem == NULL)
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable23_1
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??SPI_FLASH_SectorErase_0
    101          	{
    102          		printk("%s err\n",__func__);
   \   0000000E   0x.... 0x....      ADR.W    R1,`SPI_FLASH_SectorErase::__func__`
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000001A   0x.... 0x....      B.W      printk
    103          		return;
    104          	}
    105          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 50 )  == pdTRUE)
   \                     ??SPI_FLASH_SectorErase_0: (+1)
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2232             MOVS     R2,#+50
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0x.... 0x....      BL       xQueueGenericReceive
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD126             BNE.N    ??SPI_FLASH_SectorErase_1
    106          	{
    107              SPI_FLASH_WriteEnable();
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    108          
    109              /* Sector Erase */
    110              /* Select the FLASH: Chip Select low */
    111              SPI_FLASH_CS_LOW();
   \   00000030   0x.... 0x....      LDR.W    R6,??DataTable23  ;; 0x40020000
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       GPIO_ResetBits
    112              /* Send Sector Erase instruction */
    113              SPI_FLASH_SendByte(SE);
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       SPI_FLASH_SendByte
    114              /* Send SectorAddr high nibble address byte */
    115              SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
   \   00000042   0x0C20             LSRS     R0,R4,#+16
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x.... 0x....      BL       SPI_FLASH_SendByte
    116              /* Send SectorAddr medium nibble address byte */
    117              SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
   \   0000004A   0x0A20             LSRS     R0,R4,#+8
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       SPI_FLASH_SendByte
    118              /* Send SectorAddr low nibble address byte */
    119              SPI_FLASH_SendByte(SectorAddr & 0xFF);
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       SPI_FLASH_SendByte
    120              /* Deselect the FLASH: Chip Select high */
    121              SPI_FLASH_CS_HIGH();
   \   0000005A   0x2110             MOVS     R1,#+16
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       GPIO_SetBits
    122          
    123              SPI_FLASH_WriteDisable();
   \   00000062   0x.... 0x....      BL       SPI_FLASH_WriteDisable
    124          
    125              /* Wait the end of Flash writing */
    126              SPI_FLASH_WaitForWriteEnd();
   \   00000066   0x.... 0x....      BL       SPI_FLASH_WaitForWriteEnd
    127          
    128              xSemaphoreGive(SpiFlashDevSem);
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x461A             MOV      R2,R3
   \   0000006E   0x4611             MOV      R1,R2
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000076   0x.... 0x....      B.W      xQueueGenericSend
    129          	}
    130          }
   \                     ??SPI_FLASH_SectorErase_1: (+1)
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    131          
    132          /*******************************************************************************
    133          * Function Name  : SPI_FLASH_PageErase
    134          * Description    : Erases the specified FLASH Page.
    135          * Input          : PageAddr: address of the PageA to erase.
    136          * Output         : None
    137          * Return         : None
    138          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    139          void SPI_FLASH_PageErase(INT32U PageAddr)
    140          {
   \                     SPI_FLASH_PageErase: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    141          	if(SpiFlashDevSem == NULL)
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable23_1
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??SPI_FLASH_PageErase_0
    142          	{
    143          		printk("%s err\n",__func__);
   \   0000000E   0x.... 0x....      ADR.W    R1,`SPI_FLASH_PageErase::__func__`
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000001A   0x.... 0x....      B.W      printk
    144          		return;
    145          	}
    146          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 50 )  == pdTRUE)
   \                     ??SPI_FLASH_PageErase_0: (+1)
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2232             MOVS     R2,#+50
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0x.... 0x....      BL       xQueueGenericReceive
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD126             BNE.N    ??SPI_FLASH_PageErase_1
    147          	{
    148          		SPI_FLASH_WriteEnable();
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    149          		/* Sector Erase */
    150          		/* Select the FLASH: Chip Select low */
    151          		SPI_FLASH_CS_LOW();
   \   00000030   0x.... 0x....      LDR.W    R6,??DataTable23  ;; 0x40020000
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       GPIO_ResetBits
    152          		/* Send Sector Erase instruction */
    153          		SPI_FLASH_SendByte(SE);
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       SPI_FLASH_SendByte
    154          		/* Send SectorAddr high nibble address byte */
    155          		SPI_FLASH_SendByte((PageAddr & 0xFF0000) >> 16);
   \   00000042   0x0C20             LSRS     R0,R4,#+16
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x.... 0x....      BL       SPI_FLASH_SendByte
    156          		/* Send SectorAddr medium nibble address byte */
    157          		SPI_FLASH_SendByte((PageAddr & 0xFF00) >> 8);
   \   0000004A   0x0A20             LSRS     R0,R4,#+8
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       SPI_FLASH_SendByte
    158          		/* Send SectorAddr low nibble address byte */
    159          		SPI_FLASH_SendByte(PageAddr & 0xFF);
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       SPI_FLASH_SendByte
    160          		/* Deselect the FLASH: Chip Select high */
    161          		SPI_FLASH_CS_HIGH();
   \   0000005A   0x2110             MOVS     R1,#+16
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       GPIO_SetBits
    162          		
    163          		SPI_FLASH_WriteDisable();
   \   00000062   0x.... 0x....      BL       SPI_FLASH_WriteDisable
    164          		
    165          		/* Wait the end of Flash writing */
    166          		SPI_FLASH_WaitForWriteEnd();
   \   00000066   0x.... 0x....      BL       SPI_FLASH_WaitForWriteEnd
    167              
    168              xSemaphoreGive(SpiFlashDevSem);
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x461A             MOV      R2,R3
   \   0000006E   0x4611             MOV      R1,R2
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000076   0x.... 0x....      B.W      xQueueGenericSend
    169          	}
    170          
    171          }
   \                     ??SPI_FLASH_PageErase_1: (+1)
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    172          
    173          /*******************************************************************************
    174          * Function Name  : SPI_FLASH_BlockErase
    175          * Description    : Erases the specified FLASH Block.
    176          * Input          : BlockAddr: address of the Block to erase.
    177          * Output         : None
    178          * Return         : None
    179          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    180          void SPI_FLASH_BlockErase(INT32U BlockAddr)
    181          {
   \                     SPI_FLASH_BlockErase: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    182          	if(SpiFlashDevSem == NULL)
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable23_1
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??SPI_FLASH_BlockErase_0
    183          	{
    184          		printk("%s err\n",__func__);
   \   0000000E   0x.... 0x....      ADR.W    R1,`SPI_FLASH_BlockErase::__func__`
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000001A   0x.... 0x....      B.W      printk
    185          		return;
    186          	}
    187          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??SPI_FLASH_BlockErase_0: (+1)
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x4611             MOV      R1,R2
   \   00000024   0x.... 0x....      BL       xQueueGenericReceive
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD126             BNE.N    ??SPI_FLASH_BlockErase_1
    188          	{
    189          		SPI_FLASH_WriteEnable();
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    190          	  
    191          		/* 64K Block Erase */
    192          		/* Select the FLASH: Chip Select low */
    193          		SPI_FLASH_CS_LOW();
   \   00000030   0x.... 0x....      LDR.W    R6,??DataTable23  ;; 0x40020000
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       GPIO_ResetBits
    194          		/* Send Sector Erase instruction */
    195          		 SPI_FLASH_SendByte(BE64);
   \   0000003C   0x20D8             MOVS     R0,#+216
   \   0000003E   0x.... 0x....      BL       SPI_FLASH_SendByte
    196          		/* Send SectorAddr high nibble address byte */
    197          		SPI_FLASH_SendByte((BlockAddr & 0xFF0000) >> 16);
   \   00000042   0x0C20             LSRS     R0,R4,#+16
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x.... 0x....      BL       SPI_FLASH_SendByte
    198          		/* Send SectorAddr medium nibble address byte */
    199          		SPI_FLASH_SendByte((BlockAddr & 0xFF00) >> 8);
   \   0000004A   0x0A20             LSRS     R0,R4,#+8
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       SPI_FLASH_SendByte
    200          		/* Send SectorAddr low nibble address byte */
    201          		SPI_FLASH_SendByte(BlockAddr & 0xFF);
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       SPI_FLASH_SendByte
    202          		/* Deselect the FLASH: Chip Select high */
    203          		SPI_FLASH_CS_HIGH();
   \   0000005A   0x2110             MOVS     R1,#+16
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       GPIO_SetBits
    204          	  
    205          		SPI_FLASH_WriteDisable();
   \   00000062   0x.... 0x....      BL       SPI_FLASH_WriteDisable
    206          	  
    207          		/* Wait the end of Flash writing */
    208          		SPI_FLASH_WaitForWriteEnd();
   \   00000066   0x.... 0x....      BL       SPI_FLASH_WaitForWriteEnd
    209          		xSemaphoreGive(SpiFlashDevSem);
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x461A             MOV      R2,R3
   \   0000006E   0x4611             MOV      R1,R2
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000076   0x.... 0x....      B.W      xQueueGenericSend
    210          	}
    211          }
   \                     ??SPI_FLASH_BlockErase_1: (+1)
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    212          
    213          /*******************************************************************************
    214          * Function Name  : SPI_FLASH_ChipErase
    215          * Description    : Erases the entire FLASH.
    216          * Input          : None
    217          * Output         : None
    218          * Return         : None
    219          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void SPI_FLASH_ChipErase(void)
    221          {
   \                     SPI_FLASH_ChipErase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    222          	if(SpiFlashDevSem == NULL)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable23_1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD107             BNE.N    ??SPI_FLASH_ChipErase_0
    223          	{
    224          		printk("%s err\n",__func__);
   \   0000000C   0x.... 0x....      ADR.W    R1,`SPI_FLASH_ChipErase::__func__`
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      printk
    225          		return;
    226          	}
    227          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??SPI_FLASH_ChipErase_0: (+1)
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0x.... 0x....      BL       xQueueGenericReceive
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD11B             BNE.N    ??SPI_FLASH_ChipErase_1
    228          	{
    229          		SPI_FLASH_WriteEnable();
   \   0000002A   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    230          
    231          		/* Bulk Erase */
    232          		/* Select the FLASH: Chip Select low */
    233          		SPI_FLASH_CS_LOW();
   \   0000002E   0x.... 0x....      LDR.W    R5,??DataTable23  ;; 0x40020000
   \   00000032   0x2110             MOVS     R1,#+16
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       GPIO_ResetBits
    234          		/* Send Bulk Erase instruction  */
    235          		SPI_FLASH_SendByte(CE);
   \   0000003A   0x20C7             MOVS     R0,#+199
   \   0000003C   0x.... 0x....      BL       SPI_FLASH_SendByte
    236          		/* Deselect the FLASH: Chip Select high */
    237          		SPI_FLASH_CS_HIGH();
   \   00000040   0x2110             MOVS     R1,#+16
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       GPIO_SetBits
    238          
    239          		SPI_FLASH_WriteDisable();
   \   00000048   0x.... 0x....      BL       SPI_FLASH_WriteDisable
    240          
    241          		/* Wait the end of Flash writing */
    242          		SPI_FLASH_WaitForWriteEnd();
   \   0000004C   0x.... 0x....      BL       SPI_FLASH_WaitForWriteEnd
    243          		xSemaphoreGive(SpiFlashDevSem);
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x461A             MOV      R2,R3
   \   00000054   0x4611             MOV      R1,R2
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0xB001             ADD      SP,SP,#+4
   \   0000005A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000005E   0x.... 0x....      B.W      xQueueGenericSend
    244          	}
    245          
    246          }
   \                     ??SPI_FLASH_ChipErase_1: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    247          
    248          /*******************************************************************************
    249          * Function Name  : SPI_FLASH_PageWrite
    250          * Description    : Writes more than one byte to the FLASH with a single WRITE
    251          *                  cycle(Page WRITE sequence). The number of byte can't exceed
    252          *                  the FLASH page size.
    253          * Input          : - pBuffer : pointer to the buffer  containing the data to be
    254          *                    written to the FLASH.
    255          *                  - WriteAddr : FLASH's internal address to write to.
    256          *                  - NumByteToWrite : number of bytes to write to the FLASH,
    257          *                    must be equal or less than "SPI_FLASH_PAGE_SIZE" value.
    258          * Output         : None
    259          * Return         : None
    260          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void SPI_FLASH_PageWrite(INT8U* pBuffer, INT32U WriteAddr, INT16U NumByteToWrite)
    262          {
   \                     SPI_FLASH_PageWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    263            if((WriteAddr%SPI_FLASH_SECTOR) == 0)
   \   0000000A   0x0528             LSLS     R0,R5,#+20
   \   0000000C   0xD102             BNE.N    ??SPI_FLASH_PageWrite_0
    264              SPI_FLASH_SectorErase(WriteAddr);
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SectorErase
    265            
    266          	if(SpiFlashDevSem == NULL)
   \                     ??SPI_FLASH_PageWrite_0: (+1)
   \   00000014   0x....             LDR.N    R7,??DataTable23_1
   \   00000016   0x6838             LDR      R0,[R7, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD107             BNE.N    ??SPI_FLASH_PageWrite_1
    267          	{
    268          		printk("%s err\n",__func__);
   \   0000001C   0x.... 0x....      ADR.W    R1,`SPI_FLASH_PageWrite::__func__`
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000028   0x.... 0x....      B.W      printk
    269          		return;
    270          	}
    271          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 50 )  == pdTRUE)
   \                     ??SPI_FLASH_PageWrite_1: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x2232             MOVS     R2,#+50
   \   00000030   0x4619             MOV      R1,R3
   \   00000032   0x.... 0x....      BL       xQueueGenericReceive
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD130             BNE.N    ??SPI_FLASH_PageWrite_2
    272          	{
    273          
    274          		SPI_FLASH_WriteEnable();
   \   0000003A   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    275          
    276          		/* Select the FLASH: Chip Select low */
    277          		SPI_FLASH_CS_LOW();
   \   0000003E   0x.... 0x....      LDR.W    R8,??DataTable23  ;; 0x40020000
   \   00000042   0x2110             MOVS     R1,#+16
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    278          		/* Send "Write to Memory " instruction */
    279          		SPI_FLASH_SendByte(WRITE);
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0x.... 0x....      BL       SPI_FLASH_SendByte
    280          		/* Send WriteAddr high nibble address byte to write to */
    281          		SPI_FLASH_SendByte((WriteAddr >> 16) & 0xFF);
   \   00000050   0x0C28             LSRS     R0,R5,#+16
   \   00000052   0xB2C0             UXTB     R0,R0
   \   00000054   0x.... 0x....      BL       SPI_FLASH_SendByte
    282          		/* Send WriteAddr medium nibble address byte to write to */
    283          		SPI_FLASH_SendByte((WriteAddr >> 8) & 0xFF);
   \   00000058   0x0A28             LSRS     R0,R5,#+8
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x.... 0x....      BL       SPI_FLASH_SendByte
    284          		/* Send WriteAddr low nibble address byte to write to */
    285          		SPI_FLASH_SendByte(WriteAddr & 0xFF);
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0xB2C0             UXTB     R0,R0
   \   00000064   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000068   0xE003             B.N      ??SPI_FLASH_PageWrite_3
    286          
    287          		/* while there is data to be written on the FLASH */
    288          		while (NumByteToWrite--)
    289          		{
    290          			/* Send the current byte */
    291          			SPI_FLASH_SendByte(*pBuffer);
   \                     ??SPI_FLASH_PageWrite_4: (+1)
   \   0000006A   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000006E   0x.... 0x....      BL       SPI_FLASH_SendByte
    292          			/* Point on the next byte to be written */
    293          			pBuffer++;
    294          		}
   \                     ??SPI_FLASH_PageWrite_3: (+1)
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x1E46             SUBS     R6,R0,#+1
   \   00000076   0xB280             UXTH     R0,R0
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD1F6             BNE.N    ??SPI_FLASH_PageWrite_4
    295          
    296          		/* Deselect the FLASH: Chip Select high */
    297          		SPI_FLASH_CS_HIGH();
   \   0000007C   0x2110             MOVS     R1,#+16
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x.... 0x....      BL       GPIO_SetBits
    298          
    299          		SPI_FLASH_WriteDisable();
   \   00000084   0x.... 0x....      BL       SPI_FLASH_WriteDisable
    300          
    301          		/* Wait the end of Flash writing */
    302          		SPI_FLASH_WaitForWriteEnd();
   \   00000088   0x.... 0x....      BL       SPI_FLASH_WaitForWriteEnd
    303          		xSemaphoreGive(SpiFlashDevSem);
   \   0000008C   0x2300             MOVS     R3,#+0
   \   0000008E   0x461A             MOV      R2,R3
   \   00000090   0x4611             MOV      R1,R2
   \   00000092   0x6838             LDR      R0,[R7, #+0]
   \   00000094   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000098   0x.... 0x....      B.W      xQueueGenericSend
    304          	}
    305          }
   \                     ??SPI_FLASH_PageWrite_2: (+1)
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    306          
    307          /*******************************************************************************
    308          * Function Name  : SPI_FLASH_BufferWrite
    309          * Description    : Writes block of data to the FLASH. In this function, the
    310          *                  number of WRITE cycles are reduced, using Page WRITE sequence.
    311          * Input          : - pBuffer : pointer to the buffer  containing the data to be
    312          *                    written to the FLASH.
    313          *                  - WriteAddr : FLASH's internal address to write to.
    314          *                  - NumByteToWrite : number of bytes to write to the FLASH.
    315          * Output         : None
    316          * Return         : None
    317          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    318          INT8U SPI_FLASH_BufferWrite(INT8U* pBuffer, INT32U WriteAddr, INT32U NumByteToWrite)
    319          {
   \                     SPI_FLASH_BufferWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    320            u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
    321          
    322            Addr = WriteAddr % SPI_FLASH_PAGE_SIZE;
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0xB2C0             UXTB     R0,R0
    323            count = SPI_FLASH_PAGE_SIZE - Addr;
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0xF1C1 0x0800      RSB      R8,R1,#+0
   \   00000012   0xFA5F 0xF888      UXTB     R8,R8
    324            NumOfPage =  NumByteToWrite / SPI_FLASH_PAGE_SIZE;
   \   00000016   0x0A17             LSRS     R7,R2,#+8
    325            NumOfSingle = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
   \   00000018   0x4616             MOV      R6,R2
   \   0000001A   0xB2F6             UXTB     R6,R6
    326          
    327            if (Addr == 0) /* WriteAddr is SPI_FLASH_PAGE_SIZE aligned  */
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD114             BNE.N    ??SPI_FLASH_BufferWrite_0
    328            {
    329              if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PAGE_SIZE */
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD024             BEQ.N    ??SPI_FLASH_BufferWrite_1
    330              {
    331                SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    332              }
    333              else /* NumByteToWrite > SPI_FLASH_PAGE_SIZE */
    334              {
    335                while (NumOfPage--)
   \                     ??SPI_FLASH_BufferWrite_2: (+1)
   \   00000028   0x4638             MOV      R0,R7
   \   0000002A   0x1E47             SUBS     R7,R0,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD042             BEQ.N    ??SPI_FLASH_BufferWrite_3
    336                {
    337                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
   \   00000032   0xF44F 0x7280      MOV      R2,#+256
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       SPI_FLASH_PageWrite
    338                  WriteAddr +=  SPI_FLASH_PAGE_SIZE;
   \   0000003E   0xF505 0x7580      ADD      R5,R5,#+256
    339                  pBuffer += SPI_FLASH_PAGE_SIZE;
   \   00000042   0xF44F 0x7080      MOV      R0,#+256
   \   00000046   0x4404             ADD      R4,R4,R0
   \   00000048   0xE7EE             B.N      ??SPI_FLASH_BufferWrite_2
    340                }
    341          
    342                if(NumOfSingle !=0 ) SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    343              }
    344            }
    345            else /* WriteAddr is not SPI_FLASH_PAGE_SIZE aligned  */
    346            {
    347              if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PAGE_SIZE */
   \                     ??SPI_FLASH_BufferWrite_0: (+1)
   \   0000004A   0xB2FF             UXTB     R7,R7
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD116             BNE.N    ??SPI_FLASH_BufferWrite_4
    348              {
    349                if (NumOfSingle > count) /* (NumByteToWrite + WriteAddr) > SPI_FLASH_PAGE_SIZE */
   \   00000050   0x45B0             CMP      R8,R6
   \   00000052   0xDA0E             BGE.N    ??SPI_FLASH_BufferWrite_1
    350                {
    351                  temp = NumOfSingle - count;
    352          
    353                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
   \   00000054   0x4642             MOV      R2,R8
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       SPI_FLASH_PageWrite
    354                  WriteAddr +=  count;
    355                  pBuffer += count;
    356          
    357                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
   \   0000005E   0xEBA6 0x0208      SUB      R2,R6,R8
   \   00000062   0xB2D2             UXTB     R2,R2
   \   00000064   0xEB08 0x0105      ADD      R1,R8,R5
   \   00000068   0xEB04 0x0008      ADD      R0,R4,R8
   \   0000006C   0x.... 0x....      BL       SPI_FLASH_PageWrite
   \   00000070   0xE029             B.N      ??SPI_FLASH_BufferWrite_5
    358                }
    359                else
    360                {
    361                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
   \                     ??SPI_FLASH_BufferWrite_1: (+1)
   \   00000072   0xB292             UXTH     R2,R2
   \   00000074   0x4629             MOV      R1,R5
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       SPI_FLASH_PageWrite
   \   0000007C   0xE023             B.N      ??SPI_FLASH_BufferWrite_5
    362                }
    363              }
    364              else /* NumByteToWrite > SPI_FLASH_PAGE_SIZE */
    365              {
    366                NumByteToWrite -= count;
   \                     ??SPI_FLASH_BufferWrite_4: (+1)
   \   0000007E   0xEBA2 0x0208      SUB      R2,R2,R8
    367                NumOfPage =  NumByteToWrite / SPI_FLASH_PAGE_SIZE;
   \   00000082   0x0A17             LSRS     R7,R2,#+8
    368                NumOfSingle = NumByteToWrite % SPI_FLASH_PAGE_SIZE;
   \   00000084   0xB2D2             UXTB     R2,R2
   \   00000086   0x4616             MOV      R6,R2
    369          
    370                SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
   \   00000088   0x4642             MOV      R2,R8
   \   0000008A   0x4629             MOV      R1,R5
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       SPI_FLASH_PageWrite
    371                WriteAddr +=  count;
   \   00000092   0x4445             ADD      R5,R8,R5
    372                pBuffer += count;
   \   00000094   0x4444             ADD      R4,R4,R8
   \   00000096   0xE00A             B.N      ??SPI_FLASH_BufferWrite_6
    373          
    374                while (NumOfPage--)
    375                {
    376                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PAGE_SIZE);
   \                     ??SPI_FLASH_BufferWrite_7: (+1)
   \   00000098   0xF44F 0x7280      MOV      R2,#+256
   \   0000009C   0x4629             MOV      R1,R5
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       SPI_FLASH_PageWrite
    377                  WriteAddr +=  SPI_FLASH_PAGE_SIZE;
   \   000000A4   0xF505 0x7580      ADD      R5,R5,#+256
    378                  pBuffer += SPI_FLASH_PAGE_SIZE;
   \   000000A8   0xF44F 0x7080      MOV      R0,#+256
   \   000000AC   0x4404             ADD      R4,R4,R0
    379                }
   \                     ??SPI_FLASH_BufferWrite_6: (+1)
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0x1E47             SUBS     R7,R0,#+1
   \   000000B2   0xB2C0             UXTB     R0,R0
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD1EF             BNE.N    ??SPI_FLASH_BufferWrite_7
    380          
    381                if (NumOfSingle != 0)
   \                     ??SPI_FLASH_BufferWrite_3: (+1)
   \   000000B8   0x2E00             CMP      R6,#+0
   \   000000BA   0xD004             BEQ.N    ??SPI_FLASH_BufferWrite_5
    382                {
    383                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
   \   000000BC   0x4632             MOV      R2,R6
   \   000000BE   0x4629             MOV      R1,R5
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       SPI_FLASH_PageWrite
    384                }
    385              }
    386            }
    387            
    388            return 1;
   \                     ??SPI_FLASH_BufferWrite_5: (+1)
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    389          }
    390          
    391          /*******************************************************************************
    392          * Function Name  : SPI_FLASH_BufferRead
    393          * Description    : Reads a block of data from the FLASH.
    394          * Input          : - pBuffer : pointer to the buffer that receives the data read
    395          *                    from the FLASH.
    396          *                  - ReadAddr : FLASH's internal address to read from.
    397          *                  - NumByteToRead : number of bytes to read from the FLASH.
    398          * Output         : None
    399          * Return         : None
    400          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    401          void SPI_FLASH_BufferRead(INT8U* pBuffer, INT32U ReadAddr, INT32U NumByteToRead)
    402          {
   \                     SPI_FLASH_BufferRead: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    403          	//INT8U err;
    404          	if(SpiFlashDevSem == NULL)
   \   0000000A   0x....             LDR.N    R7,??DataTable23_1
   \   0000000C   0x6838             LDR      R0,[R7, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??SPI_FLASH_BufferRead_0
    405          	{
    406          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`SPI_FLASH_BufferRead::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000001E   0x.... 0x....      B.W      printk
    407          		return;
    408          	}
    409          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 50 )  == pdTRUE)
   \                     ??SPI_FLASH_BufferRead_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x2232             MOVS     R2,#+50
   \   00000026   0x4619             MOV      R1,R3
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD12A             BNE.N    ??SPI_FLASH_BufferRead_1
    410          	{
    411          		/* Select the FLASH: Chip Select low */
    412          		SPI_FLASH_CS_LOW();
   \   00000030   0x.... 0x....      LDR.W    R8,??DataTable23  ;; 0x40020000
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       GPIO_ResetBits
    413          
    414          		/* Send "Read from Memory " instruction */
    415          		SPI_FLASH_SendByte(READ);
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      BL       SPI_FLASH_SendByte
    416          
    417          		/* Send ReadAddr high nibble address byte to read from */
    418          		SPI_FLASH_SendByte((ReadAddr >> 16) & 0xFF);
   \   00000042   0x0C28             LSRS     R0,R5,#+16
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x.... 0x....      BL       SPI_FLASH_SendByte
    419          		/* Send ReadAddr medium nibble address byte to read from */
    420          		SPI_FLASH_SendByte((ReadAddr >> 8) & 0xFF);
   \   0000004A   0x0A28             LSRS     R0,R5,#+8
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x.... 0x....      BL       SPI_FLASH_SendByte
    421          		/* Send ReadAddr low nibble address byte to read from */
    422          		SPI_FLASH_SendByte(ReadAddr & 0xFF);
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   0000005A   0xE004             B.N      ??SPI_FLASH_BufferRead_2
    423          
    424          
    425          		while (NumByteToRead--) /* while there is data to be read */
    426          		{
    427          			/* Read a byte from the FLASH */
    428          			*pBuffer = SPI_FLASH_SendByte(Dummy_Byte);
   \                     ??SPI_FLASH_BufferRead_3: (+1)
   \   0000005C   0x20A5             MOVS     R0,#+165
   \   0000005E   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000062   0xF804 0x0B01      STRB     R0,[R4], #+1
    429          
    430          			/* Point to the next location where the byte read will be saved */
    431          			pBuffer++;
    432          		}
   \                     ??SPI_FLASH_BufferRead_2: (+1)
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x1E46             SUBS     R6,R0,#+1
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1F6             BNE.N    ??SPI_FLASH_BufferRead_3
    433          
    434          		/* Deselect the FLASH: Chip Select high */
    435          		SPI_FLASH_CS_HIGH();
   \   0000006E   0x2110             MOVS     R1,#+16
   \   00000070   0x4640             MOV      R0,R8
   \   00000072   0x.... 0x....      BL       GPIO_SetBits
    436          		xSemaphoreGive(SpiFlashDevSem);
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0x461A             MOV      R2,R3
   \   0000007A   0x4611             MOV      R1,R2
   \   0000007C   0x6838             LDR      R0,[R7, #+0]
   \   0000007E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000082   0x.... 0x....      B.W      xQueueGenericSend
    437          	}
    438          }
   \                     ??SPI_FLASH_BufferRead_1: (+1)
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    439          
    440          
    441          /*******************************************************************************
    442          * Function Name  : SPI_FLASH_ReadID
    443          * Description    : Reads FLASH identification.
    444          * Input          : None
    445          * Output         : None
    446          * Return         : FLASH identification
    447          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    448          u32 SPI_FLASH_ReadID(void)
    449          {
   \                     SPI_FLASH_ReadID: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    450          	u32 Temp = 0, Temp0 = 0, Temp1 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    451          	//INT8U err;
    452          
    453          	
    454          	if(SpiFlashDevSem == NULL)
   \   00000004   0x....             LDR.N    R5,??DataTable23_1
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD107             BNE.N    ??SPI_FLASH_ReadID_0
    455          	{
    456          		printk("%s err\n",__func__);
   \   0000000C   0x.... 0x....      ADR.W    R1,`SPI_FLASH_ReadID::__func__`
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       printk
    457          		return 0x0;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
    458          	}
    459          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??SPI_FLASH_ReadID_0: (+1)
   \   0000001C   0x4623             MOV      R3,R4
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0x.... 0x....      BL       xQueueGenericReceive
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD124             BNE.N    ??SPI_FLASH_ReadID_1
    460          	{
    461          
    462          		/* Select the FLASH: Chip Select low */
    463          		SPI_FLASH_CS_LOW();
   \   0000002A   0x....             LDR.N    R4,??DataTable23  ;; 0x40020000
   \   0000002C   0x2110             MOVS     R1,#+16
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       GPIO_ResetBits
    464          
    465          		/* Send "RDID " instruction */
    466          		SPI_FLASH_SendByte(RDID);
   \   00000034   0x2090             MOVS     R0,#+144
   \   00000036   0x.... 0x....      BL       SPI_FLASH_SendByte
    467          
    468          		/* Send the 24-bit address of the address to read from -----------------------*/
    469          		/* Send ReadAddr high nibble address byte */
    470          		SPI_FLASH_SendByte(0x00);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       SPI_FLASH_SendByte
    471          		/* Send ReadAddr medium nibble address byte */
    472          		SPI_FLASH_SendByte(0x00);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       SPI_FLASH_SendByte
    473          		/* Send ReadAddr low nibble address byte */
    474          		SPI_FLASH_SendByte(0x00);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      BL       SPI_FLASH_SendByte
    475          
    476          		/* Read a byte from the FLASH */
    477          		Temp0 = SPI_FLASH_SendByte(Dummy_Byte);
   \   0000004C   0x20A5             MOVS     R0,#+165
   \   0000004E   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000052   0x4606             MOV      R6,R0
    478          
    479          		/* Read a byte from the FLASH */
    480          		Temp1 = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000054   0x20A5             MOVS     R0,#+165
   \   00000056   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   0000005A   0x4607             MOV      R7,R0
    481          
    482          		/* Deselect the FLASH: Chip Select high */
    483          		SPI_FLASH_CS_HIGH();
   \   0000005C   0x2110             MOVS     R1,#+16
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       GPIO_SetBits
    484          
    485          		Temp = (Temp0 << 8) | Temp1;
   \   00000064   0xEA47 0x2406      ORR      R4,R7,R6, LSL #+8
    486          
    487          		xSemaphoreGive(SpiFlashDevSem);
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x461A             MOV      R2,R3
   \   0000006C   0x4611             MOV      R1,R2
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0x.... 0x....      BL       xQueueGenericSend
    488          	}
    489          
    490          	return Temp;
   \                     ??SPI_FLASH_ReadID_1: (+1)
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    491          }
    492          
    493          /*******************************************************************************
    494          * Function Name  : SPI_FLASH_StartReadSequence
    495          * Description    : Initiates a read data byte (READ) sequence from the Flash.
    496          *                  This is done by driving the /CS line low to select the device,
    497          *                  then the READ instruction is transmitted followed by 3 bytes
    498          *                  address. This function exit and keep the /CS line low, so the
    499          *                  Flash still being selected. With this technique the whole
    500          *                  content of the Flash is read with a single READ instruction.
    501          * Input          : - ReadAddr : FLASH's internal address to read from.
    502          * Output         : None
    503          * Return         : None
    504          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    505          void SPI_FLASH_StartReadSequence(INT32U ReadAddr)
    506          {
   \                     SPI_FLASH_StartReadSequence: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    507          	//INT8U err;
    508          
    509          	if(SpiFlashDevSem == NULL)
   \   00000004   0x....             LDR.N    R5,??DataTable23_1
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD107             BNE.N    ??SPI_FLASH_StartReadSequence_0
    510          	{
    511          		printk("%s err\n",__func__);
   \   0000000C   0x.... 0x....      ADR.W    R1,`SPI_FLASH_StartReadSequence::__func__`
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      printk
    512          		return;
    513          	}
    514          	if(xSemaphoreTake(SpiFlashDevSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??SPI_FLASH_StartReadSequence_0: (+1)
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0x.... 0x....      BL       xQueueGenericReceive
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD11B             BNE.N    ??SPI_FLASH_StartReadSequence_1
    515          	{
    516          		/* Select the FLASH: Chip Select low */
    517          		SPI_FLASH_CS_LOW();
   \   0000002A   0x2110             MOVS     R1,#+16
   \   0000002C   0x....             LDR.N    R0,??DataTable23  ;; 0x40020000
   \   0000002E   0x.... 0x....      BL       GPIO_ResetBits
    518          
    519          		/* Send "Read from Memory " instruction */
    520          		SPI_FLASH_SendByte(READ);
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x.... 0x....      BL       SPI_FLASH_SendByte
    521          
    522          		/* Send the 24-bit address of the address to read from -----------------------*/
    523          		/* Send ReadAddr high nibble address byte */
    524          		SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000038   0x0C20             LSRS     R0,R4,#+16
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x.... 0x....      BL       SPI_FLASH_SendByte
    525          		/* Send ReadAddr medium nibble address byte */
    526          		SPI_FLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   00000040   0x0A20             LSRS     R0,R4,#+8
   \   00000042   0xB2C0             UXTB     R0,R0
   \   00000044   0x.... 0x....      BL       SPI_FLASH_SendByte
    527          		/* Send ReadAddr low nibble address byte */
    528          		SPI_FLASH_SendByte(ReadAddr & 0xFF);
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0xB2C0             UXTB     R0,R0
   \   0000004C   0x.... 0x....      BL       SPI_FLASH_SendByte
    529          
    530          		xSemaphoreGive(SpiFlashDevSem);
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x461A             MOV      R2,R3
   \   00000054   0x4611             MOV      R1,R2
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0xB001             ADD      SP,SP,#+4
   \   0000005A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000005E   0x.... 0x....      B.W      xQueueGenericSend
    531          	}
    532          }
   \                     ??SPI_FLASH_StartReadSequence_1: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    533          
    534          /*******************************************************************************
    535          * Function Name  : SPI_FLASH_ReadByte
    536          * Description    : Reads a byte from the SPI Flash.
    537          *                  This function must be used only if the Start_Read_Sequence
    538          *                  function has been previously called.
    539          * Input          : None
    540          * Output         : None
    541          * Return         : Byte Read from the SPI Flash.
    542          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    543          u8 SPI_FLASH_ReadByte(void)
    544          {
    545            return (SPI_FLASH_SendByte(Dummy_Byte));
   \                     SPI_FLASH_ReadByte: (+1)
   \   00000000   0x20A5             MOVS     R0,#+165
   \   00000002                      REQUIRE SPI_FLASH_SendByte
   \   00000002                      ;; // Fall through to label SPI_FLASH_SendByte
    546          }
    547          
    548          /*******************************************************************************
    549          * Function Name  : SPI_FLASH_SendByte
    550          * Description    : Sends a byte through the SPI interface and return the byte
    551          *                  received from the SPI bus.
    552          * Input          : byte : byte to send.
    553          * Output         : None
    554          * Return         : The value of the received byte.
    555          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    556          u8 SPI_FLASH_SendByte(INT8U byte)
    557          {
   \                     SPI_FLASH_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable23_2  ;; 0x40013000
    558            /* Loop while DR register in not emplty */
    559            while (SPI_I2S_GetFlagStatus(SPI_FLASH_DEV, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??SPI_FLASH_SendByte_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ.N    ??SPI_FLASH_SendByte_0
    560          
    561            /* Send byte through the SPI1 peripheral */
    562            SPI_I2S_SendData(SPI_FLASH_DEV, byte);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       SPI_I2S_SendData
    563          
    564            /* Wait to receive a byte */
    565            while (SPI_I2S_GetFlagStatus(SPI_FLASH_DEV, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??SPI_FLASH_SendByte_1: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??SPI_FLASH_SendByte_1
    566          
    567            /* Return the byte read from the SPI bus */
    568            return SPI_I2S_ReceiveData(SPI_FLASH_DEV);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       SPI_I2S_ReceiveData
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    569          }
    570          
    571          /*******************************************************************************
    572          * Function Name  : SPI_FLASH_SendHalfWord
    573          * Description    : Sends a Half Word through the SPI interface and return the
    574          *                  Half Word received from the SPI bus.
    575          * Input          : Half Word : Half Word to send.
    576          * Output         : None
    577          * Return         : The value of the received Half Word.
    578          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    579          u16 SPI_FLASH_SendHalfWord(INT16U HalfWord)
    580          {
   \                     SPI_FLASH_SendHalfWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable23_2  ;; 0x40013000
    581            /* Loop while DR register in not emplty */
    582            while (SPI_I2S_GetFlagStatus(SPI_FLASH_DEV, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??SPI_FLASH_SendHalfWord_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ.N    ??SPI_FLASH_SendHalfWord_0
    583          
    584            /* Send Half Word through the SPI1 peripheral */
    585            SPI_I2S_SendData(SPI_FLASH_DEV, HalfWord);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       SPI_I2S_SendData
    586          
    587            /* Wait to receive a Half Word */
    588            while (SPI_I2S_GetFlagStatus(SPI_FLASH_DEV, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??SPI_FLASH_SendHalfWord_1: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??SPI_FLASH_SendHalfWord_1
    589          
    590            /* Return the Half Word read from the SPI bus */
    591            return SPI_I2S_ReceiveData(SPI_FLASH_DEV);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x.... 0x....      B.W      SPI_I2S_ReceiveData
    592          }
    593          
    594          /*******************************************************************************
    595          * Function Name  : SPI_FLASH_WaitForWriteEnd
    596          * Description    : Polls the status of the Write In Progress (WIP) flag in the
    597          *                  FLASH's status  register  and  loop  until write  opertaion
    598          *                  has completed.
    599          * Input          : None
    600          * Output         : None
    601          * Return         : None
    602          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    603          void SPI_FLASH_WaitForWriteEnd(void)
    604          {
   \                     SPI_FLASH_WaitForWriteEnd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    605            u8 FLASH_Status = 0;
    606          
    607            /* Select the FLASH: Chip Select low */
    608            SPI_FLASH_CS_LOW();
   \   00000002   0x....             LDR.N    R4,??DataTable23  ;; 0x40020000
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       GPIO_ResetBits
    609          
    610            /* Send "Read Status Register" instruction */
    611            SPI_FLASH_SendByte(RDSR1);
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0x.... 0x....      BL       SPI_FLASH_SendByte
    612          
    613            /* Loop as long as the memory is busy with a write cycle */
    614            do
    615            {
    616              /* Send a dummy byte to generate the clock needed by the FLASH
    617              and put the value of the status register in FLASH_Status variable */
    618              FLASH_Status = SPI_FLASH_SendByte(Dummy_Byte);
    619          	//printk("\nRead Status : %X\n", FLASH_Status);
    620            }
    621            while ((FLASH_Status & BUSY_Flag) == SET); /* Write in progress */
   \                     ??SPI_FLASH_WaitForWriteEnd_0: (+1)
   \   00000012   0x20A5             MOVS     R0,#+165
   \   00000014   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD4FA             BMI.N    ??SPI_FLASH_WaitForWriteEnd_0
    622          
    623            /* Deselect the FLASH: Chip Select high */
    624            SPI_FLASH_CS_HIGH();
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      GPIO_SetBits
    625          }
    626          
    627          /*******************************************************************************
    628          * Function Name  : SPI_FLASH_WaitForWEL
    629          * Description    : Polls the status of the Write In Progress (WEL) flag in the
    630          *                  FLASH's status  register  and  loop  until write  opertaion
    631          *                  has completed.
    632          * Input          : None
    633          * Output         : None
    634          * Return         : None
    635          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    636          void SPI_FLASH_WaitForWEL(INT8U WEL_Sts)
    637          {
   \                     SPI_FLASH_WaitForWEL: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    638            u8 FLASH_Status = 0;
    639          
    640            /* Select the FLASH: Chip Select low */
    641            SPI_FLASH_CS_LOW();
   \   00000004   0x....             LDR.N    R5,??DataTable23  ;; 0x40020000
   \   00000006   0x2110             MOVS     R1,#+16
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GPIO_ResetBits
    642          
    643            /* Send "Read Status Register" instruction */
    644            SPI_FLASH_SendByte(RDSR1);
   \   0000000E   0x2005             MOVS     R0,#+5
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    645          
    646            /* Loop as long as the memory is busy with a write cycle */
    647            do
    648            {
    649              /* Send a dummy byte to generate the clock needed by the FLASH
    650              and put the value of the status register in FLASH_Status variable */
    651              FLASH_Status = SPI_FLASH_SendByte(Dummy_Byte);
   \                     ??SPI_FLASH_WaitForWEL_0: (+1)
   \   00000014   0x20A5             MOVS     R0,#+165
   \   00000016   0x.... 0x....      BL       SPI_FLASH_SendByte
    652          	//printk("\nRead WEL : %X\n", FLASH_Status);
    653            }
    654            while (((FLASH_Status & WEL_Flag)>>1) != WEL_Sts); /* Write in progress */
   \   0000001A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD1F8             BNE.N    ??SPI_FLASH_WaitForWEL_0
    655          
    656            /* Deselect the FLASH: Chip Select high */
    657            SPI_FLASH_CS_HIGH();
   \   00000022   0x2110             MOVS     R1,#+16
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000002A   0x.... 0x....      B.W      GPIO_SetBits
    658          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     SpiFlashDevSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    
    659          
    660          
    661          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SPI_FLASH_BlockErase
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SPI_FLASH_SendByte
        16   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteDisable
        16   -> SPI_FLASH_WriteEnable
         0   -> printk
        16   -> xQueueGenericReceive
         0   -> xQueueGenericSend
      24   SPI_FLASH_BufferRead
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_FLASH_SendByte
         0   -> printk
        24   -> xQueueGenericReceive
         0   -> xQueueGenericSend
      24   SPI_FLASH_BufferWrite
        24   -> SPI_FLASH_PageWrite
      16   SPI_FLASH_ChipErase
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SPI_FLASH_SendByte
        16   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteDisable
        16   -> SPI_FLASH_WriteEnable
         0   -> printk
        16   -> xQueueGenericReceive
         0   -> xQueueGenericSend
      16   SPI_FLASH_PageErase
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SPI_FLASH_SendByte
        16   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteDisable
        16   -> SPI_FLASH_WriteEnable
         0   -> printk
        16   -> xQueueGenericReceive
         0   -> xQueueGenericSend
      24   SPI_FLASH_PageWrite
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_FLASH_SectorErase
        24   -> SPI_FLASH_SendByte
        24   -> SPI_FLASH_WaitForWriteEnd
        24   -> SPI_FLASH_WriteDisable
        24   -> SPI_FLASH_WriteEnable
         0   -> printk
        24   -> xQueueGenericReceive
         0   -> xQueueGenericSend
       0   SPI_FLASH_ReadByte
         0   -> SPI_FLASH_SendByte
      24   SPI_FLASH_ReadID
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_FLASH_SendByte
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
      16   SPI_FLASH_SectorErase
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SPI_FLASH_SendByte
        16   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteDisable
        16   -> SPI_FLASH_WriteEnable
         0   -> printk
        16   -> xQueueGenericReceive
         0   -> xQueueGenericSend
      16   SPI_FLASH_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   SPI_FLASH_SendHalfWord
        16   -> SPI_I2S_GetFlagStatus
         0   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   SPI_FLASH_StartReadSequence
        16   -> GPIO_ResetBits
        16   -> SPI_FLASH_SendByte
         0   -> printk
        16   -> xQueueGenericReceive
         0   -> xQueueGenericSend
      16   SPI_FLASH_WaitForWEL
        16   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        16   -> SPI_FLASH_SendByte
       8   SPI_FLASH_WaitForWriteEnd
         8   -> GPIO_ResetBits
         0   -> GPIO_SetBits
         8   -> SPI_FLASH_SendByte
       8   SPI_FLASH_WriteDisable
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWEL
       8   SPI_FLASH_WriteEnable
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWEL
       8   flashSemaphore_Init
         8   -> GPIO_SetBits
         8   -> xQueueCreateMutex
         8   -> xQueueGenericCreate
         0   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       8  ?_0
     124  SPI_FLASH_BlockErase
     138  SPI_FLASH_BufferRead
     204  SPI_FLASH_BufferWrite
     100  SPI_FLASH_ChipErase
     124  SPI_FLASH_PageErase
     160  SPI_FLASH_PageWrite
       2  SPI_FLASH_ReadByte
     120  SPI_FLASH_ReadID
     124  SPI_FLASH_SectorErase
      48  SPI_FLASH_SendByte
      48  SPI_FLASH_SendHalfWord
     100  SPI_FLASH_StartReadSequence
      46  SPI_FLASH_WaitForWEL
      40  SPI_FLASH_WaitForWriteEnd
      36  SPI_FLASH_WriteDisable
      36  SPI_FLASH_WriteEnable
      56  flashSemaphore_Init
     180  -- Other

 
 1 706 bytes in section .text
 
 1 706 bytes of CODE memory

Errors: none
Warnings: none
