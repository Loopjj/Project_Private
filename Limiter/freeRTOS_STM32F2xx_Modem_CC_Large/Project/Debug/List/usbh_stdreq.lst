###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_stdreq.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_stdreq.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_stdreq.c 
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file implements the standard requests for device enumeration
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          /* Includes ------------------------------------------------------------------*/
     28          
     29          #include "usbh_ioreq.h"
     30          #include "usbh_stdreq.h"
     31          
     32          /** @addtogroup USBH_LIB
     33          * @{
     34          */
     35          
     36          /** @addtogroup USBH_LIB_CORE
     37          * @{
     38          */
     39          
     40          /** @defgroup USBH_STDREQ 
     41          * @brief This file implements the standard requests for device enumeration
     42          * @{
     43          */
     44          
     45          
     46          /** @defgroup USBH_STDREQ_Private_Defines
     47          * @{
     48          */ 
     49          /**
     50          * @}
     51          */ 
     52          
     53          
     54          /** @defgroup USBH_STDREQ_Private_TypesDefinitions
     55          * @{
     56          */ 
     57          /**
     58          * @}
     59          */ 
     60          
     61          
     62          
     63          /** @defgroup USBH_STDREQ_Private_Macros
     64          * @{
     65          */ 
     66          /**
     67          * @}
     68          */ 
     69          
     70          
     71          /** @defgroup USBH_STDREQ_Private_Variables
     72          * @{
     73          */
     74          /**
     75          * @}
     76          */ 
     77          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     78            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     79              #pragma data_alignment=4   
     80            #endif
     81          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */

   \                                 In section .bss, align 4
     82          __ALIGN_BEGIN uint8_t          USBH_CfgDesc[512] __ALIGN_END ;
   \                     USBH_CfgDesc:
   \   00000000                      DS8 512
     83          
     84          
     85          /** @defgroup USBH_STDREQ_Private_FunctionPrototypes
     86          * @{
     87          */
     88          static void USBH_ParseDevDesc (USBH_DevDesc_TypeDef* , uint8_t *buf, uint16_t length);
     89          
     90          static void USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
     91                                         USBH_InterfaceDesc_TypeDef* itf_desc,
     92                                         USBH_EpDesc_TypeDef  ep_desc[][USBH_MAX_NUM_ENDPOINTS],                                                           
     93                                         uint8_t *buf, 
     94                                         uint16_t length);
     95          
     96          
     97          static void USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef  *if_descriptor, uint8_t *buf);
     98          static void USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, uint8_t *buf);
     99          
    100          static void USBH_ParseStringDesc (uint8_t* psrc, uint8_t* pdest, uint16_t length);
    101          /**
    102          * @}
    103          */ 
    104          
    105          
    106          /** @defgroup USBH_STDREQ_Private_Functions
    107          * @{
    108          */ 
    109          
    110          
    111          /**
    112          * @brief  USBH_Get_DevDesc
    113          *         Issue Get Device Descriptor command to the device. Once the response 
    114          *         received, it parses the device descriptor and updates the status.
    115          * @param  pdev: Selected device
    116          * @param  dev_desc: Device Descriptor buffer address
    117          * @param  pdev->host.Rx_Buffer: Receive Buffer address
    118          * @param  length: Length of the descriptor
    119          * @retval Status
    120          */

   \                                 In section .text, align 2, keep-with-next
    121          USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
    122                                       USBH_HOST *phost,
    123                                       uint8_t length)
    124          {
   \                     USBH_Get_DevDesc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
    125            
    126            USBH_Status status;
    127            
    128            if((status = USBH_GetDescriptor(pdev, 
    129                                            phost,
    130                                            USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
    131                                            USB_DESC_DEVICE, 
    132                                            pdev->host.Rx_Buffer,
    133                                            length)) == USBH_OK)
   \   00000008   0xF44F 0x7188      MOV      R1,#+272
   \   0000000C   0x1846             ADDS     R6,R0,R1
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x9101             STR      R1,[SP, #+4]
   \   00000012   0x9600             STR      R6,[SP, #+0]
   \   00000014   0xF44F 0x7380      MOV      R3,#+256
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x.... 0x....      BL       USBH_GetDescriptor
   \   00000020   0x0007             MOVS     R7,R0
   \   00000022   0xD105             BNE.N    ??USBH_Get_DevDesc_0
    134            {
    135              /* Commands successfully sent and Response Received */       
    136              USBH_ParseDevDesc(&phost->device_prop.Dev_Desc, pdev->host.Rx_Buffer, length);
   \   00000024   0x462A             MOV      R2,R5
   \   00000026   0x4631             MOV      R1,R6
   \   00000028   0xF104 0x0022      ADD      R0,R4,#+34
   \   0000002C   0x.... 0x....      BL       USBH_ParseDevDesc
    137            }
    138            return status;      
   \                     ??USBH_Get_DevDesc_0: (+1)
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0xBDFE             POP      {R1-R7,PC}       ;; return
    139          }
    140          
    141          /**
    142          * @brief  USBH_Get_CfgDesc
    143          *         Issues Configuration Descriptor to the device. Once the response 
    144          *         received, it parses the configuartion descriptor and updates the 
    145          *         status.
    146          * @param  pdev: Selected device
    147          * @param  cfg_desc: Configuration Descriptor address
    148          * @param  itf_desc: Interface Descriptor address
    149          * @param  ep_desc: Endpoint Descriptor address
    150          * @param  length: Length of the descriptor
    151          * @retval Status
    152          */

   \                                 In section .text, align 2, keep-with-next
    153          USBH_Status USBH_Get_CfgDesc(USB_OTG_CORE_HANDLE *pdev, 
    154                                       USBH_HOST           *phost,                      
    155                                       uint16_t length)
    156          
    157          {
   \                     USBH_Get_CfgDesc: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
    158            USBH_Status status;
    159            uint16_t index = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    160            
    161            if((status = USBH_GetDescriptor(pdev,
    162                                            phost,
    163                                            USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
    164                                            USB_DESC_CONFIGURATION, 
    165                                            pdev->host.Rx_Buffer,
    166                                            length)) == USBH_OK)
   \   0000000E   0xF44F 0x7088      MOV      R0,#+272
   \   00000012   0xEB04 0x0800      ADD      R8,R4,R0
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000001E   0xF44F 0x7300      MOV      R3,#+512
   \   00000022   0x463A             MOV      R2,R7
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USBH_GetDescriptor
   \   0000002A   0x4681             MOV      R9,R0
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD113             BNE.N    ??USBH_Get_CfgDesc_0
   \   00000030   0x....             LDR.N    R1,??DataTable1
   \   00000032   0xE005             B.N      ??USBH_Get_CfgDesc_1
    167            {
    168              /*save Cfg descriptor for class parsing usage */
    169              for( ; index < length ; index ++)
    170              {
    171                USBH_CfgDesc[index] = pdev->host.Rx_Buffer[index];
   \                     ??USBH_Get_CfgDesc_2: (+1)
   \   00000034   0x19E0             ADDS     R0,R4,R7
   \   00000036   0xF890 0x0110      LDRB     R0,[R0, #+272]
   \   0000003A   0x55C8             STRB     R0,[R1, R7]
    172              }
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   \   0000003E   0xB2BF             UXTH     R7,R7
   \                     ??USBH_Get_CfgDesc_1: (+1)
   \   00000040   0x42B7             CMP      R7,R6
   \   00000042   0xDBF7             BLT.N    ??USBH_Get_CfgDesc_2
    173              
    174              /* Commands successfully sent and Response Received  */       
    175              USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
    176                                 phost->device_prop.Itf_Desc,
    177                                 phost->device_prop.Ep_Desc, 
    178                                 pdev->host.Rx_Buffer,
    179                                 length); 
   \   00000044   0x9600             STR      R6,[SP, #+0]
   \   00000046   0x4643             MOV      R3,R8
   \   00000048   0xF105 0x0250      ADD      R2,R5,#+80
   \   0000004C   0xF105 0x013E      ADD      R1,R5,#+62
   \   00000050   0xF105 0x0034      ADD      R0,R5,#+52
   \   00000054   0x.... 0x....      BL       USBH_ParseCfgDesc
    180              
    181            }
    182            return status;
   \                     ??USBH_Get_CfgDesc_0: (+1)
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    183          }
    184          
    185          
    186          /**
    187          * @brief  USBH_Get_StringDesc
    188          *         Issues string Descriptor command to the device. Once the response 
    189          *         received, it parses the string descriptor and updates the status.
    190          * @param  pdev: Selected device
    191          * @param  string_index: String index for the descriptor
    192          * @param  buff: Buffer address for the descriptor
    193          * @param  length: Length of the descriptor
    194          * @retval Status
    195          */

   \                                 In section .text, align 2, keep-with-next
    196          USBH_Status USBH_Get_StringDesc(USB_OTG_CORE_HANDLE *pdev,
    197                                          USBH_HOST *phost,
    198                                          uint8_t string_index, 
    199                                          uint8_t *buff, 
    200                                          uint16_t length)
    201          {
   \                     USBH_Get_StringDesc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x461D             MOV      R5,R3
    202            USBH_Status status;
    203            
    204            if((status = USBH_GetDescriptor(pdev,
    205                                            phost,
    206                                            USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                                    
    207                                            USB_DESC_STRING | string_index, 
    208                                            pdev->host.Rx_Buffer,
    209                                            length)) == USBH_OK)
   \   00000006   0xF44F 0x7388      MOV      R3,#+272
   \   0000000A   0x18C6             ADDS     R6,R0,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
   \   0000000E   0x4623             MOV      R3,R4
   \   00000010   0x9301             STR      R3,[SP, #+4]
   \   00000012   0x9600             STR      R6,[SP, #+0]
   \   00000014   0xF442 0x7340      ORR      R3,R2,#0x300
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x.... 0x....      BL       USBH_GetDescriptor
   \   0000001E   0x0007             MOVS     R7,R0
   \   00000020   0xD104             BNE.N    ??USBH_Get_StringDesc_0
    210            {
    211              /* Commands successfully sent and Response Received  */       
    212              USBH_ParseStringDesc(pdev->host.Rx_Buffer,buff, length);    
   \   00000022   0x4622             MOV      R2,R4
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       USBH_ParseStringDesc
    213            }
    214            return status;
   \                     ??USBH_Get_StringDesc_0: (+1)
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0xBDFE             POP      {R1-R7,PC}       ;; return
    215          }
    216          
    217          /**
    218          * @brief  USBH_GetDescriptor
    219          *         Issues Descriptor command to the device. Once the response received,
    220          *         it parses the descriptor and updates the status.
    221          * @param  pdev: Selected device
    222          * @param  req_type: Descriptor type
    223          * @param  value_idx: wValue for the GetDescriptr request
    224          * @param  buff: Buffer to store the descriptor
    225          * @param  length: Length of the descriptor
    226          * @retval Status
    227          */

   \                                 In section .text, align 2, keep-with-next
    228          USBH_Status USBH_GetDescriptor(USB_OTG_CORE_HANDLE *pdev,
    229                                         USBH_HOST           *phost,                                
    230                                         uint8_t  req_type,
    231                                         uint16_t value_idx, 
    232                                         uint8_t* buff, 
    233                                         uint16_t length )
    234          { 
   \                     USBH_GetDescriptor: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
    235            phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   \   00000002   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000006   0x750A             STRB     R2,[R1, #+20]
    236            phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
   \   00000008   0x2206             MOVS     R2,#+6
   \   0000000A   0x754A             STRB     R2,[R1, #+21]
    237            phost->Control.setup.b.wValue.w = value_idx;
   \   0000000C   0x82CB             STRH     R3,[R1, #+22]
    238            
    239            if ((value_idx & 0xff00) == USB_DESC_STRING)
   \   0000000E   0xF403 0x427F      AND      R2,R3,#0xFF00
   \   00000012   0xF5B2 0x7F40      CMP      R2,#+768
   \   00000016   0xD103             BNE.N    ??USBH_GetDescriptor_0
    240            {
    241              phost->Control.setup.b.wIndex.w = 0x0409;
   \   00000018   0xF240 0x4209      MOVW     R2,#+1033
   \   0000001C   0x830A             STRH     R2,[R1, #+24]
   \   0000001E   0xE001             B.N      ??USBH_GetDescriptor_1
    242            }
    243            else
    244            {
    245              phost->Control.setup.b.wIndex.w = 0;
   \                     ??USBH_GetDescriptor_0: (+1)
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x830A             STRH     R2,[R1, #+24]
   \                     ??USBH_GetDescriptor_1: (+1)
   \   00000024   0x9B03             LDR      R3,[SP, #+12]
    246            }
    247            phost->Control.setup.b.wLength.w = length;           
   \   00000026   0x834B             STRH     R3,[R1, #+26]
    248            return USBH_CtlReq(pdev, phost, buff , length );     
   \   00000028   0x9A02             LDR      R2,[SP, #+8]
   \   0000002A   0xB002             ADD      SP,SP,#+8
   \   0000002C   0x.... 0x....      B.W      USBH_CtlReq
    249          }
    250          
    251          /**
    252          * @brief  USBH_SetAddress
    253          *         This command sets the address to the connected device
    254          * @param  pdev: Selected device
    255          * @param  DeviceAddress: Device address to assign
    256          * @retval Status
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          USBH_Status USBH_SetAddress(USB_OTG_CORE_HANDLE *pdev, 
    259                                      USBH_HOST *phost,
    260                                      uint8_t DeviceAddress)
    261          {
    262            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
    263              USB_REQ_TYPE_STANDARD;
   \                     USBH_SetAddress: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x750B             STRB     R3,[R1, #+20]
    264            
    265            phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
   \   00000004   0x2305             MOVS     R3,#+5
   \   00000006   0x754B             STRB     R3,[R1, #+21]
    266            
    267            phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
   \   00000008   0x82CA             STRH     R2,[R1, #+22]
    268            phost->Control.setup.b.wIndex.w = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x830A             STRH     R2,[R1, #+24]
    269            phost->Control.setup.b.wLength.w = 0;
   \   0000000E   0x834A             STRH     R2,[R1, #+26]
    270            
    271            return USBH_CtlReq(pdev, phost, 0 , 0 );
   \   00000010   0x4613             MOV      R3,R2
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    272          }
    273          
    274          /**
    275          * @brief  USBH_SetCfg
    276          *         The command sets the configuration value to the connected device
    277          * @param  pdev: Selected device
    278          * @param  cfg_idx: Configuration value
    279          * @retval Status
    280          */

   \                                 In section .text, align 2, keep-with-next
    281          USBH_Status USBH_SetCfg(USB_OTG_CORE_HANDLE *pdev, 
    282                                  USBH_HOST *phost,
    283                                  uint16_t cfg_idx)
    284          {
    285            
    286            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
    287              USB_REQ_TYPE_STANDARD;
   \                     USBH_SetCfg: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x750B             STRB     R3,[R1, #+20]
    288            phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
   \   00000004   0x2309             MOVS     R3,#+9
   \   00000006   0x754B             STRB     R3,[R1, #+21]
    289            phost->Control.setup.b.wValue.w = cfg_idx;
   \   00000008   0x82CA             STRH     R2,[R1, #+22]
    290            phost->Control.setup.b.wIndex.w = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x830A             STRH     R2,[R1, #+24]
    291            phost->Control.setup.b.wLength.w = 0;           
   \   0000000E   0x834A             STRH     R2,[R1, #+26]
    292            
    293            return USBH_CtlReq(pdev, phost, 0 , 0 );      
   \   00000010   0x4613             MOV      R3,R2
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    294          }
    295          
    296          /**
    297          * @brief  USBH_SetInterface
    298          *         The command sets the Interface value to the connected device
    299          * @param  pdev: Selected device
    300          * @param  itf_idx: Interface value
    301          * @retval Status
    302          */

   \                                 In section .text, align 2, keep-with-next
    303          USBH_Status USBH_SetInterface(USB_OTG_CORE_HANDLE *pdev, 
    304                                  USBH_HOST *phost,
    305                                  uint8_t ep_num, uint8_t altSetting)
    306          {
   \                     USBH_SetInterface: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    307            
    308            
    309            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_INTERFACE | \
    310              USB_REQ_TYPE_STANDARD;
   \   00000002   0x2401             MOVS     R4,#+1
   \   00000004   0x750C             STRB     R4,[R1, #+20]
    311            
    312            phost->Control.setup.b.bRequest = USB_REQ_SET_INTERFACE;
   \   00000006   0x240B             MOVS     R4,#+11
   \   00000008   0x754C             STRB     R4,[R1, #+21]
    313            phost->Control.setup.b.wValue.w = altSetting;
   \   0000000A   0x82CB             STRH     R3,[R1, #+22]
    314            phost->Control.setup.b.wIndex.w = ep_num;
   \   0000000C   0x830A             STRH     R2,[R1, #+24]
    315            phost->Control.setup.b.wLength.w = 0;           
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x834A             STRH     R2,[R1, #+26]
    316           
    317            return USBH_CtlReq(pdev, phost, 0 , 0 );     
   \   00000012   0x4613             MOV      R3,R2
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x.... 0x....      B.W      USBH_CtlReq
    318          }
    319          /**
    320          * @brief  USBH_ClrFeature
    321          *         This request is used to clear or disable a specific feature.
    322          
    323          * @param  pdev: Selected device
    324          * @param  ep_num: endpoint number 
    325          * @param  hc_num: Host channel number 
    326          * @retval Status
    327          */

   \                                 In section .text, align 2, keep-with-next
    328          USBH_Status USBH_ClrFeature(USB_OTG_CORE_HANDLE *pdev,
    329                                      USBH_HOST *phost,
    330                                      uint8_t ep_num, 
    331                                      uint8_t hc_num) 
    332          {
   \                     USBH_ClrFeature: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    333            
    334            phost->Control.setup.b.bmRequestType = USB_H2D | 
    335                                                   USB_REQ_RECIPIENT_ENDPOINT |
    336                                                   USB_REQ_TYPE_STANDARD;
   \   00000002   0x2402             MOVS     R4,#+2
   \   00000004   0x750C             STRB     R4,[R1, #+20]
    337            
    338            phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x754C             STRB     R4,[R1, #+21]
    339            phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x82CC             STRH     R4,[R1, #+22]
    340            phost->Control.setup.b.wIndex.w = ep_num;
   \   0000000E   0x830A             STRH     R2,[R1, #+24]
    341            phost->Control.setup.b.wLength.w = 0;           
   \   00000010   0x834C             STRH     R4,[R1, #+26]
    342            
    343            if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
   \   00000012   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000016   0xF44F 0x7471      MOV      R4,#+964
   \   0000001A   0x4423             ADD      R3,R3,R4
   \   0000001C   0x0612             LSLS     R2,R2,#+24
   \   0000001E   0xD502             BPL.N    ??USBH_ClrFeature_0
    344            { /* EP Type is IN */
    345              pdev->host.hc[hc_num].toggle_in = 0; 
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x701A             STRB     R2,[R3, #+0]
   \   00000024   0xE001             B.N      ??USBH_ClrFeature_1
    346            }
    347            else
    348            {/* EP Type is OUT */
    349              pdev->host.hc[hc_num].toggle_out = 0; 
   \                     ??USBH_ClrFeature_0: (+1)
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x705A             STRB     R2,[R3, #+1]
    350            }
    351            
    352            return USBH_CtlReq(pdev, phost, 0 , 0 );   
   \                     ??USBH_ClrFeature_1: (+1)
   \   0000002A   0x4613             MOV      R3,R2
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x.... 0x....      B.W      USBH_CtlReq
    353          }
    354          
    355          /**
    356          * @brief  USBH_ParseDevDesc 
    357          *         This function Parses the device descriptor
    358          * @param  dev_desc: device_descriptor destinaton address 
    359          * @param  buf: Buffer where the source descriptor is available
    360          * @param  length: Length of the descriptor
    361          * @retval None
    362          */

   \                                 In section .text, align 2, keep-with-next
    363          static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
    364                                          uint8_t *buf, 
    365                                          uint16_t length)
    366          {
   \                     USBH_ParseDevDesc: (+1)
   \   00000000   0xB410             PUSH     {R4}
    367            dev_desc->bLength            = *(uint8_t  *) (buf +  0);
   \   00000002   0x780B             LDRB     R3,[R1, #+0]
   \   00000004   0x7003             STRB     R3,[R0, #+0]
    368            dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
   \   00000006   0x784B             LDRB     R3,[R1, #+1]
   \   00000008   0x7043             STRB     R3,[R0, #+1]
    369            dev_desc->bcdUSB             = LE16 (buf +  2);
   \   0000000A   0x788B             LDRB     R3,[R1, #+2]
   \   0000000C   0x78CC             LDRB     R4,[R1, #+3]
   \   0000000E   0xEB03 0x2304      ADD      R3,R3,R4, LSL #+8
   \   00000012   0x8043             STRH     R3,[R0, #+2]
    370            dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
   \   00000014   0x790B             LDRB     R3,[R1, #+4]
   \   00000016   0x7103             STRB     R3,[R0, #+4]
    371            dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
   \   00000018   0x794B             LDRB     R3,[R1, #+5]
   \   0000001A   0x7143             STRB     R3,[R0, #+5]
    372            dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
   \   0000001C   0x798B             LDRB     R3,[R1, #+6]
   \   0000001E   0x7183             STRB     R3,[R0, #+6]
    373            dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
   \   00000020   0x79CB             LDRB     R3,[R1, #+7]
   \   00000022   0x71C3             STRB     R3,[R0, #+7]
    374            
    375            if (length > 8)
   \   00000024   0x2A09             CMP      R2,#+9
   \   00000026   0xDB16             BLT.N    ??USBH_ParseDevDesc_0
    376            { /* For 1st time after device connection, Host may issue only 8 bytes for 
    377              Device Descriptor Length  */
    378              dev_desc->idVendor           = LE16 (buf +  8);
   \   00000028   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000002A   0x7A4B             LDRB     R3,[R1, #+9]
   \   0000002C   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   00000030   0x8102             STRH     R2,[R0, #+8]
    379              dev_desc->idProduct          = LE16 (buf + 10);
   \   00000032   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000034   0x7ACB             LDRB     R3,[R1, #+11]
   \   00000036   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   0000003A   0x8142             STRH     R2,[R0, #+10]
    380              dev_desc->bcdDevice          = LE16 (buf + 12);
   \   0000003C   0x7B0A             LDRB     R2,[R1, #+12]
   \   0000003E   0x7B4B             LDRB     R3,[R1, #+13]
   \   00000040   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   00000044   0x8182             STRH     R2,[R0, #+12]
    381              dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
   \   00000046   0x7B8A             LDRB     R2,[R1, #+14]
   \   00000048   0x7382             STRB     R2,[R0, #+14]
    382              dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
   \   0000004A   0x7BCA             LDRB     R2,[R1, #+15]
   \   0000004C   0x73C2             STRB     R2,[R0, #+15]
    383              dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
   \   0000004E   0x7C0A             LDRB     R2,[R1, #+16]
   \   00000050   0x7402             STRB     R2,[R0, #+16]
    384              dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
   \   00000052   0x7C49             LDRB     R1,[R1, #+17]
   \   00000054   0x7441             STRB     R1,[R0, #+17]
    385            }
    386          }
   \                     ??USBH_ParseDevDesc_0: (+1)
   \   00000056   0xBC10             POP      {R4}
   \   00000058   0x4770             BX       LR               ;; return
    387          
    388          /**
    389          * @brief  USBH_ParseCfgDesc 
    390          *         This function Parses the configuration descriptor
    391          * @param  cfg_desc: Configuration Descriptor address
    392          * @param  itf_desc: Interface Descriptor address
    393          * @param  ep_desc: Endpoint Descriptor address
    394          * @param  buf: Buffer where the source descriptor is available
    395          * @param  length: Length of the descriptor
    396          * @retval None
    397          */

   \                                 In section .text, align 2, keep-with-next
    398          static void  USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
    399                                          USBH_InterfaceDesc_TypeDef* itf_desc,
    400                                          USBH_EpDesc_TypeDef   ep_desc[][USBH_MAX_NUM_ENDPOINTS], 
    401                                          uint8_t *buf, 
    402                                          uint16_t length)
    403          {  
   \                     USBH_ParseCfgDesc: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    404            USBH_InterfaceDesc_TypeDef    *pif ;
    405            USBH_InterfaceDesc_TypeDef    temp_pif ;  
    406            USBH_EpDesc_TypeDef           *pep;  
    407            USBH_DescHeader_t             *pdesc = (USBH_DescHeader_t *)buf;
    408            uint16_t                      ptr;
    409            int8_t                        if_ix = 0;
    410            int8_t                        ep_ix = 0;  
    411            static uint16_t               prev_ep_size = 0;
    412            static uint8_t                prev_itf = 0;  
    413            
    414            
    415            pdesc   = (USBH_DescHeader_t *)buf;
    416            
    417            /* Parse configuration descriptor */
    418            cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
   \   0000000E   0x7838             LDRB     R0,[R7, #+0]
   \   00000010   0x7020             STRB     R0,[R4, #+0]
    419            cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
   \   00000012   0x7878             LDRB     R0,[R7, #+1]
   \   00000014   0x7060             STRB     R0,[R4, #+1]
    420            cfg_desc->wTotalLength        = LE16 (buf + 2);
   \   00000016   0x78B8             LDRB     R0,[R7, #+2]
   \   00000018   0x78F9             LDRB     R1,[R7, #+3]
   \   0000001A   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   0000001E   0x8060             STRH     R0,[R4, #+2]
    421            cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
   \   00000020   0x7938             LDRB     R0,[R7, #+4]
   \   00000022   0x7120             STRB     R0,[R4, #+4]
    422            cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
   \   00000024   0x7978             LDRB     R0,[R7, #+5]
   \   00000026   0x7160             STRB     R0,[R4, #+5]
    423            cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
   \   00000028   0x79B8             LDRB     R0,[R7, #+6]
   \   0000002A   0x71A0             STRB     R0,[R4, #+6]
    424            cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
   \   0000002C   0x79F8             LDRB     R0,[R7, #+7]
   \   0000002E   0x71E0             STRB     R0,[R4, #+7]
    425            cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
   \   00000030   0x7A38             LDRB     R0,[R7, #+8]
   \   00000032   0x7220             STRB     R0,[R4, #+8]
    426            
    427            
    428            if (length > USB_CONFIGURATION_DESC_SIZE)
   \   00000034   0x980E             LDR      R0,[SP, #+56]
   \   00000036   0x280A             CMP      R0,#+10
   \   00000038   0xDB64             BLT.N    ??USBH_ParseCfgDesc_0
    429            {
    430              ptr = USB_LEN_CFG_DESC;
   \   0000003A   0x2009             MOVS     R0,#+9
   \   0000003C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    431              
    432              if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
   \   00000040   0x7920             LDRB     R0,[R4, #+4]
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0x.... 0x....      LDR.W    R10,??DataTable1_1
   \   00000048   0xDA57             BGE.N    ??USBH_ParseCfgDesc_1
    433              {
    434                pif = (USBH_InterfaceDesc_TypeDef *)0;
    435                
    436                while (ptr < cfg_desc->wTotalLength ) 
   \                     ??USBH_ParseCfgDesc_2: (+1)
   \   0000004A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000004E   0x8861             LDRH     R1,[R4, #+2]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD252             BCS.N    ??USBH_ParseCfgDesc_1
    437                {
    438                  pdesc = USBH_GetNextDesc((uint8_t *)pdesc, &ptr);
   \   00000054   0x4669             MOV      R1,SP
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x.... 0x....      BL       USBH_GetNextDesc
   \   0000005C   0x4607             MOV      R7,R0
    439                  if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
   \   0000005E   0x7878             LDRB     R0,[R7, #+1]
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0xD1F2             BNE.N    ??USBH_ParseCfgDesc_2
    440                  {
    441                    if_ix             = *(((uint8_t *)pdesc ) + 2);
   \   00000064   0xF997 0x8002      LDRSB    R8,[R7, #+2]
    442                    pif               = &itf_desc[if_ix];
    443                    
    444                    if((*((uint8_t *)pdesc + 3)) < 3)
   \   00000068   0x78F8             LDRB     R0,[R7, #+3]
   \   0000006A   0x2803             CMP      R0,#+3
   \   0000006C   0xDAED             BGE.N    ??USBH_ParseCfgDesc_2
    445                    {
    446                    USBH_ParseInterfaceDesc (&temp_pif, (uint8_t *)pdesc);            
   \   0000006E   0x4639             MOV      R1,R7
   \   00000070   0xA801             ADD      R0,SP,#+4
   \   00000072   0x.... 0x....      BL       USBH_ParseInterfaceDesc
    447                    ep_ix = 0;
   \   00000076   0xF04F 0x0900      MOV      R9,#+0
    448                    
    449                    /* Parse Ep descriptors relative to the current interface */
    450                    if(temp_pif.bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
   \   0000007A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000007E   0x2803             CMP      R0,#+3
   \   00000080   0xDAE3             BGE.N    ??USBH_ParseCfgDesc_2
   \   00000082   0xE019             B.N      ??USBH_ParseCfgDesc_3
    451                    {          
    452                      while (ep_ix < temp_pif.bNumEndpoints) 
    453                      {
    454                        pdesc = USBH_GetNextDesc((void* )pdesc, &ptr);
    455                        if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
    456                        {  
    457                          pep               = &ep_desc[if_ix][ep_ix];
    458                          
    459                          if(prev_itf != if_ix)
    460                          {
    461                            prev_itf = if_ix;
    462                            USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif); 
    463                          }
    464                          else
    465                          {
    466                            if(prev_ep_size > LE16((uint8_t *)pdesc + 4))
   \                     ??USBH_ParseCfgDesc_4: (+1)
   \   00000084   0x7938             LDRB     R0,[R7, #+4]
   \   00000086   0x7979             LDRB     R1,[R7, #+5]
   \   00000088   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   0000008C   0xF8BA 0x1002      LDRH     R1,[R10, #+2]
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xDBDA             BLT.N    ??USBH_ParseCfgDesc_2
    467                            {
    468                              break;
    469                            }
    470                            else
    471                            {
    472                              USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif);    
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0xEB08 0x00C8      ADD      R0,R8,R8, LSL #+3
   \   0000009A   0x4428             ADD      R0,R5,R0
   \   0000009C   0x.... 0x....      BL       USBH_ParseInterfaceDesc
    473                            }
    474                          }
    475                          USBH_ParseEPDesc (pep, (uint8_t *)pdesc);
   \                     ??USBH_ParseCfgDesc_5: (+1)
   \   000000A0   0x4639             MOV      R1,R7
   \   000000A2   0x4658             MOV      R0,R11
   \   000000A4   0x.... 0x....      BL       USBH_ParseEPDesc
    476                          prev_ep_size = LE16((uint8_t *)pdesc + 4);
   \   000000A8   0x7938             LDRB     R0,[R7, #+4]
   \   000000AA   0x7979             LDRB     R1,[R7, #+5]
   \   000000AC   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   000000B0   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    477                          ep_ix++;
   \   000000B4   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??USBH_ParseCfgDesc_3: (+1)
   \   000000B8   0x4648             MOV      R0,R9
   \   000000BA   0xB240             SXTB     R0,R0
   \   000000BC   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xDAC2             BGE.N    ??USBH_ParseCfgDesc_2
   \   000000C4   0x4669             MOV      R1,SP
   \   000000C6   0x4638             MOV      R0,R7
   \   000000C8   0x.... 0x....      BL       USBH_GetNextDesc
   \   000000CC   0x4607             MOV      R7,R0
   \   000000CE   0x7878             LDRB     R0,[R7, #+1]
   \   000000D0   0x2805             CMP      R0,#+5
   \   000000D2   0xD1F1             BNE.N    ??USBH_ParseCfgDesc_3
   \   000000D4   0xEB06 0x1008      ADD      R0,R6,R8, LSL #+4
   \   000000D8   0xFA4F 0xF989      SXTB     R9,R9
   \   000000DC   0xEB00 0x0BC9      ADD      R11,R0,R9, LSL #+3
   \   000000E0   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000E4   0x4540             CMP      R0,R8
   \   000000E6   0xD0CD             BEQ.N    ??USBH_ParseCfgDesc_4
   \   000000E8   0xF88A 0x8000      STRB     R8,[R10, #+0]
   \   000000EC   0xA901             ADD      R1,SP,#+4
   \   000000EE   0xEB08 0x00C8      ADD      R0,R8,R8, LSL #+3
   \   000000F2   0x4428             ADD      R0,R5,R0
   \   000000F4   0x.... 0x....      BL       USBH_ParseInterfaceDesc
   \   000000F8   0xE7D2             B.N      ??USBH_ParseCfgDesc_5
    478                        }
    479                      }
    480                    }
    481                   }
    482                  }
    483                }
    484              }
    485              prev_ep_size = 0;
   \                     ??USBH_ParseCfgDesc_1: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    486              prev_itf = 0; 
   \   00000100   0xF88A 0x0000      STRB     R0,[R10, #+0]
    487            }  
    488          }
   \                     ??USBH_ParseCfgDesc_0: (+1)
   \   00000104   0xB005             ADD      SP,SP,#+20
   \   00000106   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .bss, align 2
   \                     `USBH_ParseCfgDesc::prev_itf`:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
    489          
    490          
    491          /**
    492          * @brief  USBH_ParseInterfaceDesc 
    493          *         This function Parses the interface descriptor
    494          * @param  if_descriptor : Interface descriptor destination
    495          * @param  buf: Buffer where the descriptor data is available
    496          * @retval None
    497          */

   \                                 In section .text, align 2, keep-with-next
    498          static void  USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef *if_descriptor, 
    499                                                uint8_t *buf)
    500          {
    501            if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
   \                     USBH_ParseInterfaceDesc: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x7002             STRB     R2,[R0, #+0]
    502            if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x7042             STRB     R2,[R0, #+1]
    503            if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
   \   00000008   0x788A             LDRB     R2,[R1, #+2]
   \   0000000A   0x7082             STRB     R2,[R0, #+2]
    504            if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
   \   0000000C   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000E   0x70C2             STRB     R2,[R0, #+3]
    505            if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
   \   00000010   0x790A             LDRB     R2,[R1, #+4]
   \   00000012   0x7102             STRB     R2,[R0, #+4]
    506            if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
   \   00000014   0x794A             LDRB     R2,[R1, #+5]
   \   00000016   0x7142             STRB     R2,[R0, #+5]
    507            if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
   \   00000018   0x798A             LDRB     R2,[R1, #+6]
   \   0000001A   0x7182             STRB     R2,[R0, #+6]
    508            if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
   \   0000001C   0x79CA             LDRB     R2,[R1, #+7]
   \   0000001E   0x71C2             STRB     R2,[R0, #+7]
    509            if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
   \   00000020   0x7A09             LDRB     R1,[R1, #+8]
   \   00000022   0x7201             STRB     R1,[R0, #+8]
    510          }
   \   00000024   0x4770             BX       LR               ;; return
    511          
    512          /**
    513          * @brief  USBH_ParseEPDesc 
    514          *         This function Parses the endpoint descriptor
    515          * @param  ep_descriptor: Endpoint descriptor destination address
    516          * @param  buf: Buffer where the parsed descriptor stored
    517          * @retval None
    518          */

   \                                 In section .text, align 2, keep-with-next
    519          static void  USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, 
    520                                         uint8_t *buf)
    521          {
    522            
    523            ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
   \                     USBH_ParseEPDesc: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x7002             STRB     R2,[R0, #+0]
    524            ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x7042             STRB     R2,[R0, #+1]
    525            ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
   \   00000008   0x788A             LDRB     R2,[R1, #+2]
   \   0000000A   0x7082             STRB     R2,[R0, #+2]
    526            ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
   \   0000000C   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000E   0x70C2             STRB     R2,[R0, #+3]
    527            ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
   \   00000010   0x790A             LDRB     R2,[R1, #+4]
   \   00000012   0x794B             LDRB     R3,[R1, #+5]
   \   00000014   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   00000018   0x8082             STRH     R2,[R0, #+4]
    528            ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
   \   0000001A   0x7989             LDRB     R1,[R1, #+6]
   \   0000001C   0x7181             STRB     R1,[R0, #+6]
    529          }
   \   0000001E   0x4770             BX       LR               ;; return
    530          
    531          /**
    532          * @brief  USBH_ParseStringDesc 
    533          *         This function Parses the string descriptor
    534          * @param  psrc: Source pointer containing the descriptor data
    535          * @param  pdest: Destination address pointer
    536          * @param  length: Length of the descriptor
    537          * @retval None
    538          */

   \                                 In section .text, align 2, keep-with-next
    539          static void USBH_ParseStringDesc (uint8_t* psrc, 
    540                                            uint8_t* pdest, 
    541                                            uint16_t length)
    542          {
    543            uint16_t strlength;
    544            uint16_t idx;
    545            
    546            /* The UNICODE string descriptor is not NULL-terminated. The string length is
    547            computed by substracting two from the value of the first byte of the descriptor.
    548            */
    549            
    550            /* Check which is lower size, the Size of string or the length of bytes read 
    551            from the device */
    552            
    553            if ( psrc[1] == USB_DESC_TYPE_STRING)
   \                     USBH_ParseStringDesc: (+1)
   \   00000000   0x7843             LDRB     R3,[R0, #+1]
   \   00000002   0x2B03             CMP      R3,#+3
   \   00000004   0xD000             BEQ.N    ??USBH_ParseStringDesc_0
   \   00000006   0x4770             BX       LR
    554            { /* Make sure the Descriptor is String Type */
    555              
    556              /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
    557              strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
   \                     ??USBH_ParseStringDesc_0: (+1)
   \   00000008   0xB410             PUSH     {R4}
   \   0000000A   0x7803             LDRB     R3,[R0, #+0]
   \   0000000C   0x1E9C             SUBS     R4,R3,#+2
   \   0000000E   0x42A2             CMP      R2,R4
   \   00000010   0xDB01             BLT.N    ??USBH_ParseStringDesc_1
   \   00000012   0x1E9A             SUBS     R2,R3,#+2
   \   00000014   0xB292             UXTH     R2,R2
    558              psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
   \                     ??USBH_ParseStringDesc_1: (+1)
   \   00000016   0x1C80             ADDS     R0,R0,#+2
    559              
    560              for (idx = 0; idx < strlength; idx+=2 )
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0xE004             B.N      ??USBH_ParseStringDesc_2
    561              {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
    562                *pdest =  psrc[idx];
   \                     ??USBH_ParseStringDesc_3: (+1)
   \   0000001C   0x5CC4             LDRB     R4,[R0, R3]
   \   0000001E   0xF801 0x4B01      STRB     R4,[R1], #+1
    563                pdest++;
    564              }  
   \   00000022   0x1C9B             ADDS     R3,R3,#+2
   \   00000024   0xB29B             UXTH     R3,R3
   \                     ??USBH_ParseStringDesc_2: (+1)
   \   00000026   0x4293             CMP      R3,R2
   \   00000028   0xDBF8             BLT.N    ??USBH_ParseStringDesc_3
    565              *pdest = 0; /* mark end of string */  
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    566            }
    567          }
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    568          
    569          /**
    570          * @brief  USBH_GetNextDesc 
    571          *         This function return the next descriptor header
    572          * @param  buf: Buffer where the cfg descriptor is available
    573          * @param  ptr: data popinter inside the cfg descriptor
    574          * @retval next header
    575          */

   \                                 In section .text, align 2, keep-with-next
    576          USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
    577          {
    578            USBH_DescHeader_t  *pnext;
    579           
    580            *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
   \                     USBH_GetNextDesc: (+1)
   \   00000000   0x880A             LDRH     R2,[R1, #+0]
   \   00000002   0x7803             LDRB     R3,[R0, #+0]
   \   00000004   0x189A             ADDS     R2,R3,R2
   \   00000006   0x800A             STRH     R2,[R1, #+0]
    581            pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
    582                   ((USBH_DescHeader_t *)pbuf)->bLength);
    583           
    584            return(pnext);
   \   00000008   0x7801             LDRB     R1,[R0, #+0]
   \   0000000A   0x4408             ADD      R0,R0,R1
   \   0000000C   0x4770             BX       LR               ;; return
    585          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     USBH_CfgDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     `USBH_ParseCfgDesc::prev_itf`
    586          
    587          /**
    588          * @}
    589          */ 
    590          
    591          /**
    592          * @}
    593          */ 
    594          
    595          /**
    596          * @}
    597          */
    598          
    599          /**
    600          * @}
    601          */ 
    602          
    603          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    604          
    605          
    606          
    607          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USBH_ClrFeature
         0   -> USBH_CtlReq
       8   USBH_GetDescriptor
         0   -> USBH_CtlReq
       0   USBH_GetNextDesc
      40   USBH_Get_CfgDesc
        40   -> USBH_GetDescriptor
        40   -> USBH_ParseCfgDesc
      32   USBH_Get_DevDesc
        32   -> USBH_GetDescriptor
        32   -> USBH_ParseDevDesc
      32   USBH_Get_StringDesc
        32   -> USBH_GetDescriptor
        32   -> USBH_ParseStringDesc
      56   USBH_ParseCfgDesc
        56   -> USBH_GetNextDesc
        56   -> USBH_ParseEPDesc
        56   -> USBH_ParseInterfaceDesc
       4   USBH_ParseDevDesc
       0   USBH_ParseEPDesc
       0   USBH_ParseInterfaceDesc
       4   USBH_ParseStringDesc
       0   USBH_SetAddress
         0   -> USBH_CtlReq
       0   USBH_SetCfg
         0   -> USBH_CtlReq
       8   USBH_SetInterface
         0   -> USBH_CtlReq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
     512  USBH_CfgDesc
      52  USBH_ClrFeature
      48  USBH_GetDescriptor
      14  USBH_GetNextDesc
      94  USBH_Get_CfgDesc
      52  USBH_Get_DevDesc
      48  USBH_Get_StringDesc
     266  USBH_ParseCfgDesc
      90  USBH_ParseDevDesc
      32  USBH_ParseEPDesc
      38  USBH_ParseInterfaceDesc
      50  USBH_ParseStringDesc
      22  USBH_SetAddress
      22  USBH_SetCfg
      28  USBH_SetInterface
       4  prev_itf
          prev_ep_size

 
 516 bytes in section .bss
 864 bytes in section .text
 
 864 bytes of CODE memory
 516 bytes of DATA memory

Errors: none
Warnings: none
