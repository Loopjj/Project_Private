###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\bsp_free.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\bsp_free.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\bsp_free.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\bsp_free.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\bsp_free.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2014 Loop *************************************
      3          *
      4          * File Name          : bsp_free.c
      5          *
      6          * Author             : Digital Development Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 08/18/2014
     11          *
     12          * Description        : SCR board configuration 
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          #define BSP_GLOBAL
     18          #include "includes.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SystemReset(void)
   \                     NVIC_SystemReset: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0xe000ed0c
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable30  ;; 0x5fa0004
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0xF3BF 0x8F4F      DSB      
   \                     ??NVIC_SystemReset_0: (+1)
   \   0000001A   0xBF00             Nop      
   \   0000001C   0xE7FD             B.N      ??NVIC_SystemReset_0

   \                                 In section .bss, align 4
   \   __absolute INT16U adcdata[2]
   \                     adcdata:
   \   00000000                      DS8 4
     19          
     20          
     21          
     22          /*
     23          *********************************************************************************************************
     24          *                                                DEFINE
     25          *********************************************************************************************************
     26          */
     27          
     28          #define FLASH_START_BASE	0x10000	// 부트로더 Offset 
     29          
     30          
     31          
     32          /*
     33          *********************************************************************************************************
     34          *                                              TYPE DEFINE
     35          *********************************************************************************************************
     36          */
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                      LOCAL FUNCTION PROTOTYPES
     42          *********************************************************************************************************
     43          */
     44          
     45          static void BSP_IWDG_Init(void);			// Independent Watchdog
     46          
     47          static void BSP_NVIC_Init(void);			// Interrupt priority setting
     48          
     49          static void BSP_RTC_Init(void);				// 32.768KHz
     50          
     51          #if PDV_ENABLE > 0
     52          static void BSP_PVD_Init(void);				// Power Voltage Detect
     53          #endif
     54          
     55          static void BSP_GPIO_Init(void);			// etc gpio setting
     56          
     57          static void BSP_CAN1_Init(void);      // for car
     58          
     59          static void BSP_EXTI_Init(void);      // key on
     60          
     61          static void BSP_USART1_Init(void);    // cdma modem
     62          
     63          static void BSP_USART2_Init(void);	  // gps
     64          
     65          static void BSP_ADC1_Init(void);      // pressure
     66          
     67          static void BSP_I2C1_Init(void);      // fram
     68          
     69          static void BSP_SPI1_Init(void);			// serial flash
     70          
     71          static void BSP_SPI2_Init(void);			// temperature
     72          
     73          //------------------------------------------------------------------ Interrupt Service Routine Function
     74          
     75          #if PDV_ENABLE > 0
     76          void PVD_IRQHandler(void);
     77          #endif
     78          void RTC_WKUP_IRQHandler(void);
     79          
     80          void I2C1_EV_IRQHandler(void);
     81          
     82          void I2C1_ER_IRQHandler(void);
     83          
     84          void CAN1_RX0_IRQHandler(void);
     85          
     86          void EXTI9_5_IRQHandler(void);
     87          
     88          void USART1_IRQHandler(void);
     89          
     90          void USART2_IRQHandler(void);
     91          
     92          extern __IO I2C_Dir I2C_DIR;
     93          extern __IO uint8_t I2C_BLOCKED;
     94          extern __IO uint8_t I2CADDRESS;
     95          extern __IO uint8_t rx_buffer_len;
     96          extern __IO uint8_t tx_buffer_len;
     97          extern __IO uint8_t tx_buffer_ix;
     98          extern __IO uint8_t rx_buffer_ix;
     99          extern __IO uint8_t tx_buffer[];
    100          extern __IO uint8_t *rx_buffer_ptr;
    101          

   \                                 In section .rodata, align 4, keep-with-next
    102          const unsigned long CAN_MON_ID[MAX_CAN_MON_NO] = {0x0000000a, 0x18F00E51, 0x18F00F52, 0x18FFDF00, 0x18FE563D,
   \                     CAN_MON_ID:
   \   00000000   0x0000000A         DC32 10, 418385489, 418385746, 419421952, 419321405, 419351101
   \              0x18F00E51   
   \              0x18F00F52   
   \              0x18FFDF00   
   \              0x18FE563D   
   \              0x18FECA3D   
   \   00000018   0x18FDB43D         DC32 419279933, 419279677, 217057792, 419421757
   \              0x18FDB33D   
   \              0x0CF00A00   
   \              0x18FFDE3D   
    103                                                            0x18FECA3D,0x18FDB43D, 0x18FDB33D, 0x0CF00A00, 0x18FFDE3D};
    104          
    105          /*
    106          *********************************************************************************************************
    107          *********************************************************************************************************
    108          *                                            LOCAL FUNCTIONS
    109          *********************************************************************************************************
    110          *********************************************************************************************************
    111          */
    112          
    113          
    114          /*
    115          ********************************************************************************
    116          * Description : BSP_Lowlevel_Init
    117          * Arguments   : none
    118          * Return      : 
    119          * Note        : Initialize the Board Support Package (BSP).
    120          ******************************************************************************** 
    121          */
    122          

   \                                 In section .text, align 2, keep-with-next
    123          void BSP_Lowlevel_Init(void)
    124          {
   \                     BSP_Lowlevel_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    125          	
    126          	RCC_DeInit();
   \   00000002   0x.... 0x....      BL       RCC_DeInit
    127          
    128            RCC_HSEConfig(RCC_HSE_ON);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       RCC_HSEConfig
    129          
    130          	SystemInit();	
   \   0000000C   0x.... 0x....      BL       SystemInit
    131          
    132          	BSP_NVIC_Init();
   \   00000010   0x.... 0x....      BL       BSP_NVIC_Init
    133          
    134          	BSP_GPIO_Init();
   \   00000014   0x.... 0x....      BL       BSP_GPIO_Init
    135            
    136          	BSP_RTC_Init();       // interanl rtc
   \   00000018   0x.... 0x....      BL       BSP_RTC_Init
    137            
    138            BSP_I2C1_Init();      // fram
   \   0000001C   0x.... 0x....      BL       BSP_I2C1_Init
    139              
    140          	BSP_USART1_Init();    // gps
   \   00000020   0x.... 0x....      BL       BSP_USART1_Init
    141          
    142            BSP_USART2_Init();    // modem control
   \   00000024   0x.... 0x....      BL       BSP_USART2_Init
    143              
    144          	BSP_SPI1_Init();      // serial flash
   \   00000028   0x.... 0x....      BL       BSP_SPI1_Init
    145          	
    146          	BSP_SPI2_Init();      // temperature
   \   0000002C   0x.... 0x....      BL       BSP_SPI2_Init
    147          
    148          	BSP_ADC1_Init();      // adc dma set
   \   00000030   0x.... 0x....      BL       BSP_ADC1_Init
    149          
    150            BSP_EXTI_Init();      // key on
   \   00000034   0x.... 0x....      BL       BSP_EXTI_Init
    151          
    152          #if WATCHDOG_ENABLE > 0
    153          	BSP_IWDG_Init();      // watchdog
   \   00000038   0x.... 0x....      BL       BSP_IWDG_Init
    154          #endif
    155          
    156          #if SCR_USE_NAND > 0
    157          	FSMC_NAND_Init();     // nand
    158          #endif
    159            
    160          	SD_DeInit();          // sdcard
   \   0000003C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000040   0x.... 0x....      B.W      SD_DeInit
    161          
    162          }
    163          
    164          /*
    165          ********************************************************************************
    166          * Description : BSP_CAN_Init
    167          * Arguments   : none
    168          * Return      : 
    169          * Note        : Initialize the Board Support Package (BSP).
    170          ******************************************************************************** 
    171          */
    172          

   \                                 In section .text, align 2, keep-with-next
    173          void BSP_CAN_Init(void)
    174          {
    175          	BSP_CAN1_Init();      // for car
   \                     BSP_CAN_Init: (+1)
   \   00000000   0x....             B.N      BSP_CAN1_Init
    176          }
    177          
    178          /*
    179          *********************************************************************************************************
    180          *                                            BSP_NVIC_Init()
    181          *
    182          * Description : Initialize the board's nested vectered interrupt controller
    183          *
    184          * Argument(s) : none.
    185          *
    186          * Return(s)   : none.
    187          *
    188          * Caller(s)   : BSP_Lowlevel_Init().
    189          *
    190          * Note(s)     : none.
    191          *********************************************************************************************************
    192          */
    193          

   \                                 In section .text, align 2, keep-with-next
    194          static void BSP_NVIC_Init(void)
    195          {
   \                     BSP_NVIC_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196          	NVIC_InitTypeDef NVIC_InitStructure;
    197          
    198          	/* Set the Vector Table base location at 0x10000 */
    199          	NVIC_SetVectorTable(NVIC_VectTab_FLASH, FLASH_START_BASE);					// 내부 Flash 시작 번지 
   \   00000002   0xF44F 0x3180      MOV      R1,#+65536
   \   00000006   0xF04F 0x6000      MOV      R0,#+134217728
   \   0000000A   0x.... 0x....      BL       NVIC_SetVectorTable
    200          
    201          	/* Configure the NVIC Preemption Priority Bits */  
    202          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   \   0000000E   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000012   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    203          
    204          	/* Enable the USART1 Interrupt */
    205          	NVIC_InitStructure.NVIC_IRQChannel                   = USART1_IRQn;
   \   00000016   0x2025             MOVS     R0,#+37
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    206          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    207          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 3;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xF88D 0x0002      STRB     R0,[SP, #+2]
    208          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    209          	NVIC_Init(&NVIC_InitStructure);
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x.... 0x....      BL       NVIC_Init
    210          
    211          	/* Enable the USART2 Interrupt */
    212          	NVIC_InitStructure.NVIC_IRQChannel                   = USART2_IRQn;
   \   00000034   0x2026             MOVS     R0,#+38
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
    213          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    214          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 4;
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0xF88D 0x0002      STRB     R0,[SP, #+2]
    215          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF88D 0x0003      STRB     R0,[SP, #+3]
    216          	NVIC_Init(&NVIC_InitStructure);  
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x.... 0x....      BL       NVIC_Init
    217            
    218          	/* Enable the CAN1 Interrupt */  
    219          	NVIC_InitStructure.NVIC_IRQChannel					         = CAN1_RX0_IRQn;
   \   00000052   0x2014             MOVS     R0,#+20
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    220            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    221            NVIC_InitStructure.NVIC_IRQChannelSubPriority		     = 6;
   \   0000005E   0x2006             MOVS     R0,#+6
   \   00000060   0xF88D 0x0002      STRB     R0,[SP, #+2]
    222            NVIC_InitStructure.NVIC_IRQChannelCmd				         = ENABLE;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF88D 0x0003      STRB     R0,[SP, #+3]
    223            NVIC_Init(&NVIC_InitStructure);
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x.... 0x....      BL       NVIC_Init
    224          
    225          	/* Enable the PVD event interrupt */
    226          #if PDV_ENABLE > 0
    227          	NVIC_InitStructure.NVIC_IRQChannel                   = PVD_IRQn;
    228          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    229          	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 2;
    230          	NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    231          	NVIC_Init(&NVIC_InitStructure); 
    232          #endif
    233          
    234          	NVIC_InitStructure.NVIC_IRQChannel					         = I2C1_EV_IRQn;
   \   00000070   0x201F             MOVS     R0,#+31
   \   00000072   0xF88D 0x0000      STRB     R0,[SP, #+0]
    235            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF88D 0x0001      STRB     R0,[SP, #+1]
    236            NVIC_InitStructure.NVIC_IRQChannelSubPriority		     = 1;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    237            NVIC_InitStructure.NVIC_IRQChannelCmd				         = ENABLE;
   \   00000082   0xF88D 0x0003      STRB     R0,[SP, #+3]
    238            NVIC_Init(&NVIC_InitStructure);
   \   00000086   0x4668             MOV      R0,SP
   \   00000088   0x.... 0x....      BL       NVIC_Init
    239          
    240          	NVIC_InitStructure.NVIC_IRQChannel					         = I2C1_ER_IRQn;
   \   0000008C   0x2020             MOVS     R0,#+32
   \   0000008E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    241            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF88D 0x0001      STRB     R0,[SP, #+1]
    242            NVIC_InitStructure.NVIC_IRQChannelSubPriority		     = 2;
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    243            NVIC_InitStructure.NVIC_IRQChannelCmd				         = ENABLE;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF88D 0x0003      STRB     R0,[SP, #+3]
    244            NVIC_Init(&NVIC_InitStructure);
   \   000000A4   0x4668             MOV      R0,SP
   \   000000A6   0x.... 0x....      BL       NVIC_Init
    245          
    246          	NVIC_InitStructure.NVIC_IRQChannel					         = EXTI9_5_IRQn;
   \   000000AA   0x2017             MOVS     R0,#+23
   \   000000AC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    247          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF88D 0x0001      STRB     R0,[SP, #+1]
    248            NVIC_InitStructure.NVIC_IRQChannelSubPriority		     = 7;
   \   000000B6   0x2007             MOVS     R0,#+7
   \   000000B8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    249            NVIC_InitStructure.NVIC_IRQChannelCmd				         = ENABLE;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xF88D 0x0003      STRB     R0,[SP, #+3]
    250            
    251            NVIC_Init(&NVIC_InitStructure);
   \   000000C2   0x4668             MOV      R0,SP
   \   000000C4   0x.... 0x....      BL       NVIC_Init
    252          }
   \   000000C8   0xBD01             POP      {R0,PC}          ;; return
    253          
    254          
    255          /*
    256          ********************************************************************************
    257          * Description : BSP_IWDG_Init
    258          * Arguments   : none
    259          * Return      : 
    260          * Note        : Initialize the board's Independent watch-dog 
    261          ******************************************************************************** 
    262          */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          static void BSP_IWDG_Init(void)
    265          {
   \                     BSP_IWDG_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    266          	/* Select HCLK/8 as SysTick clock source */
    267          	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);
   \   00000002   0xF06F 0x0004      MVN      R0,#+4
   \   00000006   0x.... 0x....      BL       SysTick_CLKSourceConfig
    268          	
    269          	/* Check if the system has resumed from IWDG reset */
    270          	if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
   \   0000000A   0x207D             MOVS     R0,#+125
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??BSP_IWDG_Init_0
    271          	{
    272          		/* IWDGRST flag set */
    273          		/* Clear reset flags */
    274          		RCC_ClearFlag();
   \   00000014   0x.... 0x....      BL       RCC_ClearFlag
    275          	}
    276          
    277          
    278          	/* IWDG timeout equal to 1 s (the timeout may varies due to LSI frequency dispersion) */
    279          	/* Enable write access to IWDG_PR and IWDG_RLR registers */
    280          	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
   \                     ??BSP_IWDG_Init_0: (+1)
   \   00000018   0xF245 0x5055      MOVW     R0,#+21845
   \   0000001C   0x.... 0x....      BL       IWDG_WriteAccessCmd
    281          
    282          	/* IWDG counter clock: 40KHz(LSI) / 32 = 1.25 KHz(0.8ms) */
    283          	IWDG_SetPrescaler(IWDG_Prescaler_32);
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       IWDG_SetPrescaler
    284          
    285          	/* Set counter reload value to 2500(*0.8ms) */
    286          //	IWDG_SetReload(2500);	// 2초 셋팅
    287          	IWDG_SetReload(3750);	// 3초 셋팅
   \   00000026   0xF640 0x60A6      MOVW     R0,#+3750
   \   0000002A   0x.... 0x....      BL       IWDG_SetReload
    288          
    289          	/* Reload IWDG counter */
    290          	IWDG_ReloadCounter();
   \   0000002E   0x.... 0x....      BL       IWDG_ReloadCounter
    291          
    292          	/* Enable IWDG (the LSI oscillator will be enabled by hardware) */
    293          	IWDG_Enable();
   \   00000032   0xE8BD 0x4001      POP      {R0,LR}
   \   00000036   0x.... 0x....      B.W      IWDG_Enable
    294          }
    295          
    296          
    297          /*
    298          ********************************************************************************
    299          * Description : BSP_RTC_Init
    300          * Arguments   : none
    301          * Return      : 
    302          * Note        : Initialize the board's RTC (32.768KHz)
    303          ******************************************************************************** 
    304          */
    305          
    306          #define RTC_CLOCK_SOURCE_LSE

   \                                 In section .text, align 2, keep-with-next
    307          static void BSP_RTC_Init(void)
    308          {
   \                     BSP_RTC_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    309          	RTC_InitTypeDef RTC_InitStructure;
    310            NVIC_InitTypeDef NVIC_InitStructure; 
    311            EXTI_InitTypeDef EXTI_InitStructure; 
    312          
    313          	/* Enable the PWR clock */
    314          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,     ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF04F 0x5080      MOV      R0,#+268435456
   \   0000000A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    315          
    316          	/* Allow access to RTC */
    317          	PWR_BackupAccessCmd(ENABLE);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       PWR_BackupAccessCmd
    318          
    319          	#if defined (RTC_CLOCK_SOURCE_LSI)  /* LSI used as RTC source clock*/
    320          	/* LSI used as RTC source clock */
    321          	/* The RTC Clock may varies due to LSI frequency dispersion. */   
    322          	/* Enable the LSI OSC */ 
    323          	RCC_LSICmd(ENABLE);
    324          	/* Wait till LSI is ready */  
    325          	while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
    326          	{
    327          	}
    328          	/* Select the RTC Clock Source */
    329          	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
    330          	#elif defined (RTC_CLOCK_SOURCE_LSE) /* LSE used as RTC source clock */
    331          	/* Enable the LSE OSC */
    332          	RCC_LSEConfig(RCC_LSE_ON);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       RCC_LSEConfig
    333          
    334          	/* Wait till LSE is ready */  
    335          	while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
   \                     ??BSP_RTC_Init_0: (+1)
   \   0000001A   0x2041             MOVS     R0,#+65
   \   0000001C   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0FA             BEQ.N    ??BSP_RTC_Init_0
    336          	{
    337          		
    338          	}
    339          	/* Select the RTC Clock Source */
    340          	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
   \   00000024   0xF44F 0x7080      MOV      R0,#+256
   \   00000028   0x.... 0x....      BL       RCC_RTCCLKConfig
    341          	#endif
    342          
    343            /* Enable the RTC Clock */
    344            RCC_RTCCLKCmd(ENABLE);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       RCC_RTCCLKCmd
    345            
    346            /* Wait for RTC APB registers synchronisation */
    347            RTC_WaitForSynchro();
   \   00000032   0x.... 0x....      BL       RTC_WaitForSynchro
    348          
    349            if((RTC->ISR & RTC_ISR_INITS) == RESET) {
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x4000280c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x06C0             LSLS     R0,R0,#+27
   \   0000003E   0xD408             BMI.N    ??BSP_RTC_Init_1
    350              /* Calendar Configuration with LSI supposed at 32KHz */
    351          	RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
   \   00000040   0x207F             MOVS     R0,#+127
   \   00000042   0x9004             STR      R0,[SP, #+16]
    352          	RTC_InitStructure.RTC_SynchPrediv	=  0xFF; /* (32KHz / 128) - 1 = 0xFF*/
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0x9005             STR      R0,[SP, #+20]
    353          	RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x9003             STR      R0,[SP, #+12]
    354          	RTC_Init(&RTC_InitStructure);  
   \   0000004C   0xA803             ADD      R0,SP,#+12
   \   0000004E   0x.... 0x....      BL       RTC_Init
    355            } 
    356            
    357            /* EXTI configuration *******************************************************/
    358            EXTI_ClearITPendingBit(EXTI_Line22);
   \                     ??BSP_RTC_Init_1: (+1)
   \   00000052   0xF44F 0x0080      MOV      R0,#+4194304
   \   00000056   0x.... 0x....      BL       EXTI_ClearITPendingBit
    359            EXTI_InitStructure.EXTI_Line = EXTI_Line22;
   \   0000005A   0xF44F 0x0080      MOV      R0,#+4194304
   \   0000005E   0x9001             STR      R0,[SP, #+4]
    360            EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF88D 0x0008      STRB     R0,[SP, #+8]
    361            EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   00000066   0x2008             MOVS     R0,#+8
   \   00000068   0xF88D 0x0009      STRB     R0,[SP, #+9]
    362            EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF88D 0x000A      STRB     R0,[SP, #+10]
    363            EXTI_Init(&EXTI_InitStructure);
   \   00000072   0xA801             ADD      R0,SP,#+4
   \   00000074   0x.... 0x....      BL       EXTI_Init
    364           
    365            /* Enable the RTC Wakeup Interrupt */
    366            NVIC_InitStructure.NVIC_IRQChannel = RTC_WKUP_IRQn;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    367            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF88D 0x0001      STRB     R0,[SP, #+1]
    368            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000084   0xF88D 0x0002      STRB     R0,[SP, #+2]
    369            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    370            NVIC_Init(&NVIC_InitStructure);  
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x.... 0x....      BL       NVIC_Init
    371           
    372            /* Configure the RTC WakeUp Clock source: CK_SPRE (1Hz) */
    373            RTC_WakeUpClockConfig(RTC_WakeUpClock_CK_SPRE_16bits);
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x.... 0x....      BL       RTC_WakeUpClockConfig
    374            RTC_SetWakeUpCounter(0x0);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       RTC_SetWakeUpCounter
    375           
    376            RTC_ClearITPendingBit(RTC_IT_WUT); 
   \   000000A0   0xF44F 0x4080      MOV      R0,#+16384
   \   000000A4   0x.... 0x....      BL       RTC_ClearITPendingBit
    377            EXTI_ClearITPendingBit(EXTI_Line22); 
   \   000000A8   0xF44F 0x0080      MOV      R0,#+4194304
   \   000000AC   0x.... 0x....      BL       EXTI_ClearITPendingBit
    378            
    379            /* Enable the RTC Wakeup Interrupt */
    380            RTC_ITConfig(RTC_IT_WUT, ENABLE);
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xF44F 0x4080      MOV      R0,#+16384
   \   000000B6   0x.... 0x....      BL       RTC_ITConfig
    381          
    382            /* Enable Wakeup Counter */
    383            RTC_WakeUpCmd(ENABLE); 
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x.... 0x....      BL       RTC_WakeUpCmd
    384          }
   \   000000C0   0xB007             ADD      SP,SP,#+28
   \   000000C2   0xBD00             POP      {PC}             ;; return
    385          
    386          
    387          /*
    388          ********************************************************************************
    389          * Description : BSP_PVD_Init
    390          * Arguments   : none
    391          * Return      : 
    392          * Note        : Initialize the board's Power voltage detect
    393          ******************************************************************************** 
    394          */
    395          
    396          #if PDV_ENABLE > 0
    397          static void BSP_PVD_Init(void)
    398          {
    399          
    400          	EXTI_InitTypeDef EXTI_InitStructure;
    401          
    402            /* Enable PWR clock */
    403            RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
    404                
    405            /* Configure EXTI Line16(PVD Output) to generate an interrupt on rising and
    406               falling edges */
    407            EXTI_ClearITPendingBit(EXTI_Line16);
    408            EXTI_InitStructure.EXTI_Line = EXTI_Line16;
    409            EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    410            EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
    411            EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    412            EXTI_Init(&EXTI_InitStructure);
    413          
    414            /* Configure the PVD Level to 3 (PVD detection level set to 2.5V, refer to the
    415                electrical characteristics of you device datasheet for more details) */
    416            PWR_PVDLevelConfig(PWR_PVDLevel_3);
    417          
    418            /* Enable the PVD Output */
    419            PWR_PVDCmd(ENABLE);
    420          }
    421          #endif
    422          
    423          
    424          /*
    425          ********************************************************************************
    426          * Description : BSP_GPIO_Init
    427          * Arguments   : none
    428          * Return      : 
    429          * Note        : General Purpose I/O Initalize
    430          ******************************************************************************** 
    431          */
    432          

   \                                 In section .text, align 2, keep-with-next
    433          static void BSP_GPIO_Init(void)
    434          {
   \                     BSP_GPIO_Init: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    435            GPIO_InitTypeDef GPIO_InitStructure;
    436          
    437          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA , ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    438          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    439          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD , ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    440          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC , ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    441          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE , ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2010             MOVS     R0,#+16
   \   00000026   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    442          
    443          // PORTA Configure
    444          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_1;    //Charge
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    445          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000002E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    446            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF88D 0x0004      STRB     R0,[SP, #+4]
    447          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    448          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF88D 0x0007      STRB     R0,[SP, #+7]
    449          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000044   0x.... 0x....      LDR.W    R4,??DataTable36_1  ;; 0x40020000
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       GPIO_Init
    450            //Default Value Set
    451          	GPIO_WriteBit(GPIOA, GPIO_Pin_1, Bit_RESET);		//Charge On
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x2102             MOVS     R1,#+2
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       GPIO_WriteBit
    452            
    453          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_8;      //Power Check
   \   0000005A   0xF44F 0x7080      MOV      R0,#+256
   \   0000005E   0x9000             STR      R0,[SP, #+0]
    454          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xF88D 0x0005      STRB     R0,[SP, #+5]
    455            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF88D 0x0004      STRB     R0,[SP, #+4]
    456          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000006C   0xF88D 0x0007      STRB     R0,[SP, #+7]
    457          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       GPIO_Init
    458          
    459          // PORTB Configure
    460          	GPIO_InitStructure.GPIO_Pin   =   GPIO_Pin_0    //buzzer
    461          									| GPIO_Pin_1;	                  //I/O Out : DO
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0x9000             STR      R0,[SP, #+0]
    462          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    463            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF88D 0x0004      STRB     R0,[SP, #+4]
    464          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    465          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF88D 0x0007      STRB     R0,[SP, #+7]
    466          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000094   0x.... 0x....      LDR.W    R4,??DataTable36_2  ;; 0x40020400
   \   00000098   0x4669             MOV      R1,SP
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       GPIO_Init
    467            //Default Value Set
    468          	GPIO_WriteBit(GPIOB, GPIO_Pin_0, Bit_RESET);		//BUZZER Off
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       GPIO_WriteBit
    469            
    470          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;     //Button Up
   \   000000AA   0x2020             MOVS     R0,#+32
   \   000000AC   0x9000             STR      R0,[SP, #+0]
    471          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0xF88D 0x0005      STRB     R0,[SP, #+5]
    472            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF88D 0x0004      STRB     R0,[SP, #+4]
    473          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   000000BA   0xF88D 0x0007      STRB     R0,[SP, #+7]
    474          	GPIO_Init(GPIOB, &GPIO_InitStructure);  
   \   000000BE   0x4669             MOV      R1,SP
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       GPIO_Init
    475          
    476          // PORTC Configure    
    477          	GPIO_InitStructure.GPIO_Pin   =   GPIO_Pin_1    //FND A
    478          									| GPIO_Pin_2                    //FND B
    479          									| GPIO_Pin_3                    //FND C
    480          									| GPIO_Pin_4                    //FND D
    481          									| GPIO_Pin_5                    //FND E
    482          									| GPIO_Pin_6                    //FND F
    483          									| GPIO_Pin_7                    //FND G
    484          									| GPIO_Pin_13;                  //FND DP
   \   000000C6   0xF242 0x00FE      MOVW     R0,#+8446
   \   000000CA   0x9000             STR      R0,[SP, #+0]
    485            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0xF88D 0x0005      STRB     R0,[SP, #+5]
    486            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    487          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF88D 0x0006      STRB     R0,[SP, #+6]
    488          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0xF88D 0x0007      STRB     R0,[SP, #+7]
    489          	GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   000000E4   0x.... 0x....      LDR.W    R4,??DataTable38  ;; 0x40020800
   \   000000E8   0x4669             MOV      R1,SP
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       GPIO_Init
    490            //Default Value Set 
    491          	GPIO_WriteBit(GPIOC, GPIO_Pin_1, Bit_RESET);
   \   000000F0   0x2200             MOVS     R2,#+0
   \   000000F2   0x2102             MOVS     R1,#+2
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0x.... 0x....      BL       GPIO_WriteBit
    492          	GPIO_WriteBit(GPIOC, GPIO_Pin_2, Bit_RESET);
   \   000000FA   0x2200             MOVS     R2,#+0
   \   000000FC   0x2104             MOVS     R1,#+4
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       GPIO_WriteBit
    493          	GPIO_WriteBit(GPIOC, GPIO_Pin_3, Bit_RESET);
   \   00000104   0x2200             MOVS     R2,#+0
   \   00000106   0x2108             MOVS     R1,#+8
   \   00000108   0x4620             MOV      R0,R4
   \   0000010A   0x.... 0x....      BL       GPIO_WriteBit
    494          	GPIO_WriteBit(GPIOC, GPIO_Pin_4, Bit_RESET);
   \   0000010E   0x2200             MOVS     R2,#+0
   \   00000110   0x2110             MOVS     R1,#+16
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       GPIO_WriteBit
    495          	GPIO_WriteBit(GPIOC, GPIO_Pin_5, Bit_RESET);
   \   00000118   0x2200             MOVS     R2,#+0
   \   0000011A   0x2120             MOVS     R1,#+32
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       GPIO_WriteBit
    496          	GPIO_WriteBit(GPIOC, GPIO_Pin_6, Bit_RESET);
   \   00000122   0x2200             MOVS     R2,#+0
   \   00000124   0x2140             MOVS     R1,#+64
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0x.... 0x....      BL       GPIO_WriteBit
    497          	GPIO_WriteBit(GPIOC, GPIO_Pin_7, Bit_RESET);
   \   0000012C   0x2200             MOVS     R2,#+0
   \   0000012E   0x2180             MOVS     R1,#+128
   \   00000130   0x4620             MOV      R0,R4
   \   00000132   0x.... 0x....      BL       GPIO_WriteBit
    498          	GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_RESET);
   \   00000136   0x2200             MOVS     R2,#+0
   \   00000138   0xF44F 0x5100      MOV      R1,#+8192
   \   0000013C   0x4620             MOV      R0,R4
   \   0000013E   0x.... 0x....      BL       GPIO_WriteBit
    499          
    500          // PORTD Configure 
    501          	GPIO_InitStructure.GPIO_Pin   =	  GPIO_Pin_13   //FND 1
    502          		              | GPIO_Pin_3                    //FND 2
    503          									| GPIO_Pin_8                    //FND 3
    504          									| GPIO_Pin_9                    //FND 4
    505          									| GPIO_Pin_10;                  //FND 5
   \   00000142   0xF242 0x7008      MOVW     R0,#+9992
   \   00000146   0x9000             STR      R0,[SP, #+0]
    506            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000148   0x2002             MOVS     R0,#+2
   \   0000014A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    507            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0xF88D 0x0004      STRB     R0,[SP, #+4]
    508          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0xF88D 0x0006      STRB     R0,[SP, #+6]
    509          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0xF88D 0x0007      STRB     R0,[SP, #+7]
    510          	GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000160   0x4669             MOV      R1,SP
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable38_1  ;; 0x40020c00
   \   00000166   0x.... 0x....      BL       GPIO_Init
    511          
    512          // PORTE Configure  
    513          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_1      //Power LED  
    514                            | GPIO_Pin_4		                //Main Power Enable pin
    515          									| GPIO_Pin_11		                //LED SD Card status
    516                            | GPIO_Pin_12		                //LED Normal  
    517          									| GPIO_Pin_13		                //LED Temperature
    518          									| GPIO_Pin_14		                //LED Press Low
    519                            | GPIO_Pin_15;                  //LED Press High
   \   0000016A   0xF64F 0x0012      MOVW     R0,#+63506
   \   0000016E   0x9000             STR      R0,[SP, #+0]
    520            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000170   0x2002             MOVS     R0,#+2
   \   00000172   0xF88D 0x0005      STRB     R0,[SP, #+5]
    521            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   00000176   0x2001             MOVS     R0,#+1
   \   00000178   0xF88D 0x0004      STRB     R0,[SP, #+4]
    522          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    523          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0xF88D 0x0007      STRB     R0,[SP, #+7]
    524          	GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   00000188   0x.... 0x....      LDR.W    R4,??DataTable38_2  ;; 0x40021000
   \   0000018C   0x4669             MOV      R1,SP
   \   0000018E   0x4620             MOV      R0,R4
   \   00000190   0x.... 0x....      BL       GPIO_Init
    525            //Default Value Set
    526            GPIO_WriteBit(GPIOE, GPIO_Pin_1, Bit_SET);		  //Power LED
   \   00000194   0x2201             MOVS     R2,#+1
   \   00000196   0x2102             MOVS     R1,#+2
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       GPIO_WriteBit
    527          	GPIO_WriteBit(GPIOE, GPIO_Pin_4, Bit_SET);			//Power on Enable
   \   0000019E   0x2201             MOVS     R2,#+1
   \   000001A0   0x2110             MOVS     R1,#+16
   \   000001A2   0x4620             MOV      R0,R4
   \   000001A4   0x.... 0x....      BL       GPIO_WriteBit
    528          	GPIO_WriteBit(GPIOE, GPIO_Pin_11, Bit_SET);			//LED SD Card status
   \   000001A8   0x2201             MOVS     R2,#+1
   \   000001AA   0xF44F 0x6100      MOV      R1,#+2048
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0x.... 0x....      BL       GPIO_WriteBit
    529          	GPIO_WriteBit(GPIOE, GPIO_Pin_13, Bit_SET);			//LED Temp
   \   000001B4   0x2201             MOVS     R2,#+1
   \   000001B6   0xF44F 0x5100      MOV      R1,#+8192
   \   000001BA   0x4620             MOV      R0,R4
   \   000001BC   0x.... 0x....      BL       GPIO_WriteBit
    530          	GPIO_WriteBit(GPIOE, GPIO_Pin_14, Bit_SET);			//LED Press Low
   \   000001C0   0x2201             MOVS     R2,#+1
   \   000001C2   0xF44F 0x4180      MOV      R1,#+16384
   \   000001C6   0x4620             MOV      R0,R4
   \   000001C8   0x.... 0x....      BL       GPIO_WriteBit
    531          	GPIO_WriteBit(GPIOE, GPIO_Pin_15, Bit_SET);			//LED Press High
   \   000001CC   0x2201             MOVS     R2,#+1
   \   000001CE   0xF44F 0x4100      MOV      R1,#+32768
   \   000001D2   0x4620             MOV      R0,R4
   \   000001D4   0x.... 0x....      BL       GPIO_WriteBit
    532            
    533          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0      //Button mode
    534                            | GPIO_Pin_2                    //Push Key
    535                            | GPIO_Pin_3                    //SD Card Detection
    536                            | GPIO_Pin_5                    //Button set
    537                            | GPIO_Pin_6;			              //Key On Detection
   \   000001D8   0x206D             MOVS     R0,#+109
   \   000001DA   0x9000             STR      R0,[SP, #+0]
    538          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000001DC   0x2002             MOVS     R0,#+2
   \   000001DE   0xF88D 0x0005      STRB     R0,[SP, #+5]
    539            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    540          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   000001E8   0xF88D 0x0007      STRB     R0,[SP, #+7]
    541          	GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   000001EC   0x4669             MOV      R1,SP
   \   000001EE   0x4620             MOV      R0,R4
   \   000001F0   0x.... 0x....      BL       GPIO_Init
    542          
    543          }
   \   000001F4   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    544          
    545          
    546          /*
    547          ********************************************************************************
    548          * Description : BSP_EXTI_Init
    549          * Arguments   : none
    550          * Return      : 
    551          * Note        : External Int (for keyon)
    552          ******************************************************************************** 
    553          */

   \                                 In section .text, align 2, keep-with-next
    554          static void BSP_EXTI_Init(void)
    555          {
   \                     BSP_EXTI_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    556          
    557            GPIO_InitTypeDef   GPIO_InitStructure;
    558          	EXTI_InitTypeDef   EXTI_InitStructure;
    559            
    560          	/* Enable SYSCFG clock */
    561          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE , ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    562          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    563            
    564          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_6;
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x9002             STR      R0,[SP, #+8]
    565            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF88D 0x000D      STRB     R0,[SP, #+13]
    566            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x000C      STRB     R0,[SP, #+12]
    567          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   00000026   0xF88D 0x000F      STRB     R0,[SP, #+15]
    568          	GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   0000002A   0xA902             ADD      R1,SP,#+8
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable38_2  ;; 0x40021000
   \   00000030   0x.... 0x....      BL       GPIO_Init
    569             
    570          	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource6);
   \   00000034   0x2106             MOVS     R1,#+6
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x.... 0x....      BL       SYSCFG_EXTILineConfig
    571          
    572          	EXTI_InitStructure.EXTI_Mode	= EXTI_Mode_Interrupt;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    573          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF88D 0x0006      STRB     R0,[SP, #+6]
    574          	EXTI_InitStructure.EXTI_Line	= EXTI_Line6;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    575          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
   \   0000004C   0x200C             MOVS     R0,#+12
   \   0000004E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    576          	EXTI_Init(&EXTI_InitStructure);
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       EXTI_Init
    577          }
   \   00000058   0xB005             ADD      SP,SP,#+20
   \   0000005A   0xBD00             POP      {PC}             ;; return
    578          
    579          
    580          /*
    581          ********************************************************************************
    582          * Description : BSP_I2C1_Init
    583          * Arguments   : none
    584          * Return      : 
    585          * Note        : I2C1 for Fram
    586          ******************************************************************************** 
    587          */

   \                                 In section .text, align 2, keep-with-next
    588          static void BSP_I2C1_Init(void)
    589          {
   \                     BSP_I2C1_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    590            GPIO_InitTypeDef GPIO_InitStruct;
    591            I2C_InitTypeDef I2C_InitStruct;
    592          
    593            I2C_DeInit(I2C1);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable38_4  ;; 0x40005400
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_DeInit
    594          
    595            RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);		    //Enable APB1 peripheral clock for I2C1
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000014   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    596            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);		    //Enable clock for SCL and SDA pins
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    597          
    598            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;			    //Use PB6 for SCL and PB7 for SDA
   \   00000020   0x20C0             MOVS     R0,#+192
   \   00000022   0x9000             STR      R0,[SP, #+0]
    599            GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;                   //Set pins to alternate function
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF88D 0x0004      STRB     R0,[SP, #+4]
    600            GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;				      //Set GPIO speed
   \   0000002A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    601            GPIO_InitStruct.GPIO_OType = GPIO_OType_OD;                 //Set output to open drain --> the line has to be only pulled low, not driven high
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0006      STRB     R0,[SP, #+6]
    602            GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;                   //Enable pull up resistors
   \   00000034   0xF88D 0x0007      STRB     R0,[SP, #+7]
    603            GPIO_Init(GPIOB, &GPIO_InitStruct);                         //Initialise GPIOB
   \   00000038   0x.... 0x....      LDR.W    R5,??DataTable36_2  ;; 0x40020400
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       GPIO_Init
    604          
    605            GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);     //Connect I2C1 SCL pin to alternate function
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0x2106             MOVS     R1,#+6
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       GPIO_PinAFConfig
    606            GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_I2C1);     //Connect I2C1 SDA pin to alternate function
   \   0000004E   0x2204             MOVS     R2,#+4
   \   00000050   0x2107             MOVS     R1,#+7
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       GPIO_PinAFConfig
    607            
    608            I2C_StructInit(&I2C_InitStruct);
   \   00000058   0xA802             ADD      R0,SP,#+8
   \   0000005A   0x.... 0x....      BL       I2C_StructInit
    609                                                                             
    610            I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;                     //I2C mode
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    611            I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;             //50% duty cycle --> standard
   \   00000064   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000068   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    612            I2C_InitStruct.I2C_OwnAddress1 = 0x2A;                      //Own address, not relevant in master mode
   \   0000006C   0x202A             MOVS     R0,#+42
   \   0000006E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    613            I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;                    //Enable acknowledge when reading (can be changed later on)
   \   00000072   0xF44F 0x6080      MOV      R0,#+1024
   \   00000076   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    614            I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;  //Set address length to 7 bit addresses
   \   0000007A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000007E   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    615            I2C_InitStruct.I2C_ClockSpeed = 100000;									    //100kHz
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable38_5  ;; 0x186a0
   \   00000086   0x9002             STR      R0,[SP, #+8]
    616            I2C_Init(I2C1, &I2C_InitStruct);                            //Initialise I2C1
   \   00000088   0xA902             ADD      R1,SP,#+8
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       I2C_Init
    617          
    618            I2C_Cmd(I2C1, ENABLE);                                      //Enable I2C1
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       I2C_Cmd
    619            I2C_ITConfig(I2C1, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, ENABLE);
   \   00000098   0x2201             MOVS     R2,#+1
   \   0000009A   0xF44F 0x61E0      MOV      R1,#+1792
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       I2C_ITConfig
    620          }
   \   000000A4   0xB007             ADD      SP,SP,#+28
   \   000000A6   0xBD30             POP      {R4,R5,PC}       ;; return
    621          
    622          
    623          /*
    624          ********************************************************************************
    625          * Description : BSP_CAN1_Init
    626          * Arguments   : none
    627          * Return      : 
    628          * Note        : CAN for Automotive
    629          ******************************************************************************** 
    630          */
    631          

   \                                 In section .text, align 2, keep-with-next
    632          static void BSP_CAN1_Init(void)
    633          {
   \                     BSP_CAN1_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
    634          	GPIO_InitTypeDef		GPIO_InitStructure;
    635          	CAN_InitTypeDef			CAN_InitStructure;
    636          	CAN_FilterInitTypeDef	CAN_FilterInitStructure;
    637          
    638          	/* CAN GPIOs configuration **************************************************/
    639          
    640          	/* Enable GPIO clock */
    641          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    642          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    643          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF04F 0x7000      MOV      R0,#+33554432
   \   0000001A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    644          
    645          
    646          	/* Connect CAN pins to AF9 */
    647          	GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_CAN1); //Connect CAN1 RX pin to alternate function
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable36_2  ;; 0x40020400
   \   00000022   0x2209             MOVS     R2,#+9
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       GPIO_PinAFConfig
    648            GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_CAN1); //Connect CAN1 TX pin to alternate function
   \   0000002C   0x2209             MOVS     R2,#+9
   \   0000002E   0x4611             MOV      R1,R2
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       GPIO_PinAFConfig
    649          
    650          	/* Configure CAN RX and TX pins */
    651          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
   \   00000036   0xF44F 0x7040      MOV      R0,#+768
   \   0000003A   0x9007             STR      R0,[SP, #+28]
    652          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xF88D 0x0020      STRB     R0,[SP, #+32]
    653          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000042   0xF88D 0x0021      STRB     R0,[SP, #+33]
    654          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0022      STRB     R0,[SP, #+34]
    655          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF88D 0x0023      STRB     R0,[SP, #+35]
    656          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000052   0xA907             ADD      R1,SP,#+28
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       GPIO_Init
    657          
    658          	/* CAN configuration ********************************************************/
    659          	/* CAN register init */
    660          	CAN_DeInit(CAN1);
   \   0000005A   0x.... 0x....      LDR.W    R4,??DataTable38_6  ;; 0x40006400
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       CAN_DeInit
    661          
    662          	CAN_ITConfig(CAN1, CAN_IT_FMP0, DISABLE);
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x2102             MOVS     R1,#+2
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       CAN_ITConfig
    663          
    664          	/* CAN cell init */
    665          	CAN_InitStructure.CAN_TTCM = DISABLE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    666          	CAN_InitStructure.CAN_ABOM = DISABLE;
    667          	CAN_InitStructure.CAN_AWUM = DISABLE;
   \   00000074   0xF88D 0x0018      STRB     R0,[SP, #+24]
    668          	CAN_InitStructure.CAN_NART = ENABLE;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xF88D 0x0019      STRB     R0,[SP, #+25]
    669          	CAN_InitStructure.CAN_RFLM = DISABLE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    670          	CAN_InitStructure.CAN_TXFP = DISABLE;
    671          	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;//CAN_Mode_Silent;//CAN_Mode_Normal;
   \   00000084   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    672          
    673          	// CAN Bitrate
    674          	CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;      // SJW (1 bis 4 moglich)
    675          	CAN_InitStructure.CAN_BS1=CAN_BS1_6tq;      // Samplepoint 72%
   \   00000088   0x2005             MOVS     R0,#+5
   \   0000008A   0xF88D 0x0014      STRB     R0,[SP, #+20]
    676          	CAN_InitStructure.CAN_BS2=CAN_BS2_8tq;      // Samplepoint 72%
   \   0000008E   0x2007             MOVS     R0,#+7
   \   00000090   0xF88D 0x0015      STRB     R0,[SP, #+21]
    677          
    678            //if(Setting.CanBPS)
    679              CAN_InitStructure.CAN_Prescaler=4;        //  500 kbit/s
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    680            //else
    681            //  CAN_InitStructure.CAN_Prescaler=8;        //  250 kbit/s
    682              
    683          #if 0  
    684          	CAN_InitStructure.CAN_Prescaler=1;        // 2000 kbit/s
    685          	CAN_InitStructure.CAN_Prescaler=2;        // 1000 kbit/s
    686          	CAN_InitStructure.CAN_Prescaler=4;        //  500 kbit/s
    687          	CAN_InitStructure.CAN_Prescaler=5;        //  400 kbit/s
    688          	CAN_InitStructure.CAN_Prescaler=8;        //  250 kbit/s
    689          	CAN_InitStructure.CAN_Prescaler=10;       //  200 kbit/s
    690          	CAN_InitStructure.CAN_Prescaler=16;       //  125 kbit/s
    691          	CAN_InitStructure.CAN_Prescaler=20;       //  100 kbit/s
    692          	CAN_InitStructure.CAN_Prescaler=40;       //   50 kbit/s
    693          	CAN_InitStructure.CAN_Prescaler=80;       //   40 kbit/s
    694          	CAN_InitStructure.CAN_Prescaler=200;      //   10 kbit/s
    695          	CAN_InitStructure.CAN_Prescaler=1023;     //    ganz langsam
    696          #endif
    697          
    698          	CAN_Init(CAN1, &CAN_InitStructure);
   \   0000009A   0xA904             ADD      R1,SP,#+16
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       CAN_Init
    699          	/* CAN filter init */
    700          	
    701          	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;//CAN_FilterMode_IdList;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x000B      STRB     R0,[SP, #+11]
    702          	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF88D 0x000C      STRB     R0,[SP, #+12]
    703          	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    704          	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xF88D 0x000D      STRB     R0,[SP, #+13]
    705          #if 0
    706          //	CAN_FilterInitStructure.CAN_FilterNumber      = 1;											
    707          //  CAN_FilterInitStructure.CAN_FilterIdHigh		  = (u16)(0x0000<<5);
    708          //  CAN_FilterInitStructure.CAN_FilterIdLow			  = (u16) 0x0000;
    709          //  CAN_FilterInitStructure.CAN_FilterMaskIdHigh	= (u16)(0x0000<<5);
    710          //  CAN_FilterInitStructure.CAN_FilterMaskIdLow		= (u16) 0x0000;
    711          //	CAN_FilterInit(&CAN_FilterInitStructure);
    712          #else
    713          //  CAN_FilterInitStructure.CAN_FilterNumber        = 0;						
    714          //  CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x0010<<5);  // 0x010 ~ 0x013 수신
    715          //  CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;//(0x0098<<5);  // 0x098 ~ 0x099 수신
    716          //  CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x07FC<<5);
    717          //  CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;//(0x07FE<<5);
    718          //	CAN_FilterInit(&CAN_FilterInitStructure);
    719          //  
    720          //	CAN_FilterInitStructure.CAN_FilterNumber        = 1;						
    721          //  CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x0100<<5);  // x100 ~ 0x1FF 수신
    722          //  CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;//(0x0030<<5);
    723          //  CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x0700<<5);
    724          //  CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;//(0x07C8<<5);
    725          //	CAN_FilterInit(&CAN_FilterInitStructure);
    726            
    727            CAN_FilterInitStructure.CAN_FilterNumber        = 0;						
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF88D 0x000A      STRB     R0,[SP, #+10]
    728            CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x0010<<5);  // 0x010 ~ 0x013 수신
   \   000000C0   0xF44F 0x7000      MOV      R0,#+512
   \   000000C4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    729            CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;  // 0x098 ~ 0x099 수신
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    730            CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x07FC<<5);
   \   000000CE   0xF64F 0x7080      MOVW     R0,#+65408
   \   000000D2   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    731            CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    732          	CAN_FilterInit(&CAN_FilterInitStructure);
   \   000000DC   0x4668             MOV      R0,SP
   \   000000DE   0x.... 0x....      BL       CAN_FilterInit
    733            
    734          	CAN_FilterInitStructure.CAN_FilterNumber        = 1;						
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xF88D 0x000A      STRB     R0,[SP, #+10]
    735            CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x0098<<5);  // x100 ~ 0x1FF 수신
   \   000000E8   0xF44F 0x5098      MOV      R0,#+4864
   \   000000EC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    736            CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    737            CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x007FE<<5);
   \   000000F6   0xF64F 0x70C0      MOVW     R0,#+65472
   \   000000FA   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    738            CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    739            
    740            CAN_FilterInitStructure.CAN_FilterNumber        = 2;						
   \   00000104   0x2002             MOVS     R0,#+2
   \   00000106   0xF88D 0x000A      STRB     R0,[SP, #+10]
    741            CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x0100<<5);  // 0x010 ~ 0x013 수신
   \   0000010A   0xF44F 0x5500      MOV      R5,#+8192
   \   0000010E   0xF8AD 0x5000      STRH     R5,[SP, #+0]
    742            CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;  // 0x098 ~ 0x099 수신
    743            CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x0700<<5);
   \   00000112   0xF44F 0x4660      MOV      R6,#+57344
   \   00000116   0xF8AD 0x6004      STRH     R6,[SP, #+4]
    744            CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;
    745          	CAN_FilterInit(&CAN_FilterInitStructure);
   \   0000011A   0x4668             MOV      R0,SP
   \   0000011C   0x.... 0x....      BL       CAN_FilterInit
    746            
    747          	CAN_FilterInitStructure.CAN_FilterNumber        = 3;						
   \   00000120   0x2003             MOVS     R0,#+3
   \   00000122   0xF88D 0x000A      STRB     R0,[SP, #+10]
    748            CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x0030<<5);  // x100 ~ 0x1FF 수신
   \   00000126   0xF44F 0x60C0      MOV      R0,#+1536
   \   0000012A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    749            CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    750            CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x07C8<<5);
   \   00000134   0xF44F 0x4079      MOV      R0,#+63744
   \   00000138   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    751            CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    752          	CAN_FilterInit(&CAN_FilterInitStructure);
   \   00000142   0x4668             MOV      R0,SP
   \   00000144   0x.... 0x....      BL       CAN_FilterInit
    753            
    754          	CAN_FilterInitStructure.CAN_FilterNumber        = 4;						
   \   00000148   0x2004             MOVS     R0,#+4
   \   0000014A   0xF88D 0x000A      STRB     R0,[SP, #+10]
    755            CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)((0x14FF0055<<3)>>16);
   \   0000014E   0xF24A 0x70F8      MOVW     R0,#+43000
   \   00000152   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    756            CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)((0x14FF0055<<3) | 4);
   \   00000156   0xF44F 0x702B      MOV      R0,#+684
   \   0000015A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    757            CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)((0xFFFFFFFF<<3)>>16);
   \   0000015E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000162   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    758            CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)((0xFFFFFFFF<<3) | 4);
   \   00000166   0xF64F 0x70FC      MOVW     R0,#+65532
   \   0000016A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    759          	CAN_FilterInit(&CAN_FilterInitStructure);
   \   0000016E   0x4668             MOV      R0,SP
   \   00000170   0x.... 0x....      BL       CAN_FilterInit
    760            
    761          	CAN_FilterInitStructure.CAN_FilterNumber        = 5;						
   \   00000174   0x2005             MOVS     R0,#+5
   \   00000176   0xF88D 0x000A      STRB     R0,[SP, #+10]
    762            CAN_FilterInitStructure.CAN_FilterIdHigh		    = (u16)(0x700<<5);     // x100 ~ 0x1FF ????
   \   0000017A   0xF8AD 0x6000      STRH     R6,[SP, #+0]
    763            CAN_FilterInitStructure.CAN_FilterIdLow			    = (u16)0x0000;
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    764            CAN_FilterInitStructure.CAN_FilterMaskIdHigh	  = (u16)(0x900<<5);
   \   00000184   0xF8AD 0x5004      STRH     R5,[SP, #+4]
    765            CAN_FilterInitStructure.CAN_FilterMaskIdLow		  = (u16)0x0000;
   \   00000188   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    766          	CAN_FilterInit(&CAN_FilterInitStructure);    
   \   0000018C   0x4668             MOV      R0,SP
   \   0000018E   0x.... 0x....      BL       CAN_FilterInit
    767          #endif  
    768          	//GPIO_WriteBit(GPIOE, GPIO_Pin_5, Bit_RESET );	// CAN1 OBD STBY HIGH //Bit_RESET
    769          
    770          	/* Enable FIFO 0 message pending Interrupt */
    771          	CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
   \   00000192   0x2201             MOVS     R2,#+1
   \   00000194   0x2102             MOVS     R1,#+2
   \   00000196   0x4620             MOV      R0,R4
   \   00000198   0x.... 0x....      BL       CAN_ITConfig
    772          }
   \   0000019C   0xB00A             ADD      SP,SP,#+40
   \   0000019E   0xBD70             POP      {R4-R6,PC}       ;; return
    773          
    774          
    775          /*
    776          ********************************************************************************
    777          * Description : BSP_SPI1_Init
    778          * Arguments   : none
    779          * Return      : 
    780          * Note        : SPI1 for Serial Flash.
    781          ******************************************************************************** 
    782          */
    783          

   \                                 In section .text, align 2, keep-with-next
    784          static void BSP_SPI1_Init(void)
    785          {
   \                     BSP_SPI1_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    786          
    787          	GPIO_InitTypeDef GPIO_InitStructure;
    788          	SPI_InitTypeDef SPI_InitStructure;
    789          	
    790          	
    791          	/*!< Enable GPIO clocks */
    792          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    793          	/*!< Enable the SPI clock */
    794          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    795          	
    796          	/* Configure SPI pin: SCK*/
    797          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x9000             STR      R0,[SP, #+0]
    798          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    799          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000020   0xF88D 0x0005      STRB     R0,[SP, #+5]
    800          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    801          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    802          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000002A   0x.... 0x....      LDR.W    R4,??DataTable36_1  ;; 0x40020000
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       GPIO_Init
    803          
    804          	/* Configure SPI pin: MOSI */
    805          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
   \   00000036   0x2080             MOVS     R0,#+128
   \   00000038   0x9000             STR      R0,[SP, #+0]
    806          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    807          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0xF88D 0x0005      STRB     R0,[SP, #+5]
    808          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    809          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    810          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       GPIO_Init
    811          
    812          	/* Configure SPI pin: MISO */
    813          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   \   00000052   0x2040             MOVS     R0,#+64
   \   00000054   0x9000             STR      R0,[SP, #+0]
    814          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0xF88D 0x0004      STRB     R0,[SP, #+4]
    815          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000005C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    816          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    817          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    818          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       GPIO_Init
    819          
    820          	/* Enable alternate function for SPI pins */
    821          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_SPI1);
   \   0000006E   0x2205             MOVS     R2,#+5
   \   00000070   0x4611             MOV      R1,R2
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       GPIO_PinAFConfig
    822          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_SPI1);
   \   00000078   0x2205             MOVS     R2,#+5
   \   0000007A   0x2106             MOVS     R1,#+6
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       GPIO_PinAFConfig
    823          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_SPI1);
   \   00000082   0x2205             MOVS     R2,#+5
   \   00000084   0x2107             MOVS     R1,#+7
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       GPIO_PinAFConfig
    824          	
    825          	/* Configure I/O for Flash Chip select */
    826          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_4;
   \   0000008C   0x2010             MOVS     R0,#+16
   \   0000008E   0x9000             STR      R0,[SP, #+0]
    827          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xF88D 0x0004      STRB     R0,[SP, #+4]
    828          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF88D 0x0006      STRB     R0,[SP, #+6]
    829            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000009C   0x2002             MOVS     R0,#+2
   \   0000009E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    830            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x0007      STRB     R0,[SP, #+7]
    831            GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000A8   0x4669             MOV      R1,SP
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       GPIO_Init
    832          
    833          	/* Deselect the FLASH: Chip Select high */
    834          	GPIO_SetBits(GPIOA, GPIO_Pin_4);
   \   000000B0   0x2110             MOVS     R1,#+16
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       GPIO_SetBits
    835           
    836          	/* SPI1 configuration */
    837          	SPI_InitStructure.SPI_Direction         = SPI_Direction_2Lines_FullDuplex;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    838          	SPI_InitStructure.SPI_Mode              = SPI_Mode_Master;
   \   000000BE   0xF44F 0x7082      MOV      R0,#+260
   \   000000C2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    839          	SPI_InitStructure.SPI_DataSize          = SPI_DataSize_8b;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x9003             STR      R0,[SP, #+12]
    840          	SPI_InitStructure.SPI_CPOL              = SPI_CPOL_Low;		//SPI_CPOL_High;
    841          	SPI_InitStructure.SPI_CPHA              = SPI_CPHA_1Edge;	//SPI_CPHA_2Edge;
   \   000000CA   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    842          	SPI_InitStructure.SPI_NSS               = SPI_NSS_Soft;
   \   000000CE   0xF44F 0x7000      MOV      R0,#+512
   \   000000D2   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    843          	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; //SPI_BaudRatePrescaler_8;
   \   000000D6   0x2038             MOVS     R0,#+56
   \   000000D8   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    844          	SPI_InitStructure.SPI_FirstBit          = SPI_FirstBit_MSB;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    845          	SPI_InitStructure.SPI_CRCPolynomial     = 7;
   \   000000E2   0x2007             MOVS     R0,#+7
   \   000000E4   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    846          	SPI_Init(SPI1, &SPI_InitStructure);
   \   000000E8   0x.... 0x....      LDR.W    R4,??DataTable38_7  ;; 0x40013000
   \   000000EC   0xA902             ADD      R1,SP,#+8
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       SPI_Init
    847          
    848          	/* Enable SPI1  */
    849          	SPI_Cmd(SPI1, ENABLE);
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       SPI_Cmd
    850          }
   \   000000FC   0xB008             ADD      SP,SP,#+32
   \   000000FE   0xBD10             POP      {R4,PC}          ;; return
    851          
    852          
    853          /*
    854          ********************************************************************************
    855          * Description : BSP_SPI2_Init
    856          * Arguments   : none
    857          * Return      : 
    858          * Note        : SPI2 for Temperature
    859          ******************************************************************************** 
    860          */
    861          

   \                                 In section .text, align 2, keep-with-next
    862          static void BSP_SPI2_Init(void)
    863          {
   \                     BSP_SPI2_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    864          	GPIO_InitTypeDef GPIO_InitStructure;
    865          	SPI_InitTypeDef SPI_InitStructure;
    866          		
    867          	/*!< Enable GPIO clocks */
    868          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    869          	/*!< Enable the SPI clock */
    870          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    871          	
    872          	/* Configure SPI pin: SCK*/
    873          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
   \   00000016   0xF44F 0x5000      MOV      R0,#+8192
   \   0000001A   0x9000             STR      R0,[SP, #+0]
    874          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    875          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000022   0xF88D 0x0005      STRB     R0,[SP, #+5]
    876          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    877          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    878          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000002C   0x.... 0x....      LDR.W    R4,??DataTable36_2  ;; 0x40020400
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       GPIO_Init
    879          
    880          	/* Configure SPI pin: MOSI */
    881          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
   \   00000038   0xF44F 0x4000      MOV      R0,#+32768
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    882          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xF88D 0x0004      STRB     R0,[SP, #+4]
    883          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000044   0xF88D 0x0005      STRB     R0,[SP, #+5]
    884          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    885          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    886          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       GPIO_Init
    887          
    888          	/* Configure SPI pin: MISO */
    889          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
   \   00000056   0xF44F 0x4080      MOV      R0,#+16384
   \   0000005A   0x9000             STR      R0,[SP, #+0]
    890          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    891          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000062   0xF88D 0x0005      STRB     R0,[SP, #+5]
    892          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    893          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    894          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000006C   0x4669             MOV      R1,SP
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       GPIO_Init
    895          
    896          	/* Enable alternate function for SPI pins */
    897          	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
   \   00000074   0x2205             MOVS     R2,#+5
   \   00000076   0x210D             MOVS     R1,#+13
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       GPIO_PinAFConfig
    898          	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);
   \   0000007E   0x2205             MOVS     R2,#+5
   \   00000080   0x210E             MOVS     R1,#+14
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       GPIO_PinAFConfig
    899          	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
   \   00000088   0x2205             MOVS     R2,#+5
   \   0000008A   0x210F             MOVS     R1,#+15
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       GPIO_PinAFConfig
    900          	
    901          	/* Configure I/O for Temperature Chip select */
    902          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;
   \   00000092   0xF44F 0x5080      MOV      R0,#+4096
   \   00000096   0x9000             STR      R0,[SP, #+0]
    903          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    904          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF88D 0x0006      STRB     R0,[SP, #+6]
    905           	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000A4   0x2002             MOVS     R0,#+2
   \   000000A6   0xF88D 0x0005      STRB     R0,[SP, #+5]
    906           	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF88D 0x0007      STRB     R0,[SP, #+7]
    907            GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   000000B0   0x4669             MOV      R1,SP
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       GPIO_Init
    908          
    909          	/* Deselect the Temperature: Chip Select high */
    910          	GPIO_SetBits(GPIOB, GPIO_Pin_12);
   \   000000B8   0xF44F 0x5180      MOV      R1,#+4096
   \   000000BC   0x4620             MOV      R0,R4
   \   000000BE   0x.... 0x....      BL       GPIO_SetBits
    911           
    912          	/* SPI2 configuration */
    913          	SPI_InitStructure.SPI_Direction         = SPI_Direction_2Lines_FullDuplex;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    914          	SPI_InitStructure.SPI_Mode              = SPI_Mode_Master;
   \   000000C8   0xF44F 0x7082      MOV      R0,#+260
   \   000000CC   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    915          	SPI_InitStructure.SPI_DataSize          = SPI_DataSize_8b;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x9003             STR      R0,[SP, #+12]
    916          	SPI_InitStructure.SPI_CPOL              = SPI_CPOL_Low;
    917          	SPI_InitStructure.SPI_CPHA              = SPI_CPHA_2Edge;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    918          	SPI_InitStructure.SPI_NSS               = SPI_NSS_Soft;
   \   000000DA   0xF44F 0x7000      MOV      R0,#+512
   \   000000DE   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    919          	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
   \   000000E2   0x2028             MOVS     R0,#+40
   \   000000E4   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    920          	SPI_InitStructure.SPI_FirstBit          = SPI_FirstBit_MSB;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    921          	SPI_InitStructure.SPI_CRCPolynomial     = 7;
   \   000000EE   0x2007             MOVS     R0,#+7
   \   000000F0   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    922          	SPI_Init(SPI2, &SPI_InitStructure);
   \   000000F4   0x.... 0x....      LDR.W    R4,??DataTable38_8  ;; 0x40003800
   \   000000F8   0xA902             ADD      R1,SP,#+8
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       SPI_Init
    923          
    924          	/* Enable SPI2  */
    925          	SPI_Cmd(SPI2, ENABLE);
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0x.... 0x....      BL       SPI_Cmd
    926          }
   \   00000108   0xB008             ADD      SP,SP,#+32
   \   0000010A   0xBD10             POP      {R4,PC}          ;; return
    927          
    928          
    929          /*
    930          ********************************************************************************
    931          * Description : BSP_USART1_Init
    932          * Arguments   : none
    933          * Return      : 
    934          * Note        : USART1 for MODEM.
    935          ******************************************************************************** 
    936          */

   \                                 In section .text, align 2, keep-with-next
    937          static void BSP_USART1_Init(void)
    938          {
   \                     BSP_USART1_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    939          	GPIO_InitTypeDef GPIO_InitStructure;
    940          	USART_InitTypeDef USART_InitStructure;
    941          
    942          	/* Enable USART1, GPIOA clocks */
    943          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    944          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA , ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    945          
    946          	// Connect PXx to USART1_Tx 
    947          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
   \   00000014   0x.... 0x....      LDR.W    R4,??DataTable36_1  ;; 0x40020000
   \   00000018   0x2207             MOVS     R2,#+7
   \   0000001A   0x2109             MOVS     R1,#+9
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       GPIO_PinAFConfig
    948          	// Connect PXx to USART1_Rx 
    949          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
   \   00000022   0x2207             MOVS     R2,#+7
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       GPIO_PinAFConfig
    950          	
    951          	/* Configure USART Tx as alternate function  */
    952          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    953          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000032   0xF88D 0x0005      STRB     R0,[SP, #+5]
    954          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF88D 0x0006      STRB     R0,[SP, #+6]
    955          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF88D 0x0007      STRB     R0,[SP, #+7]
    956          	 /* Configure USART Rx as alternate function  */
    957          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;
   \   00000042   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000046   0x9000             STR      R0,[SP, #+0]
    958          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       GPIO_Init
    959          
    960          
    961          	/* USART configured as follow */
    962          	USART_InitStructure.USART_BaudRate            = 9600;
   \   00000050   0xF44F 0x5016      MOV      R0,#+9600
   \   00000054   0x9002             STR      R0,[SP, #+8]
    963          	USART_InitStructure.USART_WordLength          = USART_WordLength_8b;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9003             STR      R0,[SP, #+12]
    964          	USART_InitStructure.USART_StopBits            = USART_StopBits_1;
    965          	USART_InitStructure.USART_Parity              = USART_Parity_No;
   \   0000005A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    966          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000005E   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    967          	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
   \   00000062   0x200C             MOVS     R0,#+12
   \   00000064   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    968          
    969          	/* Configure USART1 */
    970          	USART_Init(USART1, &USART_InitStructure);
   \   00000068   0x.... 0x....      LDR.W    R4,??DataTable38_9  ;; 0x40011000
   \   0000006C   0xA902             ADD      R1,SP,#+8
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       USART_Init
    971          
    972          	//BSP_IntVectSet(BSP_INT_ID_USART3,BSP_USART3_IRQHandler);
    973          	
    974          	/* Enable USART1 Transmit interrupts */
    975          	USART_ITConfig(USART1, USART_IT_TC, DISABLE);
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0xF240 0x6126      MOVW     R1,#+1574
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       USART_ITConfig
    976          
    977          	/* Enable USART1 Receive interrupts */
    978          	USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xF240 0x5125      MOVW     R1,#+1317
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       USART_ITConfig
    979          	
    980          	/* Enable the USART1 */
    981          	USART_Cmd(USART1, ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       USART_Cmd
    982          }
   \   00000094   0xB006             ADD      SP,SP,#+24
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
    983          
    984          /*
    985          ********************************************************************************
    986          * Description : BSP_UART1RX_IntEnable
    987          * Arguments   : none
    988          * Return      : 
    989          * Note        : USART1 rx intterupt eanble
    990          ******************************************************************************** 
    991          */
    992          

   \                                 In section .text, align 2, keep-with-next
    993          void BSP_UART1RX_IntEnable(FunctionalState state)
    994          {
    995          	USART_ITConfig(USART1, USART_IT_RXNE, state);
   \                     BSP_UART1RX_IntEnable: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable38_9  ;; 0x40011000
   \   0000000A   0x.... 0x....      B.W      USART_ITConfig
    996          }
    997          
    998          /*
    999          ********************************************************************************
   1000          * Description : BSP_USART2_Init
   1001          * Arguments   : none
   1002          * Return      : 
   1003          * Note        : USART2 for MODEM.
   1004          ******************************************************************************** 
   1005          */
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          static void BSP_USART2_Init(void)
   1008          {
   \                     BSP_USART2_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   1009          	GPIO_InitTypeDef GPIO_InitStructure;
   1010          	USART_InitTypeDef USART_InitStructure;
   1011          														//PORT A USE
   1012          	/* Enable USART2, GPIOA clocks */
   1013          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF44F 0x3000      MOV      R0,#+131072
   \   0000000A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   1014          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA , ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   1015          
   1016          	// Connect PXx to USART2_Tx 
   1017          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
   \   00000016   0x.... 0x....      LDR.W    R4,??DataTable36_1  ;; 0x40020000
   \   0000001A   0x2207             MOVS     R2,#+7
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       GPIO_PinAFConfig
   1018          	// Connect PXx to USART3_Rx 
   1019          	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
   \   00000024   0x2207             MOVS     R2,#+7
   \   00000026   0x2103             MOVS     R1,#+3
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       GPIO_PinAFConfig
   1020          	
   1021          	/* Configure USART Tx as alternate function  */
   1022          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1023          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000034   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1024          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1025          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1026          
   1027          	 /* Configure USART Rx as alternate function  */
   1028          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
   \   00000044   0x200C             MOVS     R0,#+12
   \   00000046   0x9000             STR      R0,[SP, #+0]
   1029          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       GPIO_Init
   1030          
   1031          	/* USART configured as follow */
   1032          	USART_InitStructure.USART_BaudRate            = 115200;
   \   00000050   0xF44F 0x30E1      MOV      R0,#+115200
   \   00000054   0x9002             STR      R0,[SP, #+8]
   1033          	USART_InitStructure.USART_WordLength          = USART_WordLength_8b;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9003             STR      R0,[SP, #+12]
   1034          	USART_InitStructure.USART_StopBits            = USART_StopBits_1;
   1035          	USART_InitStructure.USART_Parity              = USART_Parity_No;
   \   0000005A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   1036          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000005E   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   1037          	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
   \   00000062   0x200C             MOVS     R0,#+12
   \   00000064   0xF8AD 0x0012      STRH     R0,[SP, #+18]
   1038          
   1039          	/* Configure USART2 */
   1040          	USART_Init(USART2, &USART_InitStructure);
   \   00000068   0x.... 0x....      LDR.W    R4,??DataTable38_10  ;; 0x40004400
   \   0000006C   0xA902             ADD      R1,SP,#+8
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       USART_Init
   1041          
   1042          	//BSP_IntVectSet(BSP_INT_ID_USART3,BSP_USART3_IRQHandler);
   1043          	
   1044          	/* Enable USART2 Transmit interrupts */
   1045          	USART_ITConfig(USART2, USART_IT_TC, DISABLE);
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0xF240 0x6126      MOVW     R1,#+1574
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       USART_ITConfig
   1046          
   1047          
   1048          	/* Enable USART2 Receive interrupts */
   1049          	USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xF240 0x5125      MOVW     R1,#+1317
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       USART_ITConfig
   1050          	
   1051          	/* Enable the USART2 */
   1052          	USART_Cmd(USART2, ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       USART_Cmd
   1053          }
   \   00000094   0xB006             ADD      SP,SP,#+24
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
   1054          
   1055          /*
   1056          ********************************************************************************
   1057          * Description : BSP_USART2RX_IntEnable
   1058          * Arguments   : none
   1059          * Return      : 
   1060          * Note        : USART2 rx intterupt eanble
   1061          ******************************************************************************** 
   1062          */

   \                                 In section .text, align 2, keep-with-next
   1063          void BSP_UART2RX_IntEnable(FunctionalState state)
   1064          {
   1065          	USART_ITConfig(USART2, USART_IT_RXNE, state);
   \                     BSP_UART2RX_IntEnable: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable38_10  ;; 0x40004400
   \   0000000A   0x.... 0x....      B.W      USART_ITConfig
   1066          }
   1067          
   1068          
   1069          /*
   1070          ********************************************************************************
   1071          * Description : BSP_ADC1_DMA_Init
   1072          * Arguments   : none
   1073          * Return      : 
   1074          * Note        : ADC1 DMA init
   1075          ******************************************************************************** 
   1076          */
   1077          

   \                                 In section .text, align 2, keep-with-next
   1078          static void BSP_ADC1_DMA_Init(void) 
   1079          {
   \                     BSP_ADC1_DMA_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   1080          	DMA_InitTypeDef DMA_InitStructure;
   1081          
   1082          	ADC_DeInit();
   \   00000004   0x.... 0x....      BL       ADC_DeInit
   1083          	DMA_DeInit(DMA2_Stream0);
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable38_11  ;; 0x40026410
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       DMA_DeInit
   1084          
   1085          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF44F 0x0080      MOV      R0,#+4194304
   \   00000018   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   1086          
   1087          	DMA_InitStructure.DMA_Channel = DMA_Channel_0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   1088          	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &ADC1->DR;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable38_12  ;; 0x4001204c
   \   00000024   0x9001             STR      R0,[SP, #+4]
   1089          	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) &adcdata[ADC_P0];
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable38_13
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   1090          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   1091          	DMA_InitStructure.DMA_BufferSize = 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x9004             STR      R0,[SP, #+16]
   1092          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9005             STR      R0,[SP, #+20]
   1093          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000038   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003C   0x9006             STR      R0,[SP, #+24]
   1094          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
   \   0000003E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000042   0x9007             STR      R0,[SP, #+28]
   1095          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
   \   00000044   0xF44F 0x5000      MOV      R0,#+8192
   \   00000048   0x9008             STR      R0,[SP, #+32]
   1096          	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA_Mode_Normal;
   \   0000004A   0xF44F 0x7080      MOV      R0,#+256
   \   0000004E   0x9009             STR      R0,[SP, #+36]
   1097          	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
   \   00000050   0xF44F 0x3000      MOV      R0,#+131072
   \   00000054   0x900A             STR      R0,[SP, #+40]
   1098          	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   00000056   0x2004             MOVS     R0,#+4
   \   00000058   0x900B             STR      R0,[SP, #+44]
   1099          	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x900C             STR      R0,[SP, #+48]
   1100          	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x900D             STR      R0,[SP, #+52]
   1101          	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   00000062   0x900E             STR      R0,[SP, #+56]
   1102          	DMA_Init(DMA2_Stream0, &DMA_InitStructure);
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       DMA_Init
   1103          	DMA_Cmd(DMA2_Stream0, ENABLE);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       DMA_Cmd
   1104          }
   \   00000074   0xB010             ADD      SP,SP,#+64
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   1105          
   1106          
   1107          /*
   1108          ********************************************************************************
   1109          * Description : BSP_ADC1ConStart
   1110          * Arguments   : none
   1111          * Return      : 
   1112          * Note        : ADC Start
   1113          ******************************************************************************** 
   1114          */

   \                                 In section .text, align 2, keep-with-next
   1115          void BSP_ADC1ConStart(void)
   1116          {
   1117          	/* Start ADC1 Software Conversion */ 
   1118          	ADC_SoftwareStartConv(ADC1);
   \                     BSP_ADC1ConStart: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable38_14  ;; 0x40012000
   \   00000004   0x.... 0x....      B.W      ADC_SoftwareStartConv
   1119          }
   1120          
   1121          
   1122          /*
   1123          ********************************************************************************
   1124          * Description : BSP_ADC1_Init
   1125          * Arguments   : none
   1126          * Return      : 
   1127          * Note        : ADC1 init
   1128          ******************************************************************************** 
   1129          */
   1130          

   \                                 In section .text, align 2, keep-with-next
   1131          static void BSP_ADC1_Init(void)
   1132          {
   \                     BSP_ADC1_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   1133          	GPIO_InitTypeDef GPIO_InitStructure;
   1134          	ADC_InitTypeDef ADC_InitStructure;
   1135          	ADC_CommonInitTypeDef ADC_CommonInitStructure;
   1136          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   1137          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x7080      MOV      R0,#+256
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   1138          
   1139          	BSP_ADC1_DMA_Init();
   \   00000016   0x.... 0x....      BL       BSP_ADC1_DMA_Init
   1140          
   1141          	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;			//ADC123_IN10
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   1142          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1143          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1144          	GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable38  ;; 0x40020800
   \   00000030   0x.... 0x....      BL       GPIO_Init
   1145          
   1146          	ADC_CommonInitStructure.ADC_Mode			      = ADC_Mode_Independent;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9002             STR      R0,[SP, #+8]
   1147          	ADC_CommonInitStructure.ADC_Prescaler		    = ADC_Prescaler_Div2;
   \   00000038   0x9003             STR      R0,[SP, #+12]
   1148          	ADC_CommonInitStructure.ADC_DMAAccessMode	  = ADC_DMAAccessMode_Disabled;
   \   0000003A   0x9004             STR      R0,[SP, #+16]
   1149          	ADC_CommonInitStructure.ADC_TwoSamplingDelay= ADC_TwoSamplingDelay_5Cycles;
   \   0000003C   0x9005             STR      R0,[SP, #+20]
   1150          	ADC_CommonInit(&ADC_CommonInitStructure);
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0x.... 0x....      BL       ADC_CommonInit
   1151          
   1152          	ADC_InitStructure.ADC_Resolution			      = ADC_Resolution_12b;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9006             STR      R0,[SP, #+24]
   1153          	ADC_InitStructure.ADC_ScanConvMode			    = ENABLE;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x001C      STRB     R0,[SP, #+28]
   1154          	ADC_InitStructure.ADC_ContinuousConvMode	  = ENABLE;
   \   0000004E   0xF88D 0x001D      STRB     R0,[SP, #+29]
   1155          
   1156          	ADC_InitStructure.ADC_ExternalTrigConvEdge	= ADC_ExternalTrigConvEdge_None;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x9008             STR      R0,[SP, #+32]
   1157          	ADC_InitStructure.ADC_DataAlign				      = ADC_DataAlign_Right;
   \   00000056   0x900A             STR      R0,[SP, #+40]
   1158          	ADC_InitStructure.ADC_NbrOfConversion		    = 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xF88D 0x002C      STRB     R0,[SP, #+44]
   1159          	ADC_Init(ADC1, &ADC_InitStructure);
   \   0000005E   0x.... 0x....      LDR.W    R4,??DataTable38_14  ;; 0x40012000
   \   00000062   0xA906             ADD      R1,SP,#+24
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       ADC_Init
   1160          
   1161          	ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_15Cycles);
   \   0000006A   0x2301             MOVS     R3,#+1
   \   0000006C   0x461A             MOV      R2,R3
   \   0000006E   0x210A             MOVS     R1,#+10
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       ADC_RegularChannelConfig
   1162          
   1163          	ADC_DMARequestAfterLastTransferCmd(ADC1, ENABLE);
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       ADC_DMARequestAfterLastTransferCmd
   1164          
   1165          	ADC_DMACmd(ADC1, ENABLE);
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       ADC_DMACmd
   1166          
   1167          	ADC_Cmd(ADC1, ENABLE);
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       ADC_Cmd
   1168            
   1169            BSP_ADC1ConStart();  
   \   0000008E   0x.... 0x....      BL       BSP_ADC1ConStart
   1170          }
   \   00000092   0xB00C             ADD      SP,SP,#+48
   \   00000094   0xBD10             POP      {R4,PC}          ;; return
   1171          
   1172          
   1173          /*
   1174          *********************************************************************************************************
   1175          *********************************************************************************************************
   1176          *                                          OS CORTEX-M3 FUNCTIONS
   1177          *********************************************************************************************************
   1178          *********************************************************************************************************
   1179          */
   1180          
   1181          /*
   1182          ********************************************************************************
   1183          * Description : BSP_CPU_ClkFreq
   1184          * Arguments   : none
   1185          * Return      : 
   1186          * Note        : 
   1187          ******************************************************************************** 
   1188          */
   1189          

   \                                 In section .text, align 2, keep-with-next
   1190          CPU_INT32U BSP_CPU_ClkFreq(void)
   1191          {
   \                     BSP_CPU_ClkFreq: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1192            RCC_ClocksTypeDef rcc_clocks;
   1193            RCC_GetClocksFreq(&rcc_clocks);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       RCC_GetClocksFreq
   1194          
   1195            return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0xB005             ADD      SP,SP,#+20
   \   0000000E   0xBD00             POP      {PC}             ;; return
   1196          }
   1197          
   1198          /*
   1199          ********************************************************************************
   1200          * Description : OS_CPU_SysTickClkFreq
   1201          * Arguments   : none
   1202          * Return      : 
   1203          * Note        : 
   1204          ******************************************************************************** 
   1205          */

   \                                 In section .text, align 2, keep-with-next
   1206          INT32U OS_CPU_SysTickClkFreq(void)
   1207          {
   1208            INT32U freq;
   1209          
   1210            freq = BSP_CPU_ClkFreq();
   1211            return (freq);
   \                     OS_CPU_SysTickClkFreq: (+1)
   \   00000000   0x....             B.N      BSP_CPU_ClkFreq
   1212          }
   1213          
   1214          /*
   1215          ********************************************************************************
   1216          * Description : CAN_Receive_mk
   1217          * Arguments   : none
   1218          * Return      : 
   1219          * Note        : CAN receive data make packet
   1220          ******************************************************************************** 
   1221          */
   1222          

   \                                 In section .text, align 2, keep-with-next
   1223          void CAN_Receive_mk(CAN_TypeDef* CANx, uint8_t FIFONumber, canrxmsg_t* RxMessage)
   1224          {
   \                     CAN_Receive_mk: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1225            /* Check the parameters */
   1226            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1227            assert_param(IS_CAN_FIFO(FIFONumber));
   1228            /* Get the Id */
   1229            RxMessage->ide = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \   00000002   0xEB00 0x1301      ADD      R3,R0,R1, LSL #+4
   \   00000006   0xF44F 0x74D8      MOV      R4,#+432
   \   0000000A   0x4423             ADD      R3,R3,R4
   \   0000000C   0x681C             LDR      R4,[R3, #+0]
   \   0000000E   0xF014 0x0404      ANDS     R4,R4,#0x4
   \   00000012   0x7114             STRB     R4,[R2, #+4]
   1230            if (RxMessage->ide == CAN_Id_Standard)
   \   00000014   0x681C             LDR      R4,[R3, #+0]
   \   00000016   0xD102             BNE.N    ??CAN_Receive_mk_0
   1231            {
   1232              RxMessage->id = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000018   0x0D64             LSRS     R4,R4,#+21
   \   0000001A   0x6014             STR      R4,[R2, #+0]
   \   0000001C   0xE001             B.N      ??CAN_Receive_mk_1
   1233            }
   1234            else
   1235            {
   1236              RxMessage->id = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_mk_0: (+1)
   \   0000001E   0x08E4             LSRS     R4,R4,#+3
   \   00000020   0x6014             STR      R4,[R2, #+0]
   1237            }
   1238            
   1239            RxMessage->rtr = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_mk_1: (+1)
   \   00000022   0x681C             LDR      R4,[R3, #+0]
   \   00000024   0xF004 0x0402      AND      R4,R4,#0x2
   \   00000028   0x7154             STRB     R4,[R2, #+5]
   1240            /* Get the DLC */
   1241            RxMessage->dlc = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   0000002A   0x685C             LDR      R4,[R3, #+4]
   \   0000002C   0xF004 0x040F      AND      R4,R4,#0xF
   \   00000030   0x7194             STRB     R4,[R2, #+6]
   1242            /* Get the FMI */
   1243            RxMessage->fmi = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000032   0x685C             LDR      R4,[R3, #+4]
   \   00000034   0x0A24             LSRS     R4,R4,#+8
   \   00000036   0x73D4             STRB     R4,[R2, #+15]
   1244            /* Get the data field */
   1245            RxMessage->data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000038   0x689C             LDR      R4,[R3, #+8]
   \   0000003A   0x71D4             STRB     R4,[R2, #+7]
   1246            RxMessage->data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   0000003C   0x689C             LDR      R4,[R3, #+8]
   \   0000003E   0x0A24             LSRS     R4,R4,#+8
   \   00000040   0x7214             STRB     R4,[R2, #+8]
   1247            RxMessage->data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   00000042   0x689C             LDR      R4,[R3, #+8]
   \   00000044   0x0C24             LSRS     R4,R4,#+16
   \   00000046   0x7254             STRB     R4,[R2, #+9]
   1248            RxMessage->data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   00000048   0x689C             LDR      R4,[R3, #+8]
   \   0000004A   0x0E24             LSRS     R4,R4,#+24
   \   0000004C   0x7294             STRB     R4,[R2, #+10]
   1249            RxMessage->data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   0000004E   0x68DC             LDR      R4,[R3, #+12]
   \   00000050   0x72D4             STRB     R4,[R2, #+11]
   1250            RxMessage->data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   00000052   0x68DC             LDR      R4,[R3, #+12]
   \   00000054   0x0A24             LSRS     R4,R4,#+8
   \   00000056   0x7314             STRB     R4,[R2, #+12]
   1251            RxMessage->data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   00000058   0x68DC             LDR      R4,[R3, #+12]
   \   0000005A   0x0C24             LSRS     R4,R4,#+16
   \   0000005C   0x7354             STRB     R4,[R2, #+13]
   1252            RxMessage->data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   0000005E   0x68DB             LDR      R3,[R3, #+12]
   \   00000060   0x0E1B             LSRS     R3,R3,#+24
   \   00000062   0x7393             STRB     R3,[R2, #+14]
   1253            /* Release the FIFO */
   1254            /* Release FIFO0 */
   1255            if (FIFONumber == CAN_FIFO0)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD104             BNE.N    ??CAN_Receive_mk_2
   1256            {
   1257              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000068   0x68C1             LDR      R1,[R0, #+12]
   \   0000006A   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000006E   0x60C1             STR      R1,[R0, #+12]
   \   00000070   0xE003             B.N      ??CAN_Receive_mk_3
   1258            }
   1259            /* Release FIFO1 */
   1260            else /* FIFONumber == CAN_FIFO1 */
   1261            {
   1262              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_mk_2: (+1)
   \   00000072   0x6901             LDR      R1,[R0, #+16]
   \   00000074   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000078   0x6101             STR      R1,[R0, #+16]
   1263            }
   1264          }
   \                     ??CAN_Receive_mk_3: (+1)
   \   0000007A   0xBC10             POP      {R4}
   \   0000007C   0x4770             BX       LR               ;; return
   1265          
   1266          /*
   1267          *********************************************************************************************************
   1268          *********************************************************************************************************
   1269          *                                         INTERRUPT SERVICE ROUTINE
   1270          *********************************************************************************************************
   1271          *********************************************************************************************************
   1272          */
   1273          
   1274          /*
   1275          ********************************************************************************
   1276          * Description : PVD_IRQHandler
   1277          * Arguments   : none
   1278          * Return      : 
   1279          * Note        : PVD Interrupt Service Routine (less than 2.9v)
   1280          ******************************************************************************** 
   1281          */
   1282          
   1283          #if PDV_ENABLE > 0
   1284          void PVD_IRQHandler(void)
   1285          {
   1286          	printd("I'm dying...\n");
   1287          }
   1288          #endif
   1289          
   1290          /*
   1291          ********************************************************************************
   1292          * Description : RTC_WKUP_IRQHandler
   1293          * Arguments   : none
   1294          * Return      : 
   1295          * Note        : RTC Wakeup global interrupt request.
   1296          ******************************************************************************** 
   1297          */

   \                                 In section .text, align 2, keep-with-next
   1298          void RTC_WKUP_IRQHandler(void)
   1299          {
   \                     RTC_WKUP_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1300          	sysinfo_t *s = &_sysinfo;
   1301            
   1302            if(RTC_GetITStatus(RTC_IT_WUT) != RESET) {
   \   00000002   0xF44F 0x4080      MOV      R0,#+16384
   \   00000006   0x.... 0x....      BL       RTC_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD030             BEQ.N    ??RTC_WKUP_IRQHandler_0
   1303              if(!Flags.StartFlag) {
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable38_15
   \   00000012   0x8820             LDRH     R0,[R4, #+0]
   \   00000014   0xF3C0 0x2040      UBFX     R0,R0,#+9,#+1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD11F             BNE.N    ??RTC_WKUP_IRQHandler_1
   1304                GetRTCTime(&s->tm_ptr);
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable38_16
   \   00000020   0x.... 0x....      BL       GetRTCTime
   1305                Flags.MMCSaveFlag = 1;
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000002A   0x8020             STRH     R0,[R4, #+0]
   1306                Flags1.GpsDataFlag = 1;
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable38_17
   \   00000030   0x880A             LDRH     R2,[R1, #+0]
   \   00000032   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   00000036   0x800A             STRH     R2,[R1, #+0]
   1307                if(Start_Flag) {
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable38_18
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD00C             BEQ.N    ??RTC_WKUP_IRQHandler_1
   1308                  SaveCnt++;
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable38_19
   \   00000046   0x780A             LDRB     R2,[R1, #+0]
   \   00000048   0x1C52             ADDS     R2,R2,#+1
   \   0000004A   0x700A             STRB     R2,[R1, #+0]
   1309                  if(SaveCnt >= SENDTIME) {
   \   0000004C   0xB2D2             UXTB     R2,R2
   \   0000004E   0x2A04             CMP      R2,#+4
   \   00000050   0xDB04             BLT.N    ??RTC_WKUP_IRQHandler_1
   1310                    SaveCnt = 0;
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x700A             STRB     R2,[R1, #+0]
   1311                    Flags.SaveDataFlag = 1;
   \   00000056   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
   1312                  }
   1313                }
   1314              }
   1315              RTC_ClearITPendingBit(RTC_IT_WUT);
   \                     ??RTC_WKUP_IRQHandler_1: (+1)
   \   0000005C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000060   0x.... 0x....      BL       RTC_ClearITPendingBit
   1316              EXTI_ClearITPendingBit(EXTI_Line22);
   \   00000064   0xF44F 0x0080      MOV      R0,#+4194304
   \   00000068   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006C   0x.... 0x....      B.W      EXTI_ClearITPendingBit
   1317            } 
   1318          } 
   \                     ??RTC_WKUP_IRQHandler_0: (+1)
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
   1319          
   1320          
   1321          /*
   1322          ********************************************************************************
   1323          * Description : I2C_Serve
   1324          * Arguments   : *I2Cx
   1325          * Return      : 
   1326          * Note        : I2C2 Service Routine 
   1327          ******************************************************************************** 
   1328          */
   1329          

   \                                 In section .text, align 2, keep-with-next
   1330          void I2C_Serve(I2C_TypeDef *I2Cx)
   1331          {
   \                     I2C_Serve: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1332          	/*
   1333               * state machine for the whole I2C events
   1334            */
   1335            switch (I2C_GetLastEvent(I2Cx))
   \   00000004   0x.... 0x....      BL       I2C_GetLastEvent
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable38_20  ;; 0x30001
   \   0000000C   0x1A40             SUBS     R0,R0,R1
   \   0000000E   0xD00B             BEQ.N    ??I2C_Serve_0
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0xF000 0x8082      BEQ.W    ??I2C_Serve_1
   \   00000016   0x383E             SUBS     R0,R0,#+62
   \   00000018   0xD059             BEQ.N    ??I2C_Serve_2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable38_21  ;; 0x40040
   \   0000001E   0x1A40             SUBS     R0,R0,R1
   \   00000020   0xD02A             BEQ.N    ??I2C_Serve_3
   \   00000022   0x1E80             SUBS     R0,R0,#+2
   \   00000024   0xD028             BEQ.N    ??I2C_Serve_3
   \   00000026   0xBD70             POP      {R4-R6,PC}
   1336          	{
   1337          		/*
   1338               * Master Mode
   1339              */
   1340              case I2C_EVENT_MASTER_MODE_SELECT:
   1341          		/*
   1342               * we want to transmit a single byte
   1343               */
   1344                if(I2C_DIR == TX) {
   \                     ??I2C_Serve_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable38_22
   \   0000002C   0x7801             LDRB     R1,[R0, #+0]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD107             BNE.N    ??I2C_Serve_4
   1345          				I2C_Send7bitAddress(I2Cx, I2CADDRESS, I2C_Direction_Transmitter);
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable38_23
   \   00000038   0x7801             LDRB     R1,[R0, #+0]
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       I2C_Send7bitAddress
   \   00000040   0xE014             B.N      ??I2C_Serve_5
   1346                  /*
   1347                   * we want to read a register value
   1348                   * first step is TRANSMITTING the register address then RECEIVE the data
   1349                   */
   1350                }
   1351          			else if(I2C_DIR == TXREG) {
   \                     ??I2C_Serve_4: (+1)
   \   00000042   0x7801             LDRB     R1,[R0, #+0]
   \   00000044   0x2902             CMP      R1,#+2
   \   00000046   0xD107             BNE.N    ??I2C_Serve_6
   1352          				I2C_Send7bitAddress(I2Cx, I2CADDRESS, I2C_Direction_Transmitter);
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable38_23
   \   0000004E   0x7801             LDRB     R1,[R0, #+0]
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       I2C_Send7bitAddress
   \   00000056   0xE009             B.N      ??I2C_Serve_5
   1353                  /*
   1354                   * we want to receive something
   1355                   */
   1356                }
   1357          			else if(I2C_DIR == RX) {
   \                     ??I2C_Serve_6: (+1)
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD106             BNE.N    ??I2C_Serve_5
   1358          				I2C_Send7bitAddress(I2Cx, I2CADDRESS, I2C_Direction_Receiver);
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable38_23
   \   00000064   0x7801             LDRB     R1,[R0, #+0]
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       I2C_Send7bitAddress
   1359                }
   1360                // address sent, if no byte should be sent: request NAK now!
   1361                if( tx_buffer_len == 0 ) {
   \                     ??I2C_Serve_5: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable38_24
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD15F             BNE.N    ??I2C_Serve_7
   \   00000076   0xE054             B.N      ??I2C_Serve_8
   1362                  // request NAK
   1363                  I2C_AcknowledgeConfig(I2Cx, DISABLE);
   1364                  // request stop condition
   1365                  I2C_GenerateSTOP(I2Cx, ENABLE);
   1366                }                        
   1367                break;
   1368                /*
   1369                 * we get here after transmitting address + write bit
   1370                 */
   1371          		case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED:
   1372          		case I2C_EVENT_MASTER_BYTE_TRANSMITTING:
   1373          			if( tx_buffer_ix < tx_buffer_len ) {
   \                     ??I2C_Serve_3: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable38_25
   \   0000007C   0x7801             LDRB     R1,[R0, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R2,??DataTable38_24
   \   00000082   0x7812             LDRB     R2,[R2, #+0]
   \   00000084   0x4291             CMP      R1,R2
   \   00000086   0xD20A             BCS.N    ??I2C_Serve_9
   1374          				I2C_SendData(I2Cx, tx_buffer[tx_buffer_ix++]);
   \   00000088   0x7801             LDRB     R1,[R0, #+0]
   \   0000008A   0x1C4A             ADDS     R2,R1,#+1
   \   0000008C   0x7002             STRB     R2,[R0, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable38_26
   \   00000092   0x5C41             LDRB     R1,[R0, R1]
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000009A   0x.... 0x....      B.W      I2C_SendData
   1375          				//printd("0x[%02X]",tx_buffer[tx_buffer_ix-1]);
   1376                }  
   1377                else {
   1378          				if(I2C_DIR == TX) {
   \                     ??I2C_Serve_9: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable38_22
   \   000000A2   0x7801             LDRB     R1,[R0, #+0]
   \   000000A4   0x2900             CMP      R1,#+0
   \   000000A6   0xD108             BNE.N    ??I2C_Serve_10
   1379          				// send stop condition
   1380                     I2C_GenerateSTOP(I2Cx, ENABLE);
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       I2C_GenerateSTOP
   1381                     I2C_BLOCKED = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable38_27
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
   \   000000B8   0xBD70             POP      {R4-R6,PC}
   1382                   }
   1383                   else if(I2C_DIR == TXREG) {
   \                     ??I2C_Serve_10: (+1)
   \   000000BA   0x7801             LDRB     R1,[R0, #+0]
   \   000000BC   0x2902             CMP      R1,#+2
   \   000000BE   0xD13A             BNE.N    ??I2C_Serve_7
   1384                    /*
   1385                     * Generate second start and switch to receiver mode
   1386                     */
   1387                     I2C_DIR = RX;
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0x7001             STRB     R1,[R0, #+0]
   1388                     I2C_GenerateSTART(I2Cx,ENABLE);
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000CA   0x.... 0x....      B.W      I2C_GenerateSTART
   1389                   }
   1390          			}
   1391          			break;
   1392          		case I2C_EVENT_MASTER_BYTE_TRANSMITTED:
   1393          			break;
   1394          		case I2C_EVENT_MASTER_MODE_ADDRESS10:
   1395          			break;                                  
   1396                  /* 
   1397                   * we received a byte...
   1398                  */
   1399          		case I2C_EVENT_MASTER_BYTE_RECEIVED:
   1400                /* Store I2C received data */
   1401                rx_buffer_ptr[rx_buffer_ix++] = I2C_ReceiveData(I2Cx);
   \                     ??I2C_Serve_2: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R5,??DataTable38_28
   \   000000D2   0x782E             LDRB     R6,[R5, #+0]
   \   000000D4   0x1C70             ADDS     R0,R6,#+1
   \   000000D6   0x7028             STRB     R0,[R5, #+0]
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       I2C_ReceiveData
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable38_29
   \   000000E2   0x6809             LDR      R1,[R1, #+0]
   \   000000E4   0x5588             STRB     R0,[R1, R6]
   1402                /* Request NACK and send I2C1 STOP condition before receiving the last data */
   1403                if ((rx_buffer_ix == rx_buffer_len - 1) || rx_buffer_len == 1) {
   \   000000E6   0x7828             LDRB     R0,[R5, #+0]
   \   000000E8   0x.... 0x....      LDR.W    R6,??DataTable38_30
   \   000000EC   0x7831             LDRB     R1,[R6, #+0]
   \   000000EE   0x1E49             SUBS     R1,R1,#+1
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xD002             BEQ.N    ??I2C_Serve_11
   \   000000F4   0x7830             LDRB     R0,[R6, #+0]
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xD107             BNE.N    ??I2C_Serve_12
   1404                  /* Request ACK and send I2C STOP condition before receiving the last data */
   1405                  /* Request NACK */
   1406                  I2C_AcknowledgeConfig(I2Cx, DISABLE);
   \                     ??I2C_Serve_11: (+1)
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       I2C_AcknowledgeConfig
   1407                  /* Send I2C STOP Condition */
   1408                  I2C_GenerateSTOP(I2Cx, ENABLE);      
   \   00000102   0x2101             MOVS     R1,#+1
   \   00000104   0x4620             MOV      R0,R4
   \   00000106   0x.... 0x....      BL       I2C_GenerateSTOP
   1409          			}
   1410                if (rx_buffer_ix == rx_buffer_len) {
   \                     ??I2C_Serve_12: (+1)
   \   0000010A   0x7828             LDRB     R0,[R5, #+0]
   \   0000010C   0x7831             LDRB     R1,[R6, #+0]
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xD111             BNE.N    ??I2C_Serve_7
   1411          				I2C_BLOCKED = 0;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x....             LDR.N    R1,??DataTable38_27
   \   00000116   0x7008             STRB     R0,[R1, #+0]
   \   00000118   0xBD70             POP      {R4-R6,PC}
   1412                }
   1413          			break;
   1414          			/*
   1415                * we switched the mode
   1416                */
   1417          		case I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED:
   1418                if(rx_buffer_len == 1) {
   \                     ??I2C_Serve_1: (+1)
   \   0000011A   0x....             LDR.N    R0,??DataTable38_30
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD109             BNE.N    ??I2C_Serve_7
   1419          				/* Request NACK */
   1420                  I2C_AcknowledgeConfig(I2Cx, DISABLE);
   \                     ??I2C_Serve_8: (+1)
   \   00000122   0x2100             MOVS     R1,#+0
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       I2C_AcknowledgeConfig
   1421                  /* Send I2C STOP Condition */
   1422                  I2C_GenerateSTOP(I2Cx,ENABLE);
   \   0000012A   0x2101             MOVS     R1,#+1
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000132   0x.... 0x....      B.W      I2C_GenerateSTOP
   1423                }
   1424          			break;
   1425          	}
   1426          }
   \                     ??I2C_Serve_7: (+1)
   \   00000136   0xBD70             POP      {R4-R6,PC}       ;; return
   1427          
   1428          
   1429          /*
   1430          ********************************************************************************
   1431          * Description : I2C1_EV_IRQHandler
   1432          * Arguments   : none
   1433          * Return      : 
   1434          * Note        : I2C1 Service Routine 
   1435          ******************************************************************************** 
   1436          */
   1437          

   \                                 In section .text, align 2, keep-with-next
   1438          void I2C1_EV_IRQHandler(void)
   1439          {
   1440            I2C_Serve(I2C1);
   \                     I2C1_EV_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable38_4  ;; 0x40005400
   \   00000002   0x....             B.N      I2C_Serve
   1441          }
   1442          
   1443          
   1444          /*
   1445          ********************************************************************************
   1446          * Description : I2C1_ER_IRQHandler
   1447          * Arguments   : none
   1448          * Return      : 
   1449          * Note        : I2C1 Error Service Routine 
   1450          ******************************************************************************** 
   1451          */
   1452          

   \                                 In section .text, align 2, keep-with-next
   1453          void I2C1_ER_IRQHandler(void)
   1454          {
   \                     I2C1_ER_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1455            if (I2C_GetITStatus(I2C1, I2C_IT_AF))
   \   00000002   0x....             LDR.N    R4,??DataTable38_4  ;; 0x40005400
   \   00000004   0x....             LDR.N    R5,??DataTable38_31  ;; 0x1000400
   \   00000006   0x4629             MOV      R1,R5
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??I2C1_ER_IRQHandler_0
   1456            {
   1457              I2C_ClearITPendingBit(I2C1, I2C_IT_AF);
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001A   0x.... 0x....      B.W      I2C_ClearITPendingBit
   1458            }
   1459          }
   \                     ??I2C1_ER_IRQHandler_0: (+1)
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1460          
   1461          
   1462          /*
   1463          *********************************************************************************************************
   1464          *                                            CAN1_RX0_IRQHandler()
   1465          *
   1466          * Description : This function handles CAN1 RX0 request. 
   1467          *
   1468          * Note(s)     : 
   1469          *********************************************************************************************************
   1470          */

   \                                 In section .text, align 2, keep-with-next
   1471          void CAN1_RX0_IRQHandler(void)
   1472          {
   \                     CAN1_RX0_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1473          	if (CAN_GetITStatus(CAN1,CAN_IT_FMP0))
   \   00000002   0x....             LDR.N    R4,??DataTable38_6  ;; 0x40006400
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       CAN_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00C             BEQ.N    ??CAN1_RX0_IRQHandler_0
   1474          	{
   1475              CAN_Receive_mk(CAN1, CAN_FIFO0, &Can_RxMsg);
   \   00000010   0x....             LDR.N    R2,??DataTable38_32
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       CAN_Receive_mk
   1476              
   1477              CAN_Decode();
   \   0000001A   0x.... 0x....      BL       CAN_Decode
   1478              
   1479          		CAN_ClearITPendingBit(CAN1, CAN_IT_FMP0);
   \   0000001E   0x2102             MOVS     R1,#+2
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      CAN_ClearITPendingBit
   1480          	}
   1481          }
   \                     ??CAN1_RX0_IRQHandler_0: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1482          
   1483          
   1484          /*
   1485          ********************************************************************************
   1486          * Description : EXTI9_5_IRQHandler
   1487          * Arguments   : none
   1488          * Return      : 
   1489          * Note        : EXTI9_5 Interrupt Service Routine 
   1490          ******************************************************************************** 
   1491          */
   1492          

   \                                 In section .text, align 2, keep-with-next
   1493          void EXTI9_5_IRQHandler(void)
   1494          {
   \                     EXTI9_5_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1495          	sysinfo_t *s = &_sysinfo 	;
   1496          
   1497          	if(EXTI_GetITStatus(EXTI_Line6) != RESET) //Key
   \   00000002   0x2040             MOVS     R0,#+64
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??EXTI9_5_IRQHandler_0
   1498          	{
   1499          		s->key.keyon_flag = 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable38_33
   \   00000010   0x6148             STR      R0,[R1, #+20]
   1500          
   1501          		EXTI_ClearITPendingBit(EXTI_Line6);   
   \   00000012   0x2040             MOVS     R0,#+64
   \   00000014   0xE8BD 0x4002      POP      {R1,LR}
   \   00000018   0x.... 0x....      B.W      EXTI_ClearITPendingBit
   1502          	}
   1503          }
   \                     ??EXTI9_5_IRQHandler_0: (+1)
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
   1504          
   1505          
   1506          /*
   1507          ********************************************************************************
   1508          * Description : USART1_IRQHandler
   1509          * Arguments   : none
   1510          * Return      : 
   1511          * Note        : USART1 Interrupt Service Routine 
   1512          ******************************************************************************** 
   1513          */
   1514          

   \                                 In section .text, align 2, keep-with-next
   1515          void USART1_IRQHandler(void)
   1516          {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1517            uint8_t rdata;
   1518            uint16_t uart1_head;
   1519            
   1520          	if(USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
   \   00000002   0x....             LDR.N    R4,??DataTable38_9  ;; 0x40011000
   \   00000004   0xF240 0x5525      MOVW     R5,#+1317
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USART_GetITStatus
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD111             BNE.N    ??USART1_IRQHandler_0
   1521          	{
   1522          	
   1523          	  rdata = (uint8_t)(USART1->DR & (uint8_t)0x00FF);
   \   00000014   0x88A0             LDRH     R0,[R4, #+4]
   1524          
   1525              uart1_head = (GPS_RxHead + 1) & GPS_RX_BUFFER_MASK;
   \   00000016   0x....             LDR.N    R1,??DataTable38_34
   \   00000018   0x880A             LDRH     R2,[R1, #+0]
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0xF3C2 0x0208      UBFX     R2,R2,#+0,#+9
   1526              GPS_RxHead = uart1_head;      // Store new index
   \   00000020   0x800A             STRH     R2,[R1, #+0]
   1527          
   1528              if (uart1_head != GPS_RxTail )
   \   00000022   0x4611             MOV      R1,R2
   \   00000024   0x....             LDR.N    R3,??DataTable38_35
   \   00000026   0x881B             LDRH     R3,[R3, #+0]
   \   00000028   0x4299             CMP      R1,R3
   \   0000002A   0xD001             BEQ.N    ??USART1_IRQHandler_1
   1529                GPS_RxBuf[uart1_head] = rdata; // Store received data in buffer 
   \   0000002C   0x....             LDR.N    R1,??DataTable38_36
   \   0000002E   0x5488             STRB     R0,[R1, R2]
   1530              
   1531          		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
   \                     ??USART1_IRQHandler_1: (+1)
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       USART_ClearITPendingBit
   1532          	}
   1533          
   1534          	if(USART_GetITStatus(USART1, USART_IT_TC) == SET)
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000038   0xF240 0x6526      MOVW     R5,#+1574
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       USART_GetITStatus
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD103             BNE.N    ??USART1_IRQHandler_2
   1535          	{
   1536          		USART_ClearITPendingBit(USART1, USART_IT_TC);
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       USART_ClearITPendingBit
   1537          	}
   1538          	// Over Run Error Clear
   1539          	if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) == SET)
   \                     ??USART1_IRQHandler_2: (+1)
   \   00000050   0x2108             MOVS     R1,#+8
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD108             BNE.N    ??USART1_IRQHandler_3
   1540          	{
   1541          		USART_ClearFlag(USART1, USART_FLAG_ORE);
   \   0000005C   0x2108             MOVS     R1,#+8
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       USART_ClearFlag
   1542          		USART_ReceiveData(USART1);
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000006A   0x.... 0x....      B.W      USART_ReceiveData
   1543          	}
   1544          
   1545          }
   \                     ??USART1_IRQHandler_3: (+1)
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1546          
   1547          
   1548          /*
   1549          ********************************************************************************
   1550          * Description : USART2_IRQHandler
   1551          * Arguments   : none
   1552          * Return      : 
   1553          * Note        : USART2 Interrupt Service Routine 
   1554          ******************************************************************************** 
   1555          */
   1556          

   \                                 In section .text, align 2, keep-with-next
   1557          void USART2_IRQHandler(void)
   1558          {
   \                     USART2_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1559            uint8_t rdata;  
   1560          	if(USART_GetITStatus(USART2, USART_IT_RXNE) == SET)
   \   00000002   0x....             LDR.N    R4,??DataTable38_10  ;; 0x40004400
   \   00000004   0xF240 0x5525      MOVW     R5,#+1317
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USART_GetITStatus
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD107             BNE.N    ??USART2_IRQHandler_0
   1561          	{
   1562          	  rdata = (uint8_t)(USART2->DR & (uint8_t)0x00FF);
   \   00000014   0x88A0             LDRH     R0,[R4, #+4]
   1563              ModemCommPutRxChar(rdata);    
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x.... 0x....      BL       ModemCommPutRxChar
   1564          		USART_ClearITPendingBit(USART2, USART_IT_RXNE);
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       USART_ClearITPendingBit
   1565          	}
   1566          
   1567          	if(USART_GetITStatus(USART2, USART_IT_TC) == SET)
   \                     ??USART2_IRQHandler_0: (+1)
   \   00000024   0xF240 0x6526      MOVW     R5,#+1574
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       USART_GetITStatus
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD103             BNE.N    ??USART2_IRQHandler_1
   1568          	{
   1569          		USART_ClearITPendingBit(USART2, USART_IT_TC);
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       USART_ClearITPendingBit
   1570          	}
   1571          	// Over Run Error Clear
   1572          	if (USART_GetFlagStatus(USART2, USART_FLAG_ORE) == SET)
   \                     ??USART2_IRQHandler_1: (+1)
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD108             BNE.N    ??USART2_IRQHandler_2
   1573          	{
   1574          		USART_ClearFlag(USART2, USART_FLAG_ORE);
   \   00000048   0x2108             MOVS     R1,#+8
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       USART_ClearFlag
   1575          		USART_ReceiveData(USART2);
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000056   0x.... 0x....      B.W      USART_ReceiveData
   1576          	}
   1577          
   1578          }
   \                     ??USART2_IRQHandler_2: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1579          
   1580          
   1581          /*
   1582          *********************************************************************************************************
   1583          *********************************************************************************************************
   1584          *                                            EXTERN API FUNCTIONS
   1585          *********************************************************************************************************
   1586          *********************************************************************************************************
   1587          */
   1588          
   1589          /*
   1590          ********************************************************************************
   1591          * Description : BSP_LED_Toggle
   1592          * Arguments   : led control
   1593          * Return      : 
   1594          * Note        : LED Toggle.. system alive check
   1595          ******************************************************************************** 
   1596          */
   1597          

   \                                 In section .text, align 2, keep-with-next
   1598          void BSP_LED_Toggle(INT8U led)
   1599          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable38_2  ;; 0x40021000
   \   00000006   0xE000             B.N      ??BSP_LED_Toggle_0
   1600              CPU_INT32U pins;
   1601          
   1602              pins = GPIO_ReadOutputData(GPIOE);
   1603          
   1604              switch(led){
   1605                  case 0:
   1606                       BSP_LED_Toggle(1);
   \                     ??BSP_LED_Toggle_1: (+1)
   \   00000008   0x2401             MOVS     R4,#+1
   1607                       break;
   \                     ??BSP_LED_Toggle_0: (+1)
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       GPIO_ReadOutputData
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD0F9             BEQ.N    ??BSP_LED_Toggle_1
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD10D             BNE.N    ??BSP_LED_Toggle_2
   1608          
   1609                  case 1:
   1610                       if ((pins & GPIO_Pin_1) == 0) {
   \   00000018   0x0780             LSLS     R0,R0,#+30
   \   0000001A   0xD405             BMI.N    ??BSP_LED_Toggle_3
   1611                           GPIO_SetBits(  GPIOE, GPIO_Pin_1);
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000024   0x.... 0x....      B.W      GPIO_SetBits
   1612                       } else {
   1613                           GPIO_ResetBits(GPIOE, GPIO_Pin_1);
   \                     ??BSP_LED_Toggle_3: (+1)
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000030   0x.... 0x....      B.W      GPIO_ResetBits
   1614                       }
   1615                      break;		
   1616          
   1617                  default:
   1618                       break;
   1619              }
   1620          }
   \                     ??BSP_LED_Toggle_2: (+1)
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1621          
   1622          
   1623          /*
   1624          ********************************************************************************
   1625          * Description : system_power_off
   1626          * Arguments   : None
   1627          * Return      : 
   1628          * Note        : system power off
   1629          ******************************************************************************** 
   1630          */
   1631          

   \                                 In section .text, align 2, keep-with-next
   1632          void system_power_off(void)
   1633          {
   1634          	GPIO_ResetBits(  GPIOE, GPIO_Pin_4 );
   \                     system_power_off: (+1)
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0x....             LDR.N    R0,??DataTable38_2  ;; 0x40021000
   \   00000004   0x.... 0x....      B.W      GPIO_ResetBits
   1635          }
   1636          
   1637          
   1638          /*
   1639          *********************************************************************************************************
   1640          *                                            DEBUG FUNCTIONS
   1641          *********************************************************************************************************
   1642          */
   1643          
   1644          /*
   1645          ********************************************************************************
   1646          * Description : dbg_tasklist
   1647          * Arguments   : none
   1648          * Return      : 
   1649          * Note        : RTOS task list display
   1650          ******************************************************************************** 
   1651          */

   \                                 In section .bss, align 4
   1652          portCHAR TaskListBuf[512];
   \                     TaskListBuf:
   \   00000000                      DS8 512

   \                                 In section .text, align 2, keep-with-next
   1653          INT16U dbg_tasklist(void)
   1654          {
   \                     dbg_tasklist: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1655          	memset(TaskListBuf, 0,512);
   \   00000002   0x....             LDR.N    R4,??DataTable38_37
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF44F 0x7100      MOV      R1,#+512
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memset4
   1656          	vTaskList((signed char *)(TaskListBuf + strlen(TaskListBuf)));
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       strlen
   \   00000016   0x4420             ADD      R0,R4,R0
   \   00000018   0x.... 0x....      BL       vTaskList
   1657          	printk("\nName          State  Priority  Stack   Num\n" );
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       printk
   1658          	printk("---------------------------------------------\n");
   \   00000024   0x.... 0x....      ADR.W    R5,?_1
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       printk
   1659          	printk("%s\n",TaskListBuf);
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x....             ADR.N    R0,??DataTable38_3  ;; "%s\n"
   \   00000032   0x.... 0x....      BL       printk
   1660          	printk("---------------------------------------------\n");
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       printk
   1661          	printk("B : Blocked, R : Ready, D : Deleted, S : Suspended\n");
   \   0000003C   0x.... 0x....      ADR.W    R0,?_3
   \   00000040   0x.... 0x....      BL       printk
   1662          
   1663          	return NO_DISPLAY;
   \   00000044   0x20C9             MOVS     R0,#+201
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1664          }
   1665          
   1666          
   1667          /*
   1668          ********************************************************************************
   1669          * Description : dbg_system_reset
   1670          * Arguments   : none
   1671          * Return      : 
   1672          * Note        : 시스템 리셋 
   1673          ******************************************************************************** 
   1674          */
   1675          

   \                                 In section .text, align 2, keep-with-next
   1676          INT16U dbg_system_reset(void)
   1677          {
   \                     dbg_system_reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1678          	vTaskEndScheduler();
   \   00000002   0x.... 0x....      BL       vTaskEndScheduler
   1679          	NVIC_SystemReset();
   \   00000006   0x.... 0x....      BL       NVIC_SystemReset
   1680          	return NO_DISPLAY;
   \   0000000A   0x20C9             MOVS     R0,#+201
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
   1681          }
   1682          
   1683          
   1684          /*
   1685          ********************************************************************************
   1686          * Description : dbg_ver_rollup
   1687          * Arguments   : none
   1688          * Return      : 
   1689          * Note        : 마지막 펌웨어 업데이트
   1690          ******************************************************************************** 
   1691          */
   1692          

   \                                 In section .text, align 2, keep-with-next
   1693          INT16U dbg_ver_rollup(void)
   1694          {
   \                     dbg_ver_rollup: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1695          	memcpy((char*)tPrjcode.boot_seq,"download",8);
   \   00000002   0x....             LDR.N    R4,??DataTable38_38
   \   00000004   0x2208             MOVS     R2,#+8
   \   00000006   0x.... 0x....      ADR.W    R1,?_4
   \   0000000A   0xF104 0x000A      ADD      R0,R4,#+10
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   1696          	SPI_FLASH_PageErase(PROJECT_BASE);
   \   00000012   0xF44F 0x0050      MOV      R0,#+13631488
   \   00000016   0x.... 0x....      BL       SPI_FLASH_PageErase
   1697          	SPI_FLASH_BufferWrite((INT8U *)&tPrjcode, PROJECT_BASE, sizeof(Prjcode_t));	
   \   0000001A   0x221C             MOVS     R2,#+28
   \   0000001C   0xF44F 0x0150      MOV      R1,#+13631488
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       SPI_FLASH_BufferWrite
   1698          
   1699          	NVIC_SystemReset();
   \   00000026   0x.... 0x....      BL       NVIC_SystemReset
   1700          	return NO_DISPLAY;	
   \   0000002A   0x20C9             MOVS     R0,#+201
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1701          }
   1702          
   1703          
   1704          /*
   1705          ********************************************************************************
   1706          * Description : dbg_ver_rollback
   1707          * Arguments   : none
   1708          * Return      : 
   1709          * Note        : 다운로드 이전 펌웨어 업데이트 
   1710          ******************************************************************************** 
   1711          */
   1712          

   \                                 In section .text, align 2, keep-with-next
   1713          INT16U dbg_ver_rollback(void)
   1714          {
   \                     dbg_ver_rollback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1715          	memcpy((char*)tPrjcode.boot_seq,"rollback",8);
   \   00000002   0x....             LDR.N    R4,??DataTable38_38
   \   00000004   0x2208             MOVS     R2,#+8
   \   00000006   0x.... 0x....      ADR.W    R1,?_5
   \   0000000A   0xF104 0x000A      ADD      R0,R4,#+10
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   1716          	SPI_FLASH_PageErase(PROJECT_BASE);
   \   00000012   0xF44F 0x0050      MOV      R0,#+13631488
   \   00000016   0x.... 0x....      BL       SPI_FLASH_PageErase
   1717          	SPI_FLASH_BufferWrite((INT8U *)&tPrjcode, PROJECT_BASE, sizeof(Prjcode_t));
   \   0000001A   0x221C             MOVS     R2,#+28
   \   0000001C   0xF44F 0x0150      MOV      R1,#+13631488
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       SPI_FLASH_BufferWrite
   1718          
   1719          	NVIC_SystemReset();
   \   00000026   0x.... 0x....      BL       NVIC_SystemReset
   1720          	return NO_DISPLAY;
   \   0000002A   0x20C9             MOVS     R0,#+201
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1721          }
   1722          
   1723          
   1724          /*
   1725          ********************************************************************************
   1726          * Description : dbg_rtc_setTest
   1727          * Arguments   : none
   1728          * Return      : 
   1729          * Note        : RTC time set
   1730          ******************************************************************************** 
   1731          */

   \                                 In section .text, align 2, keep-with-next
   1732          INT16U dbg_rtc_setTest(void)
   1733          {
   \                     dbg_rtc_setTest: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   1734          	sysinfo_t *s = &_sysinfo 	;
   1735          	INT32U yy,mon,day,hh,mm,ss,wday;
   1736          
   1737          	if(CLI_GetArgCnt() < 7) return INV_PRM;
   \   00000004   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000008   0x2807             CMP      R0,#+7
   \   0000000A   0xD201             BCS.N    ??dbg_rtc_setTest_0
   \   0000000C   0x20CA             MOVS     R0,#+202
   \   0000000E   0xE044             B.N      ??dbg_rtc_setTest_1
   1738          	
   1739          	yy  = comparison_num((char *)P_ARG(1));
   \                     ??dbg_rtc_setTest_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       Argument
   \   00000016   0x.... 0x....      BL       comparison_num
   \   0000001A   0x4604             MOV      R4,R0
   1740          	mon = comparison_num((char *)P_ARG(2));
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       Argument
   \   00000022   0x.... 0x....      BL       comparison_num
   \   00000026   0x4605             MOV      R5,R0
   1741          	day= comparison_num((char *)P_ARG(3));
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       Argument
   \   0000002E   0x.... 0x....      BL       comparison_num
   \   00000032   0x4606             MOV      R6,R0
   1742          	hh  = comparison_num((char *)P_ARG(4));
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0x.... 0x....      BL       Argument
   \   0000003A   0x.... 0x....      BL       comparison_num
   \   0000003E   0x4607             MOV      R7,R0
   1743          	mm  = comparison_num((char *)P_ARG(5));
   \   00000040   0x2005             MOVS     R0,#+5
   \   00000042   0x.... 0x....      BL       Argument
   \   00000046   0x.... 0x....      BL       comparison_num
   \   0000004A   0x4680             MOV      R8,R0
   1744          	ss  = comparison_num((char *)P_ARG(6));
   \   0000004C   0x2006             MOVS     R0,#+6
   \   0000004E   0x.... 0x....      BL       Argument
   \   00000052   0x.... 0x....      BL       comparison_num
   \   00000056   0x4681             MOV      R9,R0
   1745          	wday= comparison_num((char *)P_ARG(7));
   \   00000058   0x2007             MOVS     R0,#+7
   \   0000005A   0x.... 0x....      BL       Argument
   \   0000005E   0x.... 0x....      BL       comparison_num
   1746          
   1747          	MakeTimePtr(&s->tm_ptr,yy, mon, day, hh, mm, ss,wday);
   \   00000062   0x.... 0x....      LDR.W    R10,??DataTable38_33
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0x9003             STR      R0,[SP, #+12]
   \   0000006A   0xFA5F 0xF989      UXTB     R9,R9
   \   0000006E   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000072   0xFA5F 0xF888      UXTB     R8,R8
   \   00000076   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   0000007A   0xB2FF             UXTB     R7,R7
   \   0000007C   0x9700             STR      R7,[SP, #+0]
   \   0000007E   0x4633             MOV      R3,R6
   \   00000080   0xB2DB             UXTB     R3,R3
   \   00000082   0x462A             MOV      R2,R5
   \   00000084   0xB2D2             UXTB     R2,R2
   \   00000086   0x4621             MOV      R1,R4
   \   00000088   0xF10A 0x001C      ADD      R0,R10,#+28
   \   0000008C   0x.... 0x....      BL       MakeTimePtr
   1748          
   1749          	SetRTCTime(&s->tm_ptr);
   \   00000090   0xF10A 0x001C      ADD      R0,R10,#+28
   \   00000094   0x.... 0x....      BL       SetRTCTime
   1750          
   1751          	return NO_DISPLAY;
   \   00000098   0x20C9             MOVS     R0,#+201
   \                     ??dbg_rtc_setTest_1: (+1)
   \   0000009A   0xB004             ADD      SP,SP,#+16
   \   0000009C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1752          }
   1753          
   1754          /*
   1755          ********************************************************************************
   1756          * Description : dbg_rtc_gettimeTest
   1757          * Arguments   : none
   1758          * Return      : 
   1759          * Note        : RTC time read
   1760          ******************************************************************************** 
   1761          */

   \                                 In section .text, align 2, keep-with-next
   1762          INT16U dbg_rtc_gettimeTest(void)
   1763          {
   \                     dbg_rtc_gettimeTest: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1764          
   1765          	sysinfo_t *s = &_sysinfo 	;
   1766          
   1767          	printk("Read RTC Sec = %s\n",btime2str(&s->tm_ptr, "y-m-d h:mi:s"));
   \   00000002   0x.... 0x....      ADR.W    R1,?_7
   \   00000006   0x....             LDR.N    R0,??DataTable38_16
   \   00000008   0x.... 0x....      BL       btime2str
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x.... 0x....      ADR.W    R0,?_6
   \   00000012   0x.... 0x....      BL       printk
   1768          
   1769              return NO_DISPLAY;
   \   00000016   0x20C9             MOVS     R0,#+201
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
   1770          
   1771          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_8:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_9:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_10:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_11:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_12:
   \   00000000   0x4001204C         DC32     0x4001204c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_13:
   \   00000000   0x........         DC32     adcdata

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_14:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_15:
   \   00000000   0x........         DC32     Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_16:
   \   00000000   0x........         DC32     _sysinfo+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_17:
   \   00000000   0x........         DC32     Flags1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_18:
   \   00000000   0x........         DC32     Start_Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_19:
   \   00000000   0x........         DC32     SaveCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_20:
   \   00000000   0x00030001         DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_21:
   \   00000000   0x00040040         DC32     0x40040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_22:
   \   00000000   0x........         DC32     I2C_DIR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_23:
   \   00000000   0x........         DC32     I2CADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_24:
   \   00000000   0x........         DC32     tx_buffer_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_25:
   \   00000000   0x........         DC32     tx_buffer_ix

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_26:
   \   00000000   0x........         DC32     tx_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_27:
   \   00000000   0x........         DC32     I2C_BLOCKED

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_28:
   \   00000000   0x........         DC32     rx_buffer_ix

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_29:
   \   00000000   0x........         DC32     rx_buffer_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_30:
   \   00000000   0x........         DC32     rx_buffer_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_31:
   \   00000000   0x01000400         DC32     0x1000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_32:
   \   00000000   0x........         DC32     Can_RxMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_33:
   \   00000000   0x........         DC32     _sysinfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_34:
   \   00000000   0x........         DC32     GPS_RxHead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_35:
   \   00000000   0x........         DC32     GPS_RxTail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_36:
   \   00000000   0x........         DC32     GPS_RxBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_37:
   \   00000000   0x........         DC32     TaskListBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_38:
   \   00000000   0x........         DC32     tPrjcode

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x0A 0x4E          DC8 "\012Name          State  Priority  Stack   Num\012"
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x74 0x65    
   \              0x20 0x20    
   \              0x50 0x72    
   \              0x69 0x6F    
   \              0x72 0x69    
   \              0x74 0x79    
   \              0x20 0x20    
   \              0x53 0x74    
   \              0x61 0x63    
   \              0x6B 0x20    
   \              0x20 0x20    
   \              0x4E 0x75    
   \              0x6D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2D 0x2D          DC8 "---------------------------------------------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x0A    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x42 0x20          DC8 42H, 20H, 3AH, 20H, 42H, 6CH, 6FH, 63H
   \              0x3A 0x20    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \   00000008   0x6B 0x65          DC8 6BH, 65H, 64H, 2CH, 20H, 52H, 20H, 3AH
   \              0x64 0x2C    
   \              0x20 0x52    
   \              0x20 0x3A    
   \   00000010   0x20 0x52          DC8 20H, 52H, 65H, 61H, 64H, 79H, 2CH, 20H
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x2C 0x20    
   \   00000018   0x44 0x20          DC8 44H, 20H, 3AH, 20H, 44H, 65H, 6CH, 65H
   \              0x3A 0x20    
   \              0x44 0x65    
   \              0x6C 0x65    
   \   00000020   0x74 0x65          DC8 74H, 65H, 64H, 2CH, 20H, 53H, 20H, 3AH
   \              0x64 0x2C    
   \              0x20 0x53    
   \              0x20 0x3A    
   \   00000028   0x20 0x53          DC8 20H, 53H, 75H, 73H, 70H, 65H, 6EH, 64H
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \   00000030   0x65 0x64          DC8 65H, 64H, 0AH, 0
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x64 0x6F          DC8 "download"
   \              0x77 0x6E    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x72 0x6F          DC8 "rollback"
   \              0x6C 0x6C    
   \              0x62 0x61    
   \              0x63 0x6B    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x52 0x65          DC8 "Read RTC Sec = %s\012"
   \              0x61 0x64    
   \              0x20 0x52    
   \              0x54 0x43    
   \              0x20 0x53    
   \              0x65 0x63    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x79 0x2D          DC8 "y-m-d h:mi:s"
   \              0x6D 0x2D    
   \              0x64 0x20    
   \              0x68 0x3A    
   \              0x6D 0x69    
   \              0x3A 0x73    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1772          
   1773          /*
   1774          ********************* (C) COPYRIGHT 2014 Loop ***************END OF FILE*****************************
   1775          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_ADC1ConStart
         0   -> ADC_SoftwareStartConv
      72   BSP_ADC1_DMA_Init
        72   -> ADC_DeInit
        72   -> DMA_Cmd
        72   -> DMA_DeInit
        72   -> DMA_Init
        72   -> RCC_AHB1PeriphClockCmd
      56   BSP_ADC1_Init
        56   -> ADC_Cmd
        56   -> ADC_CommonInit
        56   -> ADC_DMACmd
        56   -> ADC_DMARequestAfterLastTransferCmd
        56   -> ADC_Init
        56   -> ADC_RegularChannelConfig
        56   -> BSP_ADC1ConStart
        56   -> BSP_ADC1_DMA_Init
        56   -> GPIO_Init
        56   -> RCC_AHB1PeriphClockCmd
        56   -> RCC_APB2PeriphClockCmd
      56   BSP_CAN1_Init
        56   -> CAN_DeInit
        56   -> CAN_FilterInit
        56   -> CAN_ITConfig
        56   -> CAN_Init
        56   -> GPIO_Init
        56   -> GPIO_PinAFConfig
        56   -> RCC_AHB1PeriphClockCmd
        56   -> RCC_APB1PeriphClockCmd
       0   BSP_CAN_Init
         0   -> BSP_CAN1_Init
      24   BSP_CPU_ClkFreq
        24   -> RCC_GetClocksFreq
      24   BSP_EXTI_Init
        24   -> EXTI_Init
        24   -> GPIO_Init
        24   -> RCC_AHB1PeriphClockCmd
        24   -> RCC_APB2PeriphClockCmd
        24   -> SYSCFG_EXTILineConfig
      16   BSP_GPIO_Init
        16   -> GPIO_Init
        16   -> GPIO_WriteBit
        16   -> RCC_AHB1PeriphClockCmd
      40   BSP_I2C1_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> I2C_Cmd
        40   -> I2C_DeInit
        40   -> I2C_ITConfig
        40   -> I2C_Init
        40   -> I2C_StructInit
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
       8   BSP_IWDG_Init
         0   -> IWDG_Enable
         8   -> IWDG_ReloadCounter
         8   -> IWDG_SetPrescaler
         8   -> IWDG_SetReload
         8   -> IWDG_WriteAccessCmd
         8   -> RCC_ClearFlag
         8   -> RCC_GetFlagStatus
         8   -> SysTick_CLKSourceConfig
      16   BSP_LED_Toggle
        16   -> GPIO_ReadOutputData
         0   -> GPIO_ResetBits
         0   -> GPIO_SetBits
       8   BSP_Lowlevel_Init
         8   -> BSP_ADC1_Init
         8   -> BSP_EXTI_Init
         8   -> BSP_GPIO_Init
         8   -> BSP_I2C1_Init
         8   -> BSP_IWDG_Init
         8   -> BSP_NVIC_Init
         8   -> BSP_RTC_Init
         8   -> BSP_SPI1_Init
         8   -> BSP_SPI2_Init
         8   -> BSP_USART1_Init
         8   -> BSP_USART2_Init
         8   -> RCC_DeInit
         8   -> RCC_HSEConfig
         0   -> SD_DeInit
         8   -> SystemInit
       8   BSP_NVIC_Init
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> NVIC_SetVectorTable
      32   BSP_RTC_Init
        32   -> EXTI_ClearITPendingBit
        32   -> EXTI_Init
        32   -> NVIC_Init
        32   -> PWR_BackupAccessCmd
        32   -> RCC_APB1PeriphClockCmd
        32   -> RCC_GetFlagStatus
        32   -> RCC_LSEConfig
        32   -> RCC_RTCCLKCmd
        32   -> RCC_RTCCLKConfig
        32   -> RTC_ClearITPendingBit
        32   -> RTC_ITConfig
        32   -> RTC_Init
        32   -> RTC_SetWakeUpCounter
        32   -> RTC_WaitForSynchro
        32   -> RTC_WakeUpClockConfig
        32   -> RTC_WakeUpCmd
      40   BSP_SPI1_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> GPIO_SetBits
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_Init
      40   BSP_SPI2_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> GPIO_SetBits
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_Init
       0   BSP_UART1RX_IntEnable
         0   -> USART_ITConfig
       0   BSP_UART2RX_IntEnable
         0   -> USART_ITConfig
      32   BSP_USART1_Init
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> RCC_AHB1PeriphClockCmd
        32   -> RCC_APB2PeriphClockCmd
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
      32   BSP_USART2_Init
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> RCC_AHB1PeriphClockCmd
        32   -> RCC_APB1PeriphClockCmd
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
       8   CAN1_RX0_IRQHandler
         0   -> CAN_ClearITPendingBit
         8   -> CAN_Decode
         8   -> CAN_GetITStatus
         8   -> CAN_Receive_mk
       4   CAN_Receive_mk
       8   EXTI9_5_IRQHandler
         0   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
      16   I2C1_ER_IRQHandler
         0   -> I2C_ClearITPendingBit
        16   -> I2C_GetITStatus
       0   I2C1_EV_IRQHandler
         0   -> I2C_Serve
      16   I2C_Serve
        16   -> I2C_AcknowledgeConfig
         0   -> I2C_GenerateSTART
         0   -> I2C_GenerateSTOP
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetLastEvent
        16   -> I2C_ReceiveData
        16   -> I2C_Send7bitAddress
         0   -> I2C_SendData
       0   NVIC_SystemReset
       0   OS_CPU_SysTickClkFreq
         0   -> BSP_CPU_ClkFreq
       8   RTC_WKUP_IRQHandler
         0   -> EXTI_ClearITPendingBit
         8   -> GetRTCTime
         8   -> RTC_ClearITPendingBit
         8   -> RTC_GetITStatus
      16   USART1_IRQHandler
        16   -> USART_ClearFlag
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
        16   -> USART_GetITStatus
         0   -> USART_ReceiveData
      16   USART2_IRQHandler
        16   -> ModemCommPutRxChar
        16   -> USART_ClearFlag
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
        16   -> USART_GetITStatus
         0   -> USART_ReceiveData
       8   dbg_rtc_gettimeTest
         8   -> btime2str
         8   -> printk
      48   dbg_rtc_setTest
        48   -> Argument
        48   -> CLI_GetArgCnt
        48   -> MakeTimePtr
        48   -> SetRTCTime
        48   -> comparison_num
       8   dbg_system_reset
         8   -> NVIC_SystemReset
         8   -> vTaskEndScheduler
      16   dbg_tasklist
        16   -> __aeabi_memset4
        16   -> printk
        16   -> strlen
        16   -> vTaskList
       8   dbg_ver_rollback
         8   -> NVIC_SystemReset
         8   -> SPI_FLASH_BufferWrite
         8   -> SPI_FLASH_PageErase
         8   -> __aeabi_memcpy
       8   dbg_ver_rollup
         8   -> NVIC_SystemReset
         8   -> SPI_FLASH_BufferWrite
         8   -> SPI_FLASH_PageErase
         8   -> __aeabi_memcpy
       0   system_power_off
         0   -> GPIO_ResetBits


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable30
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_10
       4  ??DataTable38_11
       4  ??DataTable38_12
       4  ??DataTable38_13
       4  ??DataTable38_14
       4  ??DataTable38_15
       4  ??DataTable38_16
       4  ??DataTable38_17
       4  ??DataTable38_18
       4  ??DataTable38_19
       4  ??DataTable38_2
       4  ??DataTable38_20
       4  ??DataTable38_21
       4  ??DataTable38_22
       4  ??DataTable38_23
       4  ??DataTable38_24
       4  ??DataTable38_25
       4  ??DataTable38_26
       4  ??DataTable38_27
       4  ??DataTable38_28
       4  ??DataTable38_29
       4  ??DataTable38_3
       4  ??DataTable38_30
       4  ??DataTable38_31
       4  ??DataTable38_32
       4  ??DataTable38_33
       4  ??DataTable38_34
       4  ??DataTable38_35
       4  ??DataTable38_36
       4  ??DataTable38_37
       4  ??DataTable38_38
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable38_8
       4  ??DataTable38_9
      48  ?_0
      48  ?_1
       4  ?_2
      52  ?_3
      12  ?_4
      12  ?_5
      20  ?_6
      16  ?_7
       8  BSP_ADC1ConStart
     120  BSP_ADC1_DMA_Init
     150  BSP_ADC1_Init
     416  BSP_CAN1_Init
       2  BSP_CAN_Init
      16  BSP_CPU_ClkFreq
      92  BSP_EXTI_Init
     502  BSP_GPIO_Init
     168  BSP_I2C1_Init
      58  BSP_IWDG_Init
      54  BSP_LED_Toggle
      68  BSP_Lowlevel_Init
     202  BSP_NVIC_Init
     196  BSP_RTC_Init
     256  BSP_SPI1_Init
     268  BSP_SPI2_Init
      14  BSP_UART1RX_IntEnable
      14  BSP_UART2RX_IntEnable
     152  BSP_USART1_Init
     152  BSP_USART2_Init
      44  CAN1_RX0_IRQHandler
      40  CAN_MON_ID
     126  CAN_Receive_mk
      30  EXTI9_5_IRQHandler
      32  I2C1_ER_IRQHandler
       4  I2C1_EV_IRQHandler
     312  I2C_Serve
      30  NVIC_SystemReset
       2  OS_CPU_SysTickClkFreq
     114  RTC_WKUP_IRQHandler
     512  TaskListBuf
     112  USART1_IRQHandler
      92  USART2_IRQHandler
       4  adcdata
      26  dbg_rtc_gettimeTest
     160  dbg_rtc_setTest
      14  dbg_system_reset
      72  dbg_tasklist
      46  dbg_ver_rollback
      46  dbg_ver_rollup
       8  system_power_off

 
   516 bytes in section .bss
    44 bytes in section .rodata
 4 562 bytes in section .text
 
 4 562 bytes of CODE  memory
    44 bytes of CONST memory
   516 bytes of DATA  memory

Errors: none
Warnings: none
