###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_cryp_tdes.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_cryp_tdes.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\stm32f2xx_cryp_tdes.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\stm32f2xx_cryp_tdes.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_cryp_tdes.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_cryp_tdes.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    07-October-2011
      7            * @brief   This file provides high level functions to encrypt and decrypt an 
      8            *          input message using TDES in ECB/CBC modes .
      9            *          It uses the stm32f2xx_cryp.c/.h drivers to access the STM32F2xx CRYP
     10            *          peripheral.
     11            *
     12            *  @verbatim
     13            *
     14            *          ===================================================================
     15            *                                   How to use this driver
     16            *          ===================================================================
     17            *          1. Enable The CRYP controller clock using 
     18            *            RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
     19            *
     20            *          2. Encrypt and decrypt using TDES in ECB Mode using CRYP_TDES_ECB()
     21            *             function.
     22            *
     23            *          3. Encrypt and decrypt using TDES in CBC Mode using CRYP_TDES_CBC()
     24            *             function.
     25            *
     26            *  @endverbatim
     27            *
     28            ******************************************************************************
     29            * @attention
     30            *
     31            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     32            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     33            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     34            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     35            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     36            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     37            *
     38            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     39            ******************************************************************************
     40            */ 
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32f2xx_cryp.h"
     44          
     45          
     46          /** @addtogroup STM32F2xx_StdPeriph_Driver
     47            * @{
     48            */
     49          
     50          /** @defgroup CRYP 
     51            * @brief CRYP driver modules
     52            * @{
     53            */
     54          
     55          /* Private typedef -----------------------------------------------------------*/
     56          /* Private define ------------------------------------------------------------*/
     57          #define TDESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
     58          
     59          /* Private macro -------------------------------------------------------------*/
     60          /* Private variables ---------------------------------------------------------*/
     61          /* Private function prototypes -----------------------------------------------*/
     62          /* Private functions ---------------------------------------------------------*/
     63          
     64          
     65          /** @defgroup CRYP_Private_Functions
     66            * @{
     67            */ 
     68          
     69          /** @defgroup CRYP_Group7 High Level TDES functions
     70           *  @brief   High Level TDES functions 
     71           *
     72          @verbatim   
     73           ===============================================================================
     74                                    High Level TDES functions
     75           ===============================================================================
     76          
     77          
     78          @endverbatim
     79            * @{
     80            */
     81          
     82          /**
     83            * @brief  Encrypt and decrypt using TDES in ECB Mode
     84            * @param  Mode: encryption or decryption Mode.
     85            *           This parameter can be one of the following values:
     86            *            @arg MODE_ENCRYPT: Encryption
     87            *            @arg MODE_DECRYPT: Decryption
     88            * @param  Key: Key used for TDES algorithm.
     89            * @param  Ilength: length of the Input buffer, must be a multiple of 8.
     90            * @param  Input: pointer to the Input buffer.
     91            * @param  Output: pointer to the returned buffer.
     92            * @retval An ErrorStatus enumeration value:
     93            *          - SUCCESS: Operation done
     94            *          - ERROR: Operation failed
     95            */

   \                                 In section .text, align 2, keep-with-next
     96          ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
     97                                    uint32_t Ilength, uint8_t *Output)
     98          {
   \                     CRYP_TDES_ECB: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x461C             MOV      R4,R3
     99            CRYP_InitTypeDef TDES_CRYP_InitStructure;
    100            CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
    101            __IO uint32_t counter = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
    102            uint32_t busystatus = 0;
    103            ErrorStatus status = SUCCESS;
   \   00000012   0x2501             MOVS     R5,#+1
    104            uint32_t keyaddr    = (uint32_t)Key;
    105            uint32_t inputaddr  = (uint32_t)Input;
    106            uint32_t outputaddr = (uint32_t)Output;
   \   00000014   0x9E14             LDR      R6,[SP, #+80]
    107            uint32_t i = 0;
   \   00000016   0x4607             MOV      R7,R0
    108          
    109            /* Crypto structures initialisation*/
    110            CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
   \   00000018   0xA803             ADD      R0,SP,#+12
   \   0000001A   0x.... 0x....      BL       CRYP_KeyStructInit
    111          
    112            /* Crypto Init for Encryption process */
    113            if(Mode == MODE_ENCRYPT) /* TDES encryption */
   \   0000001E   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000022   0xD103             BNE.N    ??CRYP_TDES_ECB_0
    114            {
    115               TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \   00000024   0x4638             MOV      R0,R7
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000002A   0xE002             B.N      ??CRYP_TDES_ECB_1
    116            }
    117            else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
    118            {
    119               TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_TDES_ECB_0: (+1)
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    120            }
    121          
    122            TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
   \                     ??CRYP_TDES_ECB_1: (+1)
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    123            TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000038   0x2080             MOVS     R0,#+128
   \   0000003A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    124            CRYP_Init(&TDES_CRYP_InitStructure);
   \   0000003E   0xA801             ADD      R0,SP,#+4
   \   00000040   0x.... 0x....      BL       CRYP_Init
    125          
    126            /* Key Initialisation */
    127            TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000044   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000048   0xBA00             REV      R0,R0
   \   0000004A   0x9005             STR      R0,[SP, #+20]
    128            keyaddr+=4;
   \   0000004C   0xF109 0x0004      ADD      R0,R9,#+4
    129            TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xBA09             REV      R1,R1
   \   00000054   0x9106             STR      R1,[SP, #+24]
    130            keyaddr+=4;
   \   00000056   0x1D00             ADDS     R0,R0,#+4
    131            TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xBA09             REV      R1,R1
   \   0000005C   0x9107             STR      R1,[SP, #+28]
    132            keyaddr+=4;
   \   0000005E   0x1D00             ADDS     R0,R0,#+4
    133            TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0xBA09             REV      R1,R1
   \   00000064   0x9108             STR      R1,[SP, #+32]
    134            keyaddr+=4;
   \   00000066   0x1D00             ADDS     R0,R0,#+4
    135            TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xBA09             REV      R1,R1
   \   0000006C   0x9109             STR      R1,[SP, #+36]
    136            keyaddr+=4;
    137            TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000006E   0x1D00             ADDS     R0,R0,#+4
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xBA00             REV      R0,R0
   \   00000074   0x900A             STR      R0,[SP, #+40]
    138            CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
   \   00000076   0xA803             ADD      R0,SP,#+12
   \   00000078   0x.... 0x....      BL       CRYP_KeyInit
    139          
    140            /* Flush IN/OUT FIFO */
    141            CRYP_FIFOFlush();
   \   0000007C   0x.... 0x....      BL       CRYP_FIFOFlush
    142          
    143            /* Enable Crypto processor */
    144            CRYP_Cmd(ENABLE);
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0x.... 0x....      BL       CRYP_Cmd
    145          
    146            for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
   \   00000086   0xE008             B.N      ??CRYP_TDES_ECB_2
    147            {
    148              /* Write the Input block in the Input FIFO */
    149              CRYP_DataIn(*(uint32_t*)(inputaddr));
    150              inputaddr+=4;
    151              CRYP_DataIn(*(uint32_t*)(inputaddr));
    152              inputaddr+=4;
    153          
    154              /* Wait until the complete message has been processed */
    155              counter = 0;
    156              do
    157              {
    158                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    159                counter++;
    160              }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
    161          
    162              if (busystatus != RESET)
    163              {
    164                 status = ERROR;
    165              }
    166              else
    167              {
    168          
    169                /* Read the Output block from the Output FIFO */
    170                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_TDES_ECB_3: (+1)
   \   00000088   0x.... 0x....      BL       CRYP_DataOut
   \   0000008C   0x6030             STR      R0,[R6, #+0]
    171                outputaddr+=4;
   \   0000008E   0x1D36             ADDS     R6,R6,#+4
    172                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000090   0x.... 0x....      BL       CRYP_DataOut
   \   00000094   0x6030             STR      R0,[R6, #+0]
    173                outputaddr+=4;
   \   00000096   0x1D36             ADDS     R6,R6,#+4
    174              }
   \                     ??CRYP_TDES_ECB_4: (+1)
   \   00000098   0x3708             ADDS     R7,R7,#+8
   \                     ??CRYP_TDES_ECB_2: (+1)
   \   0000009A   0x42A7             CMP      R7,R4
   \   0000009C   0xD21F             BCS.N    ??CRYP_TDES_ECB_5
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0xD01D             BEQ.N    ??CRYP_TDES_ECB_5
   \   000000A2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000A6   0x.... 0x....      BL       CRYP_DataIn
   \   000000AA   0xF108 0x0804      ADD      R8,R8,#+4
   \   000000AE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B2   0x.... 0x....      BL       CRYP_DataIn
   \   000000B6   0xF108 0x0804      ADD      R8,R8,#+4
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_TDES_ECB_6: (+1)
   \   000000BE   0x2010             MOVS     R0,#+16
   \   000000C0   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000000C4   0x9900             LDR      R1,[SP, #+0]
   \   000000C6   0x1C49             ADDS     R1,R1,#+1
   \   000000C8   0x9100             STR      R1,[SP, #+0]
   \   000000CA   0x9900             LDR      R1,[SP, #+0]
   \   000000CC   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000000D0   0xD001             BEQ.N    ??CRYP_TDES_ECB_7
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD1F3             BNE.N    ??CRYP_TDES_ECB_6
   \                     ??CRYP_TDES_ECB_7: (+1)
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD0D6             BEQ.N    ??CRYP_TDES_ECB_3
   \   000000DA   0x2500             MOVS     R5,#+0
   \   000000DC   0xE7DC             B.N      ??CRYP_TDES_ECB_4
    175            }
    176          
    177            /* Disable Crypto */
    178            CRYP_Cmd(DISABLE);
   \                     ??CRYP_TDES_ECB_5: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x.... 0x....      BL       CRYP_Cmd
    179          
    180            return status; 
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0xB00C             ADD      SP,SP,#+48
   \   000000E8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    181          }
    182          
    183          /**
    184            * @brief  Encrypt and decrypt using TDES in CBC Mode
    185            * @param  Mode: encryption or decryption Mode.
    186            *           This parameter can be one of the following values:
    187            *            @arg MODE_ENCRYPT: Encryption
    188            *            @arg MODE_DECRYPT: Decryption
    189            * @param  Key: Key used for TDES algorithm.
    190            * @param  InitVectors: Initialisation Vectors used for TDES algorithm.
    191            * @param  Input: pointer to the Input buffer.
    192            * @param  Ilength: length of the Input buffer, must be a multiple of 8.
    193            * @param  Output: pointer to the returned buffer.
    194            * @retval An ErrorStatus enumeration value:
    195            *          - SUCCESS: Operation done
    196            *          - ERROR: Operation failed
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
    199                                    uint8_t *Input, uint32_t Ilength, uint8_t *Output)
    200          {
   \                     CRYP_TDES_CBC: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB090             SUB      SP,SP,#+64
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4691             MOV      R9,R2
    201            CRYP_InitTypeDef TDES_CRYP_InitStructure;
    202            CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
    203            CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
    204            __IO uint32_t counter = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    205            uint32_t busystatus = 0;
    206            ErrorStatus status = SUCCESS;
   \   00000010   0x2501             MOVS     R5,#+1
    207            uint32_t keyaddr    = (uint32_t)Key;
    208            uint32_t inputaddr  = (uint32_t)Input;
   \   00000012   0x461C             MOV      R4,R3
    209            uint32_t outputaddr = (uint32_t)Output;
   \   00000014   0x9F19             LDR      R7,[SP, #+100]
    210            uint32_t ivaddr     = (uint32_t)InitVectors;
    211            uint32_t i = 0;
   \   00000016   0x4606             MOV      R6,R0
    212          
    213            /* Crypto structures initialisation*/
    214            CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
   \   00000018   0xA807             ADD      R0,SP,#+28
   \   0000001A   0x.... 0x....      BL       CRYP_KeyStructInit
    215          
    216            /* Crypto Init for Encryption process */
    217            if(Mode == MODE_ENCRYPT) /* TDES encryption */
   \   0000001E   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000022   0xD103             BNE.N    ??CRYP_TDES_CBC_0
    218            {
    219              TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000002A   0xE002             B.N      ??CRYP_TDES_CBC_1
    220            }
    221            else
    222            {
    223              TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_TDES_CBC_0: (+1)
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    224            }
    225            TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
   \                     ??CRYP_TDES_CBC_1: (+1)
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    226            TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000038   0x2080             MOVS     R0,#+128
   \   0000003A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    227          
    228            CRYP_Init(&TDES_CRYP_InitStructure);
   \   0000003E   0xA801             ADD      R0,SP,#+4
   \   00000040   0x.... 0x....      BL       CRYP_Init
    229          
    230            /* Key Initialisation */
    231            TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000044   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000048   0xBA00             REV      R0,R0
   \   0000004A   0x9009             STR      R0,[SP, #+36]
    232            keyaddr+=4;
   \   0000004C   0xF108 0x0004      ADD      R0,R8,#+4
    233            TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xBA09             REV      R1,R1
   \   00000054   0x910A             STR      R1,[SP, #+40]
    234            keyaddr+=4;
   \   00000056   0x1D00             ADDS     R0,R0,#+4
    235            TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xBA09             REV      R1,R1
   \   0000005C   0x910B             STR      R1,[SP, #+44]
    236            keyaddr+=4;
   \   0000005E   0x1D00             ADDS     R0,R0,#+4
    237            TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0xBA09             REV      R1,R1
   \   00000064   0x910C             STR      R1,[SP, #+48]
    238            keyaddr+=4;
   \   00000066   0x1D00             ADDS     R0,R0,#+4
    239            TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xBA09             REV      R1,R1
   \   0000006C   0x910D             STR      R1,[SP, #+52]
    240            keyaddr+=4;
    241            TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000006E   0x1D00             ADDS     R0,R0,#+4
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xBA00             REV      R0,R0
   \   00000074   0x900E             STR      R0,[SP, #+56]
    242            CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
   \   00000076   0xA807             ADD      R0,SP,#+28
   \   00000078   0x.... 0x....      BL       CRYP_KeyInit
    243          
    244            /* Initialization Vectors */
    245            TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \   0000007C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000080   0xBA00             REV      R0,R0
   \   00000082   0x9003             STR      R0,[SP, #+12]
    246            ivaddr+=4;
    247            TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   00000084   0xF109 0x0004      ADD      R0,R9,#+4
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xBA00             REV      R0,R0
   \   0000008C   0x9004             STR      R0,[SP, #+16]
    248            CRYP_IVInit(&TDES_CRYP_IVInitStructure);
   \   0000008E   0xA803             ADD      R0,SP,#+12
   \   00000090   0x.... 0x....      BL       CRYP_IVInit
    249          
    250            /* Flush IN/OUT FIFO */
    251            CRYP_FIFOFlush();
   \   00000094   0x.... 0x....      BL       CRYP_FIFOFlush
    252          
    253            /* Enable Crypto processor */
    254            CRYP_Cmd(ENABLE);
   \   00000098   0x4628             MOV      R0,R5
   \   0000009A   0x.... 0x....      BL       CRYP_Cmd
    255          
    256            for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
   \   0000009E   0xF8DD 0x8060      LDR      R8,[SP, #+96]
   \   000000A2   0xE008             B.N      ??CRYP_TDES_CBC_2
    257            {
    258              /* Write the Input block in the Input FIFO */
    259              CRYP_DataIn(*(uint32_t*)(inputaddr));
    260              inputaddr+=4;
    261              CRYP_DataIn(*(uint32_t*)(inputaddr));
    262              inputaddr+=4;
    263          
    264              /* Wait until the complete message has been processed */
    265              counter = 0;
    266              do
    267              {
    268                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    269                counter++;
    270              }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
    271          
    272              if (busystatus != RESET)
    273             {
    274                 status = ERROR;
    275              }
    276              else
    277              {
    278          
    279                /* Read the Output block from the Output FIFO */
    280                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_TDES_CBC_3: (+1)
   \   000000A4   0x.... 0x....      BL       CRYP_DataOut
   \   000000A8   0x6038             STR      R0,[R7, #+0]
    281                outputaddr+=4;
   \   000000AA   0x1D3F             ADDS     R7,R7,#+4
    282                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000000AC   0x.... 0x....      BL       CRYP_DataOut
   \   000000B0   0x6038             STR      R0,[R7, #+0]
    283                outputaddr+=4;
   \   000000B2   0x1D3F             ADDS     R7,R7,#+4
    284              }
   \                     ??CRYP_TDES_CBC_4: (+1)
   \   000000B4   0x3608             ADDS     R6,R6,#+8
   \                     ??CRYP_TDES_CBC_2: (+1)
   \   000000B6   0x4546             CMP      R6,R8
   \   000000B8   0xD21B             BCS.N    ??CRYP_TDES_CBC_5
   \   000000BA   0x0028             MOVS     R0,R5
   \   000000BC   0xD019             BEQ.N    ??CRYP_TDES_CBC_5
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x.... 0x....      BL       CRYP_DataIn
   \   000000C4   0x1D24             ADDS     R4,R4,#+4
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x.... 0x....      BL       CRYP_DataIn
   \   000000CC   0x1D24             ADDS     R4,R4,#+4
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_TDES_CBC_6: (+1)
   \   000000D2   0x2010             MOVS     R0,#+16
   \   000000D4   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000000D8   0x9900             LDR      R1,[SP, #+0]
   \   000000DA   0x1C49             ADDS     R1,R1,#+1
   \   000000DC   0x9100             STR      R1,[SP, #+0]
   \   000000DE   0x9900             LDR      R1,[SP, #+0]
   \   000000E0   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000000E4   0xD001             BEQ.N    ??CRYP_TDES_CBC_7
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD1F3             BNE.N    ??CRYP_TDES_CBC_6
   \                     ??CRYP_TDES_CBC_7: (+1)
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD0DA             BEQ.N    ??CRYP_TDES_CBC_3
   \   000000EE   0x2500             MOVS     R5,#+0
   \   000000F0   0xE7E0             B.N      ??CRYP_TDES_CBC_4
    285            }
    286          
    287            /* Disable Crypto */
    288            CRYP_Cmd(DISABLE);
   \                     ??CRYP_TDES_CBC_5: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x.... 0x....      BL       CRYP_Cmd
    289          
    290            return status; 
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0xB010             ADD      SP,SP,#+64
   \   000000FC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    291          }
    292          /**
    293            * @}
    294            */ 
    295          
    296          /**
    297            * @}
    298            */ 
    299          
    300          /**
    301            * @}
    302            */ 
    303          
    304          /**
    305            * @}
    306            */ 
    307          
    308          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      96   CRYP_TDES_CBC
        96   -> CRYP_Cmd
        96   -> CRYP_DataIn
        96   -> CRYP_DataOut
        96   -> CRYP_FIFOFlush
        96   -> CRYP_GetFlagStatus
        96   -> CRYP_IVInit
        96   -> CRYP_Init
        96   -> CRYP_KeyInit
        96   -> CRYP_KeyStructInit
      80   CRYP_TDES_ECB
        80   -> CRYP_Cmd
        80   -> CRYP_DataIn
        80   -> CRYP_DataOut
        80   -> CRYP_FIFOFlush
        80   -> CRYP_GetFlagStatus
        80   -> CRYP_Init
        80   -> CRYP_KeyInit
        80   -> CRYP_KeyStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     256  CRYP_TDES_CBC
     236  CRYP_TDES_ECB

 
 492 bytes in section .text
 
 492 bytes of CODE memory

Errors: none
Warnings: none
