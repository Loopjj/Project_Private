###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:05
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\modem.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\modem.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\modem.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\modem.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\modem.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2017 LOOP *************************************
      3          *
      4          * File Name          : modem.c
      5          *
      6          * Author             : Reserch & Developing 1 Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 012/21/2017
     11          *
     12          * Description        : modem process 
     13          *
     14          *********************************************************************************************************
     15          */
     16          /* Includes ------------------------------------------------------------------*/
     17          #define MODEM_GLOBALS
     18          #include "includes.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char const *, char const *)
   \                     strstr: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SystemReset(void)
   \                     NVIC_SystemReset: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable135  ;; 0xe000ed0c
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable135_1  ;; 0x5fa0004
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0xF3BF 0x8F4F      DSB      
   \                     ??NVIC_SystemReset_0: (+1)
   \   0000001A   0xBF00             Nop      
   \   0000001C   0xE7FD             B.N      ??NVIC_SystemReset_0

   \                                 In section EXTCCRAM, align 4
   \   __absolute u8 ModemTxBuff[40960]
   \                     ModemTxBuff:
   \   00000000                      DS8 40960
     19          #include "modem_Loop.h"
     20          
     21          #define MODEM_TYPE 1 // 0: M66,  1 : UC20/EC20
     22          

   \                                 In section .text, align 4, keep-with-next
     23          const unsigned short crc16tab[256]= {
   \                     crc16tab:
   \   00000000   0x0000 0x1021      DC16 0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161
   \              0x2042 0x3063
   \              0x4084 0x50A5
   \              0x60C6 0x70E7
   \              0x8108 0x9129
   \   00000014   0xA14A 0xB16B      DC16 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786
   \              0xC18C 0xD1AD
   \              0xE1CE 0xF1EF
   \              0x1231 0x0210
   \              0x3273 0x2252
   \   00000028   0x52B5 0x4294      DC16 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205
   \              0x72F7 0x62D6
   \              0x9339 0x8318
   \              0xB37B 0xA35A
   \              0xD3BD       
   \   0000003A   0xC39C 0xF3FF      DC16 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572
   \              0xE3DE 0x2462
   \              0x3443 0x0420
   \              0x1401 0x64E6
   \              0x74C7 0x44A4
   \   0000004E   0x5485 0xA56A      DC16 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669
   \              0xB54B 0x8528
   \              0x9509 0xE5EE
   \              0xF5CF 0xC5AC
   \              0xD58D       
   \   00000060   0x3653 0x2672      DC16 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874
   \              0x1611 0x0630
   \              0x76D7 0x66F6
   \              0x5695 0x46B4
   \              0xB75B 0xA77A
   \   00000074   0x9719 0x8738      DC16 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758
   \              0xF7DF 0xE7FE
   \              0xD79D 0xC7BC
   \              0x48C4 0x58E5
   \              0x6886       
   \   00000086   0x78A7 0x0840      DC16 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144
   \              0x1861 0x2802
   \              0x3823 0xC9CC
   \              0xD9ED 0xE98E
   \              0xF9AF 0x8948
   \   0000009A   0x9969 0xA90A      DC16 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899
   \              0xB92B 0x5AF5
   \              0x4AD4 0x7AB7
   \              0x6A96 0x1A71
   \              0x0A50 0x3A33
   \   000000AE   0x2A12 0xDBFD      DC16 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802
   \              0xCBDC 0xFBBF
   \              0xEB9E 0x9B79
   \              0x8B58 0xBB3B
   \              0xAB1A       
   \   000000C0   0x6CA6 0x7C87      DC16 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911
   \              0x4CE4 0x5CC5
   \              0x2C22 0x3C03
   \              0x0C60 0x1C41
   \              0xEDAE 0xFD8F
   \   000000D4   0xCDEC 0xDDCD      DC16 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277
   \              0xAD2A 0xBD0B
   \              0x8D68 0x9D49
   \              0x7E97 0x6EB6
   \              0x5ED5       
   \   000000E6   0x4EF4 0x3E13      DC16 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923
   \              0x2E32 0x1E51
   \              0x0E70 0xFF9F
   \              0xEFBE 0xDFDD
   \              0xCFFC 0xBF1B
   \   000000FA   0xAF3A 0x9F59      DC16 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453
   \              0x8F78 0x9188
   \              0x81A9 0xB1CA
   \              0xA1EB 0xD10C
   \              0xC12D       
   \   0000010C   0xF14E 0xE16F      DC16 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679
   \              0x1080 0x00A1
   \              0x30C2 0x20E3
   \              0x5004 0x4025
   \              0x7046 0x6067
   \   00000120   0x83B9 0x9398      DC16 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752
   \              0xA3FB 0xB3DA
   \              0xC33D 0xD31C
   \              0xE37F 0xF35E
   \              0x02B1 0x1290
   \   00000134   0x22F3 0x32D2      DC16 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312
   \              0x4235 0x5214
   \              0x6277 0x7256
   \              0xB5EA 0xA5CB
   \              0x95A8       
   \   00000146   0x8589 0xF56E      DC16 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798
   \              0xE54F 0xD52C
   \              0xC50D 0x34E2
   \              0x24C3 0x14A0
   \              0x0481 0x7466
   \   0000015A   0x6447 0x5424      DC16 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358
   \              0x4405 0xA7DB
   \              0xB7FA 0x8799
   \              0x97B8 0xE75F
   \              0xF77E       
   \   0000016C   0xC71D 0xD73C      DC16 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068
   \              0x26D3 0x36F2
   \              0x0691 0x16B0
   \              0x6657 0x7676
   \              0x4615 0x5634
   \   00000180   0xD94C 0xC96D      DC16 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596
   \              0xF90E 0xE92F
   \              0x99C8 0x89E9
   \              0xB98A 0xA9AB
   \              0x5844       
   \   00000192   0x4865 0x7806      DC16 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223
   \              0x6827 0x18C0
   \              0x08E1 0x3882
   \              0x28A3 0xCB7D
   \              0xDB5C 0xEB3F
   \   000001A6   0xFB1E 0x8BF9      DC16 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254
   \              0x9BD8 0xABBB
   \              0xBB9A 0x4A75
   \              0x5A54 0x6A37
   \              0x7A16       
   \   000001B8   0x0AF1 0x1AD0      DC16 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427
   \              0x2AB3 0x3A92
   \              0xFD2E 0xED0F
   \              0xDD6C 0xCD4D
   \              0xBDAA 0xAD8B
   \   000001CC   0x9DE8 0x8DC9      DC16 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265
   \              0x7C26 0x6C07
   \              0x5C64 0x4C45
   \              0x3CA2 0x2C83
   \              0x1CE0 0x0CC1
   \   000001E0   0xEF1F 0xFF3E      DC16 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183
   \              0xCF5D 0xDF7C
   \              0xAF9B 0xBFBA
   \              0x8FD9 0x9FF8
   \              0x6E17       
   \   000001F2   0x7E36 0x4E55      DC16 32310, 20053, 24180, 11923, 16050, 3793, 7920
   \              0x5E74 0x2E93
   \              0x3EB2 0x0ED1
   \              0x1EF0       
     24          0x0000,0x1021,0x2042,0x3063,0x4084,
     25          0x50a5,0x60c6,0x70e7,0x8108,0x9129,
     26          0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,
     27          0xf1ef,0x1231,0x0210,0x3273,0x2252,
     28          0x52b5,0x4294,0x72f7,0x62d6,0x9339,
     29          0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,
     30          0xf3ff,0xe3de,0x2462,0x3443,0x0420,
     31          0x1401,0x64e6,0x74c7,0x44a4,0x5485,
     32          0xa56a,0xb54b,0x8528,0x9509,0xe5ee,
     33          0xf5cf,0xc5ac,0xd58d,0x3653,0x2672,
     34          0x1611,0x0630,0x76d7,0x66f6,0x5695,
     35          0x46b4,0xb75b,0xa77a,0x9719,0x8738,
     36          0xf7df,0xe7fe,0xd79d,0xc7bc,0x48c4,
     37          0x58e5,0x6886,0x78a7,0x0840,0x1861,
     38          0x2802,0x3823,0xc9cc,0xd9ed,0xe98e,
     39          0xf9af,0x8948,0x9969,0xa90a,0xb92b,
     40          0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,
     41          0x0a50,0x3a33,0x2a12,0xdbfd,0xcbdc,
     42          0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,
     43          0xab1a,0x6ca6,0x7c87,0x4ce4,0x5cc5,
     44          0x2c22,0x3c03,0x0c60,0x1c41,0xedae,
     45          0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,
     46          0x8d68,0x9d49,0x7e97,0x6eb6,0x5ed5,
     47          0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
     48          0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,
     49          0xaf3a,0x9f59,0x8f78,0x9188,0x81a9,
     50          0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,
     51          0xe16f,0x1080,0x00a1,0x30c2,0x20e3,
     52          0x5004,0x4025,0x7046,0x6067,0x83b9,
     53          0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,
     54          0xe37f,0xf35e,0x02b1,0x1290,0x22f3,
     55          0x32d2,0x4235,0x5214,0x6277,0x7256,
     56          0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,
     57          0xe54f,0xd52c,0xc50d,0x34e2,0x24c3,
     58          0x14a0,0x0481,0x7466,0x6447,0x5424,
     59          0x4405,0xa7db,0xb7fa,0x8799,0x97b8,
     60          0xe75f,0xf77e,0xc71d,0xd73c,0x26d3,
     61          0x36f2,0x0691,0x16b0,0x6657,0x7676,
     62          0x4615,0x5634,0xd94c,0xc96d,0xf90e,
     63          0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
     64          0x5844,0x4865,0x7806,0x6827,0x18c0,
     65          0x08e1,0x3882,0x28a3,0xcb7d,0xdb5c,
     66          0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,
     67          0xbb9a,0x4a75,0x5a54,0x6a37,0x7a16,
     68          0x0af1,0x1ad0,0x2ab3,0x3a92,0xfd2e,
     69          0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,
     70          0x9de8,0x8dc9,0x7c26,0x6c07,0x5c64,
     71          0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
     72          0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,
     73          0xbfba,0x8fd9,0x9ff8,0x6e17,0x7e36,
     74          0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,
     75          0x1ef0
     76          };
     77          
     78          typedef enum {
     79            KT_OLLEH,
     80            SKTELECOM,
     81            LGUPLUS
     82          }teTELECOM;
     83          
     84          uint32_t _millisCounter;
     85          
     86          u32 Loop_SendTimeCnt = 0;
     87          
     88          u32 SMSDecodeWaitCnt;
     89          
     90          
     91          u8 ModemInitCnt = 0;
     92          u8 Modem_FotaFlag;
     93          
     94          
     95          u8 TellRespFlag;
     96          int TellRespNo;
     97          
     98          u8 NetRespFlag;
     99          int NetRespNo;
    100          
    101          u8 NotiRespFlag;
    102          int NotiRespNo;
    103          
    104          u8 UsimState;
    105          u8 PppState;
    106          u16 KtfState;
    107          u8 TldState;
    108          u8 SmsState;
    109          
    110          typedef struct {
    111          	u16	 RingBufRxCtr;					/* Rx 링 버퍼에 저장된 데이터 수					*/
    112          	u8	  *RingBufRxInPtr;				/* 다음 데이터를 저장할 곳을 가리키는 포인터		*/
    113          	u8	  *RingBufRxOutPtr;				/* 다음에 읽어갈 데이터를 가리키는 포인터			*/
    114          	u8	   RingBufRx[MODEM_COMM_RX_BUF_SIZE]; 	/* 수신용 링 버퍼 저장영역(Rx)						*/
    115          } COMM_RX_RING_BUF;
    116          
    117          static COMM_RX_RING_BUF ModemCommBuf;
    118          
    119          u8 ModemServiceFaultCnt;
    120          u8 ModemServiceFault;
    121          
    122          /* Private define ------------------------------------------------------------*/
    123          /* Private macro -------------------------------------------------------------*/
    124          /* Private variables ---------------------------------------------------------*/
    125          /* Private function prototypes -----------------------------------------------*/
    126          /* Private functions ---------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    127          void ModemCommBuffCheck(void)
    128          {
    129            if ((ModemCommBuf.RingBufRxInPtr != ModemCommBuf.RingBufRxOutPtr)) 
   \                     ModemCommBuffCheck: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable135_2
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable135_3
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x6889             LDR      R1,[R1, #+8]
   \   0000000C   0x428A             CMP      R2,R1
   \   0000000E   0xD002             BEQ.N    ??ModemCommBuffCheck_0
    130              RxBuffEmpty  = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0x4770             BX       LR
    131            else
    132              RxBuffEmpty  = 1;
   \                     ??ModemCommBuffCheck_0: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    133          }
   \   0000001A   0x4770             BX       LR               ;; return
    134          

   \                                 In section .text, align 2, keep-with-next
    135          void ModemCommInit(void)
    136          {
    137          	ModemCommBuf.RingBufRxCtr    = 0;
   \                     ModemCommInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable135_3
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    138          	ModemCommBuf.RingBufRxInPtr  = &ModemCommBuf.RingBufRx[0];
   \   00000008   0xF100 0x010C      ADD      R1,R0,#+12
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    139          	ModemCommBuf.RingBufRxOutPtr = &ModemCommBuf.RingBufRx[0];
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    140          }
   \   00000010   0x4770             BX       LR               ;; return
    141          

   \                                 In section .text, align 2, keep-with-next
    142          void ModemCommPutRxChar(u8 c)
    143          {
    144          	if (ModemCommBuf.RingBufRxCtr < MODEM_COMM_RX_BUF_SIZE) {	
   \                     ModemCommPutRxChar: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable135_3
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
   \   00000006   0xF5B2 0x5F88      CMP      R2,#+4352
   \   0000000A   0xDA0E             BGE.N    ??ModemCommPutRxChar_0
    145          		ModemCommBuf.RingBufRxCtr++;							 
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \   0000000E   0x800A             STRH     R2,[R1, #+0]
    146          		*ModemCommBuf.RingBufRxInPtr++ = c;						
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x7010             STRB     R0,[R2, #+0]
   \   00000014   0x6848             LDR      R0,[R1, #+4]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x6048             STR      R0,[R1, #+4]
    147          		if (ModemCommBuf.RingBufRxInPtr >= &ModemCommBuf.RingBufRx[MODEM_COMM_RX_BUF_SIZE]) { 
   \   0000001A   0xF241 0x120C      MOVW     R2,#+4364
   \   0000001E   0x440A             ADD      R2,R1,R2
   \   00000020   0x4290             CMP      R0,R2
   \   00000022   0xD302             BCC.N    ??ModemCommPutRxChar_0
    148          			ModemCommBuf.RingBufRxInPtr = &ModemCommBuf.RingBufRx[0];
   \   00000024   0xF101 0x000C      ADD      R0,R1,#+12
   \   00000028   0x6048             STR      R0,[R1, #+4]
    149          		}
    150          	}
    151          }
   \                     ??ModemCommPutRxChar_0: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    152          

   \                                 In section .text, align 2, keep-with-next
    153          u8 ModemCommGetChar(u8 *err)
    154          {
   \                     ModemCommGetChar: (+1)
   \   00000000   0xB410             PUSH     {R4}
    155          	u8 c;
    156          
    157          	if ((ModemCommBuf.RingBufRxInPtr != ModemCommBuf.RingBufRxOutPtr))
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable135_3
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x6851             LDR      R1,[R2, #+4]
   \   0000000A   0x4299             CMP      R1,R3
   \   0000000C   0xD013             BEQ.N    ??ModemCommGetChar_0
    158          	{
    159          //    portENTER_CRITICAL();
    160              if(ModemCommBuf.RingBufRxCtr > 0)
   \   0000000E   0x8811             LDRH     R1,[R2, #+0]
   \   00000010   0x000C             MOVS     R4,R1
   \   00000012   0xD001             BEQ.N    ??ModemCommGetChar_1
    161                ModemCommBuf.RingBufRxCtr--;	
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8011             STRH     R1,[R2, #+0]
    162          
    163          		c = *ModemCommBuf.RingBufRxOutPtr++;					  
   \                     ??ModemCommGetChar_1: (+1)
   \   00000018   0x7819             LDRB     R1,[R3, #+0]
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0x6093             STR      R3,[R2, #+8]
    164          		if (ModemCommBuf.RingBufRxOutPtr >= &ModemCommBuf.RingBufRx[MODEM_COMM_RX_BUF_SIZE]) {	
   \   0000001E   0xF241 0x140C      MOVW     R4,#+4364
   \   00000022   0x4414             ADD      R4,R2,R4
   \   00000024   0x42A3             CMP      R3,R4
   \   00000026   0xD302             BCC.N    ??ModemCommGetChar_2
    165          			ModemCommBuf.RingBufRxOutPtr = &ModemCommBuf.RingBufRx[0];
   \   00000028   0xF102 0x030C      ADD      R3,R2,#+12
   \   0000002C   0x6093             STR      R3,[R2, #+8]
    166          		}
    167          		*err = MODEM_COMM_NO_ERR;
   \                     ??ModemCommGetChar_2: (+1)
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x7002             STRB     R2,[R0, #+0]
    168          //    portEXIT_CRITICAL();
    169          		return (c);
   \   00000032   0x4608             MOV      R0,R1
   \   00000034   0xE002             B.N      ??ModemCommGetChar_3
    170          	}
    171          	else
    172          	{
    173          		*err = MODEM_COMM_RX_EMPTY;
   \                     ??ModemCommGetChar_0: (+1)
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x7001             STRB     R1,[R0, #+0]
    174          		return (0);
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??ModemCommGetChar_3: (+1)
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    175          	}
    176          }
    177          

   \                                 In section .text, align 2, keep-with-next
    178          unsigned short int  getcrc16(u16 crc, unsigned char *buf, unsigned int len)
    179          {
   \                     getcrc16: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    180          //  volatile  unsigned int counter;
    181          //  volatile  unsigned short int crc=0;
    182            unsigned int counter;
    183          
    184            
    185            for( counter = 0; counter < len; counter++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00C             B.N      ??getcrc16_0
    186            {
    187              crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
   \                     ??getcrc16_1: (+1)
   \   00000006   0x.... 0x....      ADR.W    R4,crc16tab
   \   0000000A   0x4605             MOV      R5,R0
   \   0000000C   0xB2AD             UXTH     R5,R5
   \   0000000E   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   00000012   0xEA86 0x2525      EOR      R5,R6,R5, ASR #+8
   \   00000016   0xF834 0x4015      LDRH     R4,[R4, R5, LSL #+1]
   \   0000001A   0xEA84 0x2000      EOR      R0,R4,R0, LSL #+8
    188            }
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??getcrc16_0: (+1)
   \   00000020   0x4293             CMP      R3,R2
   \   00000022   0xD3F0             BCC.N    ??getcrc16_1
    189            return(crc);
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR               ;; return
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          unsigned short getcrc16c(unsigned short crc, unsigned char data)
    193          {
    194            return((crc<<8) ^ crc16tab[((crc>>8) ^ data)&0x00FF]);
   \                     getcrc16c: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,crc16tab
   \   00000004   0x4603             MOV      R3,R0
   \   00000006   0xEA81 0x2123      EOR      R1,R1,R3, ASR #+8
   \   0000000A   0xF832 0x1011      LDRH     R1,[R2, R1, LSL #+1]
   \   0000000E   0xEA81 0x2000      EOR      R0,R1,R0, LSL #+8
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x4770             BX       LR               ;; return
    195          }
    196          
    197          /*
    198          ********************************************************************************
    199          * Description : StringLen
    200          * Arguments   : str1, len
    201          * Return      : length
    202          * Note        : Compare string
    203          ******************************************************************************** 
    204          */

   \                                 In section .text, align 2, keep-with-next
    205          int StringLen(char* str, int len)
    206          {  
    207            for(int i = 0; i < len; i++) {
   \                     StringLen: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE000             B.N      ??StringLen_0
   \                     ??StringLen_1: (+1)
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \                     ??StringLen_0: (+1)
   \   00000006   0x428A             CMP      R2,R1
   \   00000008   0xDA04             BGE.N    ??StringLen_2
    208              if(str[i] == 0)
   \   0000000A   0x5C83             LDRB     R3,[R0, R2]
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD1F9             BNE.N    ??StringLen_1
    209                return i;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR
    210            }
    211          
    212            return len;
   \                     ??StringLen_2: (+1)
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
    213          }
    214          
    215          /*
    216          ********************************************************************************
    217          * Description : millis
    218          * Arguments   : none
    219          * Return      : 
    220          * Note        : miliis time 
    221          ******************************************************************************** 
    222          */

   \                                 In section .text, align 2, keep-with-next
    223          uint32_t millis(void) 
    224          { 
    225           	return _millisCounter; 
   \                     millis: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable138
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    226          }
    227          

   \                                 In section .text, align 2, keep-with-next
    228          void init_millis(void) 
    229          { 
    230           	_millisCounter = 0; 
   \                     init_millis: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable138
   \   00000006   0x6008             STR      R0,[R1, #+0]
    231          }
   \   00000008   0x4770             BX       LR               ;; return
    232          
    233          /*
    234          ********************************************************************************
    235          * Description : AsciiToVal
    236          * Arguments   : str
    237          * Return      : val
    238          * Note        : AsciiToVal
    239          ******************************************************************************** 
    240          */

   \                                 In section .text, align 2, keep-with-next
    241          long AsciiToVal(char* str)  
    242          {
   \                     AsciiToVal: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    243            long val = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    244            int i, sign = 1;
   \   00000004   0x2201             MOVS     R2,#+1
    245            
    246            if(str[0] == '-') {
   \   00000006   0x7803             LDRB     R3,[R0, #+0]
   \   00000008   0x2B2D             CMP      R3,#+45
   \   0000000A   0xD109             BNE.N    ??AsciiToVal_0
    247              sign = -1;
   \   0000000C   0xF04F 0x32FF      MOV      R2,#-1
    248              for(i = 0; i < 9; i++) {
   \   00000010   0x460B             MOV      R3,R1
   \   00000012   0xE003             B.N      ??AsciiToVal_1
    249                str[i] = str[i+1];
   \                     ??AsciiToVal_2: (+1)
   \   00000014   0x18C4             ADDS     R4,R0,R3
   \   00000016   0x7864             LDRB     R4,[R4, #+1]
   \   00000018   0x54C4             STRB     R4,[R0, R3]
    250              }
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??AsciiToVal_1: (+1)
   \   0000001C   0x2B09             CMP      R3,#+9
   \   0000001E   0xDBF9             BLT.N    ??AsciiToVal_2
    251            }
    252            for(i = 0; i < 10; i++) {
   \                     ??AsciiToVal_0: (+1)
   \   00000020   0x460B             MOV      R3,R1
   \   00000022   0xE007             B.N      ??AsciiToVal_3
    253              if(str[i] >= 0x30 && str[i] <= 0x39) {
    254                if(i > 0) val *= 10;
   \                     ??AsciiToVal_4: (+1)
   \   00000024   0x2B01             CMP      R3,#+1
   \   00000026   0xDB02             BLT.N    ??AsciiToVal_5
   \   00000028   0xEB01 0x0581      ADD      R5,R1,R1, LSL #+2
   \   0000002C   0x0069             LSLS     R1,R5,#+1
    255                val += str[i]-0x30;
   \                     ??AsciiToVal_5: (+1)
   \   0000002E   0x3C30             SUBS     R4,R4,#+48
   \   00000030   0x1861             ADDS     R1,R4,R1
    256              }
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
   \                     ??AsciiToVal_3: (+1)
   \   00000034   0x2B0A             CMP      R3,#+10
   \   00000036   0xDA09             BGE.N    ??AsciiToVal_6
   \   00000038   0x5CC4             LDRB     R4,[R0, R3]
   \   0000003A   0xF1A4 0x0530      SUB      R5,R4,#+48
   \   0000003E   0x2D0A             CMP      R5,#+10
   \   00000040   0xD3F0             BCC.N    ??AsciiToVal_4
    257              else if(str[i] == 0) break;
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD002             BEQ.N    ??AsciiToVal_6
    258              else return -1;
   \   00000046   0xF04F 0x30FF      MOV      R0,#-1
   \   0000004A   0xE001             B.N      ??AsciiToVal_7
    259            }
    260            return (sign*val);
   \                     ??AsciiToVal_6: (+1)
   \   0000004C   0xFB01 0xF002      MUL      R0,R1,R2
   \                     ??AsciiToVal_7: (+1)
   \   00000050   0xBC30             POP      {R4,R5}
   \   00000052   0x4770             BX       LR               ;; return
    261          }
    262          
    263          /*
    264          ********************************************************************************
    265          * Description : IsSameString
    266          * Arguments   : str1, str2, len
    267          * Return      : 
    268          * Note        : Compare string
    269          ******************************************************************************** 
    270          */

   \                                 In section .text, align 2, keep-with-next
    271          u8 IsSameString(char* str1, char* str2, u8 len)
    272          {  
   \                     IsSameString: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    273            for(int i = 0; i < len; i++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE000             B.N      ??IsSameString_0
   \                     ??IsSameString_1: (+1)
   \   00000006   0x1C5B             ADDS     R3,R3,#+1
   \                     ??IsSameString_0: (+1)
   \   00000008   0x4293             CMP      R3,R2
   \   0000000A   0xDA05             BGE.N    ??IsSameString_2
    274              if(str1[i] != str2[i])
   \   0000000C   0x5CC4             LDRB     R4,[R0, R3]
   \   0000000E   0x5CCD             LDRB     R5,[R1, R3]
   \   00000010   0x42AC             CMP      R4,R5
   \   00000012   0xD0F8             BEQ.N    ??IsSameString_1
    275                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B.N      ??IsSameString_3
    276            }
    277            
    278            return 1;
   \                     ??IsSameString_2: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??IsSameString_3: (+1)
   \   0000001A   0xBC30             POP      {R4,R5}
   \   0000001C   0x4770             BX       LR               ;; return
    279          }
    280          
    281          /*
    282          ********************************************************************************
    283          * Description : IsSameString2
    284          * Arguments   : str1, str2, mlen, len, start
    285          * Return      : 
    286          * Note        : Compare string2
    287          ******************************************************************************** 
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          u8 IsSameString2(char* str1, char* str2, u8 mlen, u8 len, u8* start)
    290          { 
   \                     IsSameString2: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    291            u8 idx = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    292            
    293            for(int i = 0; i < mlen; i++) {
   \   00000004   0x4625             MOV      R5,R4
   \   00000006   0xE001             B.N      ??IsSameString2_0
    294              if(str1[i] == str2[idx]) {
    295                idx++;
    296                if(idx == len) {
    297                  *start = i+1;
    298                  return 1;
    299                }
    300              }
    301              else idx = 0;
   \                     ??IsSameString2_1: (+1)
   \   00000008   0x2400             MOVS     R4,#+0
   \                     ??IsSameString2_2: (+1)
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??IsSameString2_0: (+1)
   \   0000000C   0x4295             CMP      R5,R2
   \   0000000E   0xDA0F             BGE.N    ??IsSameString2_3
   \   00000010   0x5D46             LDRB     R6,[R0, R5]
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x5D0F             LDRB     R7,[R1, R4]
   \   00000016   0x42BE             CMP      R6,R7
   \   00000018   0xD1F6             BNE.N    ??IsSameString2_1
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0x4626             MOV      R6,R4
   \   0000001E   0x461F             MOV      R7,R3
   \   00000020   0xB2F6             UXTB     R6,R6
   \   00000022   0x42BE             CMP      R6,R7
   \   00000024   0xD1F1             BNE.N    ??IsSameString2_2
   \   00000026   0x1C68             ADDS     R0,R5,#+1
   \   00000028   0x9904             LDR      R1,[SP, #+16]
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??IsSameString2_4
    302            }
    303            
    304            return 0;
   \                     ??IsSameString2_3: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??IsSameString2_4: (+1)
   \   00000032   0xBCF0             POP      {R4-R7}
   \   00000034   0x4770             BX       LR               ;; return
    305          }
    306          
    307          /*
    308          ********************************************************************************
    309          * Description : IsSamePassWord
    310          * Arguments   : str1, str2, mlen, len, start
    311          * Return      : 
    312          * Note        : PassWord compare
    313          ******************************************************************************** 
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          unsigned char IsSamePassWord(char* str1, char* str2, unsigned char mlen, unsigned char len, unsigned char* start)
    316          {
   \                     IsSamePassWord: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    317            unsigned char idx = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    318            
    319            for(int i = 0; i < mlen; i++) {
   \   00000004   0x4625             MOV      R5,R4
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0xE000             B.N      ??IsSamePassWord_0
   \                     ??IsSamePassWord_1: (+1)
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??IsSamePassWord_0: (+1)
   \   0000000C   0x42B5             CMP      R5,R6
   \   0000000E   0xDA19             BGE.N    ??IsSamePassWord_2
    320              if(str1[i] != ' ') {
   \   00000010   0x5D47             LDRB     R7,[R0, R5]
   \   00000012   0x2F20             CMP      R7,#+32
   \   00000014   0xD0F9             BEQ.N    ??IsSamePassWord_1
    321                if(str1[i] == str2[idx]) {
   \   00000016   0xB2E4             UXTB     R4,R4
   \   00000018   0xF811 0xC004      LDRB     R12,[R1, R4]
   \   0000001C   0x4567             CMP      R7,R12
   \   0000001E   0xD111             BNE.N    ??IsSamePassWord_2
    322                  idx++;
   \   00000020   0x1C64             ADDS     R4,R4,#+1
    323                  if(idx == len) {
   \   00000022   0x4627             MOV      R7,R4
   \   00000024   0x469C             MOV      R12,R3
   \   00000026   0xB2FF             UXTB     R7,R7
   \   00000028   0x4567             CMP      R7,R12
   \   0000002A   0xD1EE             BNE.N    ??IsSamePassWord_1
    324                    if(i+1 < mlen) {
   \   0000002C   0x1C69             ADDS     R1,R5,#+1
   \   0000002E   0x42B1             CMP      R1,R6
   \   00000030   0xDA03             BGE.N    ??IsSamePassWord_3
    325                      if(str1[i+1] != ' ')
   \   00000032   0x4428             ADD      R0,R0,R5
   \   00000034   0x7840             LDRB     R0,[R0, #+1]
   \   00000036   0x2820             CMP      R0,#+32
   \   00000038   0xD104             BNE.N    ??IsSamePassWord_2
    326                        return 0;
    327                    }
    328                    *start = i+1;
   \                     ??IsSamePassWord_3: (+1)
   \   0000003A   0x1C68             ADDS     R0,R5,#+1
   \   0000003C   0x9904             LDR      R1,[SP, #+16]
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    329                    return 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??IsSamePassWord_4
    330                  }
    331                }
    332                else break;
    333              }
    334            }
    335            return 0;
   \                     ??IsSamePassWord_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??IsSamePassWord_4: (+1)
   \   00000046   0xBCF0             POP      {R4-R7}
   \   00000048   0x4770             BX       LR               ;; return
    336          }
    337          
    338          /*
    339          ********************************************************************************
    340          * Description : data send
    341          * Arguments   : uchar port, uchar *data, int len
    342          * Return      : none
    343          * Note        : 
    344          ********************************************************************************
    345          */

   \                                 In section .text, align 2, keep-with-next
    346          void modem_sendstr (INT8U *data, int len)
    347          {
    348            modemPutCharStr((INT8U *)data, len);  
   \                     modem_sendstr: (+1)
   \   00000000   0x.... 0x....      B.W      modemPutCharStr
    349          }
    350          
    351          /*
    352          ********************************************************************************
    353          * Description : TxStrToModem
    354          * Arguments   : *string
    355          * Return      : 
    356          * Note        : Tx sting to Modem
    357          ******************************************************************************** 
    358          */

   \                                 In section .text, align 2, keep-with-next
    359          void TxStrToModem(char* str)
    360          {
   \                     TxStrToModem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    361            u8 len;
    362            
    363            len = StringLen(str,100);
   \   00000004   0x2164             MOVS     R1,#+100
   \   00000006   0x.... 0x....      BL       StringLen
    364            modem_sendstr((u8*)str,len);
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x....             B.N      modem_sendstr
    365          }
    366          
    367          #ifdef __USE_TXBUF_DELAY__
    368          #define DELAY_BYTES   512
    369          #endif

   \                                 In section .text, align 2, keep-with-next
    370          void TxDataStrToModem(u8* data, int len)
    371          {
    372          #ifdef __USE_TXBUF_DELAY__  
    373            int i;
    374            int dev, mod;
    375          #endif  
    376            
    377            if(Setting.ExtModemModel == 2 && TcpState == 1) {  
   \                     TxDataStrToModem: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable139
   \   00000004   0xF892 0x20B7      LDRB     R2,[R2, #+183]
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD105             BNE.N    ??TxDataStrToModem_0
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable139_1
   \   00000010   0x7A52             LDRB     R2,[R2, #+9]
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD100             BNE.N    ??TxDataStrToModem_0
    378              TxHexStrToModem(data, len);
   \   00000016   0x....             B.N      TxHexStrToModem
    379            }
    380            else {
    381          #ifdef __USE_TXBUF_DELAY__    
    382              dev = len / DELAY_BYTES;
    383              mod = len % DELAY_BYTES;
    384              for(i = 0; i < dev; i++) {
    385                modem_sendstr((uint8_t*)&data[i * DELAY_BYTES], DELAY_BYTES);        
    386                vTaskDelay(100);
    387              }
    388              if(mod) {
    389                modem_sendstr((uint8_t*)&data[dev * DELAY_BYTES], mod);      
    390              }
    391          #else    
    392              modem_sendstr(data,len);
   \                     ??TxDataStrToModem_0: (+1)
   \   00000018   0x....             B.N      modem_sendstr
    393          #endif    
    394            } 
    395          }
    396          
    397          /*
    398          ********************************************************************************
    399          * Description : TxCharToModem
    400          * Arguments   : data
    401          * Return      : 
    402          * Note        : Tx hex char to Modem
    403          ******************************************************************************** 
    404          */

   \                                 In section .text, align 2, keep-with-next
    405          void TxCharToModem(char ch)
    406          {
   \                     TxCharToModem: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable139_2  ;; 0x40004400
    407          	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET); 
   \                     ??TxCharToModem_0: (+1)
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD0F9             BEQ.N    ??TxCharToModem_0
    408              USART_SendData(USART2,ch);    
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      USART_SendData
    409          }
    410          
    411          #define MAX_SOCKET_TX_LEN 512
    412          u8 TxResp, TxRespStep;
    413          int TxMsgLen;
    414          /*
    415          ********************************************************************************
    416          * Description : TxHexStrToModem
    417          * Arguments   : data, int len
    418          * Return      : 
    419          * Note        : Tx hex string to Modem
    420          ******************************************************************************** 
    421          */

   \                                 In section .text, align 2, keep-with-next
    422          unsigned char TxHexStrToModem(u8* data, int len)
    423          {
   \                     TxHexStrToModem: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
    424            int cnt, n, mod, i, j;
    425            u8 sdata1,sdata2;
    426            u32  current, previous;
    427            int idx = 0, msg_len = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x462E             MOV      R6,R5
    428            u8 rdata, err, len_flag = 0, resp_flag = 0;
   \   0000000A   0x462F             MOV      R7,R5
   \   0000000C   0x46A8             MOV      R8,R5
    429            u8 resp = 1;
   \   0000000E   0xF04F 0x0901      MOV      R9,#+1
    430            unsigned int timeout = 5000;
    431            
    432            n = len/MAX_SOCKET_TX_LEN;
   \   00000012   0x1208             ASRS     R0,R1,#+8
   \   00000014   0xEB01 0x50D0      ADD      R0,R1,R0, LSR #+23
   \   00000018   0x1240             ASRS     R0,R0,#+9
   \   0000001A   0x9000             STR      R0,[SP, #+0]
    433            mod = len%MAX_SOCKET_TX_LEN;
   \   0000001C   0xEBA1 0x2040      SUB      R0,R1,R0, LSL #+9
   \   00000020   0x9002             STR      R0,[SP, #+8]
    434            
    435            for(i = 0; i <= n; i++) {
   \   00000022   0x462C             MOV      R4,R5
   \   00000024   0x.... 0x....      LDR.W    R10,??DataTable139_3
   \   00000028   0xE006             B.N      ??TxHexStrToModem_0
    436              if(!(i == n && mod == 0)) {
    437                if(i == n) cnt = mod;
    438                else cnt = MAX_SOCKET_TX_LEN;
    439                ModemCommInit();
    440                printk("\r\n");
    441                TxStrToModem("AT@SOCKSND=0,1,\"");
    442                for(j = 0; j < cnt; j++) {
    443                  sdata1 = (data[i*MAX_SOCKET_TX_LEN+j]>>4)&0x0F;
    444                  sdata2 = (data[i*MAX_SOCKET_TX_LEN+j]&0x0F);
    445                  if(sdata1 < 0x0A)
    446                    TxCharToModem(sdata1+'0');
    447                  else
    448                    TxCharToModem(sdata1 - 0x0A +'A');
    449                  if(sdata2 < 0x0A)
    450                    TxCharToModem(sdata2+'0');
    451                  else
    452                    TxCharToModem(sdata2 - 0x0A +'A');
    453                }
    454                TxStrToModem("\"\r");
    455                
    456                msg_len = 0;
    457                len_flag = 0;
    458                resp_flag = 0;
    459                resp = 1;
    460                idx = 0;
    461                init_millis();
    462                previous = millis();
    463                memset(AT_Response, 0, 256);
    464                do{
    465                  rdata = ModemCommGetChar(&err);
    466                  if ( err == MODEM_COMM_NO_ERR ) {
    467                    if(len_flag == 0 && resp_flag == 0) {
    468                      if(idx < 255) 
    469                        AT_Response[idx++] = rdata;
    470                      else {
    471                        resp = 1;        
    472                        break;
    473                      }
    474                      if (strstr(AT_Response, "@SOCKSND:") != NULL)
    475                        len_flag = 1;
    476                    }
    477                    else if(len_flag == 1 && resp_flag == 0) {
    478                      if(rdata >= '0' && rdata <= '9') 
    479                        msg_len = msg_len*10+(rdata-'0');
    480                      else if(rdata == ',') 
    481                        resp_flag = 1;
    482                      else if(rdata != ' ') 
    483                          break;
    484                    }
    485                    else if(resp_flag == 1) {
    486                      if(rdata == '0' ||  rdata == '1')  {
    487                        resp = rdata-'0';
    488                        printk("\r\n");
    489                        break;
    490                      }
    491                      else if(rdata != ' ') break;
    492                    }
    493                    else {
    494                      break;//idle
    495                    }
    496                  }
    497                  current = millis();
    498                  vTaskDelay(1);
    499                }
    500                while(((current-previous) < timeout));
    501              }
    502              if(!(resp == 0 && msg_len == cnt)) {
    503                TxResp = resp;
    504                TxMsgLen = idx;
    505                TxRespStep = len_flag*10+resp_flag;
    506                printk("\r\nMODEM : Send TCP DATA ERROR\r\n"); 
    507                return 0;
    508              }
    509              if(i != n) vTaskDelay(100);
   \                     ??TxHexStrToModem_1: (+1)
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD002             BEQ.N    ??TxHexStrToModem_2
   \   00000030   0x2064             MOVS     R0,#+100
   \   00000032   0x.... 0x....      BL       vTaskDelay
   \                     ??TxHexStrToModem_2: (+1)
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \                     ??TxHexStrToModem_0: (+1)
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x42A0             CMP      R0,R4
   \   0000003C   0xF2C0 0x80B4      BLT.W    ??TxHexStrToModem_3
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD103             BNE.N    ??TxHexStrToModem_4
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xF000 0x8096      BEQ.W    ??TxHexStrToModem_5
   \                     ??TxHexStrToModem_4: (+1)
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD102             BNE.N    ??TxHexStrToModem_6
   \   00000052   0x9802             LDR      R0,[SP, #+8]
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0xE002             B.N      ??TxHexStrToModem_7
   \                     ??TxHexStrToModem_6: (+1)
   \   00000058   0xF44F 0x7000      MOV      R0,#+512
   \   0000005C   0x9001             STR      R0,[SP, #+4]
   \                     ??TxHexStrToModem_7: (+1)
   \   0000005E   0x.... 0x....      BL       ModemCommInit
   \   00000062   0x....             ADR.N    R0,??DataTable127  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000064   0x.... 0x....      BL       printk
   \   00000068   0x.... 0x....      ADR.W    R0,?_1
   \   0000006C   0x.... 0x....      BL       TxStrToModem
   \   00000070   0x2500             MOVS     R5,#+0
   \   00000072   0xE005             B.N      ??TxHexStrToModem_8
   \                     ??TxHexStrToModem_9: (+1)
   \   00000074   0xF106 0x0037      ADD      R0,R6,#+55
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x.... 0x....      BL       TxCharToModem
   \                     ??TxHexStrToModem_10: (+1)
   \   0000007E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??TxHexStrToModem_8: (+1)
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x4285             CMP      R5,R0
   \   00000084   0xDA1C             BGE.N    ??TxHexStrToModem_11
   \   00000086   0x9806             LDR      R0,[SP, #+24]
   \   00000088   0xEB05 0x2144      ADD      R1,R5,R4, LSL #+9
   \   0000008C   0x5C41             LDRB     R1,[R0, R1]
   \   0000008E   0x4608             MOV      R0,R1
   \   00000090   0x0900             LSRS     R0,R0,#+4
   \   00000092   0xF001 0x060F      AND      R6,R1,#0xF
   \   00000096   0x4601             MOV      R1,R0
   \   00000098   0x290A             CMP      R1,#+10
   \   0000009A   0xDA04             BGE.N    ??TxHexStrToModem_12
   \   0000009C   0x3030             ADDS     R0,R0,#+48
   \   0000009E   0xB2C0             UXTB     R0,R0
   \   000000A0   0x.... 0x....      BL       TxCharToModem
   \   000000A4   0xE003             B.N      ??TxHexStrToModem_13
   \                     ??TxHexStrToModem_12: (+1)
   \   000000A6   0x3037             ADDS     R0,R0,#+55
   \   000000A8   0xB2C0             UXTB     R0,R0
   \   000000AA   0x.... 0x....      BL       TxCharToModem
   \                     ??TxHexStrToModem_13: (+1)
   \   000000AE   0x4630             MOV      R0,R6
   \   000000B0   0x280A             CMP      R0,#+10
   \   000000B2   0xDADF             BGE.N    ??TxHexStrToModem_9
   \   000000B4   0xF106 0x0030      ADD      R0,R6,#+48
   \   000000B8   0xB2C0             UXTB     R0,R0
   \   000000BA   0x.... 0x....      BL       TxCharToModem
   \   000000BE   0xE7DE             B.N      ??TxHexStrToModem_10
   \                     ??TxHexStrToModem_11: (+1)
   \   000000C0   0x....             ADR.N    R0,??DataTable127_1  ;; 0x22, 0x0D, 0x00, 0x00
   \   000000C2   0x.... 0x....      BL       TxStrToModem
   \   000000C6   0x2600             MOVS     R6,#+0
   \   000000C8   0x4637             MOV      R7,R6
   \   000000CA   0x46B0             MOV      R8,R6
   \   000000CC   0xF04F 0x0901      MOV      R9,#+1
   \   000000D0   0x4635             MOV      R5,R6
   \   000000D2   0x.... 0x....      BL       init_millis
   \   000000D6   0x.... 0x....      BL       millis
   \   000000DA   0x9004             STR      R0,[SP, #+16]
   \   000000DC   0x462A             MOV      R2,R5
   \   000000DE   0xF44F 0x7180      MOV      R1,#+256
   \   000000E2   0x4650             MOV      R0,R10
   \   000000E4   0x.... 0x....      BL       __aeabi_memset4
   \                     ??TxHexStrToModem_14: (+1)
   \   000000E8   0xA803             ADD      R0,SP,#+12
   \   000000EA   0x.... 0x....      BL       ModemCommGetChar
   \   000000EE   0xF89D 0x100C      LDRB     R1,[SP, #+12]
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD133             BNE.N    ??TxHexStrToModem_15
   \   000000F6   0xEA58 0x0107      ORRS     R1,R8,R7
   \   000000FA   0xD10D             BNE.N    ??TxHexStrToModem_16
   \   000000FC   0x2DFF             CMP      R5,#+255
   \   000000FE   0xDA3B             BGE.N    ??TxHexStrToModem_5
   \   00000100   0xF80A 0x0005      STRB     R0,[R10, R5]
   \   00000104   0x1C6D             ADDS     R5,R5,#+1
   \   00000106   0x.... 0x....      ADR.W    R1,?_3
   \   0000010A   0x4650             MOV      R0,R10
   \   0000010C   0x.... 0x....      BL       strstr
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD024             BEQ.N    ??TxHexStrToModem_15
   \   00000114   0x464F             MOV      R7,R9
   \   00000116   0xE022             B.N      ??TxHexStrToModem_15
   \                     ??TxHexStrToModem_16: (+1)
   \   00000118   0x2F01             CMP      R7,#+1
   \   0000011A   0xD111             BNE.N    ??TxHexStrToModem_17
   \   0000011C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000120   0xD10E             BNE.N    ??TxHexStrToModem_17
   \   00000122   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000126   0x290A             CMP      R1,#+10
   \   00000128   0xD206             BCS.N    ??TxHexStrToModem_18
   \   0000012A   0xEB06 0x0186      ADD      R1,R6,R6, LSL #+2
   \   0000012E   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000132   0xF1A0 0x0630      SUB      R6,R0,#+48
   \   00000136   0xE012             B.N      ??TxHexStrToModem_15
   \                     ??TxHexStrToModem_18: (+1)
   \   00000138   0x282C             CMP      R0,#+44
   \   0000013A   0xD10E             BNE.N    ??TxHexStrToModem_19
   \   0000013C   0x46C8             MOV      R8,R9
   \   0000013E   0xE00E             B.N      ??TxHexStrToModem_15
   \                     ??TxHexStrToModem_17: (+1)
   \   00000140   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000144   0xD118             BNE.N    ??TxHexStrToModem_5
   \   00000146   0x2830             CMP      R0,#+48
   \   00000148   0xD001             BEQ.N    ??TxHexStrToModem_20
   \   0000014A   0x2831             CMP      R0,#+49
   \   0000014C   0xD105             BNE.N    ??TxHexStrToModem_19
   \                     ??TxHexStrToModem_20: (+1)
   \   0000014E   0xF1A0 0x0930      SUB      R9,R0,#+48
   \   00000152   0x....             ADR.N    R0,??DataTable127  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000154   0x.... 0x....      BL       printk
   \   00000158   0xE00E             B.N      ??TxHexStrToModem_5
   \                     ??TxHexStrToModem_19: (+1)
   \   0000015A   0x2820             CMP      R0,#+32
   \   0000015C   0xD10C             BNE.N    ??TxHexStrToModem_5
   \                     ??TxHexStrToModem_15: (+1)
   \   0000015E   0x.... 0x....      BL       millis
   \   00000162   0x4683             MOV      R11,R0
   \   00000164   0x4648             MOV      R0,R9
   \   00000166   0x.... 0x....      BL       vTaskDelay
   \   0000016A   0x9804             LDR      R0,[SP, #+16]
   \   0000016C   0xEBAB 0x0000      SUB      R0,R11,R0
   \   00000170   0xF241 0x3188      MOVW     R1,#+5000
   \   00000174   0x4288             CMP      R0,R1
   \   00000176   0xD3B7             BCC.N    ??TxHexStrToModem_14
   \                     ??TxHexStrToModem_5: (+1)
   \   00000178   0x4648             MOV      R0,R9
   \   0000017A   0xB2C0             UXTB     R0,R0
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD103             BNE.N    ??TxHexStrToModem_21
   \   00000180   0x9801             LDR      R0,[SP, #+4]
   \   00000182   0x4286             CMP      R6,R0
   \   00000184   0xF43F 0xAF51      BEQ.W    ??TxHexStrToModem_1
   \                     ??TxHexStrToModem_21: (+1)
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable140
   \   0000018C   0xF880 0x9000      STRB     R9,[R0, #+0]
   \   00000190   0x6045             STR      R5,[R0, #+4]
   \   00000192   0xEB07 0x0187      ADD      R1,R7,R7, LSL #+2
   \   00000196   0xEB08 0x0141      ADD      R1,R8,R1, LSL #+1
   \   0000019A   0x7041             STRB     R1,[R0, #+1]
   \   0000019C   0x.... 0x....      ADR.W    R0,?_4
   \   000001A0   0x.... 0x....      BL       printk
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0xE000             B.N      ??TxHexStrToModem_22
    510            }
    511             return 1;
   \                     ??TxHexStrToModem_3: (+1)
   \   000001A8   0x2001             MOVS     R0,#+1
   \                     ??TxHexStrToModem_22: (+1)
   \   000001AA   0xB007             ADD      SP,SP,#+28
   \   000001AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    512          }
    513          
    514          /*
    515          ********************************************************************************
    516          * Description : sendATcommand
    517          * Arguments   : ATcommand, answer1, answer2, timeout
    518          * Return      : 
    519          * Note        : AT command
    520          ******************************************************************************** 
    521          */

   \                                 In section .text, align 2, keep-with-next
    522          u8 sendATcommand(char* ATcommand, char* expected_answer1,
    523                  char* expected_answer2, unsigned int timeout){
   \                     sendATcommand: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    524          
    525          	char data = 0;          
    526            u8 x=0,  answer=0, err;
   \   0000000E   0x2700             MOVS     R7,#+0
   \   00000010   0x46B8             MOV      R8,R7
    527            u32  current, previous;
    528            
    529            memset(AT_Response, 0, 256);
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable139_3
   \   00000016   0x463A             MOV      R2,R7
   \   00000018   0xF44F 0x7180      MOV      R1,#+256
   \   0000001C   0x4648             MOV      R0,R9
   \   0000001E   0x.... 0x....      BL       __aeabi_memset4
    530            
    531            ModemCommInit();
   \   00000022   0x.... 0x....      BL       ModemCommInit
    532            // Send the AT command    
    533            TxStrToModem(ATcommand);
   \   00000026   0x4650             MOV      R0,R10
   \   00000028   0x.... 0x....      BL       TxStrToModem
    534          
    535            x = 0;
    536            init_millis();
   \   0000002C   0x.... 0x....      BL       init_millis
    537            previous = millis();
   \   00000030   0x.... 0x....      BL       millis
   \   00000034   0x4682             MOV      R10,R0
    538          
    539            // loop waits for the answer
    540            do{
    541              data = ModemCommGetChar(&err);
   \                     ??sendATcommand_0: (+1)
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       ModemCommGetChar
    542          //    put_ch_console(data);
    543             	if ( err == MODEM_COMM_NO_ERR ) {
   \   0000003C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD11C             BNE.N    ??sendATcommand_1
    544                AT_Response[x] = data;
   \   00000044   0xB2FF             UXTB     R7,R7
   \   00000046   0xF809 0x0007      STRB     R0,[R9, R7]
    545                if(x < 255)  x++;
   \   0000004A   0x2FFF             CMP      R7,#+255
   \   0000004C   0xD009             BEQ.N    ??sendATcommand_2
   \   0000004E   0x1C7F             ADDS     R7,R7,#+1
    546                else {
    547                  printk("\r\nMODEM : sendATcommand 256 bytes over ERROR\r\n");              
    548                  return 0;        
    549                }
    550                // check answer 1
    551                if (strstr(AT_Response, expected_answer1) != NULL)
   \   00000050   0x4621             MOV      R1,R4
   \   00000052   0x4648             MOV      R0,R9
   \   00000054   0x.... 0x....      BL       strstr
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD008             BEQ.N    ??sendATcommand_3
    552                {
    553                    answer = 1;
   \   0000005C   0xF04F 0x0801      MOV      R8,#+1
   \   00000060   0xE00D             B.N      ??sendATcommand_1
    554                }
   \                     ??sendATcommand_2: (+1)
   \   00000062   0x.... 0x....      ADR.W    R0,?_5
   \   00000066   0x.... 0x....      BL       printk
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE014             B.N      ??sendATcommand_4
    555                // check answer 2
    556                else if (strstr(AT_Response, expected_answer2) != NULL)
   \                     ??sendATcommand_3: (+1)
   \   0000006E   0x4629             MOV      R1,R5
   \   00000070   0x4648             MOV      R0,R9
   \   00000072   0x.... 0x....      BL       strstr
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD001             BEQ.N    ??sendATcommand_1
    557                {
    558                    answer = 2;
   \   0000007A   0xF04F 0x0802      MOV      R8,#+2
    559                }
    560              }
    561              vTaskDelay(1);
   \                     ??sendATcommand_1: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x.... 0x....      BL       vTaskDelay
    562              current = millis();
   \   00000084   0x.... 0x....      BL       millis
    563            }
    564            while((answer == 0) && ((current-previous) < timeout));
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x2900             CMP      R1,#+0
   \   0000008C   0xD103             BNE.N    ??sendATcommand_5
   \   0000008E   0xEBA0 0x000A      SUB      R0,R0,R10
   \   00000092   0x42B0             CMP      R0,R6
   \   00000094   0xD3CF             BCC.N    ??sendATcommand_0
    565          
    566            return answer;
   \                     ??sendATcommand_5: (+1)
   \   00000096   0x4640             MOV      R0,R8
   \                     ??sendATcommand_4: (+1)
   \   00000098   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    567          }
    568          
    569          /*
    570          ********************************************************************************
    571          * Description : sendATcommand
    572          * Arguments   : ATcommand, answer1, answer2, timeout
    573          * Return      : 
    574          * Note        : AT command
    575          ******************************************************************************** 
    576          */

   \                                 In section .text, align 2, keep-with-next
    577          int8_t sendATcommand2(char* ATcommand, char expected_answer1, char* expected_answer2, unsigned int timeout){
   \                     sendATcommand2: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    578          
    579          	char data = 0;          
    580            u8 x=0,  answer=0, err;
   \   0000000E   0x2700             MOVS     R7,#+0
   \   00000010   0x46B8             MOV      R8,R7
    581            u32  current, previous;
    582            
    583            memset(AT_Response, 0, 256);
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable139_3
   \   00000016   0x463A             MOV      R2,R7
   \   00000018   0xF44F 0x7180      MOV      R1,#+256
   \   0000001C   0x4648             MOV      R0,R9
   \   0000001E   0x.... 0x....      BL       __aeabi_memset4
    584            
    585            ModemCommInit();
   \   00000022   0x.... 0x....      BL       ModemCommInit
    586          
    587            // Send the AT command    
    588            TxStrToModem(ATcommand);    
   \   00000026   0x4650             MOV      R0,R10
   \   00000028   0x.... 0x....      BL       TxStrToModem
    589          
    590            x = 0;
    591            init_millis();
   \   0000002C   0x.... 0x....      BL       init_millis
    592            previous = millis();
   \   00000030   0x.... 0x....      BL       millis
   \   00000034   0x4682             MOV      R10,R0
    593          
    594            // loop waits for the answer
    595            do{
    596              data = ModemCommGetChar(&err);
   \                     ??sendATcommand2_0: (+1)
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       ModemCommGetChar
    597          //    put_ch_console(data);
    598             	if ( err == MODEM_COMM_NO_ERR ) {
   \   0000003C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD119             BNE.N    ??sendATcommand2_1
    599                AT_Response[x] = data;
   \   00000044   0xB2FF             UXTB     R7,R7
   \   00000046   0xF809 0x0007      STRB     R0,[R9, R7]
    600                if(x < 255)  x++;
   \   0000004A   0x2FFF             CMP      R7,#+255
   \   0000004C   0xD006             BEQ.N    ??sendATcommand2_2
   \   0000004E   0x1C7F             ADDS     R7,R7,#+1
    601                else {
    602                  printk("\r\nMODEM : sendATcommand 256 bytes over ERROR\r\n");              
    603                  return 0;        
    604                }
    605                // check answer 1
    606                if (data == expected_answer1)
   \   00000050   0x4621             MOV      R1,R4
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD108             BNE.N    ??sendATcommand2_3
    607                {
    608                    answer = 1;
   \   00000056   0xF04F 0x0801      MOV      R8,#+1
   \   0000005A   0xE00D             B.N      ??sendATcommand2_1
    609                }
   \                     ??sendATcommand2_2: (+1)
   \   0000005C   0x.... 0x....      ADR.W    R0,?_5
   \   00000060   0x.... 0x....      BL       printk
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE014             B.N      ??sendATcommand2_4
    610                // check answer 2
    611                else if (strstr(AT_Response, expected_answer2) != NULL)
   \                     ??sendATcommand2_3: (+1)
   \   00000068   0x4629             MOV      R1,R5
   \   0000006A   0x4648             MOV      R0,R9
   \   0000006C   0x.... 0x....      BL       strstr
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??sendATcommand2_1
    612                {
    613                    answer = 2;
   \   00000074   0xF04F 0x0802      MOV      R8,#+2
    614                }
    615              }
    616              vTaskDelay(1);
   \                     ??sendATcommand2_1: (+1)
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x.... 0x....      BL       vTaskDelay
    617              current = millis();
   \   0000007E   0x.... 0x....      BL       millis
    618            }
    619            while((answer == 0) && ((current-previous) < timeout));
   \   00000082   0x4641             MOV      R1,R8
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD103             BNE.N    ??sendATcommand2_5
   \   00000088   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000008C   0x42B0             CMP      R0,R6
   \   0000008E   0xD3D2             BCC.N    ??sendATcommand2_0
    620          
    621            return answer;
   \                     ??sendATcommand2_5: (+1)
   \   00000090   0x4640             MOV      R0,R8
   \                     ??sendATcommand2_4: (+1)
   \   00000092   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    622          }
    623          /*
    624          ********************************************************************************
    625          * Description : AT_SendWithRecievedData
    626          * Arguments   : cmd, cmdResp, valNum, timeout
    627          * Return      : resp
    628          * Note        : AT command + Recieve data
    629          ******************************************************************************** 
    630          */

   \                                 In section .text, align 2, keep-with-next
    631          int AT_SendWithRecieveData(char* cmd, char* cmdResp, u8 valNum, unsigned int timeout) 
    632          {
   \                     AT_SendWithRecieveData: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4682             MOV      R10,R0
    633            
    634            u32  current, previous;
    635            int i, idx = 0, val_idx = 0, msg_len = 0;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x4625             MOV      R5,R4
   \   0000000C   0x4626             MOV      R6,R4
    636            u8 str_flag = 0, data, err, data_flag = 0;
   \   0000000E   0x4627             MOV      R7,R4
    637            u8 resp = 0;
   \   00000010   0x46A0             MOV      R8,R4
    638          
    639            memset(AT_Response, 0, 256);
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable139_3
   \   00000016   0x4622             MOV      R2,R4
   \   00000018   0xF44F 0x7180      MOV      R1,#+256
   \   0000001C   0x4648             MOV      R0,R9
   \   0000001E   0x.... 0x....      BL       __aeabi_memset4
    640            for(i = 0; i < 10; i++) {
   \   00000022   0x46A3             MOV      R11,R4
   \   00000024   0xE009             B.N      ??AT_SendWithRecieveData_0
    641              memset(ATCmdRxMsg[i], 0, 32);
   \                     ??AT_SendWithRecieveData_1: (+1)
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable141
   \   0000002E   0xEB00 0x104B      ADD      R0,R0,R11, LSL #+5
   \   00000032   0x.... 0x....      BL       __aeabi_memset
    642            }
   \   00000036   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??AT_SendWithRecieveData_0: (+1)
   \   0000003A   0xF1BB 0x0F0A      CMP      R11,#+10
   \   0000003E   0xDBF2             BLT.N    ??AT_SendWithRecieveData_1
    643          
    644            ModemCommInit();
   \   00000040   0x.... 0x....      BL       ModemCommInit
    645            
    646            TxStrToModem(cmd);    
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0x.... 0x....      BL       TxStrToModem
    647            init_millis();
   \   0000004A   0x.... 0x....      BL       init_millis
    648            previous = millis();
   \   0000004E   0x.... 0x....      BL       millis
   \   00000052   0x4682             MOV      R10,R0
    649            do{
    650              data = ModemCommGetChar(&err);
   \                     ??AT_SendWithRecieveData_2: (+1)
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       ModemCommGetChar
    651          //    put_ch_console(data);
    652             	if ( err == MODEM_COMM_NO_ERR ) {
   \   0000005A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD13A             BNE.N    ??AT_SendWithRecieveData_3
    653                if(data_flag == 0) {
   \   00000062   0x0039             MOVS     R1,R7
   \   00000064   0xD114             BNE.N    ??AT_SendWithRecieveData_4
    654                  if(idx < 255) {
   \   00000066   0x2CFF             CMP      R4,#+255
   \   00000068   0xDA03             BGE.N    ??AT_SendWithRecieveData_5
    655                    AT_Response[idx++] = data;
   \   0000006A   0xF809 0x0004      STRB     R0,[R9, R4]
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xE006             B.N      ??AT_SendWithRecieveData_6
    656                  }
    657                  else {
    658                    printk("\r\nMODEM : sendATcommand 256 bytes over ERROR\r\n");              
   \                     ??AT_SendWithRecieveData_5: (+1)
   \   00000072   0x.... 0x....      ADR.W    R0,?_5
   \   00000076   0x.... 0x....      BL       printk
    659                    resp = 0;        
   \   0000007A   0xF04F 0x0800      MOV      R8,#+0
    660                    data_flag = 2;
   \   0000007E   0x2702             MOVS     R7,#+2
    661                  }
    662                  if (strstr(AT_Response, cmdResp) != NULL)
   \                     ??AT_SendWithRecieveData_6: (+1)
   \   00000080   0x9902             LDR      R1,[SP, #+8]
   \   00000082   0x4648             MOV      R0,R9
   \   00000084   0x.... 0x....      BL       strstr
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD025             BEQ.N    ??AT_SendWithRecieveData_3
    663                    data_flag = 1;
   \   0000008C   0x2701             MOVS     R7,#+1
   \   0000008E   0xE023             B.N      ??AT_SendWithRecieveData_3
    664                }
    665                else if(data_flag == 1) {
   \                     ??AT_SendWithRecieveData_4: (+1)
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD12C             BNE.N    ??AT_SendWithRecieveData_7
    666                  if(data == '\r') {
   \   00000094   0x280D             CMP      R0,#+13
   \   00000096   0xD102             BNE.N    ??AT_SendWithRecieveData_8
    667                      resp = 1;
   \   00000098   0xF04F 0x0801      MOV      R8,#+1
    668                      break;
   \   0000009C   0xE027             B.N      ??AT_SendWithRecieveData_7
    669                  }
    670                  else if(data == ',') {
   \                     ??AT_SendWithRecieveData_8: (+1)
   \   0000009E   0x282C             CMP      R0,#+44
   \   000000A0   0xD10C             BNE.N    ??AT_SendWithRecieveData_9
    671                    if(val_idx < valNum && val_idx < 9) {
   \   000000A2   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000A6   0x4285             CMP      R5,R0
   \   000000A8   0xDA04             BGE.N    ??AT_SendWithRecieveData_10
   \   000000AA   0x2D09             CMP      R5,#+9
   \   000000AC   0xDA02             BGE.N    ??AT_SendWithRecieveData_10
    672                      val_idx++;
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
    673                      msg_len = 0;
   \   000000B0   0x2600             MOVS     R6,#+0
   \   000000B2   0xE011             B.N      ??AT_SendWithRecieveData_3
    674                    }
    675                    else {
    676                      resp = 1;
   \                     ??AT_SendWithRecieveData_10: (+1)
   \   000000B4   0xF04F 0x0801      MOV      R8,#+1
    677                      data_flag = 2;
   \   000000B8   0x2702             MOVS     R7,#+2
   \   000000BA   0xE00D             B.N      ??AT_SendWithRecieveData_3
    678                    }
    679                    str_flag = 0;
    680                  }
    681                  else if(data == '\"') {
   \                     ??AT_SendWithRecieveData_9: (+1)
   \   000000BC   0x2822             CMP      R0,#+34
   \   000000BE   0xD00B             BEQ.N    ??AT_SendWithRecieveData_3
    682                    if(str_flag) str_flag = 0;
    683                    else str_flag = 1;
    684                  }
    685                  else {
    686                    if(msg_len < 32) {
   \   000000C0   0x2E20             CMP      R6,#+32
   \   000000C2   0xDA09             BGE.N    ??AT_SendWithRecieveData_3
    687                      if(!(msg_len == 0 && data == ' '))
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD101             BNE.N    ??AT_SendWithRecieveData_11
   \   000000C8   0x2820             CMP      R0,#+32
   \   000000CA   0xD005             BEQ.N    ??AT_SendWithRecieveData_3
    688                        ATCmdRxMsg[val_idx][msg_len++] = data;
   \                     ??AT_SendWithRecieveData_11: (+1)
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable141
   \   000000D0   0xEB01 0x1145      ADD      R1,R1,R5, LSL #+5
   \   000000D4   0x5588             STRB     R0,[R1, R6]
   \   000000D6   0x1C76             ADDS     R6,R6,#+1
    689                    }
    690                  }
    691                }
    692                else {
    693                  break;//idle
    694                }
    695              }
    696              current = millis();
   \                     ??AT_SendWithRecieveData_3: (+1)
   \   000000D8   0x.... 0x....      BL       millis
   \   000000DC   0x4683             MOV      R11,R0
    697              vTaskDelay(1);
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x.... 0x....      BL       vTaskDelay
    698            }
    699            while(((current-previous) < timeout));
   \   000000E4   0xEBAB 0x000A      SUB      R0,R11,R10
   \   000000E8   0x9904             LDR      R1,[SP, #+16]
   \   000000EA   0x4288             CMP      R0,R1
   \   000000EC   0xD3B2             BCC.N    ??AT_SendWithRecieveData_2
    700          
    701            return resp;
   \                     ??AT_SendWithRecieveData_7: (+1)
   \   000000EE   0x4640             MOV      R0,R8
   \   000000F0   0xB005             ADD      SP,SP,#+20
   \   000000F2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    702          }
    703          
    704          /*
    705          ********************************************************************************
    706          * Description : AT_SendWithRecievedData
    707          * Arguments   : cmd, cmdResp, valNum, timeout
    708          * Return      : resp
    709          * Note        : AT command + Recieve data
    710          ******************************************************************************** 
    711          */

   \                                 In section .text, align 2, keep-with-next
    712          int AT_SendWithRecieveData2(char* cmd, char* cmdResp, u8 valNum, unsigned int timeout) 
    713          {
   \                     AT_SendWithRecieveData2: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4681             MOV      R9,R0
    714            
    715            u32  current, previous;
    716            int i, idx = 0, val_idx = 0, msg_len = 0;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x4625             MOV      R5,R4
   \   0000000C   0x4626             MOV      R6,R4
    717            u8 str_flag = 0, data, err, data_flag = 0;
    718            u8 resp = 0;
   \   0000000E   0x4627             MOV      R7,R4
    719          
    720            memset(AT_Response, 0, 256);
   \   00000010   0x.... 0x....      LDR.W    R8,??DataTable139_3
   \   00000014   0x4622             MOV      R2,R4
   \   00000016   0xF44F 0x7180      MOV      R1,#+256
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       __aeabi_memset4
    721            for(i = 0; i < 10; i++) {
   \   00000020   0x46A2             MOV      R10,R4
   \   00000022   0xE009             B.N      ??AT_SendWithRecieveData2_0
    722              memset(ATCmdRxMsg[i], 0, 32);
   \                     ??AT_SendWithRecieveData2_1: (+1)
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x2120             MOVS     R1,#+32
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable141
   \   0000002C   0xEB00 0x104A      ADD      R0,R0,R10, LSL #+5
   \   00000030   0x.... 0x....      BL       __aeabi_memset
    723            }
   \   00000034   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??AT_SendWithRecieveData2_0: (+1)
   \   00000038   0xF1BA 0x0F0A      CMP      R10,#+10
   \   0000003C   0xDBF2             BLT.N    ??AT_SendWithRecieveData2_1
    724          
    725            ModemCommInit();
   \   0000003E   0x.... 0x....      BL       ModemCommInit
    726            
    727            TxStrToModem(cmd);    
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0x.... 0x....      BL       TxStrToModem
    728            init_millis();
   \   00000048   0x.... 0x....      BL       init_millis
    729            previous = millis();
   \   0000004C   0x.... 0x....      BL       millis
   \   00000050   0x4681             MOV      R9,R0
    730            data_flag = 1;
   \   00000052   0xF04F 0x0A01      MOV      R10,#+1
    731            do{
    732              data = ModemCommGetChar(&err);
   \                     ??AT_SendWithRecieveData2_2: (+1)
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       ModemCommGetChar
    733          //    put_ch_console(data);
    734             	if ( err == MODEM_COMM_NO_ERR ) {
   \   0000005C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xD144             BNE.N    ??AT_SendWithRecieveData2_3
    735                if(data_flag == 0) {
   \   00000064   0x4651             MOV      R1,R10
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0xD114             BNE.N    ??AT_SendWithRecieveData2_4
    736                  if(idx < 255) {
   \   0000006A   0x2CFF             CMP      R4,#+255
   \   0000006C   0xDA03             BGE.N    ??AT_SendWithRecieveData2_5
    737                    AT_Response[idx++] = data;
   \   0000006E   0xF808 0x0004      STRB     R0,[R8, R4]
   \   00000072   0x1C64             ADDS     R4,R4,#+1
   \   00000074   0xE006             B.N      ??AT_SendWithRecieveData2_6
    738                  }
    739                  else {
    740                    printk("\r\nMODEM : sendATcommand 256 bytes over ERROR\r\n");              
   \                     ??AT_SendWithRecieveData2_5: (+1)
   \   00000076   0x.... 0x....      ADR.W    R0,?_5
   \   0000007A   0x.... 0x....      BL       printk
    741                    resp = 0;        
   \   0000007E   0x2700             MOVS     R7,#+0
    742                    data_flag = 2;
   \   00000080   0xF04F 0x0A02      MOV      R10,#+2
    743                  }
    744                  if (strstr(AT_Response, cmdResp) != NULL) {
   \                     ??AT_SendWithRecieveData2_6: (+1)
   \   00000084   0x9902             LDR      R1,[SP, #+8]
   \   00000086   0x4640             MOV      R0,R8
   \   00000088   0x.... 0x....      BL       strstr
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD02E             BEQ.N    ??AT_SendWithRecieveData2_3
    745                    resp = 1;        
   \   00000090   0x2701             MOVS     R7,#+1
    746                    break;
   \   00000092   0xE037             B.N      ??AT_SendWithRecieveData2_7
    747                  }
    748                }
    749                else if(data_flag == 1) {
   \                     ??AT_SendWithRecieveData2_4: (+1)
   \   00000094   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000098   0xD134             BNE.N    ??AT_SendWithRecieveData2_7
    750                  if(data == '\r' && (msg_len > 0 || val_idx > 0)) 
   \   0000009A   0x280D             CMP      R0,#+13
   \   0000009C   0xD106             BNE.N    ??AT_SendWithRecieveData2_8
   \   0000009E   0x2E01             CMP      R6,#+1
   \   000000A0   0xDA01             BGE.N    ??AT_SendWithRecieveData2_9
   \   000000A2   0x2D01             CMP      R5,#+1
   \   000000A4   0xDB02             BLT.N    ??AT_SendWithRecieveData2_8
    751                      data_flag = 0;
   \                     ??AT_SendWithRecieveData2_9: (+1)
   \   000000A6   0xF04F 0x0A00      MOV      R10,#+0
   \   000000AA   0xE020             B.N      ??AT_SendWithRecieveData2_3
    752                  else if(data == ',') {
   \                     ??AT_SendWithRecieveData2_8: (+1)
   \   000000AC   0x282C             CMP      R0,#+44
   \   000000AE   0xD10C             BNE.N    ??AT_SendWithRecieveData2_10
    753                    if(val_idx < valNum && val_idx < 9) {
   \   000000B0   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000B4   0x4285             CMP      R5,R0
   \   000000B6   0xDA04             BGE.N    ??AT_SendWithRecieveData2_11
   \   000000B8   0x2D09             CMP      R5,#+9
   \   000000BA   0xDA02             BGE.N    ??AT_SendWithRecieveData2_11
    754                      val_idx++;
   \   000000BC   0x1C6D             ADDS     R5,R5,#+1
    755                      msg_len = 0;
   \   000000BE   0x2600             MOVS     R6,#+0
   \   000000C0   0xE015             B.N      ??AT_SendWithRecieveData2_3
    756                    }
    757                    else {
    758                      resp = 1;
   \                     ??AT_SendWithRecieveData2_11: (+1)
   \   000000C2   0x2701             MOVS     R7,#+1
    759                      data_flag = 2;
   \   000000C4   0xF04F 0x0A02      MOV      R10,#+2
   \   000000C8   0xE011             B.N      ??AT_SendWithRecieveData2_3
    760                    }
    761                    str_flag = 0;
    762                  }
    763                  else if(data == '\"') {
   \                     ??AT_SendWithRecieveData2_10: (+1)
   \   000000CA   0x2822             CMP      R0,#+34
   \   000000CC   0xD00F             BEQ.N    ??AT_SendWithRecieveData2_3
    764                    if(str_flag) str_flag = 0;
    765                    else str_flag = 1;
    766                  }
    767                  else {
    768                    if(msg_len < 32) {
   \   000000CE   0x2E20             CMP      R6,#+32
   \   000000D0   0xDA0D             BGE.N    ??AT_SendWithRecieveData2_3
    769                      if(!(msg_len == 0 && data == ' ') && data != '\r' && data != '\n')
   \   000000D2   0x2E00             CMP      R6,#+0
   \   000000D4   0xD101             BNE.N    ??AT_SendWithRecieveData2_12
   \   000000D6   0x2820             CMP      R0,#+32
   \   000000D8   0xD009             BEQ.N    ??AT_SendWithRecieveData2_3
   \                     ??AT_SendWithRecieveData2_12: (+1)
   \   000000DA   0x280D             CMP      R0,#+13
   \   000000DC   0xD007             BEQ.N    ??AT_SendWithRecieveData2_3
   \   000000DE   0x280A             CMP      R0,#+10
   \   000000E0   0xD005             BEQ.N    ??AT_SendWithRecieveData2_3
    770                        ATCmdRxMsg[val_idx][msg_len++] = data;
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable141
   \   000000E6   0xEB01 0x1145      ADD      R1,R1,R5, LSL #+5
   \   000000EA   0x5588             STRB     R0,[R1, R6]
   \   000000EC   0x1C76             ADDS     R6,R6,#+1
    771                    }
    772                  }
    773                }
    774                else {
    775                  break;//idle
    776                }
    777              }
    778              current = millis();
   \                     ??AT_SendWithRecieveData2_3: (+1)
   \   000000EE   0x.... 0x....      BL       millis
   \   000000F2   0x4683             MOV      R11,R0
    779              vTaskDelay(1);
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x.... 0x....      BL       vTaskDelay
    780            }
    781            while(((current-previous) < timeout));
   \   000000FA   0xEBAB 0x0009      SUB      R0,R11,R9
   \   000000FE   0x9904             LDR      R1,[SP, #+16]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD3A8             BCC.N    ??AT_SendWithRecieveData2_2
    782          
    783            return resp;
   \                     ??AT_SendWithRecieveData2_7: (+1)
   \   00000104   0x4638             MOV      R0,R7
   \   00000106   0xB005             ADD      SP,SP,#+20
   \   00000108   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    784          }
    785          /*
    786          ********************************************************************************
    787          * Description : AT_SendWithRecievedData
    788          * Arguments   : cmd, cmdResp, valNum, timeout
    789          * Return      : resp
    790          * Note        : AT command + Recieve data
    791          ******************************************************************************** 
    792          */

   \                                 In section .text, align 2, keep-with-next
    793          int AT_SendWithRecieveMultiRowData(char* cmd, char* cmdResp, u8 valNum, unsigned int timeout) 
    794          {
   \                     AT_SendWithRecieveMultiRowData: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4682             MOV      R10,R0
    795            
    796            u32  current, previous;
    797            int i, idx = 0, val_idx = 0, msg_len = 0;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x4625             MOV      R5,R4
   \   0000000C   0x4626             MOV      R6,R4
    798            u8  data, err, data_flag = 0;
   \   0000000E   0x4627             MOV      R7,R4
    799            u8 resp = 0;
   \   00000010   0x46A0             MOV      R8,R4
    800          
    801            memset(AT_Response, 0, 256);
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable139_3
   \   00000016   0x4622             MOV      R2,R4
   \   00000018   0xF44F 0x7180      MOV      R1,#+256
   \   0000001C   0x4648             MOV      R0,R9
   \   0000001E   0x.... 0x....      BL       __aeabi_memset4
    802            for(i = 0; i < 10; i++) {
   \   00000022   0x46A3             MOV      R11,R4
   \   00000024   0xE009             B.N      ??AT_SendWithRecieveMultiRowData_0
    803              memset(ATCmdRxMsg[i], 0, 32);
   \                     ??AT_SendWithRecieveMultiRowData_1: (+1)
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable141
   \   0000002E   0xEB00 0x104B      ADD      R0,R0,R11, LSL #+5
   \   00000032   0x.... 0x....      BL       __aeabi_memset
    804            }
   \   00000036   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??AT_SendWithRecieveMultiRowData_0: (+1)
   \   0000003A   0xF1BB 0x0F0A      CMP      R11,#+10
   \   0000003E   0xDBF2             BLT.N    ??AT_SendWithRecieveMultiRowData_1
    805          
    806            ModemCommInit();
   \   00000040   0x.... 0x....      BL       ModemCommInit
    807            
    808            TxStrToModem(cmd);    
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0x.... 0x....      BL       TxStrToModem
    809            init_millis();
   \   0000004A   0x.... 0x....      BL       init_millis
    810            previous = millis();
   \   0000004E   0x.... 0x....      BL       millis
   \   00000052   0x4682             MOV      R10,R0
    811            do{
    812              data = ModemCommGetChar(&err);
   \                     ??AT_SendWithRecieveMultiRowData_2: (+1)
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       ModemCommGetChar
    813          //    put_ch_console(data);
    814             	if ( err == MODEM_COMM_NO_ERR ) {
   \   0000005A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD134             BNE.N    ??AT_SendWithRecieveMultiRowData_3
    815                if(data_flag == 0) {
   \   00000062   0x0039             MOVS     R1,R7
   \   00000064   0xD114             BNE.N    ??AT_SendWithRecieveMultiRowData_4
    816                  if(idx < 255) {
   \   00000066   0x2CFF             CMP      R4,#+255
   \   00000068   0xDA03             BGE.N    ??AT_SendWithRecieveMultiRowData_5
    817                    AT_Response[idx++] = data;
   \   0000006A   0xF809 0x0004      STRB     R0,[R9, R4]
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xE006             B.N      ??AT_SendWithRecieveMultiRowData_6
    818                  }
    819                  else {
    820                    printk("\r\nMODEM : sendATcommand 256 bytes over ERROR\r\n");              
   \                     ??AT_SendWithRecieveMultiRowData_5: (+1)
   \   00000072   0x.... 0x....      ADR.W    R0,?_5
   \   00000076   0x.... 0x....      BL       printk
    821                    resp = 0;        
   \   0000007A   0xF04F 0x0800      MOV      R8,#+0
    822                    data_flag = 2;
   \   0000007E   0x2702             MOVS     R7,#+2
    823                  }
    824                  if (strstr(AT_Response, cmdResp) != NULL)
   \                     ??AT_SendWithRecieveMultiRowData_6: (+1)
   \   00000080   0x9902             LDR      R1,[SP, #+8]
   \   00000082   0x4648             MOV      R0,R9
   \   00000084   0x.... 0x....      BL       strstr
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD01F             BEQ.N    ??AT_SendWithRecieveMultiRowData_3
    825                    data_flag = 1;
   \   0000008C   0x2701             MOVS     R7,#+1
   \   0000008E   0xE01D             B.N      ??AT_SendWithRecieveMultiRowData_3
    826                }
    827                else if(data_flag == 1) {
   \                     ??AT_SendWithRecieveMultiRowData_4: (+1)
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD126             BNE.N    ??AT_SendWithRecieveMultiRowData_7
    828                  if(data == '\r') {
   \   00000094   0x4601             MOV      R1,R0
   \   00000096   0x290D             CMP      R1,#+13
   \   00000098   0xD10C             BNE.N    ??AT_SendWithRecieveMultiRowData_8
    829                    if(val_idx < valNum && val_idx < 9) {
   \   0000009A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000009E   0x4285             CMP      R5,R0
   \   000000A0   0xDA04             BGE.N    ??AT_SendWithRecieveMultiRowData_9
   \   000000A2   0x2D09             CMP      R5,#+9
   \   000000A4   0xDA02             BGE.N    ??AT_SendWithRecieveMultiRowData_9
    830                      val_idx++;
   \   000000A6   0x1C6D             ADDS     R5,R5,#+1
    831                      msg_len = 0;
   \   000000A8   0x2600             MOVS     R6,#+0
   \   000000AA   0xE00F             B.N      ??AT_SendWithRecieveMultiRowData_3
    832                    }
    833                    else {
    834                      resp = 1;
   \                     ??AT_SendWithRecieveMultiRowData_9: (+1)
   \   000000AC   0xF04F 0x0801      MOV      R8,#+1
    835                      data_flag = 2;
   \   000000B0   0x2702             MOVS     R7,#+2
   \   000000B2   0xE00B             B.N      ??AT_SendWithRecieveMultiRowData_3
    836                    }
    837                  }
    838                  else {
    839                    if(data == '\n') msg_len = 0;
   \                     ??AT_SendWithRecieveMultiRowData_8: (+1)
   \   000000B4   0x290A             CMP      R1,#+10
   \   000000B6   0xD101             BNE.N    ??AT_SendWithRecieveMultiRowData_10
   \   000000B8   0x2600             MOVS     R6,#+0
   \   000000BA   0xE007             B.N      ??AT_SendWithRecieveMultiRowData_3
    840                    else if(msg_len < 32)
   \                     ??AT_SendWithRecieveMultiRowData_10: (+1)
   \   000000BC   0x2E20             CMP      R6,#+32
   \   000000BE   0xDA05             BGE.N    ??AT_SendWithRecieveMultiRowData_3
    841                      ATCmdRxMsg[val_idx][msg_len++] = data;
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable141
   \   000000C4   0xEB01 0x1145      ADD      R1,R1,R5, LSL #+5
   \   000000C8   0x5588             STRB     R0,[R1, R6]
   \   000000CA   0x1C76             ADDS     R6,R6,#+1
    842                  }
    843                }
    844                else {
    845                  break;//idle
    846                }
    847              }
    848              current = millis();
   \                     ??AT_SendWithRecieveMultiRowData_3: (+1)
   \   000000CC   0x.... 0x....      BL       millis
   \   000000D0   0x4683             MOV      R11,R0
    849              vTaskDelay(1);
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0x.... 0x....      BL       vTaskDelay
    850            }
    851            while(((current-previous) < timeout));
   \   000000D8   0xEBAB 0x000A      SUB      R0,R11,R10
   \   000000DC   0x9904             LDR      R1,[SP, #+16]
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD3B8             BCC.N    ??AT_SendWithRecieveMultiRowData_2
    852          
    853            return resp;
   \                     ??AT_SendWithRecieveMultiRowData_7: (+1)
   \   000000E2   0x4640             MOV      R0,R8
   \   000000E4   0xB005             ADD      SP,SP,#+20
   \   000000E6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    854          }
    855          
    856          /*
    857          ********************************************************************************
    858          * Description : Modem_PowerOff
    859          * Arguments   : 
    860          * Return      : 
    861          * Note        : Modem Power Off
    862          ******************************************************************************** 
    863          */

   \                                 In section .text, align 2, keep-with-next
    864          void Modem_PowerOff(void)
    865          {
   \                     Modem_PowerOff: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    866            printk("\r\nMODEM : power off\r\n");  
   \   00000002   0x.... 0x....      ADR.W    R0,?_6
   \   00000006   0x.... 0x....      BL       printk
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable139
   \   0000000E   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD10E             BNE.N    ??Modem_PowerOff_0
    867            if(Setting.ExtModemModel == 0)   {
    868              sendATcommand("AT$$MODE=2\r", "OK", "ERROR", 1000);
   \   00000016   0xF44F 0x737A      MOV      R3,#+1000
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable142
   \   0000001E   0x....             ADR.N    R1,??DataTable136  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000020   0x.... 0x....      ADR.W    R0,?_7
   \   00000024   0x.... 0x....      BL       sendATcommand
    869              vTaskDelay(5000);
   \   00000028   0xF241 0x3088      MOVW     R0,#+5000
   \   0000002C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000030   0x.... 0x....      B.W      vTaskDelay
    870            }
    871            else if(Setting.ExtModemModel == 1)   {
   \                     ??Modem_PowerOff_0: (+1)
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD10E             BNE.N    ??Modem_PowerOff_1
    872              sendATcommand("AT$$HWRESET\r", "OK", "ERROR", 1000);
   \   00000038   0xF44F 0x737A      MOV      R3,#+1000
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable142
   \   00000040   0x....             ADR.N    R1,??DataTable136  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000042   0x.... 0x....      ADR.W    R0,?_10
   \   00000046   0x.... 0x....      BL       sendATcommand
    873              vTaskDelay(3000);
   \   0000004A   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000004E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000052   0x.... 0x....      B.W      vTaskDelay
    874            }
    875            else if(Setting.ExtModemModel == 2)   {
   \                     ??Modem_PowerOff_1: (+1)
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD10E             BNE.N    ??Modem_PowerOff_2
    876              sendATcommand("AT+CFUN=7\r\n", "OK", "ERROR", 1000);
   \   0000005A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable142
   \   00000062   0x....             ADR.N    R1,??DataTable136  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000064   0x.... 0x....      ADR.W    R0,?_11
   \   00000068   0x.... 0x....      BL       sendATcommand
    877              vTaskDelay(3000);
   \   0000006C   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000070   0xE8BD 0x4002      POP      {R1,LR}
   \   00000074   0x.... 0x....      B.W      vTaskDelay
    878            }
    879          }
   \                     ??Modem_PowerOff_2: (+1)
   \   00000078   0xBD01             POP      {R0,PC}          ;; return
    880          
    881          /*
    882          ********************************************************************************
    883          * Description : Modem_PowerOn
    884          * Arguments   : 
    885          * Return      : 
    886          * Note        : Modem Power ON
    887          ******************************************************************************** 
    888          */

   \                                 In section .text, align 2, keep-with-next
    889          unsigned char Modem_PowerOnCheck(void)
    890          {
   \                     Modem_PowerOnCheck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    891            u8 resp=0, sendcnt=0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x4625             MOV      R5,R4
    892          
    893            printk("\r\nMODEM : Check Modem on\r\n");
   \   00000006   0x.... 0x....      ADR.W    R0,?_12
   \   0000000A   0x.... 0x....      BL       printk
   \   0000000E   0xE00D             B.N      ??Modem_PowerOnCheck_0
    894          
    895            while(resp == 0 && sendcnt < 5) { 
    896              resp = sendATcommand("AT\r\n", "OK", "ERROR", 1000);
   \                     ??Modem_PowerOnCheck_1: (+1)
   \   00000010   0xF44F 0x737A      MOV      R3,#+1000
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable142
   \   00000018   0x....             ADR.N    R1,??DataTable136  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000001A   0x.... 0x....      ADR.W    R0,?_13
   \   0000001E   0x.... 0x....      BL       sendATcommand
   \   00000022   0x4604             MOV      R4,R0
    897              sendcnt++;
   \   00000024   0x1C6D             ADDS     R5,R5,#+1
    898              vTaskDelay(1);
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       vTaskDelay
    899            }
   \                     ??Modem_PowerOnCheck_0: (+1)
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xD102             BNE.N    ??Modem_PowerOnCheck_2
   \   00000030   0xB2ED             UXTB     R5,R5
   \   00000032   0x2D05             CMP      R5,#+5
   \   00000034   0xDBEC             BLT.N    ??Modem_PowerOnCheck_1
    900          
    901            return resp;
   \                     ??Modem_PowerOnCheck_2: (+1)
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    902          }
    903          /*
    904          ********************************************************************************
    905          * Description : Modem_PowerOn
    906          * Arguments   : 
    907          * Return      : 
    908          * Note        : Modem Power ON
    909          ******************************************************************************** 
    910          */

   \                                 In section .text, align 2, keep-with-next
    911          void Modem_PowerOn(void)
    912          {
   \                     Modem_PowerOn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    913            printk("\r\nMODEM : power on\r\n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_14
   \   00000006   0x.... 0x....      BL       printk
    914            
    915            vTaskDelay(1000);
   \   0000000A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000E   0x.... 0x....      BL       vTaskDelay
    916            ModemOffFlag = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable144_1
   \   00000018   0x7148             STRB     R0,[R1, #+5]
    917          
    918          //  ReadValue.Status.ModemReset = 1;
    919          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    920          
    921          /*
    922          ********************************************************************************
    923          * Description : AT_SendWithRecieveCNUM
    924          * Arguments   : timeout
    925          * Return      : resp
    926          * Note        : AT+CNUM  -> CNUM Data
    927          ******************************************************************************** 
    928          */

   \                                 In section .text, align 2, keep-with-next
    929          int AT_SendWithRecieveCNUM(unsigned int timeout) 
    930          {
   \                     AT_SendWithRecieveCNUM: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    931            int d = 1, i, cnt = 0;
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x2500             MOVS     R5,#+0
    932            u8 resp = 0;
    933            u32 cnum=0;
   \   00000008   0x462E             MOV      R6,R5
    934            u16 addr;
    935            
    936            resp = AT_SendWithRecieveData("AT+CNUM\r\n", "+CNUM: ", 5, timeout);
   \   0000000A   0x4603             MOV      R3,R0
   \   0000000C   0x2205             MOVS     R2,#+5
   \   0000000E   0x.... 0x....      ADR.W    R1,?_16
   \   00000012   0x.... 0x....      ADR.W    R0,?_15
   \   00000016   0x.... 0x....      BL       AT_SendWithRecieveData
   \   0000001A   0x4607             MOV      R7,R0
   \   0000001C   0xB2FF             UXTB     R7,R7
    937            if(resp == 1) {
   \   0000001E   0x2F01             CMP      R7,#+1
   \   00000020   0xD14A             BNE.N    ??AT_SendWithRecieveCNUM_0
    938              memcpy(ModemInfo.MSISDN, ATCmdRxMsg[1], 16);
   \   00000022   0x.... 0x....      LDR.W    R8,??DataTable141
   \   00000026   0xF44F 0x70A5      MOV      R0,#+330
   \   0000002A   0xEB08 0x0A00      ADD      R10,R8,R0
   \   0000002E   0x2210             MOVS     R2,#+16
   \   00000030   0xF108 0x0120      ADD      R1,R8,#+32
   \   00000034   0x4650             MOV      R0,R10
   \   00000036   0x.... 0x....      BL       __aeabi_memcpy
    939              if(ModemInfo.MSISDN[0] == '+') {
   \   0000003A   0xF44F 0x70A3      MOV      R0,#+326
   \   0000003E   0xEB08 0x0900      ADD      R9,R8,R0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable144_2
   \   00000046   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   0000004A   0x292B             CMP      R1,#+43
   \   0000004C   0xD108             BNE.N    ??AT_SendWithRecieveCNUM_1
    940                ModemCTN[0] = '0';
   \   0000004E   0x2130             MOVS     R1,#+48
   \   00000050   0x7001             STRB     R1,[R0, #+0]
    941                memcpy((u8*)&ModemCTN[1],(u8*)&ModemInfo.MSISDN[3],10);
   \   00000052   0x220A             MOVS     R2,#+10
   \   00000054   0xF208 0x114D      ADDW     R1,R8,#+333
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_memcpy
    942              }
   \   0000005E   0xE003             B.N      ??AT_SendWithRecieveCNUM_2
    943              else
    944                memcpy((u8*)ModemCTN,(u8*)ModemInfo.MSISDN,11);
   \                     ??AT_SendWithRecieveCNUM_1: (+1)
   \   00000060   0x220B             MOVS     R2,#+11
   \   00000062   0x4651             MOV      R1,R10
   \   00000064   0x.... 0x....      BL       __aeabi_memcpy
    945              
    946              for(i = 29; i >= 0 ; i--) {
   \                     ??AT_SendWithRecieveCNUM_2: (+1)
   \   00000068   0x201D             MOVS     R0,#+29
   \   0000006A   0xE000             B.N      ??AT_SendWithRecieveCNUM_3
   \                     ??AT_SendWithRecieveCNUM_4: (+1)
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \                     ??AT_SendWithRecieveCNUM_3: (+1)
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD410             BMI.N    ??AT_SendWithRecieveCNUM_5
    947                if(ATCmdRxMsg[1][i] >= 0x30 && ATCmdRxMsg[1][i] <= 0x39) {
   \   00000072   0xEB08 0x0100      ADD      R1,R8,R0
   \   00000076   0xF891 0x1020      LDRB     R1,[R1, #+32]
   \   0000007A   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   0000007E   0x2A0A             CMP      R2,#+10
   \   00000080   0xD2F4             BCS.N    ??AT_SendWithRecieveCNUM_4
    948                  cnum += (ATCmdRxMsg[1][i]-0x30)*d;
   \   00000082   0x3930             SUBS     R1,R1,#+48
   \   00000084   0xFB04 0x6601      MLA      R6,R4,R1,R6
    949                  d *= 10;
   \   00000088   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   0000008C   0x004C             LSLS     R4,R1,#+1
    950                  cnt++;
   \   0000008E   0x1C6D             ADDS     R5,R5,#+1
    951                  if(cnt >= 10) break;
   \   00000090   0x2D0A             CMP      R5,#+10
   \   00000092   0xDBEB             BLT.N    ??AT_SendWithRecieveCNUM_4
    952                }
    953              }
    954              if(cnum > 1000000000 && cnt == 10) {
   \                     ??AT_SendWithRecieveCNUM_5: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable144_3  ;; 0x3b9aca01
   \   00000098   0x4286             CMP      R6,R0
   \   0000009A   0xD30D             BCC.N    ??AT_SendWithRecieveCNUM_0
   \   0000009C   0x2D0A             CMP      R5,#+10
   \   0000009E   0xD10B             BNE.N    ??AT_SendWithRecieveCNUM_0
    955                if(cnum != ModemInfo.CNUM) {
   \   000000A0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000A4   0x4286             CMP      R6,R0
   \   000000A6   0xD007             BEQ.N    ??AT_SendWithRecieveCNUM_0
    956                  ModemInfo.CNUM = cnum;
   \   000000A8   0xF8C9 0x6000      STR      R6,[R9, #+0]
    957                  addr = MODEM_INFO + (u8 *)&ModemInfo.CNUM - (u8 *)&ModemInfo;
    958                  FRAMMultiWrite((u8 *)&ModemInfo.CNUM, addr, sizeof(ModemInfo.CNUM));
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF240 0x2146      MOVW     R1,#+582
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0x.... 0x....      BL       FRAMMultiWrite
    959                }
    960              }
    961            }
    962            
    963            return resp;
   \                     ??AT_SendWithRecieveCNUM_0: (+1)
   \   000000B8   0x4638             MOV      R0,R7
   \   000000BA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    964          }
    965          
    966          /*
    967          ********************************************************************************
    968          * Description : Modem_SimCard
    969          * Arguments   : void
    970          * Return      : answer
    971          * Note        : Modem Sim Card Reeady check
    972          ******************************************************************************** 
    973          */

   \                                 In section .text, align 2, keep-with-next
    974          unsigned char Modem_SimCard(void)
    975          {
   \                     Modem_SimCard: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    976            printk("\r\nMODEM : simcard \r\n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_17
   \   00000006   0x.... 0x....      BL       printk
    977            
    978            u8 resp=0, sendcnt=0;
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x4625             MOV      R5,R4
   \   0000000E   0xE00E             B.N      ??Modem_SimCard_0
    979          
    980            while(resp == 0 && sendcnt < 5) { 
    981              resp = sendATcommand("AT+CPIN?\r\n", "+CPIN: READY", "+CPIN: NOT INSERTED", 5000); //Maximum Response Time 5s
   \                     ??Modem_SimCard_1: (+1)
   \   00000010   0xF241 0x3388      MOVW     R3,#+5000
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable144_4
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable144_5
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable144_6
   \   00000020   0x.... 0x....      BL       sendATcommand
   \   00000024   0x4604             MOV      R4,R0
    982              sendcnt++;
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
    983              vTaskDelay(1);
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       vTaskDelay
    984            }
   \                     ??Modem_SimCard_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xD102             BNE.N    ??Modem_SimCard_2
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D05             CMP      R5,#+5
   \   00000036   0xDBEB             BLT.N    ??Modem_SimCard_1
    985          
    986            return resp;
   \                     ??Modem_SimCard_2: (+1)
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    987          }
    988          
    989          
    990          /*
    991          ********************************************************************************
    992          * Description : Modem_CREG_Check
    993          * Arguments   : none
    994          * Return      : resp
    995          * Note        : CREG Check
    996          ******************************************************************************** 
    997          */

   \                                 In section .text, align 2, keep-with-next
    998          unsigned char Modem_CREG_Check(void)
    999          {
   \                     Modem_CREG_Check: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1000            
   1001            unsigned char resp;
   1002            u8 val1, val2;
   1003            
   1004            resp=0;
   1005            if(Setting.ExtModemModel == 0)  
   \   00000002   0xF241 0x3388      MOVW     R3,#+5000
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable139
   \   0000000A   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD108             BNE.N    ??Modem_CREG_Check_0
   1006              resp = AT_SendWithRecieveData("AT+CREG?\r\n","+CREG: ", 2, 5000);
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0x.... 0x....      ADR.W    R1,?_22
   \   00000018   0x.... 0x....      ADR.W    R0,?_21
   \   0000001C   0x.... 0x....      BL       AT_SendWithRecieveData
   \   00000020   0x4606             MOV      R6,R0
   \   00000022   0xE007             B.N      ??Modem_CREG_Check_1
   1007            else
   1008              resp = AT_SendWithRecieveData("AT+CGREG?\r\n","+CGREG: ", 2, 5000);
   \                     ??Modem_CREG_Check_0: (+1)
   \   00000024   0x2202             MOVS     R2,#+2
   \   00000026   0x.... 0x....      ADR.W    R1,?_24
   \   0000002A   0x.... 0x....      ADR.W    R0,?_23
   \   0000002E   0x.... 0x....      BL       AT_SendWithRecieveData
   \   00000032   0x4606             MOV      R6,R0
   1009            val1 = AsciiToVal(ATCmdRxMsg[0]);
   \                     ??Modem_CREG_Check_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable141
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       AsciiToVal
   \   0000003E   0x4604             MOV      R4,R0
   1010            val2 = AsciiToVal(ATCmdRxMsg[1]);
   \   00000040   0xF105 0x0020      ADD      R0,R5,#+32
   \   00000044   0x.... 0x....      BL       AsciiToVal
   \   00000048   0x4605             MOV      R5,R0
   \   0000004A   0xB2ED             UXTB     R5,R5
   1011            if(resp) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable139_1
   \   00000050   0xB2F6             UXTB     R6,R6
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD003             BEQ.N    ??Modem_CREG_Check_2
   1012              TCP_Open = 0;
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x7201             STRB     R1,[R0, #+8]
   1013              TcpState = 0;
   \   0000005A   0x7241             STRB     R1,[R0, #+9]
   \   0000005C   0xE008             B.N      ??Modem_CREG_Check_3
   1014            }
   1015            else {
   1016              if(TcpState == 1 || TCP_Open)  Modem_SocketClose(0);
   \                     ??Modem_CREG_Check_2: (+1)
   \   0000005E   0x7A41             LDRB     R1,[R0, #+9]
   \   00000060   0x2901             CMP      R1,#+1
   \   00000062   0xD002             BEQ.N    ??Modem_CREG_Check_4
   \   00000064   0x7A00             LDRB     R0,[R0, #+8]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??Modem_CREG_Check_3
   \                     ??Modem_CREG_Check_4: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       Modem_SocketClose
   1017            }
   1018            if(val2 == 1 || val2 == 5) {
   \                     ??Modem_CREG_Check_3: (+1)
   \   00000070   0x2D01             CMP      R5,#+1
   \   00000072   0xD001             BEQ.N    ??Modem_CREG_Check_5
   \   00000074   0x2D05             CMP      R5,#+5
   \   00000076   0xD109             BNE.N    ??Modem_CREG_Check_6
   1019              resp = 1;
   \                     ??Modem_CREG_Check_5: (+1)
   \   00000078   0x2601             MOVS     R6,#+1
   1020              ReadValue.Sts.Comm = 0;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable144_7
   \   0000007E   0xF890 0x1057      LDRB     R1,[R0, #+87]
   \   00000082   0xF001 0x01BF      AND      R1,R1,#0xBF
   \   00000086   0xF880 0x1057      STRB     R1,[R0, #+87]
   \   0000008A   0xE00C             B.N      ??Modem_CREG_Check_7
   1021            }
   1022            else {
   1023              printk("\r\nMODEM : CREG ERROR\r\n");   
   \                     ??Modem_CREG_Check_6: (+1)
   \   0000008C   0x.... 0x....      ADR.W    R0,?_25
   \   00000090   0x.... 0x....      BL       printk
   1024              ReadValue.Sts.Comm = 1;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable144_7
   \   00000098   0xF890 0x1057      LDRB     R1,[R0, #+87]
   \   0000009C   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000A0   0xF880 0x1057      STRB     R1,[R0, #+87]
   1025              resp = 0;
   \   000000A4   0x2600             MOVS     R6,#+0
   1026            }
   1027            
   1028            printk("\r\nMODEM : Check CREG status %u / %u,%u\r\n", resp,val1,val2);
   \                     ??Modem_CREG_Check_7: (+1)
   \   000000A6   0x462B             MOV      R3,R5
   \   000000A8   0xB2E4             UXTB     R4,R4
   \   000000AA   0x4622             MOV      R2,R4
   \   000000AC   0x4631             MOV      R1,R6
   \   000000AE   0x.... 0x....      ADR.W    R0,?_26
   \   000000B2   0x.... 0x....      BL       printk
   1029            return resp;
   \   000000B6   0x4630             MOV      R0,R6
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
   1030          }
   1031          
   1032          
   1033          /*
   1034          ********************************************************************************
   1035          * Description : Modem_CSQ_Check
   1036          * Arguments   : none
   1037          * Return      : resp
   1038          * Note        : Modem CSQ Check
   1039          ******************************************************************************** 
   1040          */

   \                                 In section .text, align 2, keep-with-next
   1041          unsigned char Modem_CSQ_Check(void)
   1042          {
   \                     Modem_CSQ_Check: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1043            unsigned char resp;
   1044            
   1045            resp=0;
   1046            resp = AT_SendWithRecieveData("AT+CSQ\r\n","+CSQ: ", 2, 1000);
   \   00000002   0xF44F 0x737A      MOV      R3,#+1000
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0x.... 0x....      ADR.W    R1,?_28
   \   0000000C   0x.... 0x....      ADR.W    R0,?_27
   \   00000010   0x.... 0x....      BL       AT_SendWithRecieveData
   \   00000014   0x4604             MOV      R4,R0
   1047            u8 val1 = AsciiToVal(ATCmdRxMsg[0]);
   \   00000016   0x.... 0x....      LDR.W    R6,??DataTable141
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x.... 0x....      BL       AsciiToVal
   \   00000020   0x4605             MOV      R5,R0
   1048            u8 val2 = AsciiToVal(ATCmdRxMsg[1]);
   \   00000022   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000026   0x.... 0x....      BL       AsciiToVal
   1049            
   1050            if(resp != 1) {
   \   0000002A   0xB2E4             UXTB     R4,R4
   \   0000002C   0x4626             MOV      R6,R4
   \   0000002E   0x....             LDR.N    R0,??DataTable139_1
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD015             BEQ.N    ??Modem_CSQ_Check_0
   1051              if(TcpState == 1 || TCP_Open)  Modem_SocketClose(0);
   \   00000034   0x7A41             LDRB     R1,[R0, #+9]
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD002             BEQ.N    ??Modem_CSQ_Check_1
   \   0000003A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??Modem_CSQ_Check_2
   \                     ??Modem_CSQ_Check_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       Modem_SocketClose
   1052              printk("\r\nMODEM : CSQ ERROR\r\n");   
   \                     ??Modem_CSQ_Check_2: (+1)
   \   00000046   0x.... 0x....      ADR.W    R0,?_29
   \   0000004A   0x.... 0x....      BL       printk
   1053              ReadValue.Sts.Comm = 1;
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable144_7
   \   00000052   0xF891 0x0057      LDRB     R0,[R1, #+87]
   \   00000056   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000005A   0xF881 0x0057      STRB     R0,[R1, #+87]
   \   0000005E   0xE00F             B.N      ??Modem_CSQ_Check_3
   1054            }
   1055            else {
   1056              RSSI = val1;
   \                     ??Modem_CSQ_Check_0: (+1)
   \   00000060   0x.... 0x....      LDR.W    R2,??DataTable144_10
   \   00000064   0x7015             STRB     R5,[R2, #+0]
   1057              ReadValue.CSQ = RSSI;
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable144_7
   \   0000006A   0x7812             LDRB     R2,[R2, #+0]
   \   0000006C   0x734A             STRB     R2,[R1, #+13]
   1058              TCP_Open = 0;
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x7202             STRB     R2,[R0, #+8]
   1059              TcpState = 0;
   \   00000072   0x7242             STRB     R2,[R0, #+9]
   1060              ReadValue.Sts.Comm = 0;
   \   00000074   0xF891 0x0057      LDRB     R0,[R1, #+87]
   \   00000078   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   0000007C   0xF881 0x0057      STRB     R0,[R1, #+87]
   1061            }
   1062            
   1063            printk("\r\nMODEM : Check CSQ status %u / %u\r\n", resp, val1);
   \                     ??Modem_CSQ_Check_3: (+1)
   \   00000080   0xB2ED             UXTB     R5,R5
   \   00000082   0x462A             MOV      R2,R5
   \   00000084   0x4631             MOV      R1,R6
   \   00000086   0x.... 0x....      ADR.W    R0,?_30
   \   0000008A   0x.... 0x....      BL       printk
   1064            return resp;
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
   1065          }
   1066          
   1067          /*
   1068          ********************************************************************************
   1069          * Description : Modem_CREG_Check
   1070          * Arguments   : none
   1071          * Return      : resp
   1072          * Note        : CREG Check
   1073          ******************************************************************************** 
   1074          */

   \                                 In section .text, align 2, keep-with-next
   1075          unsigned char Modem_State_Check(void)
   1076          {
   \                     Modem_State_Check: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x....             LDR.N    R0,??DataTable139
   \   00000006   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0xD001             BEQ.N    ??Modem_State_Check_0
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD165             BNE.N    ??Modem_State_Check_1
   1077            
   1078            unsigned char resp;
   1079            u8 i, val[7];
   1080            
   1081            if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1)  {
   1082              resp=0;
   1083              resp = AT_SendWithRecieveData("AT$$MODEM_STATE?\r","$$MODEM_STATE: ", 7, 1000);
   \                     ??Modem_State_Check_0: (+1)
   \   00000012   0xF44F 0x737A      MOV      R3,#+1000
   \   00000016   0x2207             MOVS     R2,#+7
   \   00000018   0x.... 0x....      ADR.W    R1,?_32
   \   0000001C   0x.... 0x....      ADR.W    R0,?_31
   \   00000020   0x.... 0x....      BL       AT_SendWithRecieveData
   \   00000024   0x4605             MOV      R5,R0
   1084              for(i = 0; i < 7; i++) {
   \   00000026   0x2600             MOVS     R6,#+0
   \   00000028   0xAC04             ADD      R4,SP,#+16
   \   0000002A   0xE007             B.N      ??Modem_State_Check_2
   1085                val[i] = AsciiToVal(ATCmdRxMsg[i]);
   \                     ??Modem_State_Check_3: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable141
   \   00000030   0xEB00 0x1046      ADD      R0,R0,R6, LSL #+5
   \   00000034   0x.... 0x....      BL       AsciiToVal
   \   00000038   0x55A0             STRB     R0,[R4, R6]
   1086              }
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \                     ??Modem_State_Check_2: (+1)
   \   0000003C   0x2E07             CMP      R6,#+7
   \   0000003E   0xDBF5             BLT.N    ??Modem_State_Check_3
   1087          
   1088              if(resp == 1 && val[0] == 0 && val[2] == 0 && val[3] == 0 && val[5] == 0  && val[6] == 0 ) {
   \   00000040   0xB2ED             UXTB     R5,R5
   \   00000042   0x2D01             CMP      R5,#+1
   \   00000044   0xD121             BNE.N    ??Modem_State_Check_4
   \   00000046   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD11D             BNE.N    ??Modem_State_Check_4
   \   0000004E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD11A             BNE.N    ??Modem_State_Check_4
   \   00000054   0x78E0             LDRB     R0,[R4, #+3]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD117             BNE.N    ??Modem_State_Check_4
   \   0000005A   0x7960             LDRB     R0,[R4, #+5]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD114             BNE.N    ??Modem_State_Check_4
   \   00000060   0x79A0             LDRB     R0,[R4, #+6]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD111             BNE.N    ??Modem_State_Check_4
   1089                RSSI = val[1];
   \   00000066   0x7860             LDRB     R0,[R4, #+1]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable144_10
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
   1090                TCP_Open = 0;
   \   0000006E   0x....             LDR.N    R0,??DataTable139_1
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x7201             STRB     R1,[R0, #+8]
   1091                TcpState = 0;
   \   00000074   0x7241             STRB     R1,[R0, #+9]
   1092                ReadValue.Sts.Comm = 0;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable144_7
   \   0000007A   0xF890 0x1057      LDRB     R1,[R0, #+87]
   \   0000007E   0xF001 0x01BF      AND      R1,R1,#0xBF
   \   00000082   0xF880 0x1057      STRB     R1,[R0, #+87]
   1093                resp = 1;
   \   00000086   0x2501             MOVS     R5,#+1
   \   00000088   0xE018             B.N      ??Modem_State_Check_5
   1094              }
   1095              else {
   1096                printk("\r\nMODEM : MODEM_STATE ERROR\r\n"); 
   \                     ??Modem_State_Check_4: (+1)
   \   0000008A   0x.... 0x....      ADR.W    R0,?_33
   \   0000008E   0x.... 0x....      BL       printk
   1097                if(val[6] != 0) {
   \   00000092   0x79A0             LDRB     R0,[R4, #+6]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD008             BEQ.N    ??Modem_State_Check_6
   1098                  ModemServiceFaultCnt++;
   \   00000098   0x....             LDR.N    R0,??DataTable139_1
   \   0000009A   0x7E41             LDRB     R1,[R0, #+25]
   \   0000009C   0x1C49             ADDS     R1,R1,#+1
   \   0000009E   0x7641             STRB     R1,[R0, #+25]
   1099                  if(ModemServiceFaultCnt > 3)
   \   000000A0   0xB2C9             UXTB     R1,R1
   \   000000A2   0x2904             CMP      R1,#+4
   \   000000A4   0xDB01             BLT.N    ??Modem_State_Check_6
   1100                    ModemServiceFault = 1;
   \   000000A6   0x2101             MOVS     R1,#+1
   \   000000A8   0x7681             STRB     R1,[R0, #+26]
   1101                }
   1102                ReadValue.Sts.Comm = 1;
   \                     ??Modem_State_Check_6: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable144_7
   \   000000AE   0xF890 0x1057      LDRB     R1,[R0, #+87]
   \   000000B2   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000B6   0xF880 0x1057      STRB     R1,[R0, #+87]
   1103                resp = 0;
   \   000000BA   0x2500             MOVS     R5,#+0
   1104              }
   1105              
   1106              printk("\r\nMODEM : Check modem status %u,%u,%u,%u,%u,%u,%u\r\n", val[0], val[1], val[2], val[3], val[4], val[5], val[6]);
   \                     ??Modem_State_Check_5: (+1)
   \   000000BC   0x79A0             LDRB     R0,[R4, #+6]
   \   000000BE   0x9003             STR      R0,[SP, #+12]
   \   000000C0   0x7960             LDRB     R0,[R4, #+5]
   \   000000C2   0x9002             STR      R0,[SP, #+8]
   \   000000C4   0x7920             LDRB     R0,[R4, #+4]
   \   000000C6   0x9001             STR      R0,[SP, #+4]
   \   000000C8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x78A3             LDRB     R3,[R4, #+2]
   \   000000CE   0x7862             LDRB     R2,[R4, #+1]
   \   000000D0   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   000000D4   0x.... 0x....      ADR.W    R0,?_34
   \   000000D8   0x.... 0x....      BL       printk
   \   000000DC   0xE002             B.N      ??Modem_State_Check_7
   1107            }
   1108            else {
   1109              resp = Modem_CSQ_Check();
   \                     ??Modem_State_Check_1: (+1)
   \   000000DE   0x.... 0x....      BL       Modem_CSQ_Check
   \   000000E2   0x4605             MOV      R5,R0
   1110            }
   1111            return resp;
   \                     ??Modem_State_Check_7: (+1)
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0xB006             ADD      SP,SP,#+24
   \   000000E8   0xBD70             POP      {R4-R6,PC}       ;; return
   1112          }
   1113          
   1114          
   1115          /*
   1116          ********************************************************************************
   1117          * Description : Modem_PPPOpen
   1118          * Arguments   : sw
   1119          * Return      : resp
   1120          * Note        : Modem ppp open
   1121          ******************************************************************************** 
   1122          */

   \                                 In section .text, align 2, keep-with-next
   1123          unsigned char Modem_PPPOpen(void)
   1124          {
   \                     Modem_PPPOpen: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R0,??DataTable139
   \   00000004   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD001             BEQ.N    ??Modem_PPPOpen_0
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD11D             BNE.N    ??Modem_PPPOpen_1
   1125            unsigned char resp;
   1126            
   1127          //  resp = sendATcommand("AT$$TCP_PPPOP\r", "OK", "ERROR", 5000);
   1128            if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1)  {
   1129              resp = AT_SendWithRecieveData("AT$$TCP_PPPOP\r","$$TCP_PPPOP: ", 1, 5000);
   \                     ??Modem_PPPOpen_0: (+1)
   \   00000010   0xF241 0x3388      MOVW     R3,#+5000
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x.... 0x....      ADR.W    R1,?_36
   \   0000001A   0x.... 0x....      ADR.W    R0,?_35
   \   0000001E   0x.... 0x....      BL       AT_SendWithRecieveData
   1130              if(resp == 1 && ATCmdRxMsg[0][0] == '0') {
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD106             BNE.N    ??Modem_PPPOpen_2
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable141
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2830             CMP      R0,#+48
   \   00000030   0xD101             BNE.N    ??Modem_PPPOpen_2
   1131                resp = 1;
   \   00000032   0x2401             MOVS     R4,#+1
   \   00000034   0xE000             B.N      ??Modem_PPPOpen_3
   1132          //      PppState = 1;
   1133              }
   1134              else
   1135                resp = 0;
   \                     ??Modem_PPPOpen_2: (+1)
   \   00000036   0x2400             MOVS     R4,#+0
   1136              vTaskDelay(2000);
   \                     ??Modem_PPPOpen_3: (+1)
   \   00000038   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000003C   0x.... 0x....      BL       vTaskDelay
   1137              if(resp == 1)
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xD101             BNE.N    ??Modem_PPPOpen_4
   1138                return 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}
   1139              else
   1140                return 0;
   \                     ??Modem_PPPOpen_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}
   1141            }
   1142            else if(Setting.ExtModemModel == 2){
   \                     ??Modem_PPPOpen_1: (+1)
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD11B             BNE.N    ??Modem_PPPOpen_5
   1143              if(PppState != 1) {
   \   00000050   0x....             LDR.N    R5,??DataTable139_1
   \   00000052   0x7DA8             LDRB     R0,[R5, #+22]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD015             BEQ.N    ??Modem_PPPOpen_6
   1144                resp = sendATcommand("AT@NETCONN=1\r", "OK", "ERROR", 5000);
   \   00000058   0xF241 0x3388      MOVW     R3,#+5000
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable142
   \   00000060   0x....             ADR.N    R1,??DataTable140_1  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000062   0x.... 0x....      ADR.W    R0,?_37
   \   00000066   0x.... 0x....      BL       sendATcommand
   \   0000006A   0x4604             MOV      R4,R0
   1145                vTaskDelay(2000);
   \   0000006C   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000070   0x.... 0x....      BL       vTaskDelay
   1146                if(resp == 1) {
   \   00000074   0x2C01             CMP      R4,#+1
   \   00000076   0xD103             BNE.N    ??Modem_PPPOpen_7
   1147                  PppState = 3;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0x75A8             STRB     R0,[R5, #+22]
   1148                  return 1;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xBD32             POP      {R1,R4,R5,PC}
   1149                }
   1150                else
   1151                  return 0;
   \                     ??Modem_PPPOpen_7: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD32             POP      {R1,R4,R5,PC}
   1152              }
   1153              else
   1154                return 1;
   \                     ??Modem_PPPOpen_6: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xBD32             POP      {R1,R4,R5,PC}
   1155            }
   1156             return 1;
   \                     ??Modem_PPPOpen_5: (+1)
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1157          }
   1158          
   1159          /*
   1160          ********************************************************************************
   1161          * Description : Modem_PPPClose
   1162          * Arguments   : sw
   1163          * Return      : resp
   1164          * Note        : Modem ppp open
   1165          ******************************************************************************** 
   1166          */

   \                                 In section .text, align 2, keep-with-next
   1167          unsigned char Modem_PPPClose(void)
   1168          {
   \                     Modem_PPPClose: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable145_2
   \   00000006   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0xD001             BEQ.N    ??Modem_PPPClose_0
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD11A             BNE.N    ??Modem_PPPClose_1
   1169            unsigned char resp;
   1170            
   1171          //  resp = sendATcommand("AT$$TCP_PPPCL\r", "OK", "ERROR", 5000);
   1172            if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1)  {
   1173              if(PppState != 1) return 1;
   \                     ??Modem_PPPClose_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable144_1
   \   00000016   0x7D80             LDRB     R0,[R0, #+22]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD001             BEQ.N    ??Modem_PPPClose_2
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD10             POP      {R4,PC}
   1174              resp = AT_SendWithRecieveData("AT$$TCP_PPPCL\r","$$TCP_PPPCL: ", 1, 5000);
   \                     ??Modem_PPPClose_2: (+1)
   \   00000020   0xF241 0x3388      MOVW     R3,#+5000
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x.... 0x....      ADR.W    R1,?_39
   \   0000002A   0x.... 0x....      ADR.W    R0,?_38
   \   0000002E   0x.... 0x....      BL       AT_SendWithRecieveData
   1175              if(resp == 1 && ATCmdRxMsg[0][0] == '0')
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD105             BNE.N    ??Modem_PPPClose_3
   \   00000038   0x....             LDR.N    R0,??DataTable141
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2830             CMP      R0,#+48
   \   0000003E   0xD101             BNE.N    ??Modem_PPPClose_3
   1176                resp = 1;
   \   00000040   0x2401             MOVS     R4,#+1
   \   00000042   0xE018             B.N      ??Modem_PPPClose_4
   1177              else
   1178                resp = 0;
   \                     ??Modem_PPPClose_3: (+1)
   \   00000044   0x2400             MOVS     R4,#+0
   \   00000046   0xE016             B.N      ??Modem_PPPClose_4
   1179            }
   1180            else if(Setting.ExtModemModel == 2){
   \                     ??Modem_PPPClose_1: (+1)
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD114             BNE.N    ??Modem_PPPClose_4
   1181              if(TcpState == 1) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable145_3
   \   00000050   0x7A40             LDRB     R0,[R0, #+9]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD10E             BNE.N    ??Modem_PPPClose_5
   1182                resp = sendATcommand("AT@SOCKCLOSE=0\r", "OK", "ERROR", 5000);
   \   00000056   0xF241 0x3388      MOVW     R3,#+5000
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable142
   \   0000005E   0x....             ADR.N    R1,??DataTable140_1  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable145_4
   \   00000064   0x.... 0x....      BL       sendATcommand
   \   00000068   0x4604             MOV      R4,R0
   1183                vTaskDelay(1000);
   \   0000006A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000006E   0x.... 0x....      BL       vTaskDelay
   \   00000072   0xE000             B.N      ??Modem_PPPClose_4
   1184              }
   1185              else  resp = 1;
   \                     ??Modem_PPPClose_5: (+1)
   \   00000074   0x2401             MOVS     R4,#+1
   1186          //    if(PppState == 1) {
   1187          //      resp = sendATcommand("AT@NETCONN=0\r", "OK", "ERROR", 5000);
   1188          //      if(resp != 1) resp = 0;
   1189          //    }
   1190          //    else  resp = 1;
   1191            }
   1192            vTaskDelay(2000);
   \                     ??Modem_PPPClose_4: (+1)
   \   00000076   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000007A   0x.... 0x....      BL       vTaskDelay
   1193            if(resp == 1)
   \   0000007E   0xB2E4             UXTB     R4,R4
   \   00000080   0x2C01             CMP      R4,#+1
   \   00000082   0xD101             BNE.N    ??Modem_PPPClose_6
   1194              return 1;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xBD10             POP      {R4,PC}
   1195            else
   1196              return 0;
   \                     ??Modem_PPPClose_6: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBD10             POP      {R4,PC}          ;; return
   1197          }
   1198          
   1199          u16 APNProcessCnt;
   1200          

   \                                 In section .text, align 2, keep-with-next
   1201          unsigned char APNProcess(unsigned char mode)
   1202          {
   \                     APNProcess: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1203            unsigned char resp,rcnt, len;
   1204            
   1205            if(mode > 0) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable145_3
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xD007             BEQ.N    ??APNProcess_0
   1206              if(ModemServiceFault)
   \   0000000A   0x7EA1             LDRB     R1,[R4, #+26]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??APNProcess_1
   1207                ModemStep = MODEM_POWER_ON;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x72A1             STRB     R1,[R4, #+10]
   1208              ModemServiceFaultCnt = 0;
   \                     ??APNProcess_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7661             STRB     R1,[R4, #+25]
   1209              ModemServiceFault = 0;
   \   00000018   0x76A1             STRB     R1,[R4, #+26]
   1210            }
   1211            if(mode == 0) {
   \                     ??APNProcess_0: (+1)
   \   0000001A   0x0001             MOVS     R1,R0
   \   0000001C   0xD139             BNE.N    ??APNProcess_2
   1212              resp = AT_SendWithRecieveData("AT+CGDCONT?\r\n","+CGDCONT: ", 6, 1000);
   \   0000001E   0xF44F 0x737A      MOV      R3,#+1000
   \   00000022   0x2206             MOVS     R2,#+6
   \   00000024   0x.... 0x....      ADR.W    R1,?_42
   \   00000028   0x.... 0x....      ADR.W    R0,?_41
   \   0000002C   0x.... 0x....      BL       AT_SendWithRecieveData
   \   00000030   0x4605             MOV      R5,R0
   1213              len = StringLen(ATCmdRxMsg[2],32);
   \   00000032   0x....             LDR.N    R6,??DataTable141
   \   00000034   0x2120             MOVS     R1,#+32
   \   00000036   0xF106 0x0040      ADD      R0,R6,#+64
   \   0000003A   0x.... 0x....      BL       StringLen
   \   0000003E   0x4607             MOV      R7,R0
   1214              if(resp == 1 && IsSameString(APN_Name,ATCmdRxMsg[2],len) == 0) {
   \   00000040   0xB2ED             UXTB     R5,R5
   \   00000042   0x2D01             CMP      R5,#+1
   \   00000044   0xD11E             BNE.N    ??APNProcess_3
   \   00000046   0x463A             MOV      R2,R7
   \   00000048   0xB2D2             UXTB     R2,R2
   \   0000004A   0xF106 0x0140      ADD      R1,R6,#+64
   \   0000004E   0xF104 0x003C      ADD      R0,R4,#+60
   \   00000052   0x.... 0x....      BL       IsSameString
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD114             BNE.N    ??APNProcess_3
   1215                memset((u8*)APN_Name, 0, sizeof(APN_Name));
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x2120             MOVS     R1,#+32
   \   0000005E   0xF104 0x003C      ADD      R0,R4,#+60
   \   00000062   0x.... 0x....      BL       __aeabi_memset4
   1216                memcpy((u8*)APN_Name, (u8*)ATCmdRxMsg[2], len);
   \   00000066   0xB2FF             UXTB     R7,R7
   \   00000068   0x463A             MOV      R2,R7
   \   0000006A   0xF106 0x0140      ADD      R1,R6,#+64
   \   0000006E   0xF104 0x003C      ADD      R0,R4,#+60
   \   00000072   0x.... 0x....      BL       __aeabi_memcpy
   1217                FRAMMultiWrite((u8*)APN_Name, APN_NAME_INFO, sizeof(APN_Name));  
   \   00000076   0x2220             MOVS     R2,#+32
   \   00000078   0xF44F 0x7120      MOV      R1,#+640
   \   0000007C   0xF104 0x003C      ADD      R0,R4,#+60
   \   00000080   0x.... 0x....      BL       FRAMMultiWrite
   1218              }
   1219              if(MtReadAPNFlag ) MtTxAPNFlag = 1;
   \                     ??APNProcess_3: (+1)
   \   00000084   0x7860             LDRB     R0,[R4, #+1]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xF000 0x80F2      BEQ.W    ??APNProcess_4
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x7020             STRB     R0,[R4, #+0]
   \   00000090   0xE0EE             B.N      ??APNProcess_4
   1220            }
   1221            else if(mode == 1) {
   \                     ??APNProcess_2: (+1)
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD13E             BNE.N    ??APNProcess_5
   1222              Modem_PPPClose();
   \   00000096   0x.... 0x....      BL       Modem_PPPClose
   1223              memset(MdmTmpString,0,100);
   \   0000009A   0x2200             MOVS     R2,#+0
   \   0000009C   0x2164             MOVS     R1,#+100
   \   0000009E   0xF104 0x007C      ADD      R0,R4,#+124
   \   000000A2   0x.... 0x....      BL       __aeabi_memset4
   1224              if(Setting.ExtModemModel == 1 || Setting.ExtModemModel == 2)  
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable145_2
   \   000000AA   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD001             BEQ.N    ??APNProcess_6
   \   000000B2   0x2802             CMP      R0,#+2
   \   000000B4   0xD108             BNE.N    ??APNProcess_7
   1225                sprintf(MdmTmpString, "AT+CGDCONT=1,\"IPV4V6\",\"%s\"\r\n",APN_Name);
   \                     ??APNProcess_6: (+1)
   \   000000B6   0xF104 0x023C      ADD      R2,R4,#+60
   \   000000BA   0x.... 0x....      ADR.W    R1,?_43
   \   000000BE   0xF104 0x007C      ADD      R0,R4,#+124
   \   000000C2   0x.... 0x....      BL       sprintf
   \   000000C6   0xE007             B.N      ??APNProcess_8
   1226              else
   1227                sprintf(MdmTmpString, "AT+CGDCONT=1,\"IP\",\"%s\"\r\n",APN_Name);
   \                     ??APNProcess_7: (+1)
   \   000000C8   0xF104 0x023C      ADD      R2,R4,#+60
   \   000000CC   0x.... 0x....      ADR.W    R1,?_44
   \   000000D0   0xF104 0x007C      ADD      R0,R4,#+124
   \   000000D4   0x.... 0x....      BL       sprintf
   1228              rcnt=0;  resp=0;
   \                     ??APNProcess_8: (+1)
   \   000000D8   0x2600             MOVS     R6,#+0
   \   000000DA   0x4635             MOV      R5,R6
   \   000000DC   0xE00C             B.N      ??APNProcess_9
   1229              while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1230                resp = sendATcommand(MdmTmpString, "OK", "ERROR", 300); 
   \                     ??APNProcess_10: (+1)
   \   000000DE   0xF44F 0x7396      MOV      R3,#+300
   \   000000E2   0x....             LDR.N    R2,??DataTable142
   \   000000E4   0x....             ADR.N    R1,??DataTable141_1  ;; 0x4F, 0x4B, 0x00, 0x00
   \   000000E6   0xF104 0x007C      ADD      R0,R4,#+124
   \   000000EA   0x.... 0x....      BL       sendATcommand
   \   000000EE   0x4605             MOV      R5,R0
   1231                vTaskDelay(1);
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x.... 0x....      BL       vTaskDelay
   1232                rcnt++;
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   1233              }  
   \                     ??APNProcess_9: (+1)
   \   000000F8   0xB2F6             UXTB     R6,R6
   \   000000FA   0x4630             MOV      R0,R6
   \   000000FC   0x0029             MOVS     R1,R5
   \   000000FE   0xD101             BNE.N    ??APNProcess_11
   \   00000100   0x2805             CMP      R0,#+5
   \   00000102   0xDBEC             BLT.N    ??APNProcess_10
   1234              if(rcnt >= AT_RETRY_CNT) {
   \                     ??APNProcess_11: (+1)
   \   00000104   0x2805             CMP      R0,#+5
   \   00000106   0xDA40             BGE.N    ??APNProcess_12
   1235                printk("\r\nMODEM : CGDCONT ERROR\r\n");
   1236                return resp;
   1237              }
   1238              if(resp == 1) Modem_PPPOpen();
   \   00000108   0x2D01             CMP      R5,#+1
   \   0000010A   0xF040 0x80B1      BNE.W    ??APNProcess_4
   \   0000010E   0x.... 0x....      BL       Modem_PPPOpen
   \   00000112   0xE0AD             B.N      ??APNProcess_4
   1239            }
   1240            else if(mode == 2) {
   \                     ??APNProcess_5: (+1)
   \   00000114   0x2802             CMP      R0,#+2
   \   00000116   0xD144             BNE.N    ??APNProcess_13
   1241              Modem_PPPClose();
   \   00000118   0x.... 0x....      BL       Modem_PPPClose
   1242              memset(MdmTmpString,0,100);
   \   0000011C   0x2200             MOVS     R2,#+0
   \   0000011E   0x2164             MOVS     R1,#+100
   \   00000120   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000124   0x.... 0x....      BL       __aeabi_memset4
   1243              if(Setting.ExtModemModel == 1 || Setting.ExtModemModel == 2)  
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable145_2
   \   0000012C   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   00000130   0x2801             CMP      R0,#+1
   \   00000132   0xD001             BEQ.N    ??APNProcess_14
   \   00000134   0x2802             CMP      R0,#+2
   \   00000136   0xD108             BNE.N    ??APNProcess_15
   1244                sprintf(MdmTmpString, "AT+CGDCONT=1,\"IPV4V6\",\"%s\"\r\n",ComRxAPN_Name);
   \                     ??APNProcess_14: (+1)
   \   00000138   0xF104 0x025C      ADD      R2,R4,#+92
   \   0000013C   0x.... 0x....      ADR.W    R1,?_43
   \   00000140   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000144   0x.... 0x....      BL       sprintf
   \   00000148   0xE007             B.N      ??APNProcess_16
   1245              else
   1246                sprintf(MdmTmpString, "AT+CGDCONT=1,\"IP\",\"%s\"\r\n",ComRxAPN_Name);
   \                     ??APNProcess_15: (+1)
   \   0000014A   0xF104 0x025C      ADD      R2,R4,#+92
   \   0000014E   0x.... 0x....      ADR.W    R1,?_44
   \   00000152   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000156   0x.... 0x....      BL       sprintf
   1247              rcnt=0;  resp=0;
   \                     ??APNProcess_16: (+1)
   \   0000015A   0x2600             MOVS     R6,#+0
   \   0000015C   0x4635             MOV      R5,R6
   \   0000015E   0xE00C             B.N      ??APNProcess_17
   1248              while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1249                resp = sendATcommand(MdmTmpString, "OK", "ERROR", 300); 
   \                     ??APNProcess_18: (+1)
   \   00000160   0xF44F 0x7396      MOV      R3,#+300
   \   00000164   0x....             LDR.N    R2,??DataTable142
   \   00000166   0x....             ADR.N    R1,??DataTable141_1  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000168   0xF104 0x007C      ADD      R0,R4,#+124
   \   0000016C   0x.... 0x....      BL       sendATcommand
   \   00000170   0x4605             MOV      R5,R0
   1250                vTaskDelay(1);
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0x.... 0x....      BL       vTaskDelay
   1251                rcnt++;
   \   00000178   0x1C76             ADDS     R6,R6,#+1
   1252              }  
   \                     ??APNProcess_17: (+1)
   \   0000017A   0xB2F6             UXTB     R6,R6
   \   0000017C   0x4630             MOV      R0,R6
   \   0000017E   0x0029             MOVS     R1,R5
   \   00000180   0xD101             BNE.N    ??APNProcess_19
   \   00000182   0x2805             CMP      R0,#+5
   \   00000184   0xDBEC             BLT.N    ??APNProcess_18
   1253              if(rcnt >= AT_RETRY_CNT) {
   \                     ??APNProcess_19: (+1)
   \   00000186   0x2805             CMP      R0,#+5
   \   00000188   0xDB05             BLT.N    ??APNProcess_20
   1254                printk("\r\nMODEM : CGDCONT ERROR\r\n");
   \                     ??APNProcess_12: (+1)
   \   0000018A   0x.... 0x....      ADR.W    R0,?_45
   \   0000018E   0x.... 0x....      BL       printk
   1255                return resp;
   \   00000192   0x4628             MOV      R0,R5
   \   00000194   0xBDF2             POP      {R1,R4-R7,PC}
   1256              }
   1257              PppState = 0;
   \                     ??APNProcess_20: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x75A0             STRB     R0,[R4, #+22]
   1258              APNProcessCnt = 0;
   \   0000019A   0x8420             STRH     R0,[R4, #+32]
   1259              Modem_PPPOpen();
   \   0000019C   0x.... 0x....      BL       Modem_PPPOpen
   \   000001A0   0xE066             B.N      ??APNProcess_4
   1260            }
   1261            else if(mode == 3) {
   \                     ??APNProcess_13: (+1)
   \   000001A2   0x2803             CMP      R0,#+3
   \   000001A4   0xD164             BNE.N    ??APNProcess_4
   1262              APNProcessCnt++;
   \   000001A6   0x8C20             LDRH     R0,[R4, #+32]
   \   000001A8   0x1C40             ADDS     R0,R0,#+1
   \   000001AA   0x8420             STRH     R0,[R4, #+32]
   1263              if(PppState == 1) {
   \   000001AC   0x7DA1             LDRB     R1,[R4, #+22]
   \   000001AE   0x2901             CMP      R1,#+1
   \   000001B0   0xD116             BNE.N    ??APNProcess_21
   1264                APNProcessCnt = 0;
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x8420             STRH     R0,[R4, #+32]
   1265                memset(APN_Name,0,32);
   \   000001B6   0x4602             MOV      R2,R0
   \   000001B8   0x2120             MOVS     R1,#+32
   \   000001BA   0xF104 0x003C      ADD      R0,R4,#+60
   \   000001BE   0x.... 0x....      BL       __aeabi_memset4
   1266                memcpy((u8*)APN_Name,(u8*)ComRxAPN_Name, sizeof(ComRxAPN_Name));
   \   000001C2   0x2220             MOVS     R2,#+32
   \   000001C4   0xF104 0x015C      ADD      R1,R4,#+92
   \   000001C8   0xF104 0x003C      ADD      R0,R4,#+60
   \   000001CC   0x.... 0x....      BL       __aeabi_memcpy
   1267                FRAMMultiWrite((u8*)APN_Name, APN_NAME_INFO, sizeof(APN_Name));    
   \   000001D0   0x2220             MOVS     R2,#+32
   \   000001D2   0xF44F 0x7120      MOV      R1,#+640
   \   000001D6   0xF104 0x003C      ADD      R0,R4,#+60
   \   000001DA   0x.... 0x....      BL       FRAMMultiWrite
   \   000001DE   0xE047             B.N      ??APNProcess_4
   1268              }
   1269              else if(APNProcessCnt > 10000) {
   \                     ??APNProcess_21: (+1)
   \   000001E0   0xB280             UXTH     R0,R0
   \   000001E2   0xF242 0x7111      MOVW     R1,#+10001
   \   000001E6   0x4288             CMP      R0,R1
   \   000001E8   0xDB42             BLT.N    ??APNProcess_4
   1270                memset(MdmTmpString,0,100);
   \   000001EA   0x2200             MOVS     R2,#+0
   \   000001EC   0x2164             MOVS     R1,#+100
   \   000001EE   0xF104 0x007C      ADD      R0,R4,#+124
   \   000001F2   0x.... 0x....      BL       __aeabi_memset4
   1271                if(Setting.ExtModemModel == 1 || Setting.ExtModemModel == 2)  
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable145_2
   \   000001FA   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   000001FE   0x2801             CMP      R0,#+1
   \   00000200   0xD001             BEQ.N    ??APNProcess_22
   \   00000202   0x2802             CMP      R0,#+2
   \   00000204   0xD108             BNE.N    ??APNProcess_23
   1272                  sprintf(MdmTmpString, "AT+CGDCONT=1,\"IPV4V6\",\"%s\"\r\n",APN_Name);
   \                     ??APNProcess_22: (+1)
   \   00000206   0xF104 0x023C      ADD      R2,R4,#+60
   \   0000020A   0x.... 0x....      ADR.W    R1,?_43
   \   0000020E   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000212   0x.... 0x....      BL       sprintf
   \   00000216   0xE007             B.N      ??APNProcess_24
   1273                else
   1274                  sprintf(MdmTmpString, "AT+CGDCONT=1,\"IP\",\"%s\"\r\n",APN_Name);
   \                     ??APNProcess_23: (+1)
   \   00000218   0xF104 0x023C      ADD      R2,R4,#+60
   \   0000021C   0x.... 0x....      ADR.W    R1,?_44
   \   00000220   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000224   0x.... 0x....      BL       sprintf
   1275                rcnt=0;  resp=0;
   \                     ??APNProcess_24: (+1)
   \   00000228   0x2600             MOVS     R6,#+0
   \   0000022A   0x4635             MOV      R5,R6
   \   0000022C   0xE00C             B.N      ??APNProcess_25
   1276                while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1277                  resp = sendATcommand(MdmTmpString, "OK", "ERROR", 300); 
   \                     ??APNProcess_26: (+1)
   \   0000022E   0xF44F 0x7396      MOV      R3,#+300
   \   00000232   0x....             LDR.N    R2,??DataTable142
   \   00000234   0x....             ADR.N    R1,??DataTable141_1  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000236   0xF104 0x007C      ADD      R0,R4,#+124
   \   0000023A   0x.... 0x....      BL       sendATcommand
   \   0000023E   0x4605             MOV      R5,R0
   1278                  vTaskDelay(1);
   \   00000240   0x2001             MOVS     R0,#+1
   \   00000242   0x.... 0x....      BL       vTaskDelay
   1279                  rcnt++;
   \   00000246   0x1C76             ADDS     R6,R6,#+1
   1280                }  
   \                     ??APNProcess_25: (+1)
   \   00000248   0xB2F6             UXTB     R6,R6
   \   0000024A   0x4630             MOV      R0,R6
   \   0000024C   0x0029             MOVS     R1,R5
   \   0000024E   0xD101             BNE.N    ??APNProcess_27
   \   00000250   0x2805             CMP      R0,#+5
   \   00000252   0xDBEC             BLT.N    ??APNProcess_26
   1281                if(rcnt >= AT_RETRY_CNT) {
   \                     ??APNProcess_27: (+1)
   \   00000254   0x2805             CMP      R0,#+5
   \   00000256   0xDB07             BLT.N    ??APNProcess_28
   1282                  printk("\r\nMODEM : CGDCONT ERROR\r\n");
   \   00000258   0x.... 0x....      ADR.W    R0,?_45
   \   0000025C   0x.... 0x....      BL       printk
   1283                  APNProcessCnt = 0;
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0x8420             STRH     R0,[R4, #+32]
   1284                  return resp;
   \   00000264   0x4628             MOV      R0,R5
   \   00000266   0xBDF2             POP      {R1,R4-R7,PC}
   1285                }
   1286                APNProcessCnt = 0;
   \                     ??APNProcess_28: (+1)
   \   00000268   0x2000             MOVS     R0,#+0
   \   0000026A   0x8420             STRH     R0,[R4, #+32]
   1287                Modem_PPPOpen();
   \   0000026C   0x.... 0x....      BL       Modem_PPPOpen
   1288              }
   1289            }
   1290            
   1291            return resp;
   \                     ??APNProcess_4: (+1)
   \   00000270   0x4628             MOV      R0,R5
   \   00000272   0xB2C0             UXTB     R0,R0
   \   00000274   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1292          }
   1293          

   \                                 In section .text, align 2, keep-with-next
   1294          unsigned char QoSAdust(unsigned char mode, unsigned short val)
   1295          {
   \                     QoSAdust: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x460C             MOV      R4,R1
   1296            unsigned char resp,rcnt;
   1297            u8 cid, tc;
   1298            u16 up,down;
   1299            
   1300            if(Setting.ExtModemModel == 2)   return 1;  
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable145_2
   \   0000000C   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD101             BNE.N    ??QoSAdust_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE08E             B.N      ??QoSAdust_1
   1301            
   1302            resp = AT_SendWithRecieveData("AT+CGEQREQ?\r\n","+CGEQREQ: ",4, 1000);
   \                     ??QoSAdust_0: (+1)
   \   00000018   0xF44F 0x737A      MOV      R3,#+1000
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x.... 0x....      ADR.W    R1,?_47
   \   00000022   0x.... 0x....      ADR.W    R0,?_46
   \   00000026   0x.... 0x....      BL       AT_SendWithRecieveData
   \   0000002A   0x4605             MOV      R5,R0
   1303            cid = AsciiToVal(ATCmdRxMsg[0]);
   \   0000002C   0x.... 0x....      LDR.W    R10,??DataTable144_11
   \   00000030   0x4650             MOV      R0,R10
   \   00000032   0x.... 0x....      BL       AsciiToVal
   \   00000036   0x4606             MOV      R6,R0
   \   00000038   0xB2F6             UXTB     R6,R6
   1304            tc = AsciiToVal(ATCmdRxMsg[1]);
   \   0000003A   0xF10A 0x0020      ADD      R0,R10,#+32
   \   0000003E   0x.... 0x....      BL       AsciiToVal
   \   00000042   0x4607             MOV      R7,R0
   \   00000044   0xB2FF             UXTB     R7,R7
   1305            up = AsciiToVal(ATCmdRxMsg[2]);
   \   00000046   0xF10A 0x0040      ADD      R0,R10,#+64
   \   0000004A   0x.... 0x....      BL       AsciiToVal
   \   0000004E   0x4680             MOV      R8,R0
   1306            down = AsciiToVal(ATCmdRxMsg[3]);
   \   00000050   0xF10A 0x0060      ADD      R0,R10,#+96
   \   00000054   0x.... 0x....      BL       AsciiToVal
   \   00000058   0x4682             MOV      R10,R0
   1307            
   1308            if(mode == 0) { // Upload
   \   0000005A   0x4648             MOV      R0,R9
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD132             BNE.N    ??QoSAdust_2
   1309              memset(MdmTmpString,0,100);
   \   00000060   0x.... 0x....      LDR.W    R9,??DataTable145_3
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x2164             MOVS     R1,#+100
   \   00000068   0xF109 0x007C      ADD      R0,R9,#+124
   \   0000006C   0x.... 0x....      BL       __aeabi_memset
   1310          //    sprintf(MdmTmpString, "AT+CGEQREQ=1,\"IP\",4,%u,0,%u,0\r",val,val);
   1311              sprintf(MdmTmpString, "AT+CGEQREQ=%u,%u,%u,%u\r\n",cid,tc,val,down);
   \   00000070   0xFA1F 0xFA8A      UXTH     R10,R10
   \   00000074   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   00000078   0x9400             STR      R4,[SP, #+0]
   \   0000007A   0x463B             MOV      R3,R7
   \   0000007C   0x4632             MOV      R2,R6
   \   0000007E   0x.... 0x....      ADR.W    R1,?_48
   \   00000082   0xF109 0x007C      ADD      R0,R9,#+124
   \   00000086   0x.... 0x....      BL       sprintf
   1312              rcnt=0;  resp=0;
   \   0000008A   0x2400             MOVS     R4,#+0
   \   0000008C   0x4625             MOV      R5,R4
   \   0000008E   0xE00C             B.N      ??QoSAdust_3
   1313              while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1314                resp = sendATcommand(MdmTmpString, "OK", "ERROR", 300); 
   \                     ??QoSAdust_4: (+1)
   \   00000090   0xF44F 0x7396      MOV      R3,#+300
   \   00000094   0x....             LDR.N    R2,??DataTable142
   \   00000096   0x....             ADR.N    R1,??DataTable144  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000098   0xF109 0x007C      ADD      R0,R9,#+124
   \   0000009C   0x.... 0x....      BL       sendATcommand
   \   000000A0   0x4605             MOV      R5,R0
   1315                vTaskDelay(1);
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x.... 0x....      BL       vTaskDelay
   1316                rcnt++;
   \   000000A8   0x1C64             ADDS     R4,R4,#+1
   1317              }  
   \                     ??QoSAdust_3: (+1)
   \   000000AA   0xB2E4             UXTB     R4,R4
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x0029             MOVS     R1,R5
   \   000000B0   0xD101             BNE.N    ??QoSAdust_5
   \   000000B2   0x2805             CMP      R0,#+5
   \   000000B4   0xDBEC             BLT.N    ??QoSAdust_4
   1318              if(rcnt >= AT_RETRY_CNT) {
   \                     ??QoSAdust_5: (+1)
   \   000000B6   0x2805             CMP      R0,#+5
   \   000000B8   0xDB3B             BLT.N    ??QoSAdust_6
   1319                printk("\r\nMODEM : CGEQREQ Upload ERROR\r\n");
   \   000000BA   0x.... 0x....      ADR.W    R0,?_49
   \   000000BE   0x.... 0x....      BL       printk
   1320                return resp;
   \   000000C2   0x4628             MOV      R0,R5
   \   000000C4   0xE037             B.N      ??QoSAdust_1
   1321              }
   1322            }
   1323            else if(mode == 1) {  // Dnload
   \                     ??QoSAdust_2: (+1)
   \   000000C6   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000CA   0xD132             BNE.N    ??QoSAdust_6
   1324              memset(MdmTmpString,0,100);
   \   000000CC   0x.... 0x....      LDR.W    R9,??DataTable145_3
   \   000000D0   0x2200             MOVS     R2,#+0
   \   000000D2   0x2164             MOVS     R1,#+100
   \   000000D4   0xF109 0x007C      ADD      R0,R9,#+124
   \   000000D8   0x.... 0x....      BL       __aeabi_memset
   1325          //    sprintf(MdmTmpString, "AT+CGEQREQ=1,\"IP\",4,0,%u,0,%u\r",val,val);
   1326              sprintf(MdmTmpString, "AT+CGEQREQ=%u,%u,%u,%u\r\n",cid,tc,up,val);
   \   000000DC   0x9401             STR      R4,[SP, #+4]
   \   000000DE   0xFA1F 0xF888      UXTH     R8,R8
   \   000000E2   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000E6   0x463B             MOV      R3,R7
   \   000000E8   0x4632             MOV      R2,R6
   \   000000EA   0x.... 0x....      ADR.W    R1,?_48
   \   000000EE   0xF109 0x007C      ADD      R0,R9,#+124
   \   000000F2   0x.... 0x....      BL       sprintf
   1327              rcnt=0;  resp=0;
   \   000000F6   0x2400             MOVS     R4,#+0
   \   000000F8   0x4625             MOV      R5,R4
   \   000000FA   0xE00C             B.N      ??QoSAdust_7
   1328              while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1329                resp = sendATcommand(MdmTmpString, "OK", "ERROR", 300); 
   \                     ??QoSAdust_8: (+1)
   \   000000FC   0xF44F 0x7396      MOV      R3,#+300
   \   00000100   0x....             LDR.N    R2,??DataTable142
   \   00000102   0x....             ADR.N    R1,??DataTable144  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000104   0xF109 0x007C      ADD      R0,R9,#+124
   \   00000108   0x.... 0x....      BL       sendATcommand
   \   0000010C   0x4605             MOV      R5,R0
   1330                vTaskDelay(1);
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0x.... 0x....      BL       vTaskDelay
   1331                rcnt++;
   \   00000114   0x1C64             ADDS     R4,R4,#+1
   1332              }  
   \                     ??QoSAdust_7: (+1)
   \   00000116   0xB2E4             UXTB     R4,R4
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x0029             MOVS     R1,R5
   \   0000011C   0xD101             BNE.N    ??QoSAdust_9
   \   0000011E   0x2805             CMP      R0,#+5
   \   00000120   0xDBEC             BLT.N    ??QoSAdust_8
   1333              if(rcnt >= AT_RETRY_CNT) {
   \                     ??QoSAdust_9: (+1)
   \   00000122   0x2805             CMP      R0,#+5
   \   00000124   0xDB05             BLT.N    ??QoSAdust_6
   1334                printk("\r\nMODEM : CGEQREQ Dnload ERROR\r\n");
   \   00000126   0x.... 0x....      ADR.W    R0,?_50
   \   0000012A   0x.... 0x....      BL       printk
   1335                return resp;
   \   0000012E   0x4628             MOV      R0,R5
   \   00000130   0xE001             B.N      ??QoSAdust_1
   1336              }    
   1337            }
   1338          
   1339            return resp;
   \                     ??QoSAdust_6: (+1)
   \   00000132   0x4628             MOV      R0,R5
   \   00000134   0xB2C0             UXTB     R0,R0
   \                     ??QoSAdust_1: (+1)
   \   00000136   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1340          }
   1341          
   1342          

   \                                 In section .text, align 2, keep-with-next
   1343          int ServerIPCheck(void) 
   1344          {
   \                     ServerIPCheck: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   1345            unsigned char rip[4] = {0,}, sip[4], idx = 0; 
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x460C             MOV      R4,R1
   1346            unsigned short port, sport, val = 0;
   \   0000000C   0x460F             MOV      R7,R1
   1347            unsigned char i, resp;
   1348            
   1349            resp=0;  
   1350          
   1351            if(Setting.ExtModemModel == 2)   {
   \   0000000E   0x.... 0x....      LDR.W    R8,??DataTable150_1
   \   00000012   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD105             BNE.N    ??ServerIPCheck_0
   1352              ServerIPCheckFlag = 0;
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable145_3
   \   00000020   0x7388             STRB     R0,[R1, #+14]
   1353              return 1;   
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE080             B.N      ??ServerIPCheck_1
   1354            }
   1355            
   1356            resp = AT_SendWithRecieveData("AT$$TCP_ADDR?\r","[0] ", 1, 2000);
   \                     ??ServerIPCheck_0: (+1)
   \   00000026   0xF44F 0x63FA      MOV      R3,#+2000
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x.... 0x....      ADR.W    R1,?_53
   \   00000030   0x.... 0x....      ADR.W    R0,?_52
   \   00000034   0x.... 0x....      BL       AT_SendWithRecieveData
   \   00000038   0x4681             MOV      R9,R0
   \   0000003A   0xFA5F 0xF989      UXTB     R9,R9
   1357            if(resp == 1) {
   \   0000003E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000042   0xD12B             BNE.N    ??ServerIPCheck_2
   1358              for(i = 0; i < 32; i++) {
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      LDR.W    R10,??DataTable144_11
   \   0000004A   0xE008             B.N      ??ServerIPCheck_3
   1359                if(ATCmdRxMsg[0][i] >= '0' && ATCmdRxMsg[0][i] <= '9' )
   1360                  val = val*10 + (ATCmdRxMsg[0][i]-'0');
   \                     ??ServerIPCheck_4: (+1)
   \   0000004C   0xEB07 0x0287      ADD      R2,R7,R7, LSL #+2
   \   00000050   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   00000054   0xF1A1 0x0730      SUB      R7,R1,#+48
   \   00000058   0xB2BF             UXTH     R7,R7
   \                     ??ServerIPCheck_5: (+1)
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0xB2C0             UXTB     R0,R0
   \                     ??ServerIPCheck_3: (+1)
   \   0000005E   0x2820             CMP      R0,#+32
   \   00000060   0xDA1C             BGE.N    ??ServerIPCheck_2
   \   00000062   0xF81A 0x1000      LDRB     R1,[R10, R0]
   \   00000066   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   0000006A   0x2A0A             CMP      R2,#+10
   \   0000006C   0xD3EE             BCC.N    ??ServerIPCheck_4
   1361                else if(ATCmdRxMsg[0][i] == '.' || ATCmdRxMsg[0][i] == ':') {
   \   0000006E   0x460A             MOV      R2,R1
   \   00000070   0x2A2E             CMP      R2,#+46
   \   00000072   0xD001             BEQ.N    ??ServerIPCheck_6
   \   00000074   0x2A3A             CMP      R2,#+58
   \   00000076   0xD10B             BNE.N    ??ServerIPCheck_7
   1362                  if(idx < 4 && val < 256)
   \                     ??ServerIPCheck_6: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4
   \   0000007A   0x4621             MOV      R1,R4
   \   0000007C   0x2904             CMP      R1,#+4
   \   0000007E   0xDA05             BGE.N    ??ServerIPCheck_8
   \   00000080   0x463A             MOV      R2,R7
   \   00000082   0x2AFF             CMP      R2,#+255
   \   00000084   0xDC02             BGT.N    ??ServerIPCheck_8
   1363                    rip[idx++] = val;
   \   00000086   0xAA01             ADD      R2,SP,#+4
   \   00000088   0x5457             STRB     R7,[R2, R1]
   \   0000008A   0x1C64             ADDS     R4,R4,#+1
   1364                    val = 0;
   \                     ??ServerIPCheck_8: (+1)
   \   0000008C   0x2700             MOVS     R7,#+0
   \   0000008E   0xE7E4             B.N      ??ServerIPCheck_5
   1365                }
   1366                else if(ATCmdRxMsg[0][i] == 0) {
   \                     ??ServerIPCheck_7: (+1)
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0xD1E2             BNE.N    ??ServerIPCheck_5
   1367                  if(idx == 4)
   \   00000094   0xB2E4             UXTB     R4,R4
   \   00000096   0x2C04             CMP      R4,#+4
   \   00000098   0xD100             BNE.N    ??ServerIPCheck_2
   1368                    port = val;
   \   0000009A   0x463D             MOV      R5,R7
   1369                  break;
   1370                }
   1371              }
   1372            }
   1373            else
   1374              ServerIPCheckFlag = 0;
   1375            
   1376            if(Setting.ExtModemMode == LOOP_PROTOCOL) {
   \                     ??ServerIPCheck_2: (+1)
   \   0000009C   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD113             BNE.N    ??ServerIPCheck_9
   1377              if(!LoopFotaFlag) {
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable145_3
   \   000000A8   0x7BC0             LDRB     R0,[R0, #+15]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD11A             BNE.N    ??ServerIPCheck_10
   1378                memcpy((u8*)sip, (u8*)&ModemInfo.LpIP, 4);
   \   000000AE   0x.... 0x....      LDR.W    R10,??DataTable144_11
   \   000000B2   0x2204             MOVS     R2,#+4
   \   000000B4   0xF44F 0x70B0      MOV      R0,#+352
   \   000000B8   0xEB0A 0x0100      ADD      R1,R10,R0
   \   000000BC   0x4668             MOV      R0,SP
   \   000000BE   0x.... 0x....      BL       __aeabi_memcpy
   1379                sport = ModemInfo.LpPort ;
   \   000000C2   0xF44F 0x70A2      MOV      R0,#+324
   \   000000C6   0x4450             ADD      R0,R10,R0
   \   000000C8   0x8C06             LDRH     R6,[R0, #+32]
   \   000000CA   0xE00B             B.N      ??ServerIPCheck_10
   1380              }
   1381            }
   1382            else {
   1383              memcpy((u8*)sip, (u8*)&ModemInfo.SrvIP, 4);
   \                     ??ServerIPCheck_9: (+1)
   \   000000CC   0x.... 0x....      LDR.W    R10,??DataTable144_11
   \   000000D0   0x2204             MOVS     R2,#+4
   \   000000D2   0xF44F 0x70A0      MOV      R0,#+320
   \   000000D6   0xEB0A 0x0100      ADD      R1,R10,R0
   \   000000DA   0x4668             MOV      R0,SP
   \   000000DC   0x.... 0x....      BL       __aeabi_memcpy
   1384              sport = ModemInfo.SrvPort ;
   \   000000E0   0xF8BA 0x6144      LDRH     R6,[R10, #+324]
   1385            }
   1386            
   1387            if(port == sport && rip[0] == sip[0] && rip[1] == sip[1] && rip[2] == sip[2] && rip[3] == sip[3]) 
   \                     ??ServerIPCheck_10: (+1)
   \   000000E4   0xB2AD             UXTH     R5,R5
   \   000000E6   0xB2B6             UXTH     R6,R6
   \   000000E8   0x42B5             CMP      R5,R6
   \   000000EA   0xD118             BNE.N    ??ServerIPCheck_11
   \   000000EC   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000F0   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000F4   0x4288             CMP      R0,R1
   \   000000F6   0xD112             BNE.N    ??ServerIPCheck_11
   \   000000F8   0xA801             ADD      R0,SP,#+4
   \   000000FA   0x4669             MOV      R1,SP
   \   000000FC   0x7842             LDRB     R2,[R0, #+1]
   \   000000FE   0x784B             LDRB     R3,[R1, #+1]
   \   00000100   0x429A             CMP      R2,R3
   \   00000102   0xD10C             BNE.N    ??ServerIPCheck_11
   \   00000104   0x7882             LDRB     R2,[R0, #+2]
   \   00000106   0x788B             LDRB     R3,[R1, #+2]
   \   00000108   0x429A             CMP      R2,R3
   \   0000010A   0xD108             BNE.N    ??ServerIPCheck_11
   \   0000010C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000010E   0x78C9             LDRB     R1,[R1, #+3]
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xD104             BNE.N    ??ServerIPCheck_11
   1388                ServerIPCheckFlag = 1;
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable145_3
   \   0000011A   0x7388             STRB     R0,[R1, #+14]
   \   0000011C   0xE003             B.N      ??ServerIPCheck_12
   1389            else
   1390              ServerIPCheckFlag = 0;
   \                     ??ServerIPCheck_11: (+1)
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable145_3
   \   00000124   0x7388             STRB     R0,[R1, #+14]
   1391            
   1392            return resp;
   \                     ??ServerIPCheck_12: (+1)
   \   00000126   0x4648             MOV      R0,R9
   \                     ??ServerIPCheck_1: (+1)
   \   00000128   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1393          }
   1394          

   \                                 In section .text, align 2, keep-with-next
   1395          unsigned char Modem_CheckTelecom(void)
   1396          {
   \                     Modem_CheckTelecom: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1397            unsigned char resp = 0;
   1398            u16 addr;
   1399          
   1400            resp = AT_SendWithRecieveData("AT+COPS?\r\n","+COPS: ", 4, 5000);
   \   00000002   0xF241 0x3388      MOVW     R3,#+5000
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x.... 0x....      ADR.W    R1,?_55
   \   0000000C   0x.... 0x....      ADR.W    R0,?_54
   \   00000010   0x.... 0x....      BL       AT_SendWithRecieveData
   1401            if(resp == 1) {
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD15C             BNE.N    ??Modem_CheckTelecom_0
   1402              if(strstr(ATCmdRxMsg[2], "olleh") != NULL || (ATCmdRxMsg[2][0] == 'K' && ATCmdRxMsg[2][1] == 'T')) {
   \   0000001A   0x.... 0x....      LDR.W    R4,??DataTable151
   \   0000001E   0x.... 0x....      ADR.W    R1,?_56
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       strstr
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD105             BNE.N    ??Modem_CheckTelecom_1
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x284B             CMP      R0,#+75
   \   00000030   0xD113             BNE.N    ??Modem_CheckTelecom_2
   \   00000032   0x7860             LDRB     R0,[R4, #+1]
   \   00000034   0x2854             CMP      R0,#+84
   \   00000036   0xD110             BNE.N    ??Modem_CheckTelecom_2
   1403                if(Setting.ExtModemTelecom != 0) {
   \                     ??Modem_CheckTelecom_1: (+1)
   \   00000038   0x.... 0x....      LDR.W    R3,??DataTable145_2
   \   0000003C   0xF103 0x00B5      ADD      R0,R3,#+181
   \   00000040   0x7841             LDRB     R1,[R0, #+1]
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD044             BEQ.N    ??Modem_CheckTelecom_3
   1404                  Setting.ExtModemTelecom = 0;
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x7041             STRB     R1,[R0, #+1]
   1405                  addr = DRV_SETTING_PARM + offsetof(st_Setting,ExtModemTelecom); 
   1406                  FRAMMultiWrite((u8 *)&Setting.ExtModemTelecom, addr, sizeof(Setting.ExtModemTelecom));   
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0xF44F 0x71DB      MOV      R1,#+438
   \   00000050   0xF103 0x00B6      ADD      R0,R3,#+182
   \   00000054   0x.... 0x....      BL       FRAMMultiWrite
   \   00000058   0xE03A             B.N      ??Modem_CheckTelecom_3
   1407                }
   1408              }
   1409              else if(strstr(ATCmdRxMsg[2], "SK") != NULL) {
   \                     ??Modem_CheckTelecom_2: (+1)
   \   0000005A   0x....             ADR.N    R1,??DataTable144_8  ;; 0x53, 0x4B, 0x00, 0x00
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       strstr
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD010             BEQ.N    ??Modem_CheckTelecom_4
   1410                if(Setting.ExtModemTelecom != 1) {
   \   00000066   0x.... 0x....      LDR.W    R3,??DataTable145_2
   \   0000006A   0xF103 0x00B5      ADD      R0,R3,#+181
   \   0000006E   0x7841             LDRB     R1,[R0, #+1]
   \   00000070   0x2901             CMP      R1,#+1
   \   00000072   0xD01F             BEQ.N    ??Modem_CheckTelecom_5
   1411                  Setting.ExtModemTelecom = 1;
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0x7041             STRB     R1,[R0, #+1]
   1412                  addr = DRV_SETTING_PARM + offsetof(st_Setting,ExtModemTelecom); 
   1413                  FRAMMultiWrite((u8 *)&Setting.ExtModemTelecom, addr, sizeof(Setting.ExtModemTelecom));   
   \   00000078   0x460A             MOV      R2,R1
   \   0000007A   0xF44F 0x71DB      MOV      R1,#+438
   \   0000007E   0xF103 0x00B6      ADD      R0,R3,#+182
   \   00000082   0x.... 0x....      BL       FRAMMultiWrite
   \   00000086   0xE015             B.N      ??Modem_CheckTelecom_5
   1414                }
   1415                if(Setting.ExtModemMode > 0) {
   1416                  Setting.ExtModemMode = 0;
   1417                  addr = DRV_SETTING_PARM + offsetof(st_Setting,ExtModemMode); 
   1418                  FRAMMultiWrite((u8 *)&Setting.ExtModemMode, addr, sizeof(Setting.ExtModemMode));   
   1419                }
   1420              }
   1421              else if(strstr(ATCmdRxMsg[2], "LG") != NULL) {
   \                     ??Modem_CheckTelecom_4: (+1)
   \   00000088   0x....             ADR.N    R1,??DataTable144_9  ;; 0x4C, 0x47, 0x00, 0x00
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       strstr
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD01D             BEQ.N    ??Modem_CheckTelecom_3
   1422                if(Setting.ExtModemTelecom != 2) {
   \   00000094   0x.... 0x....      LDR.W    R3,??DataTable145_2
   \   00000098   0xF103 0x00B5      ADD      R0,R3,#+181
   \   0000009C   0x7841             LDRB     R1,[R0, #+1]
   \   0000009E   0x2902             CMP      R1,#+2
   \   000000A0   0xD008             BEQ.N    ??Modem_CheckTelecom_5
   1423                  Setting.ExtModemTelecom = 2;
   \   000000A2   0x2102             MOVS     R1,#+2
   \   000000A4   0x7041             STRB     R1,[R0, #+1]
   1424                  addr = DRV_SETTING_PARM + offsetof(st_Setting,ExtModemTelecom); 
   1425                  FRAMMultiWrite((u8 *)&Setting.ExtModemTelecom, addr, sizeof(Setting.ExtModemTelecom));   
   \   000000A6   0x2201             MOVS     R2,#+1
   \   000000A8   0xF44F 0x71DB      MOV      R1,#+438
   \   000000AC   0xF103 0x00B6      ADD      R0,R3,#+182
   \   000000B0   0x.... 0x....      BL       FRAMMultiWrite
   1426                }
   1427                if(Setting.ExtModemMode > 0) {
   \                     ??Modem_CheckTelecom_5: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R3,??DataTable145_2
   \   000000B8   0xF103 0x00B5      ADD      R0,R3,#+181
   \   000000BC   0x7801             LDRB     R1,[R0, #+0]
   \   000000BE   0x2900             CMP      R1,#+0
   \   000000C0   0xD006             BEQ.N    ??Modem_CheckTelecom_3
   1428                  Setting.ExtModemMode = 0;
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x7001             STRB     R1,[R0, #+0]
   1429                  addr = DRV_SETTING_PARM + offsetof(st_Setting,ExtModemMode); 
   1430                  FRAMMultiWrite((u8 *)&Setting.ExtModemMode, addr, sizeof(Setting.ExtModemMode));   
   \   000000C6   0x2201             MOVS     R2,#+1
   \   000000C8   0xF240 0x11B5      MOVW     R1,#+437
   \   000000CC   0x.... 0x....      BL       FRAMMultiWrite
   1431                }
   1432              }
   1433              return 1;
   \                     ??Modem_CheckTelecom_3: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xBD10             POP      {R4,PC}
   1434            }
   1435            return 0;
   \                     ??Modem_CheckTelecom_0: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xBD10             POP      {R4,PC}          ;; return
   1436          }
   1437          
   1438          /*
   1439          ********************************************************************************
   1440          * Description : Modem_Initialize
   1441          * Arguments   : resp
   1442          * Return      : 
   1443          * Note        : Modem Initialize
   1444          ******************************************************************************** 
   1445          */

   \                                 In section .text, align 2, keep-with-next
   1446          unsigned char Modem_Initialize(void)
   1447          {
   \                     Modem_Initialize: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1448            unsigned char resp, rcnt, apn_change = 0;
   1449          //  unsigned char len;
   1450            u16 addr;
   1451            
   1452            if(TcpState == 1 || TCP_Open)  {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable145_3
   \   00000006   0x7A60             LDRB     R0,[R4, #+9]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD002             BEQ.N    ??Modem_Initialize_0
   \   0000000C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD006             BEQ.N    ??Modem_Initialize_1
   1453              Modem_SocketClose(0);
   \                     ??Modem_Initialize_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       Modem_SocketClose
   1454              vTaskDelay(1000); 
   \   00000018   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001C   0x.... 0x....      BL       vTaskDelay
   1455            }
   1456          
   1457            TCP_Open = 0;
   \                     ??Modem_Initialize_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7220             STRB     R0,[R4, #+8]
   1458            TcpState = 0;
   \   00000024   0x7260             STRB     R0,[R4, #+9]
   1459            
   1460            printk("\r\nMODEM : Initialize Start\r\n");
   \   00000026   0x.... 0x....      ADR.W    R0,?_59
   \   0000002A   0x.... 0x....      BL       printk
   1461          
   1462            rcnt=0;  resp=0;
   \   0000002E   0x2700             MOVS     R7,#+0
   \   00000030   0x463E             MOV      R6,R7
   \   00000032   0xE00D             B.N      ??Modem_Initialize_2
   1463            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1464              resp = sendATcommand("ATE0\r\n", "OK", "ERROR", 1000);
   \                     ??Modem_Initialize_3: (+1)
   \   00000034   0xF44F 0x737A      MOV      R3,#+1000
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable152
   \   0000003C   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000003E   0x.... 0x....      ADR.W    R0,?_60
   \   00000042   0x.... 0x....      BL       sendATcommand
   \   00000046   0x4606             MOV      R6,R0
   1465              vTaskDelay(1);
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       vTaskDelay
   1466              rcnt++;
   \   0000004E   0x1C7F             ADDS     R7,R7,#+1
   1467            }
   \                     ??Modem_Initialize_2: (+1)
   \   00000050   0xB2FF             UXTB     R7,R7
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0xD101             BNE.N    ??Modem_Initialize_4
   \   00000058   0x2805             CMP      R0,#+5
   \   0000005A   0xDBEB             BLT.N    ??Modem_Initialize_3
   1468            if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_4: (+1)
   \   0000005C   0x2805             CMP      R0,#+5
   \   0000005E   0xDB05             BLT.N    ??Modem_Initialize_5
   1469              printk("\r\nMODEM : ATE0 ERROR\r\n");
   \   00000060   0x.... 0x....      ADR.W    R0,?_61
   \   00000064   0x.... 0x....      BL       printk
   1470              return resp;
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}
   1471            }
   1472            vTaskDelay(100);  
   \                     ??Modem_Initialize_5: (+1)
   \   0000006C   0x2064             MOVS     R0,#+100
   \   0000006E   0x.... 0x....      BL       vTaskDelay
   1473          
   1474            printk("\r\n");
   \   00000072   0x....             ADR.N    R4,??DataTable145_1  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       printk
   1475            rcnt=0;  resp=0;
   \   0000007A   0x2500             MOVS     R5,#+0
   \   0000007C   0x462E             MOV      R6,R5
   \   0000007E   0xE00C             B.N      ??Modem_Initialize_6
   1476            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1477              resp = AT_SendWithRecieveData2("AT+GMM\r\n","OK", 1, 1000);
   \                     ??Modem_Initialize_7: (+1)
   \   00000080   0xF44F 0x737A      MOV      R3,#+1000
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000088   0x.... 0x....      ADR.W    R0,?_62
   \   0000008C   0x.... 0x....      BL       AT_SendWithRecieveData2
   \   00000090   0x4606             MOV      R6,R0
   1478              vTaskDelay(1);
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      BL       vTaskDelay
   1479              rcnt++;
   \   00000098   0x1C6D             ADDS     R5,R5,#+1
   1480            }
   \                     ??Modem_Initialize_6: (+1)
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0xB2C0             UXTB     R0,R0
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD102             BNE.N    ??Modem_Initialize_8
   \   000000A2   0xB2ED             UXTB     R5,R5
   \   000000A4   0x2D05             CMP      R5,#+5
   \   000000A6   0xDBEB             BLT.N    ??Modem_Initialize_7
   1481            if(resp == 1 && ATCmdRxMsg[0][0] !=  0) {
   \                     ??Modem_Initialize_8: (+1)
   \   000000A8   0xB2F6             UXTB     R6,R6
   \   000000AA   0x2E01             CMP      R6,#+1
   \   000000AC   0xD132             BNE.N    ??Modem_Initialize_9
   \   000000AE   0x.... 0x....      LDR.W    R7,??DataTable152_1
   \   000000B2   0x7838             LDRB     R0,[R7, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD02D             BEQ.N    ??Modem_Initialize_9
   1482              rcnt = StringLen(ATCmdRxMsg[0],20);
   \   000000B8   0x2114             MOVS     R1,#+20
   \   000000BA   0x4638             MOV      R0,R7
   \   000000BC   0x.... 0x....      BL       StringLen
   \   000000C0   0x4605             MOV      R5,R0
   1483              memcpy(ModemVer,ATCmdRxMsg[0], rcnt);
   \   000000C2   0x.... 0x....      LDR.W    R6,??DataTable152_2
   \   000000C6   0xB2ED             UXTB     R5,R5
   \   000000C8   0x462A             MOV      R2,R5
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x4630             MOV      R0,R6
   \   000000CE   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000D2   0x7830             LDRB     R0,[R6, #+0]
   \   000000D4   0x.... 0x....      LDR.W    R5,??DataTable152_3
   \   000000D8   0x2854             CMP      R0,#+84
   \   000000DA   0xD104             BNE.N    ??Modem_Initialize_10
   \   000000DC   0x78B1             LDRB     R1,[R6, #+2]
   \   000000DE   0x2932             CMP      R1,#+50
   \   000000E0   0xD00B             BEQ.N    ??Modem_Initialize_11
   \   000000E2   0x2933             CMP      R1,#+51
   \   000000E4   0xD009             BEQ.N    ??Modem_Initialize_11
   1484              if(ModemVer[0] == 'T' && (ModemVer[2] == '2' || ModemVer[2] == '3')) {
   1485                Setting.ExtModemModel = 0;
   1486          #ifdef __USE_LTE_ONLY_MODE__      
   1487                return 0;
   1488          #endif      
   1489              }
   1490              else if(ModemVer[0] == 'T' && ModemVer[2] == 'X' && (ModemVer[3] == '2' || ModemVer[3] == '3')) {
   \                     ??Modem_Initialize_10: (+1)
   \   000000E6   0x2854             CMP      R0,#+84
   \   000000E8   0xD10A             BNE.N    ??Modem_Initialize_12
   \   000000EA   0x78B1             LDRB     R1,[R6, #+2]
   \   000000EC   0x2958             CMP      R1,#+88
   \   000000EE   0xD107             BNE.N    ??Modem_Initialize_12
   \   000000F0   0x78F1             LDRB     R1,[R6, #+3]
   \   000000F2   0x2932             CMP      R1,#+50
   \   000000F4   0xD001             BEQ.N    ??Modem_Initialize_11
   \   000000F6   0x2933             CMP      R1,#+51
   \   000000F8   0xD102             BNE.N    ??Modem_Initialize_12
   1491                Setting.ExtModemModel = 0;
   \                     ??Modem_Initialize_11: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x7068             STRB     R0,[R5, #+1]
   \   000000FE   0xE010             B.N      ??Modem_Initialize_13
   1492          #ifdef __USE_LTE_ONLY_MODE__            
   1493                return 0;      
   1494          #endif      
   1495              }
   1496              else if(ModemVer[0] == 'T' && (ModemVer[2] == '4' || ModemVer[2] == '5'))
   \                     ??Modem_Initialize_12: (+1)
   \   00000100   0x2854             CMP      R0,#+84
   \   00000102   0xD10E             BNE.N    ??Modem_Initialize_13
   \   00000104   0x78B1             LDRB     R1,[R6, #+2]
   \   00000106   0x2934             CMP      R1,#+52
   \   00000108   0xD001             BEQ.N    ??Modem_Initialize_14
   \   0000010A   0x2935             CMP      R1,#+53
   \   0000010C   0xD109             BNE.N    ??Modem_Initialize_13
   1497                Setting.ExtModemModel = 1;
   \                     ??Modem_Initialize_14: (+1)
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0x7068             STRB     R0,[R5, #+1]
   \   00000112   0xE006             B.N      ??Modem_Initialize_13
   1498              else if(ModemVer[0] == 'A' && ModemVer[0] == 'M')
   1499                Setting.ExtModemModel = 2;      
   1500            }
   1501            else if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_9: (+1)
   \   00000114   0xB2ED             UXTB     R5,R5
   \   00000116   0x2D05             CMP      R5,#+5
   \   00000118   0xDB03             BLT.N    ??Modem_Initialize_13
   1502              printk("\r\nMODEM : GMM ERROR\r\n");
   \   0000011A   0x.... 0x....      ADR.W    R0,?_63
   \   0000011E   0x.... 0x....      BL       printk
   1503            }
   1504            if(Setting.ExtModemModel > 2) Setting.ExtModemModel = 0;
   \                     ??Modem_Initialize_13: (+1)
   \   00000122   0x.... 0x....      LDR.W    R5,??DataTable152_3
   \   00000126   0x7868             LDRB     R0,[R5, #+1]
   \   00000128   0x2803             CMP      R0,#+3
   \   0000012A   0xDB01             BLT.N    ??Modem_Initialize_15
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x7068             STRB     R0,[R5, #+1]
   1505            vTaskDelay(100);
   \                     ??Modem_Initialize_15: (+1)
   \   00000130   0x2064             MOVS     R0,#+100
   \   00000132   0x.... 0x....      BL       vTaskDelay
   1506            
   1507            printk("\r\n");
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       printk
   1508            rcnt=0;  resp=0;
   \   0000013C   0x2700             MOVS     R7,#+0
   \   0000013E   0x463E             MOV      R6,R7
   \   00000140   0xE00D             B.N      ??Modem_Initialize_16
   1509            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1510              resp = sendATcommand("AT+IPR=115200\r\n", "OK", "ERROR", 300); //Maximum Response Time 5s
   \                     ??Modem_Initialize_17: (+1)
   \   00000142   0xF44F 0x7396      MOV      R3,#+300
   \   00000146   0x.... 0x....      LDR.W    R2,??DataTable152
   \   0000014A   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000014C   0x.... 0x....      ADR.W    R0,?_64
   \   00000150   0x.... 0x....      BL       sendATcommand
   \   00000154   0x4606             MOV      R6,R0
   1511              vTaskDelay(1);
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0x.... 0x....      BL       vTaskDelay
   1512              rcnt++;
   \   0000015C   0x1C7F             ADDS     R7,R7,#+1
   1513            }  
   \                     ??Modem_Initialize_16: (+1)
   \   0000015E   0xB2FF             UXTB     R7,R7
   \   00000160   0x4638             MOV      R0,R7
   \   00000162   0x0031             MOVS     R1,R6
   \   00000164   0xD101             BNE.N    ??Modem_Initialize_18
   \   00000166   0x2805             CMP      R0,#+5
   \   00000168   0xDBEB             BLT.N    ??Modem_Initialize_17
   1514            if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_18: (+1)
   \   0000016A   0x2805             CMP      R0,#+5
   \   0000016C   0xDB05             BLT.N    ??Modem_Initialize_19
   1515              printk("\r\nMODEM : IPR ERROR\r\n");
   \   0000016E   0x.... 0x....      ADR.W    R0,?_65
   \   00000172   0x.... 0x....      BL       printk
   1516          //    LED_2(RED);  
   1517              return resp;
   \   00000176   0x4630             MOV      R0,R6
   \   00000178   0xBDF2             POP      {R1,R4-R7,PC}
   1518            }
   1519            vTaskDelay(100);
   \                     ??Modem_Initialize_19: (+1)
   \   0000017A   0x2064             MOVS     R0,#+100
   \   0000017C   0x.... 0x....      BL       vTaskDelay
   1520          
   1521            printk("\r\n");
   \   00000180   0x4620             MOV      R0,R4
   \   00000182   0x.... 0x....      BL       printk
   1522            rcnt=0;  resp=0;
   \   00000186   0x2700             MOVS     R7,#+0
   \   00000188   0x463E             MOV      R6,R7
   \   0000018A   0xE00E             B.N      ??Modem_Initialize_20
   1523            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1524              resp = sendATcommand("AT+CPIN?\r\n", "+CPIN: READY", "+CPIN: NOT INSERTED", 5000); //Maximum Response Time 5s
   \                     ??Modem_Initialize_21: (+1)
   \   0000018C   0xF241 0x3388      MOVW     R3,#+5000
   \   00000190   0x.... 0x....      ADR.W    R2,?_20
   \   00000194   0x.... 0x....      ADR.W    R1,?_19
   \   00000198   0x.... 0x....      ADR.W    R0,?_18
   \   0000019C   0x.... 0x....      BL       sendATcommand
   \   000001A0   0x4606             MOV      R6,R0
   1525              vTaskDelay(1);
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0x.... 0x....      BL       vTaskDelay
   1526              rcnt++;
   \   000001A8   0x1C7F             ADDS     R7,R7,#+1
   1527            }  
   \                     ??Modem_Initialize_20: (+1)
   \   000001AA   0xB2FF             UXTB     R7,R7
   \   000001AC   0x4638             MOV      R0,R7
   \   000001AE   0x0031             MOVS     R1,R6
   \   000001B0   0xD101             BNE.N    ??Modem_Initialize_22
   \   000001B2   0x2805             CMP      R0,#+5
   \   000001B4   0xDBEA             BLT.N    ??Modem_Initialize_21
   1528            if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_22: (+1)
   \   000001B6   0x2805             CMP      R0,#+5
   \   000001B8   0xDB05             BLT.N    ??Modem_Initialize_23
   1529              printk("\r\nMODEM : CPIN ERROR\r\n");
   \   000001BA   0x.... 0x....      ADR.W    R0,?_66
   \   000001BE   0x.... 0x....      BL       printk
   1530          //    LED_2(RED);  
   1531              return resp;
   \   000001C2   0x4630             MOV      R0,R6
   \   000001C4   0xBDF2             POP      {R1,R4-R7,PC}
   1532            }
   1533            vTaskDelay(100);
   \                     ??Modem_Initialize_23: (+1)
   \   000001C6   0x2064             MOVS     R0,#+100
   \   000001C8   0x.... 0x....      BL       vTaskDelay
   1534          
   1535            printk("\r\n");
   \   000001CC   0x4620             MOV      R0,R4
   \   000001CE   0x.... 0x....      BL       printk
   1536            rcnt=0;  resp=0;
   \   000001D2   0x2700             MOVS     R7,#+0
   \   000001D4   0x463E             MOV      R6,R7
   \   000001D6   0xE008             B.N      ??Modem_Initialize_24
   1537            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1538              resp = AT_SendWithRecieveCNUM(1000); //Maximum Response Time 300ms
   \                     ??Modem_Initialize_25: (+1)
   \   000001D8   0xF44F 0x707A      MOV      R0,#+1000
   \   000001DC   0x.... 0x....      BL       AT_SendWithRecieveCNUM
   \   000001E0   0x4606             MOV      R6,R0
   1539              vTaskDelay(1);
   \   000001E2   0x2001             MOVS     R0,#+1
   \   000001E4   0x.... 0x....      BL       vTaskDelay
   1540              rcnt++;
   \   000001E8   0x1C7F             ADDS     R7,R7,#+1
   1541            }  
   \                     ??Modem_Initialize_24: (+1)
   \   000001EA   0xB2FF             UXTB     R7,R7
   \   000001EC   0x4638             MOV      R0,R7
   \   000001EE   0x4631             MOV      R1,R6
   \   000001F0   0xB2C9             UXTB     R1,R1
   \   000001F2   0x2900             CMP      R1,#+0
   \   000001F4   0xD101             BNE.N    ??Modem_Initialize_26
   \   000001F6   0x2805             CMP      R0,#+5
   \   000001F8   0xDBEE             BLT.N    ??Modem_Initialize_25
   1542            if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_26: (+1)
   \   000001FA   0x2805             CMP      R0,#+5
   \   000001FC   0xDB06             BLT.N    ??Modem_Initialize_27
   1543              printk("\r\nMODEM : CNUM ERROR\r\n");    
   \   000001FE   0x.... 0x....      ADR.W    R0,?_67
   \   00000202   0x.... 0x....      BL       printk
   1544              return resp;
   \   00000206   0x4630             MOV      R0,R6
   \   00000208   0xB2C0             UXTB     R0,R0
   \   0000020A   0xBDF2             POP      {R1,R4-R7,PC}
   1545            }
   1546            printk("\r\nMODEM : CNUM %u / %u \r\n",resp, ModemInfo.CNUM);    
   \                     ??Modem_Initialize_27: (+1)
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable152_1
   \   00000210   0xF8D0 0x2146      LDR      R2,[R0, #+326]
   \   00000214   0x.... 0x....      ADR.W    R0,?_68
   \   00000218   0x.... 0x....      BL       printk
   1547            vTaskDelay(100);
   \   0000021C   0x2064             MOVS     R0,#+100
   \   0000021E   0x.... 0x....      BL       vTaskDelay
   1548            
   1549            printk("\r\n");
   \   00000222   0x4620             MOV      R0,R4
   \   00000224   0x.... 0x....      BL       printk
   1550            rcnt=0;  resp=0;
   \   00000228   0x2700             MOVS     R7,#+0
   \   0000022A   0x463E             MOV      R6,R7
   \   0000022C   0xE00D             B.N      ??Modem_Initialize_28
   1551            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1552              resp = sendATcommand("AT+CNMI=2,1\r\n", "OK", "ERROR", 1000);
   \                     ??Modem_Initialize_29: (+1)
   \   0000022E   0xF44F 0x737A      MOV      R3,#+1000
   \   00000232   0x.... 0x....      LDR.W    R2,??DataTable152
   \   00000236   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000238   0x.... 0x....      ADR.W    R0,?_69
   \   0000023C   0x.... 0x....      BL       sendATcommand
   \   00000240   0x4606             MOV      R6,R0
   1553              vTaskDelay(1);
   \   00000242   0x2001             MOVS     R0,#+1
   \   00000244   0x.... 0x....      BL       vTaskDelay
   1554              rcnt++;
   \   00000248   0x1C7F             ADDS     R7,R7,#+1
   1555            }
   \                     ??Modem_Initialize_28: (+1)
   \   0000024A   0xB2FF             UXTB     R7,R7
   \   0000024C   0x4638             MOV      R0,R7
   \   0000024E   0x0031             MOVS     R1,R6
   \   00000250   0xD101             BNE.N    ??Modem_Initialize_30
   \   00000252   0x2805             CMP      R0,#+5
   \   00000254   0xDBEB             BLT.N    ??Modem_Initialize_29
   1556            if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_30: (+1)
   \   00000256   0x2805             CMP      R0,#+5
   \   00000258   0xDB05             BLT.N    ??Modem_Initialize_31
   1557              printk("\r\nMODEM : CNMI ERROR\r\n");
   \   0000025A   0x.... 0x....      ADR.W    R0,?_70
   \   0000025E   0x.... 0x....      BL       printk
   1558              return resp;
   \   00000262   0x4630             MOV      R0,R6
   \   00000264   0xBDF2             POP      {R1,R4-R7,PC}
   1559            }
   1560            vTaskDelay(100);
   \                     ??Modem_Initialize_31: (+1)
   \   00000266   0x2064             MOVS     R0,#+100
   \   00000268   0x.... 0x....      BL       vTaskDelay
   1561          
   1562            printk("\r\n");
   \   0000026C   0x4620             MOV      R0,R4
   \   0000026E   0x.... 0x....      BL       printk
   1563            rcnt=0;  resp=0;
   \   00000272   0x2700             MOVS     R7,#+0
   \   00000274   0x463E             MOV      R6,R7
   \   00000276   0xE00D             B.N      ??Modem_Initialize_32
   1564            while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1565              resp = sendATcommand("AT+CMGF=1\r\n", "OK", "ERROR", 1000);
   \                     ??Modem_Initialize_33: (+1)
   \   00000278   0xF44F 0x737A      MOV      R3,#+1000
   \   0000027C   0x.... 0x....      LDR.W    R2,??DataTable152
   \   00000280   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000282   0x.... 0x....      ADR.W    R0,?_71
   \   00000286   0x.... 0x....      BL       sendATcommand
   \   0000028A   0x4606             MOV      R6,R0
   1566              vTaskDelay(1);
   \   0000028C   0x2001             MOVS     R0,#+1
   \   0000028E   0x.... 0x....      BL       vTaskDelay
   1567              rcnt++;
   \   00000292   0x1C7F             ADDS     R7,R7,#+1
   1568            }
   \                     ??Modem_Initialize_32: (+1)
   \   00000294   0xB2FF             UXTB     R7,R7
   \   00000296   0x4638             MOV      R0,R7
   \   00000298   0x0031             MOVS     R1,R6
   \   0000029A   0xD101             BNE.N    ??Modem_Initialize_34
   \   0000029C   0x2805             CMP      R0,#+5
   \   0000029E   0xDBEB             BLT.N    ??Modem_Initialize_33
   1569            if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_34: (+1)
   \   000002A0   0x2805             CMP      R0,#+5
   \   000002A2   0xDB05             BLT.N    ??Modem_Initialize_35
   1570              printk("\r\nMODEM : CMGF ERROR\r\n");
   \   000002A4   0x.... 0x....      ADR.W    R0,?_72
   \   000002A8   0x.... 0x....      BL       printk
   1571              return resp;
   \   000002AC   0x4630             MOV      R0,R6
   \   000002AE   0xBDF2             POP      {R1,R4-R7,PC}
   1572            }
   1573            vTaskDelay(100);
   \                     ??Modem_Initialize_35: (+1)
   \   000002B0   0x2064             MOVS     R0,#+100
   \   000002B2   0x.... 0x....      BL       vTaskDelay
   1574          
   1575            printk("\r\n");
   \   000002B6   0x4620             MOV      R0,R4
   \   000002B8   0x.... 0x....      BL       printk
   1576            Modem_CheckTelecom();  
   \   000002BC   0x.... 0x....      BL       Modem_CheckTelecom
   1577           
   1578            if(apn_change) {
   1579              resp = APNProcess(1);
   1580              if(resp == 1 && ModemInfo.FactoryInit == 1) {
   1581                ModemInfo.FactoryInit = 0;
   1582                addr = MODEM_INFO + (u8 *)&ModemInfo.FactoryInit - (u8 *)&ModemInfo;
   1583                FRAMMultiWrite((u8 *)&ModemInfo.FactoryInit, addr, sizeof(ModemInfo.FactoryInit));
   1584              }
   1585              vTaskDelay(100);
   1586            }
   1587            else {
   1588              resp = APNProcess(0);
   \   000002C0   0x2000             MOVS     R0,#+0
   \   000002C2   0x.... 0x....      BL       APNProcess
   \   000002C6   0x4606             MOV      R6,R0
   1589              vTaskDelay(100);
   \   000002C8   0x2064             MOVS     R0,#+100
   \   000002CA   0x.... 0x....      BL       vTaskDelay
   1590            }
   1591          
   1592            if(Setting.ExtModemTelecom == 0 && Setting.ExtModemModel == 1) {
   \   000002CE   0x7828             LDRB     R0,[R5, #+0]
   \   000002D0   0x2800             CMP      R0,#+0
   \   000002D2   0xD14C             BNE.N    ??Modem_Initialize_36
   \   000002D4   0x7868             LDRB     R0,[R5, #+1]
   \   000002D6   0x2801             CMP      R0,#+1
   \   000002D8   0xD149             BNE.N    ??Modem_Initialize_36
   1593              printk("\r\n");
   \   000002DA   0x4620             MOV      R0,R4
   \   000002DC   0x.... 0x....      BL       printk
   1594              rcnt=0;  resp=0;
   \   000002E0   0x2700             MOVS     R7,#+0
   \   000002E2   0x463E             MOV      R6,R7
   \   000002E4   0xE00D             B.N      ??Modem_Initialize_37
   1595              while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1596                resp = sendATcommand("AT$$SPC_LOCK=000000\r\n", "OK", "ERROR", 1000);
   \                     ??Modem_Initialize_38: (+1)
   \   000002E6   0xF44F 0x737A      MOV      R3,#+1000
   \   000002EA   0x.... 0x....      LDR.W    R2,??DataTable152
   \   000002EE   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   000002F0   0x.... 0x....      ADR.W    R0,?_73
   \   000002F4   0x.... 0x....      BL       sendATcommand
   \   000002F8   0x4606             MOV      R6,R0
   1597                vTaskDelay(1);
   \   000002FA   0x2001             MOVS     R0,#+1
   \   000002FC   0x.... 0x....      BL       vTaskDelay
   1598                rcnt++;
   \   00000300   0x1C7F             ADDS     R7,R7,#+1
   1599              }
   \                     ??Modem_Initialize_37: (+1)
   \   00000302   0xB2FF             UXTB     R7,R7
   \   00000304   0x4638             MOV      R0,R7
   \   00000306   0x0031             MOVS     R1,R6
   \   00000308   0xD101             BNE.N    ??Modem_Initialize_39
   \   0000030A   0x2805             CMP      R0,#+5
   \   0000030C   0xDBEB             BLT.N    ??Modem_Initialize_38
   1600              if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_39: (+1)
   \   0000030E   0x2805             CMP      R0,#+5
   \   00000310   0xDB05             BLT.N    ??Modem_Initialize_40
   1601                printk("\r\nMODEM : SPC_LOCK ERROR\r\n");
   \   00000312   0x.... 0x....      ADR.W    R0,?_74
   \   00000316   0x.... 0x....      BL       printk
   1602                return resp;
   \   0000031A   0x4630             MOV      R0,R6
   \   0000031C   0xBDF2             POP      {R1,R4-R7,PC}
   1603              }
   1604              vTaskDelay(100);
   \                     ??Modem_Initialize_40: (+1)
   \   0000031E   0x2064             MOVS     R0,#+100
   \   00000320   0x.... 0x....      BL       vTaskDelay
   1605              
   1606              printk("\r\n");
   \   00000324   0x4620             MOV      R0,R4
   \   00000326   0x.... 0x....      BL       printk
   1607              rcnt=0;  resp=0;
   \   0000032A   0x2700             MOVS     R7,#+0
   \   0000032C   0x463E             MOV      R6,R7
   \   0000032E   0xE00D             B.N      ??Modem_Initialize_41
   1608              while(resp == 0 && rcnt < AT_RETRY_CNT) { 
   1609                resp = sendATcommand("AT$$NETWORK_MODE=1\r\n", "OK", "ERROR", 1000);  //0 : 3G, 1 : LTE, 2 : 3G+LTE
   \                     ??Modem_Initialize_42: (+1)
   \   00000330   0xF44F 0x737A      MOV      R3,#+1000
   \   00000334   0x.... 0x....      LDR.W    R2,??DataTable152
   \   00000338   0x....             ADR.N    R1,??DataTable145  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000033A   0x.... 0x....      ADR.W    R0,?_75
   \   0000033E   0x.... 0x....      BL       sendATcommand
   \   00000342   0x4606             MOV      R6,R0
   1610                vTaskDelay(1);
   \   00000344   0x2001             MOVS     R0,#+1
   \   00000346   0x.... 0x....      BL       vTaskDelay
   1611                rcnt++;
   \   0000034A   0x1C7F             ADDS     R7,R7,#+1
   1612              }
   \                     ??Modem_Initialize_41: (+1)
   \   0000034C   0xB2FF             UXTB     R7,R7
   \   0000034E   0x4638             MOV      R0,R7
   \   00000350   0x0031             MOVS     R1,R6
   \   00000352   0xD101             BNE.N    ??Modem_Initialize_43
   \   00000354   0x2805             CMP      R0,#+5
   \   00000356   0xDBEB             BLT.N    ??Modem_Initialize_42
   1613              if(rcnt >= AT_RETRY_CNT) {
   \                     ??Modem_Initialize_43: (+1)
   \   00000358   0x2805             CMP      R0,#+5
   \   0000035A   0xDB05             BLT.N    ??Modem_Initialize_44
   1614                printk("\r\nMODEM : NETWORK_MODE ERROR\r\n");
   \   0000035C   0x.... 0x....      ADR.W    R0,?_76
   \   00000360   0x.... 0x....      BL       printk
   1615                return resp;
   \   00000364   0x4630             MOV      R0,R6
   \   00000366   0xBDF2             POP      {R1,R4-R7,PC}
   1616              }
   1617              vTaskDelay(100);
   \                     ??Modem_Initialize_44: (+1)
   \   00000368   0x2064             MOVS     R0,#+100
   \   0000036A   0x.... 0x....      BL       vTaskDelay
   1618            }
   1619          //  ServerIPCheck();
   1620            
   1621          //  vTaskDelay(100);
   1622          
   1623          //  Modem_SMS_DeleteAll()
   1624          
   1625            printk("\r\n");
   \                     ??Modem_Initialize_36: (+1)
   \   0000036E   0x4620             MOV      R0,R4
   \   00000370   0x.... 0x....      BL       printk
   1626            vTaskDelay(1000);
   \   00000374   0xF44F 0x707A      MOV      R0,#+1000
   \   00000378   0x.... 0x....      BL       vTaskDelay
   1627            Modem_SMS_ReadAll();
   \   0000037C   0x.... 0x....      BL       Modem_SMS_ReadAll
   1628            vTaskDelay(1000);
   \   00000380   0xF44F 0x707A      MOV      R0,#+1000
   \   00000384   0x.... 0x....      BL       vTaskDelay
   1629            
   1630            return resp;
   \   00000388   0x4630             MOV      R0,R6
   \   0000038A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1631          }
   1632          
   1633          

   \                                 In section .text, align 2, keep-with-next
   1634          unsigned char Modem_GetIP(char* url, u8* ip)
   1635          {
   \                     Modem_GetIP: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460C             MOV      R4,R1
   1636            unsigned char val = 0, idx = 0; 
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x462E             MOV      R6,R5
   1637            unsigned char i, resp = 0, len = 0;
   \   0000000C   0x462F             MOV      R7,R5
   1638          
   1639            memset(MdmTmpString,0,100);
   \   0000000E   0x.... 0x....      LDR.W    R9,??DataTable153_1
   \   00000012   0x462A             MOV      R2,R5
   \   00000014   0x2164             MOVS     R1,#+100
   \   00000016   0xF109 0x007C      ADD      R0,R9,#+124
   \   0000001A   0x.... 0x....      BL       __aeabi_memset
   1640            
   1641            if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1)   {  
   \   0000001E   0x.... 0x....      LDR.W    R10,??DataTable153_2
   \   00000022   0xF89A 0x00B7      LDRB     R0,[R10, #+183]
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0xD001             BEQ.N    ??Modem_GetIP_0
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD156             BNE.N    ??Modem_GetIP_1
   1642              sprintf(MdmTmpString,"AT$$TCP_DNIP=%s\r",url);  
   \                     ??Modem_GetIP_0: (+1)
   \   0000002E   0x4642             MOV      R2,R8
   \   00000030   0x.... 0x....      ADR.W    R1,?_77
   \   00000034   0xF109 0x007C      ADD      R0,R9,#+124
   \   00000038   0x.... 0x....      BL       sprintf
   1643              resp = AT_SendWithRecieveData(MdmTmpString,"$$TCP_DNIP: ", 2, 5000);
   \   0000003C   0xF241 0x3388      MOVW     R3,#+5000
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0x.... 0x....      ADR.W    R1,?_78
   \   00000046   0xF109 0x007C      ADD      R0,R9,#+124
   \   0000004A   0x.... 0x....      BL       AT_SendWithRecieveData
   1644              if(resp == 1) {
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD17B             BNE.N    ??Modem_GetIP_2
   1645                if(Setting.ExtModemModel == 1 && ATCmdRxMsg[1][0] == 0) {
   \   00000054   0xF89A 0x00B7      LDRB     R0,[R10, #+183]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD113             BNE.N    ??Modem_GetIP_3
   \   0000005C   0x.... 0x....      LDR.W    R8,??DataTable152_1
   \   00000060   0xF898 0x0020      LDRB     R0,[R8, #+32]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD10D             BNE.N    ??Modem_GetIP_3
   1646                  len = StringLen(ATCmdRxMsg[0], 16);
   \   00000068   0x2110             MOVS     R1,#+16
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       StringLen
   \   00000070   0x4607             MOV      R7,R0
   \   00000072   0xB2FF             UXTB     R7,R7
   1647                  if(len > 6)  memcpy(ATCmdRxMsg[1], ATCmdRxMsg[0], len);
   \   00000074   0x2F07             CMP      R7,#+7
   \   00000076   0xDB05             BLT.N    ??Modem_GetIP_3
   \   00000078   0x463A             MOV      R2,R7
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0xF108 0x0020      ADD      R0,R8,#+32
   \   00000080   0x.... 0x....      BL       __aeabi_memcpy4
   1648                }
   1649                if(len > 6 || ATCmdRxMsg[0][0] == '0') {
   \                     ??Modem_GetIP_3: (+1)
   \   00000084   0x2F07             CMP      R7,#+7
   \   00000086   0xDA04             BGE.N    ??Modem_GetIP_4
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable152_1
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x2830             CMP      R0,#+48
   \   00000090   0xD15C             BNE.N    ??Modem_GetIP_2
   1650                  for(i = 0; i < 16; i++) {
   \                     ??Modem_GetIP_4: (+1)
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0x.... 0x....      LDR.W    R8,??DataTable152_1
   \   00000098   0xE00F             B.N      ??Modem_GetIP_5
   1651                    if(ATCmdRxMsg[1][i] >= '0' && ATCmdRxMsg[1][i] <= '9' )
   1652                      val = val*10 + ATCmdRxMsg[1][i]-'0';
   1653                    else if(ATCmdRxMsg[1][i] == '.' || ATCmdRxMsg[1][i] == 0 || i == 15) {
   \                     ??Modem_GetIP_6: (+1)
   \   0000009A   0x292E             CMP      R1,#+46
   \   0000009C   0xD003             BEQ.N    ??Modem_GetIP_7
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD001             BEQ.N    ??Modem_GetIP_7
   \   000000A2   0x280F             CMP      R0,#+15
   \   000000A4   0xD105             BNE.N    ??Modem_GetIP_8
   1654                      if(idx < 4) {
   \                     ??Modem_GetIP_7: (+1)
   \   000000A6   0x2E04             CMP      R6,#+4
   \   000000A8   0xDA03             BGE.N    ??Modem_GetIP_8
   1655                        ip[idx++] = val;
   \   000000AA   0x55A5             STRB     R5,[R4, R6]
   \   000000AC   0x1C76             ADDS     R6,R6,#+1
   \   000000AE   0xB2F6             UXTB     R6,R6
   1656                        val = 0;
   \   000000B0   0x2500             MOVS     R5,#+0
   1657                      }
   1658                    }
   1659                    if(idx > 3) {
   \                     ??Modem_GetIP_8: (+1)
   \   000000B2   0x2E04             CMP      R6,#+4
   \   000000B4   0xDA48             BGE.N    ??Modem_GetIP_9
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0xB2C0             UXTB     R0,R0
   \                     ??Modem_GetIP_5: (+1)
   \   000000BA   0x2810             CMP      R0,#+16
   \   000000BC   0xDA44             BGE.N    ??Modem_GetIP_9
   \   000000BE   0xEB08 0x0100      ADD      R1,R8,R0
   \   000000C2   0xF891 0x1020      LDRB     R1,[R1, #+32]
   \   000000C6   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   000000CA   0x2A0A             CMP      R2,#+10
   \   000000CC   0xD2E5             BCS.N    ??Modem_GetIP_6
   \   000000CE   0xEB05 0x0285      ADD      R2,R5,R5, LSL #+2
   \   000000D2   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   000000D6   0xF1A1 0x0530      SUB      R5,R1,#+48
   \   000000DA   0xE7EA             B.N      ??Modem_GetIP_8
   1660                      break;
   1661                    }
   1662                  }
   1663                  return 1;
   1664                }
   1665              }
   1666            }
   1667            else if(Setting.ExtModemModel == 2) {
   \                     ??Modem_GetIP_1: (+1)
   \   000000DC   0x2802             CMP      R0,#+2
   \   000000DE   0xD135             BNE.N    ??Modem_GetIP_2
   1668              sprintf(MdmTmpString,"AT@DNSQ=%s\r",url);  
   \   000000E0   0x4642             MOV      R2,R8
   \   000000E2   0x.... 0x....      ADR.W    R1,?_79
   \   000000E6   0xF109 0x007C      ADD      R0,R9,#+124
   \   000000EA   0x.... 0x....      BL       sprintf
   1669              resp = AT_SendWithRecieveData(MdmTmpString,"@DNSQUERY:", 1, 5000);
   \   000000EE   0xF241 0x3388      MOVW     R3,#+5000
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0x.... 0x....      ADR.W    R1,?_80
   \   000000F8   0xF109 0x007C      ADD      R0,R9,#+124
   \   000000FC   0x.... 0x....      BL       AT_SendWithRecieveData
   1670              if(resp == 1) {
   \   00000100   0xB2C0             UXTB     R0,R0
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xD122             BNE.N    ??Modem_GetIP_2
   1671                for(i = 0; i < 16; i++) {
   \   00000106   0x4628             MOV      R0,R5
   \   00000108   0x.... 0x....      LDR.W    R8,??DataTable152_1
   \   0000010C   0xE001             B.N      ??Modem_GetIP_10
   \                     ??Modem_GetIP_11: (+1)
   \   0000010E   0x1C40             ADDS     R0,R0,#+1
   \   00000110   0xB2C0             UXTB     R0,R0
   \                     ??Modem_GetIP_10: (+1)
   \   00000112   0x2810             CMP      R0,#+16
   \   00000114   0xDA18             BGE.N    ??Modem_GetIP_9
   1672                  if(ATCmdRxMsg[0][i] >= '0' && ATCmdRxMsg[0][i] <= '9' )
   \   00000116   0xF818 0x1000      LDRB     R1,[R8, R0]
   \   0000011A   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   0000011E   0x2A0A             CMP      R2,#+10
   \   00000120   0xD206             BCS.N    ??Modem_GetIP_12
   1673                    val = val*10 + ATCmdRxMsg[0][i]-'0';
   \   00000122   0xEB05 0x0285      ADD      R2,R5,R5, LSL #+2
   \   00000126   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   0000012A   0xF1A1 0x0530      SUB      R5,R1,#+48
   \   0000012E   0xE009             B.N      ??Modem_GetIP_13
   1674                  else if(ATCmdRxMsg[0][i] == '.' || ATCmdRxMsg[0][i] == 0) {
   \                     ??Modem_GetIP_12: (+1)
   \   00000130   0x292E             CMP      R1,#+46
   \   00000132   0xD001             BEQ.N    ??Modem_GetIP_14
   \   00000134   0x2900             CMP      R1,#+0
   \   00000136   0xD105             BNE.N    ??Modem_GetIP_13
   1675                    if(idx < 4) {
   \                     ??Modem_GetIP_14: (+1)
   \   00000138   0x2E04             CMP      R6,#+4
   \   0000013A   0xDA03             BGE.N    ??Modem_GetIP_13
   1676                      ip[idx++] = val;
   \   0000013C   0x55A5             STRB     R5,[R4, R6]
   \   0000013E   0x1C76             ADDS     R6,R6,#+1
   \   00000140   0xB2F6             UXTB     R6,R6
   1677                      val = 0;
   \   00000142   0x463D             MOV      R5,R7
   1678                    }
   1679                  }
   1680                  if(idx > 3) {
   \                     ??Modem_GetIP_13: (+1)
   \   00000144   0x2E04             CMP      R6,#+4
   \   00000146   0xDBE2             BLT.N    ??Modem_GetIP_11
   1681                    break;
   1682                  }
   1683                }
   1684                return 1;
   \                     ??Modem_GetIP_9: (+1)
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xE000             B.N      ??Modem_GetIP_15
   1685              }
   1686            }
   1687            return 0;
   \                     ??Modem_GetIP_2: (+1)
   \   0000014C   0x4628             MOV      R0,R5
   \                     ??Modem_GetIP_15: (+1)
   \   0000014E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1688          }
   1689          
   1690          /*
   1691          ********************************************************************************
   1692          * Description : Modem_SocketOpen
   1693          * Arguments   : sw
   1694          * Return      : resp
   1695          * Note        : Modem TCP socket open
   1696          ******************************************************************************** 
   1697          */
   1698          

   \                                 In section .text, align 2, keep-with-next
   1699          unsigned char Modem_SocketOpenIP(u8* ip, u16 port)
   1700          {
   \                     Modem_SocketOpenIP: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   1701            
   1702            unsigned char resp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1703          
   1704            TCP_Open = 0;
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable153_1
   \   0000000C   0x4630             MOV      R0,R6
   \   0000000E   0x7220             STRB     R0,[R4, #+8]
   1705            
   1706            printk("\r\nMODEM : Socket Open ip:%u.%u.%u.%u port: %u\r\n", ip[0],ip[1],ip[2],ip[3], port);
   \   00000010   0x9701             STR      R7,[SP, #+4]
   \   00000012   0x78E8             LDRB     R0,[R5, #+3]
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x78AB             LDRB     R3,[R5, #+2]
   \   00000018   0x786A             LDRB     R2,[R5, #+1]
   \   0000001A   0x7829             LDRB     R1,[R5, #+0]
   \   0000001C   0x.... 0x....      ADR.W    R0,?_81
   \   00000020   0x.... 0x....      BL       printk
   1707          
   1708            memset(MdmTmpString,0,100);
   \   00000024   0x4632             MOV      R2,R6
   \   00000026   0x2164             MOVS     R1,#+100
   \   00000028   0xF104 0x007C      ADD      R0,R4,#+124
   \   0000002C   0x.... 0x....      BL       __aeabi_memset
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable153_2
   \   00000034   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   00000038   0x0001             MOVS     R1,R0
   \   0000003A   0xD001             BEQ.N    ??Modem_SocketOpenIP_0
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD13D             BNE.N    ??Modem_SocketOpenIP_1
   1709          
   1710            if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1)   {    
   1711              sprintf(MdmTmpString,"AT$$TCP_ADDR=0,%u,%u,%u,%u,%u\r",ip[0],ip[1],ip[2],ip[3],port);  
   \                     ??Modem_SocketOpenIP_0: (+1)
   \   00000040   0x9702             STR      R7,[SP, #+8]
   \   00000042   0x78E8             LDRB     R0,[R5, #+3]
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x78A8             LDRB     R0,[R5, #+2]
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x786B             LDRB     R3,[R5, #+1]
   \   0000004C   0x782A             LDRB     R2,[R5, #+0]
   \   0000004E   0x.... 0x....      ADR.W    R1,?_82
   \   00000052   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000056   0x.... 0x....      BL       sprintf
   1712              resp = AT_SendWithRecieveData(MdmTmpString,"$$TCP_ADDR: ", 1, 1000);
   \   0000005A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x.... 0x....      ADR.W    R1,?_83
   \   00000064   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000068   0x.... 0x....      BL       AT_SendWithRecieveData
   1713              if(resp == 1 && ATCmdRxMsg[0][0] == '0')
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD105             BNE.N    ??Modem_SocketOpenIP_2
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable152_1
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2830             CMP      R0,#+48
   \   0000007A   0xD100             BNE.N    ??Modem_SocketOpenIP_2
   1714                resp = 1;
   \   0000007C   0x2601             MOVS     R6,#+1
   1715              else
   1716                resp = 0;
   1717              if(resp == 1)
   \                     ??Modem_SocketOpenIP_2: (+1)
   \   0000007E   0x2E01             CMP      R6,#+1
   \   00000080   0xD118             BNE.N    ??Modem_SocketOpenIP_3
   1718                vTaskDelay(100);
   \   00000082   0x2064             MOVS     R0,#+100
   \   00000084   0x.... 0x....      BL       vTaskDelay
   1719              else
   1720                return resp;
   1721              
   1722              resp = AT_SendWithRecieveData("AT$$TCP_SCOP\r","$$TCP_SCOP: ", 1, 2000);
   \   00000088   0xF44F 0x63FA      MOV      R3,#+2000
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x.... 0x....      ADR.W    R1,?_85
   \   00000092   0x.... 0x....      ADR.W    R0,?_84
   \   00000096   0x.... 0x....      BL       AT_SendWithRecieveData
   1723              if(resp == 1 && ATCmdRxMsg[0][0] == '0')
   \   0000009A   0xB2C0             UXTB     R0,R0
   \   0000009C   0x2801             CMP      R0,#+1
   \   0000009E   0xD10B             BNE.N    ??Modem_SocketOpenIP_4
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable152_1
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x2830             CMP      R0,#+48
   \   000000A8   0xD106             BNE.N    ??Modem_SocketOpenIP_4
   1724                resp = 1;
   \   000000AA   0x2601             MOVS     R6,#+1
   1725              else
   1726                resp = 0;
   1727            }
   1728            else if(Setting.ExtModemModel == 2) {
   1729              sprintf(MdmTmpString,"AT@SOCKOPEN=0,0,1,%u.%u.%u.%u,%u\r",ip[0],ip[1],ip[2],ip[3],port);  
   1730              resp = sendATcommand(MdmTmpString, "OK", "ERROR", 2000);
   1731              if(resp == 1) { 
   1732                resp = 1;
   1733                vTaskDelay(100);
   1734              }
   1735              else {
   1736                resp = 0;
   1737                return resp;
   1738              }
   1739            }
   1740            
   1741            if(resp == 1)  {
   \                     ??Modem_SocketOpenIP_5: (+1)
   \   000000AC   0x2E01             CMP      R6,#+1
   \   000000AE   0xD101             BNE.N    ??Modem_SocketOpenIP_3
   1742              TCP_Open = 1;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x7220             STRB     R0,[R4, #+8]
   1743            }
   1744            return resp;
   \                     ??Modem_SocketOpenIP_3: (+1)
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??Modem_SocketOpenIP_4: (+1)
   \   000000B8   0x2600             MOVS     R6,#+0
   \   000000BA   0xE7F7             B.N      ??Modem_SocketOpenIP_5
   \                     ??Modem_SocketOpenIP_1: (+1)
   \   000000BC   0x2802             CMP      R0,#+2
   \   000000BE   0xD1F5             BNE.N    ??Modem_SocketOpenIP_5
   \   000000C0   0x9702             STR      R7,[SP, #+8]
   \   000000C2   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C4   0x9001             STR      R0,[SP, #+4]
   \   000000C6   0x78A8             LDRB     R0,[R5, #+2]
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x786B             LDRB     R3,[R5, #+1]
   \   000000CC   0x782A             LDRB     R2,[R5, #+0]
   \   000000CE   0x.... 0x....      ADR.W    R1,?_86
   \   000000D2   0xF104 0x007C      ADD      R0,R4,#+124
   \   000000D6   0x.... 0x....      BL       sprintf
   \   000000DA   0xF44F 0x63FA      MOV      R3,#+2000
   \   000000DE   0x.... 0x....      LDR.W    R2,??DataTable152
   \   000000E2   0x....             ADR.N    R1,??DataTable150  ;; 0x4F, 0x4B, 0x00, 0x00
   \   000000E4   0xF104 0x007C      ADD      R0,R4,#+124
   \   000000E8   0x.... 0x....      BL       sendATcommand
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD104             BNE.N    ??Modem_SocketOpenIP_6
   \   000000F0   0x2601             MOVS     R6,#+1
   \   000000F2   0x2064             MOVS     R0,#+100
   \   000000F4   0x.... 0x....      BL       vTaskDelay
   \   000000F8   0xE7D8             B.N      ??Modem_SocketOpenIP_5
   \                     ??Modem_SocketOpenIP_6: (+1)
   \   000000FA   0x4630             MOV      R0,R6
   \   000000FC   0xBDFE             POP      {R1-R7,PC}
   1745            
   1746          }
   1747          

   \                                 In section .text, align 2, keep-with-next
   1748          void Modem_CheckConnectIP(u32 tmp_ip, u16 port, u8 mode)
   1749          {
   1750            if(tmp_ip == 0 || port == 0) return;
   \                     Modem_CheckConnectIP: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE.N    ??Modem_CheckConnectIP_0
   \   00000004   0x4770             BX       LR
   \                     ??Modem_CheckConnectIP_0: (+1)
   \   00000006   0xB430             PUSH     {R4,R5}
   \   00000008   0x000B             MOVS     R3,R1
   \   0000000A   0xD034             BEQ.N    ??Modem_CheckConnectIP_1
   1751            if(mode == 0) {
   \   0000000C   0x0013             MOVS     R3,R2
   \   0000000E   0xD11B             BNE.N    ??Modem_CheckConnectIP_2
   1752              if((tmp_ip != ModemInfo.LpIP || port != ModemInfo.LpPort) && !LoopFotaFlag) {
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable152_1
   \   00000014   0xF44F 0x72A0      MOV      R2,#+320
   \   00000018   0x18A3             ADDS     R3,R4,R2
   \   0000001A   0x6A1A             LDR      R2,[R3, #+32]
   \   0000001C   0x4290             CMP      R0,R2
   \   0000001E   0xD103             BNE.N    ??Modem_CheckConnectIP_3
   \   00000020   0x460A             MOV      R2,R1
   \   00000022   0x8C9D             LDRH     R5,[R3, #+36]
   \   00000024   0x42AA             CMP      R2,R5
   \   00000026   0xD026             BEQ.N    ??Modem_CheckConnectIP_1
   \                     ??Modem_CheckConnectIP_3: (+1)
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable153_1
   \   0000002C   0x7BD2             LDRB     R2,[R2, #+15]
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD121             BNE.N    ??Modem_CheckConnectIP_1
   1753                ModemInfo.LpIP = tmp_ip;
   \   00000032   0x6218             STR      R0,[R3, #+32]
   1754                ModemInfo.LpPort = port;
   \   00000034   0x8499             STRH     R1,[R3, #+36]
   1755                FRAMMultiWrite((u8 *)&ModemInfo.LpIP, MODEM_INFO + (u8 *)&ModemInfo.LpIP - (u8 *)&ModemInfo, sizeof(ModemInfo.LpIP)+sizeof(ModemInfo.LpPort));
   \   00000036   0x2206             MOVS     R2,#+6
   \   00000038   0xF44F 0x7118      MOV      R1,#+608
   \   0000003C   0xF44F 0x70B0      MOV      R0,#+352
   \   00000040   0x4420             ADD      R0,R4,R0
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x.... 0x....      B.W      FRAMMultiWrite
   1756              }
   1757            }
   1758            else if(mode == 2) {
   \                     ??Modem_CheckConnectIP_2: (+1)
   \   00000048   0x2A02             CMP      R2,#+2
   \   0000004A   0xD114             BNE.N    ??Modem_CheckConnectIP_1
   1759              if(tmp_ip != ModemInfo.SrvIP || port != ModemInfo.SrvPort) {
   \   0000004C   0x.... 0x....      LDR.W    R4,??DataTable152_1
   \   00000050   0xF44F 0x72A0      MOV      R2,#+320
   \   00000054   0x18A3             ADDS     R3,R4,R2
   \   00000056   0x681A             LDR      R2,[R3, #+0]
   \   00000058   0x4290             CMP      R0,R2
   \   0000005A   0xD103             BNE.N    ??Modem_CheckConnectIP_4
   \   0000005C   0x460A             MOV      R2,R1
   \   0000005E   0x889C             LDRH     R4,[R3, #+4]
   \   00000060   0x42A2             CMP      R2,R4
   \   00000062   0xD008             BEQ.N    ??Modem_CheckConnectIP_1
   1760                ModemInfo.SrvIP = tmp_ip;
   \                     ??Modem_CheckConnectIP_4: (+1)
   \   00000064   0x6018             STR      R0,[R3, #+0]
   1761                ModemInfo.SrvPort = port;
   \   00000066   0x8099             STRH     R1,[R3, #+4]
   1762                FRAMMultiWrite((u8 *)&ModemInfo.SrvIP, MODEM_INFO + (u8 *)&ModemInfo.SrvIP - (u8 *)&ModemInfo, sizeof(ModemInfo.SrvIP)+sizeof(ModemInfo.SrvPort));
   \   00000068   0x2206             MOVS     R2,#+6
   \   0000006A   0xF44F 0x7110      MOV      R1,#+576
   \   0000006E   0x4618             MOV      R0,R3
   \   00000070   0xBC30             POP      {R4,R5}
   \   00000072   0x.... 0x....      B.W      FRAMMultiWrite
   1763              }
   1764            }    
   1765          }
   \                     ??Modem_CheckConnectIP_1: (+1)
   \   00000076   0xBC30             POP      {R4,R5}
   \   00000078   0x4770             BX       LR               ;; return
   1766          
   1767          

   \                                 In section .text, align 2, keep-with-next
   1768          unsigned char Modem_SocketOpenSvrName(char *svr_name, u16 port, u8 mode)
   1769          {
   \                     Modem_SocketOpenSvrName: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1770            
   1771            unsigned char ip[4] = {0,}; 
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1772            unsigned char resp = 0;
   1773            u32 tmp_ip = 0;
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x9001             STR      R0,[SP, #+4]
   1774            
   1775            TCP_Open = 0;
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable153_1
   \   00000016   0x7208             STRB     R0,[R1, #+8]
   1776            
   1777            if(mode != 1) {
   \   00000018   0x2E01             CMP      R6,#+1
   \   0000001A   0xD019             BEQ.N    ??Modem_SocketOpenSvrName_0
   1778              printk("\r\nMODEM : Socket Open Start  %s, %u\r\n", svr_name, port);  
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x.... 0x....      ADR.W    R0,?_88
   \   00000024   0x.... 0x....      BL       printk
   1779              
   1780              resp = Modem_GetIP(svr_name, ip);
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       Modem_GetIP
   1781              if(resp == 1) 
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD116             BNE.N    ??Modem_SocketOpenSvrName_1
   1782                vTaskDelay(100);
   \   00000034   0x2064             MOVS     R0,#+100
   \   00000036   0x.... 0x....      BL       vTaskDelay
   1783              else
   1784                return resp;
   1785          
   1786              memcpy((u8*)&tmp_ip,ip,4);
   \   0000003A   0x2204             MOVS     R2,#+4
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0xA801             ADD      R0,SP,#+4
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy4
   1787              Modem_CheckConnectIP(tmp_ip, port, mode);
   \   00000044   0x4632             MOV      R2,R6
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x9801             LDR      R0,[SP, #+4]
   \   0000004A   0x.... 0x....      BL       Modem_CheckConnectIP
   \   0000004E   0xE004             B.N      ??Modem_SocketOpenSvrName_2
   1788            }
   1789            else {
   1790              memcpy(ip, (u8*)svr_name, 4);
   \                     ??Modem_SocketOpenSvrName_0: (+1)
   \   00000050   0x2204             MOVS     R2,#+4
   \   00000052   0x4621             MOV      R1,R4
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy
   1791            }
   1792          
   1793            resp = Modem_SocketOpenIP(ip, port);
   1794            
   1795            return resp;
   \                     ??Modem_SocketOpenSvrName_2: (+1)
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x.... 0x....      BL       Modem_SocketOpenIP
   \                     ??Modem_SocketOpenSvrName_1: (+1)
   \   00000062   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1796            
   1797          }
   1798          
   1799          /*
   1800          ********************************************************************************
   1801          * Description : Modem_SocketClose
   1802          * Arguments   : sw
   1803          * Return      : resp
   1804          * Note        : Modem TCP socket close
   1805          ******************************************************************************** 
   1806          */

   \                                 In section .text, align 2, keep-with-next
   1807          unsigned char Modem_SocketClose(int sw)
   1808          {
   \                     Modem_SocketClose: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1809            u8 resp;
   1810            
   1811            if(FotaRespFlag) FotaRespFlag = 0;
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable153_1
   \   00000006   0x7AE9             LDRB     R1,[R5, #+11]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD001             BEQ.N    ??Modem_SocketClose_0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x72E9             STRB     R1,[R5, #+11]
   1812            if(sw == 0)  {
   \                     ??Modem_SocketClose_0: (+1)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD135             BNE.N    ??Modem_SocketClose_1
   1813              vTaskDelay(1000);
   \   00000014   0xF44F 0x707A      MOV      R0,#+1000
   \   00000018   0x.... 0x....      BL       vTaskDelay
   1814              
   1815              ModemCommInit();
   \   0000001C   0x.... 0x....      BL       ModemCommInit
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable153_2
   \   00000024   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   00000028   0x0001             MOVS     R1,R0
   \   0000002A   0xD001             BEQ.N    ??Modem_SocketClose_2
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD105             BNE.N    ??Modem_SocketClose_3
   1816              if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1){
   1817                TxStrToModem("AT$$TCP_SCCL\r");
   \                     ??Modem_SocketClose_2: (+1)
   \   00000030   0x.... 0x....      ADR.W    R0,?_89
   \   00000034   0x.... 0x....      BL       TxStrToModem
   1818                resp = 1; 
   \   00000038   0x2401             MOVS     R4,#+1
   \   0000003A   0xE00F             B.N      ??Modem_SocketClose_4
   1819              }
   1820              else if(Setting.ExtModemModel == 2){
   \                     ??Modem_SocketClose_3: (+1)
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD10D             BNE.N    ??Modem_SocketClose_4
   1821                resp = sendATcommand("AT@SOCKCLOSE=0\r", "OK", "ERROR", 5000);      
   1822                if(resp == 1) 
   \   00000040   0xF241 0x3388      MOVW     R3,#+5000
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable152
   \   00000048   0x....             ADR.N    R1,??DataTable150  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000004A   0x.... 0x....      ADR.W    R0,?_40
   \   0000004E   0x.... 0x....      BL       sendATcommand
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD101             BNE.N    ??Modem_SocketClose_5
   1823                  resp = 1;
   \   00000056   0x2401             MOVS     R4,#+1
   \   00000058   0xE000             B.N      ??Modem_SocketClose_4
   1824                else
   1825                  resp = 0;
   \                     ??Modem_SocketClose_5: (+1)
   \   0000005A   0x2400             MOVS     R4,#+0
   1826              }
   1827              if(resp == 1) {
   \                     ??Modem_SocketClose_4: (+1)
   \   0000005C   0xB2E4             UXTB     R4,R4
   \   0000005E   0x2C01             CMP      R4,#+1
   \   00000060   0xD109             BNE.N    ??Modem_SocketClose_6
   1828                TCP_Open = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7228             STRB     R0,[R5, #+8]
   1829                SocketConnectStep = SOCKET_CLOSE;
   \   00000066   0x2009             MOVS     R0,#+9
   \   00000068   0x7328             STRB     R0,[R5, #+12]
   1830                Urc.Mode = URCMODE_IDLE;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable160
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x6741             STR      R1,[R0, #+116]
   1831                Urc.RespFlag = 0;  
   \   00000072   0x6701             STR      R1,[R0, #+112]
   1832                Urc.Cnt = 0;    
   \   00000074   0x6681             STR      R1,[R0, #+104]
   1833              }
   1834              vTaskDelay(1000);
   \                     ??Modem_SocketClose_6: (+1)
   \   00000076   0xF44F 0x707A      MOV      R0,#+1000
   \   0000007A   0x.... 0x....      BL       vTaskDelay
   \   0000007E   0xE002             B.N      ??Modem_SocketClose_7
   1835            }
   1836            else {
   1837              resp = Modem_PPPClose();
   \                     ??Modem_SocketClose_1: (+1)
   \   00000080   0x.... 0x....      BL       Modem_PPPClose
   \   00000084   0x4604             MOV      R4,R0
   1838            }
   1839            return resp;
   \                     ??Modem_SocketClose_7: (+1)
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1840          }
   1841          
   1842          
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844          void TellRespDecode(void) 
   1845          {
   \                     TellRespDecode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1846            if(TellRespNo > 499  && TellRespNo < 600)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable153_1
   \   00000006   0x6B60             LDR      R0,[R4, #+52]
   \   00000008   0xF5A0 0x71FA      SUB      R1,R0,#+500
   \   0000000C   0x2964             CMP      R1,#+100
   \   0000000E   0xD200             BCS.N    ??TellRespDecode_0
   1847              KtfState = TellRespNo;
   \   00000010   0x83E0             STRH     R0,[R4, #+30]
   1848            
   1849            switch(TellRespNo) {
   \                     ??TellRespDecode_0: (+1)
   \   00000012   0x3828             SUBS     R0,R0,#+40
   \   00000014   0xD030             BEQ.N    ??TellRespDecode_1
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0xD031             BEQ.N    ??TellRespDecode_2
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0xD032             BEQ.N    ??TellRespDecode_3
   \   0000001E   0x381C             SUBS     R0,R0,#+28
   \   00000020   0xD033             BEQ.N    ??TellRespDecode_4
   \   00000022   0x3816             SUBS     R0,R0,#+22
   \   00000024   0xD037             BEQ.N    ??TellRespDecode_5
   \   00000026   0x386C             SUBS     R0,R0,#+108
   \   00000028   0xD032             BEQ.N    ??TellRespDecode_6
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0xD033             BEQ.N    ??TellRespDecode_5
   \   0000002E   0x1EC0             SUBS     R0,R0,#+3
   \   00000030   0xD031             BEQ.N    ??TellRespDecode_5
   \   00000032   0x380D             SUBS     R0,R0,#+13
   \   00000034   0xD032             BEQ.N    ??TellRespDecode_7
   \   00000036   0xF240 0x117F      MOVW     R1,#+383
   \   0000003A   0x1A40             SUBS     R0,R0,R1
   \   0000003C   0xD031             BEQ.N    ??TellRespDecode_8
   \   0000003E   0x1E40             SUBS     R0,R0,#+1
   \   00000040   0xD032             BEQ.N    ??TellRespDecode_9
   \   00000042   0x1E80             SUBS     R0,R0,#+2
   \   00000044   0xD034             BEQ.N    ??TellRespDecode_10
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0xD035             BEQ.N    ??TellRespDecode_11
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0xD036             BEQ.N    ??TellRespDecode_12
   \   0000004E   0x380F             SUBS     R0,R0,#+15
   \   00000050   0xD037             BEQ.N    ??TellRespDecode_13
   \   00000052   0x3814             SUBS     R0,R0,#+20
   \   00000054   0xD038             BEQ.N    ??TellRespDecode_14
   \   00000056   0x38AA             SUBS     R0,R0,#+170
   \   00000058   0xD044             BEQ.N    ??TellRespDecode_15
   \   0000005A   0x1F00             SUBS     R0,R0,#+4
   \   0000005C   0xD037             BEQ.N    ??TellRespDecode_16
   \   0000005E   0x1F80             SUBS     R0,R0,#+6
   \   00000060   0xD049             BEQ.N    ??TellRespDecode_17
   \   00000062   0x382E             SUBS     R0,R0,#+46
   \   00000064   0xD050             BEQ.N    ??TellRespDecode_18
   \   00000066   0x1E80             SUBS     R0,R0,#+2
   \   00000068   0xD055             BEQ.N    ??TellRespDecode_19
   \   0000006A   0x380C             SUBS     R0,R0,#+12
   \   0000006C   0xD05A             BEQ.N    ??TellRespDecode_20
   \   0000006E   0x3814             SUBS     R0,R0,#+20
   \   00000070   0xD05F             BEQ.N    ??TellRespDecode_21
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0xD06D             BEQ.N    ??TellRespDecode_22
   \   00000076   0xE06E             B.N      ??TellRespDecode_23
   1850              case 40:
   1851                UsimState = 2;
   \                     ??TellRespDecode_1: (+1)
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x7560             STRB     R0,[R4, #+21]
   1852                break;
   \   0000007C   0xE06B             B.N      ??TellRespDecode_23
   1853              case 41:
   1854                UsimState = 1;
   \                     ??TellRespDecode_2: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x7560             STRB     R0,[R4, #+21]
   1855                break;
   \   00000082   0xE068             B.N      ??TellRespDecode_23
   1856              case 42:
   1857                UsimState = 3;
   \                     ??TellRespDecode_3: (+1)
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x7560             STRB     R0,[R4, #+21]
   1858                break;
   \   00000088   0xE065             B.N      ??TellRespDecode_23
   1859                
   1860              case 70:
   1861                SmsState = 1;
   \                     ??TellRespDecode_4: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x7620             STRB     R0,[R4, #+24]
   1862                break;
   \   0000008E   0xE062             B.N      ??TellRespDecode_23
   1863          
   1864              case 92:
   1865                PppState = 2;
   1866                break;
   1867                
   1868              case 200:
   1869                PppState = 0;    //Connect 
   \                     ??TellRespDecode_6: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x75A0             STRB     R0,[R4, #+22]
   1870                break;      
   \   00000094   0xE05F             B.N      ??TellRespDecode_23
   1871              case 201:
   1872                PppState = 2;    //Connect Reject
   1873                break;
   1874              case 204:
   1875                PppState = 2;    //Connect Reject
   \                     ??TellRespDecode_5: (+1)
   \   00000096   0x2002             MOVS     R0,#+2
   \   00000098   0x75A0             STRB     R0,[R4, #+22]
   1876                break;
   \   0000009A   0xE05C             B.N      ??TellRespDecode_23
   1877              case 217:
   1878                PppState = 3;    //Connect Close
   \                     ??TellRespDecode_7: (+1)
   \   0000009C   0x2003             MOVS     R0,#+3
   \   0000009E   0x75A0             STRB     R0,[R4, #+22]
   1879                break;
   \   000000A0   0xE059             B.N      ??TellRespDecode_23
   1880                
   1881              case 600:
   1882                PppState = 1;   //Connect Sucess
   \                     ??TellRespDecode_8: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x75A0             STRB     R0,[R4, #+22]
   1883                break;
   \   000000A6   0xE056             B.N      ??TellRespDecode_23
   1884              case 601:
   1885                TcpState = 3;
   \                     ??TellRespDecode_9: (+1)
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0x7260             STRB     R0,[R4, #+9]
   1886                PppState = 3;   //Connect Close
   \   000000AC   0x75A0             STRB     R0,[R4, #+22]
   1887                break;
   \   000000AE   0xE052             B.N      ??TellRespDecode_23
   1888              case 603:
   1889                TcpState = 1;   //Connect Sucess
   \                     ??TellRespDecode_10: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x7260             STRB     R0,[R4, #+9]
   1890                break;
   \   000000B4   0xE04F             B.N      ??TellRespDecode_23
   1891              case 604:
   1892                TcpState = 2;   //Connect Fail
   \                     ??TellRespDecode_11: (+1)
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0x7260             STRB     R0,[R4, #+9]
   1893                break;
   \   000000BA   0xE04C             B.N      ??TellRespDecode_23
   1894              case 605:
   1895                TcpState = 3;   //Connect Close
   \                     ??TellRespDecode_12: (+1)
   \   000000BC   0x2003             MOVS     R0,#+3
   \   000000BE   0x7260             STRB     R0,[R4, #+9]
   1896                break;
   \   000000C0   0xE049             B.N      ??TellRespDecode_23
   1897              case 620:
   1898                TcpState = 4;   //Listening
   \                     ??TellRespDecode_13: (+1)
   \   000000C2   0x2004             MOVS     R0,#+4
   \   000000C4   0x7260             STRB     R0,[R4, #+9]
   1899                break;
   \   000000C6   0xE046             B.N      ??TellRespDecode_23
   1900              case 640:
   1901                TcpState = 5;   //Connect Closed event
   \                     ??TellRespDecode_14: (+1)
   \   000000C8   0x2005             MOVS     R0,#+5
   \   000000CA   0x7260             STRB     R0,[R4, #+9]
   1902                break;
   \   000000CC   0xE043             B.N      ??TellRespDecode_23
   1903          
   1904              case 814:
   1905                Modem_FotaFlag = 1;
   \                     ??TellRespDecode_16: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x74A0             STRB     R0,[R4, #+18]
   1906                printk("\r\nMODEM : MODEM FOTA SMS\r\n");
   \   000000D2   0x.... 0x....      ADR.W    R0,?_90
   \   000000D6   0x.... 0x....      BL       printk
   1907                ModemWaitCnt = 0;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x62A0             STR      R0,[R4, #+40]
   1908                ModemStep = MODEM_FOTA_IDLE;     //Modem Fota Idle
   \   000000DE   0x2016             MOVS     R0,#+22
   \   000000E0   0x72A0             STRB     R0,[R4, #+10]
   1909                break;
   \   000000E2   0xE038             B.N      ??TellRespDecode_23
   1910              case 810:
   1911                printk("\r\nMODEM : MODEM FOTA START\r\n");
   \                     ??TellRespDecode_15: (+1)
   \   000000E4   0x.... 0x....      ADR.W    R0,?_91
   \   000000E8   0x.... 0x....      BL       printk
   1912                ModemWaitCnt = 0;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x62A0             STR      R0,[R4, #+40]
   1913                ModemStep = MODEM_FOTA_IDLE;     //Modem Fota Idle
   \   000000F0   0x2016             MOVS     R0,#+22
   \   000000F2   0x72A0             STRB     R0,[R4, #+10]
   1914                break;
   \   000000F4   0xE02F             B.N      ??TellRespDecode_23
   1915              case 820:
   1916                printk("\r\nMODEM : MODEM DOWNLOAD START\r\n");
   \                     ??TellRespDecode_17: (+1)
   \   000000F6   0x.... 0x....      ADR.W    R0,?_92
   \   000000FA   0x.... 0x....      BL       printk
   1917                ModemWaitCnt = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x62A0             STR      R0,[R4, #+40]
   1918                ModemStep = MODEM_FOTA_IDLE;     //Modem Fota Idle
   \   00000102   0x2016             MOVS     R0,#+22
   \   00000104   0x72A0             STRB     R0,[R4, #+10]
   1919                break;
   \   00000106   0xE026             B.N      ??TellRespDecode_23
   1920              case 866:
   1921                printk("\r\nMODEM : MODEM FOTA RESET\r\n");
   \                     ??TellRespDecode_18: (+1)
   \   00000108   0x.... 0x....      ADR.W    R0,?_93
   \   0000010C   0x.... 0x....      BL       printk
   1922                NVIC_SystemReset();
   \   00000110   0x.... 0x....      BL       NVIC_SystemReset
   1923          //      ModemStep = MODEM_RESET_REQ;
   1924                break;
   \   00000114   0xE01F             B.N      ??TellRespDecode_23
   1925              case 868:
   1926                printk("\r\nMODEM : MODEM FOTA ERROR\r\n");
   \                     ??TellRespDecode_19: (+1)
   \   00000116   0x.... 0x....      ADR.W    R0,?_94
   \   0000011A   0x.... 0x....      BL       printk
   1927                ModemStep = MODEM_RESET_REQ;
   \   0000011E   0x2014             MOVS     R0,#+20
   \   00000120   0x72A0             STRB     R0,[R4, #+10]
   1928                break;
   \   00000122   0xE018             B.N      ??TellRespDecode_23
   1929              case 880:
   1930                printk("\r\nMODEM : MODEM FOTA FAIL\r\n");
   \                     ??TellRespDecode_20: (+1)
   \   00000124   0x.... 0x....      ADR.W    R0,?_95
   \   00000128   0x.... 0x....      BL       printk
   1931                ModemStep = MODEM_RESET_REQ;
   \   0000012C   0x2014             MOVS     R0,#+20
   \   0000012E   0x72A0             STRB     R0,[R4, #+10]
   1932                break;
   \   00000130   0xE011             B.N      ??TellRespDecode_23
   1933                
   1934              case 900:
   1935                TldState = 1;   //Boot up
   \                     ??TellRespDecode_21: (+1)
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0x75E0             STRB     R0,[R4, #+23]
   1936                ModemStep = MODEM_POWER_ON_IDLE;  
   \   00000136   0x72A0             STRB     R0,[R4, #+10]
   1937                if(ModemPowerOnFlag) ModemWaitCnt = 0;
   \   00000138   0x79E0             LDRB     R0,[R4, #+7]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD001             BEQ.N    ??TellRespDecode_24
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x62A0             STR      R0,[R4, #+40]
   1938                ModemPowerOnFlag = 1;
   \                     ??TellRespDecode_24: (+1)
   \   00000142   0x2001             MOVS     R0,#+1
   \   00000144   0x71E0             STRB     R0,[R4, #+7]
   1939                Setting.ExtModemModel = 0;
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable153_2
   \   0000014C   0xF881 0x00B7      STRB     R0,[R1, #+183]
   1940                break;
   \   00000150   0xE001             B.N      ??TellRespDecode_23
   1941              case 901:
   1942                TldState = 2;   //Reset
   \                     ??TellRespDecode_22: (+1)
   \   00000152   0x2002             MOVS     R0,#+2
   \   00000154   0x75E0             STRB     R0,[R4, #+23]
   1943                break;
   1944            }
   1945            TellRespFlag = 0;
   \                     ??TellRespDecode_23: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x74E0             STRB     R0,[R4, #+19]
   1946            TellRespNo = 0;
   \   0000015A   0x6360             STR      R0,[R4, #+52]
   1947          }
   \   0000015C   0xBD10             POP      {R4,PC}          ;; return
   1948          
   1949          /*
   1950          ********************************************************************************
   1951          * Description : Modem_URC_Parser
   1952          * Arguments   : r
   1953          * Return      : none
   1954          * Note        : Modem URC Parser
   1955          ******************************************************************************** 
   1956          */
   1957          
   1958          #define MAX_SOCKET_RX_LEN 512
   1959          
   1960          u8 RxHexStrStep;
   1961          u16 RxHexStrCnt, RxHexStrLen;
   1962          u8 RxBinData;
   1963          char RxHexStr[10];

   \                                 In section .text, align 4, keep-with-next
   1964          unsigned int RxHexStrData(unsigned char r)
   1965          {
   \                     RxHexStrData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1966            if(r == '@') RxHexStrStep = 0;
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable161
   \   00000008   0x2A40             CMP      R2,#+64
   \   0000000A   0xD101             BNE.N    ??RxHexStrData_1
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7021             STRB     R1,[R4, #+0]
   1967            switch(RxHexStrStep) {
   \                     ??RxHexStrData_1: (+1)
   \   00000010   0x7821             LDRB     R1,[R4, #+0]
   \   00000012   0x2903             CMP      R1,#+3
   \   00000014   0xF200 0x80A2      BHI.W    ??RxHexStrData_2
   \   00000018   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??RxHexStrData_0:
   \   0000001C   0x02 0x0F          DC8      0x2,0xF,0x2B,0x67
   \              0x2B 0x67    
   1968              case 0:
   1969                if(r == '@') {
   \                     ??RxHexStrData_3: (+1)
   \   00000020   0x2A40             CMP      R2,#+64
   \   00000022   0xF040 0x809B      BNE.W    ??RxHexStrData_2
   1970                  RxHexStrStep = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   1971                  RxHexStrCnt = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x8220             STRH     R0,[R4, #+16]
   1972                  memset((u8*)RxHexStr, 0, 10);
   \   0000002E   0x4602             MOV      R2,R0
   \   00000030   0x210A             MOVS     R1,#+10
   \   00000032   0x1D20             ADDS     R0,R4,#+4
   \   00000034   0x.... 0x....      BL       __aeabi_memset4
   1973                }
   \   00000038   0xE090             B.N      ??RxHexStrData_2
   1974                break;
   1975              case 1:
   1976                if(r == '=') {
   \                     ??RxHexStrData_4: (+1)
   \   0000003A   0x2A3D             CMP      R2,#+61
   \   0000003C   0xD10D             BNE.N    ??RxHexStrData_5
   1977                  if (strstr(RxHexStr, "SOCKRCV") != NULL) {
   \   0000003E   0x.... 0x....      ADR.W    R1,?_96
   \   00000042   0x1D20             ADDS     R0,R4,#+4
   \   00000044   0x.... 0x....      BL       strstr
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xF000 0x8087      BEQ.W    ??RxHexStrData_2
   1978                    RxHexStrStep = 2;
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x7020             STRB     R0,[R4, #+0]
   1979                    RxHexStrLen = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x8260             STRH     R0,[R4, #+18]
   1980                    RxHexStrCnt = 0;
   \   00000056   0x8220             STRH     R0,[R4, #+16]
   \   00000058   0xE080             B.N      ??RxHexStrData_2
   1981                  }
   1982                }
   1983                else if(RxHexStrCnt < 9){
   \                     ??RxHexStrData_5: (+1)
   \   0000005A   0x8A21             LDRH     R1,[R4, #+16]
   \   0000005C   0x460B             MOV      R3,R1
   \   0000005E   0x2B09             CMP      R3,#+9
   \   00000060   0xDA04             BGE.N    ??RxHexStrData_6
   1984                  RxHexStr[RxHexStrCnt++] = r;
   \   00000062   0x18E2             ADDS     R2,R4,R3
   \   00000064   0x7110             STRB     R0,[R2, #+4]
   \   00000066   0x1C48             ADDS     R0,R1,#+1
   \   00000068   0x8220             STRH     R0,[R4, #+16]
   \   0000006A   0xE077             B.N      ??RxHexStrData_2
   1985                }
   1986                else RxHexStrStep = 0;
   \                     ??RxHexStrData_6: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
   \   00000070   0xE074             B.N      ??RxHexStrData_2
   1987                break;
   1988              case 2:
   1989                if(r == ',') {
   \                     ??RxHexStrData_7: (+1)
   \   00000072   0x2A2C             CMP      R2,#+44
   \   00000074   0xD112             BNE.N    ??RxHexStrData_8
   1990                  RxHexStrCnt++;
   \   00000076   0x8A21             LDRH     R1,[R4, #+16]
   \   00000078   0x1C48             ADDS     R0,R1,#+1
   \   0000007A   0x8220             STRH     R0,[R4, #+16]
   1991                  if(RxHexStrCnt == 3) {
   \   0000007C   0xB280             UXTH     R0,R0
   \   0000007E   0x2803             CMP      R0,#+3
   \   00000080   0xD16C             BNE.N    ??RxHexStrData_2
   1992                    if(RxHexStrLen > 0) {
   \   00000082   0x8A61             LDRH     R1,[R4, #+18]
   \   00000084   0x0008             MOVS     R0,R1
   \   00000086   0xD006             BEQ.N    ??RxHexStrData_9
   1993                      RxHexStrLen = 2*RxHexStrLen;
   \   00000088   0x0048             LSLS     R0,R1,#+1
   \   0000008A   0x8260             STRH     R0,[R4, #+18]
   1994                      RxHexStrCnt = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x8220             STRH     R0,[R4, #+16]
   1995                      RxHexStrStep = 3;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0x7020             STRB     R0,[R4, #+0]
   \   00000094   0xE062             B.N      ??RxHexStrData_2
   1996                    }
   1997                    else
   1998                      RxHexStrStep = 0;
   \                     ??RxHexStrData_9: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x7020             STRB     R0,[R4, #+0]
   \   0000009A   0xE05F             B.N      ??RxHexStrData_2
   1999                  }
   2000                }
   2001                else if((r >= '0' && r <= '9')) {
   \                     ??RxHexStrData_8: (+1)
   \   0000009C   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   000000A0   0x290A             CMP      R1,#+10
   \   000000A2   0xD21D             BCS.N    ??RxHexStrData_10
   2002                  if(RxHexStrCnt == 0) {
   \   000000A4   0x8A21             LDRH     R1,[R4, #+16]
   \   000000A6   0x000B             MOVS     R3,R1
   \   000000A8   0xD103             BNE.N    ??RxHexStrData_11
   2003                    if(r != '0') RxHexStrStep = 0;
   \   000000AA   0x2A30             CMP      R2,#+48
   \   000000AC   0xD001             BEQ.N    ??RxHexStrData_11
   \   000000AE   0x2300             MOVS     R3,#+0
   \   000000B0   0x7023             STRB     R3,[R4, #+0]
   2004                  }
   2005                  if(RxHexStrCnt == 1) {
   \                     ??RxHexStrData_11: (+1)
   \   000000B2   0x460B             MOV      R3,R1
   \   000000B4   0x2B01             CMP      R3,#+1
   \   000000B6   0xD103             BNE.N    ??RxHexStrData_12
   2006                    if(r != '1') RxHexStrStep = 0;
   \   000000B8   0x2A31             CMP      R2,#+49
   \   000000BA   0xD001             BEQ.N    ??RxHexStrData_12
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0x7021             STRB     R1,[R4, #+0]
   2007                  }
   2008                  if(RxHexStrCnt == 2) {
   \                     ??RxHexStrData_12: (+1)
   \   000000C0   0x2B02             CMP      R3,#+2
   \   000000C2   0xD14B             BNE.N    ??RxHexStrData_2
   2009                    RxHexStrLen = RxHexStrLen*10+(r-'0');
   \   000000C4   0x8A61             LDRH     R1,[R4, #+18]
   \   000000C6   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   000000CA   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   000000CE   0x3830             SUBS     R0,R0,#+48
   \   000000D0   0x8260             STRH     R0,[R4, #+18]
   2010                    if(RxHexStrLen > MAX_SOCKET_RX_LEN) RxHexStrStep = 0;
   \   000000D2   0xB280             UXTH     R0,R0
   \   000000D4   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000D8   0xDD40             BLE.N    ??RxHexStrData_2
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x7020             STRB     R0,[R4, #+0]
   \   000000DE   0xE03D             B.N      ??RxHexStrData_2
   2011                  }
   2012                }
   2013                else if(r != ' ') RxHexStrStep = 0;
   \                     ??RxHexStrData_10: (+1)
   \   000000E0   0x2A20             CMP      R2,#+32
   \   000000E2   0xD03B             BEQ.N    ??RxHexStrData_2
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x7020             STRB     R0,[R4, #+0]
   \   000000E8   0xE038             B.N      ??RxHexStrData_2
   2014                break;
   2015              case 3:
   2016                if((r >= '0' && r <= '9') || (r >= 'A' && r <= 'F')) {
   \                     ??RxHexStrData_13: (+1)
   \   000000EA   0xF1A2 0x0330      SUB      R3,R2,#+48
   \   000000EE   0x2B0A             CMP      R3,#+10
   \   000000F0   0xD303             BCC.N    ??RxHexStrData_14
   \   000000F2   0xF1A2 0x0141      SUB      R1,R2,#+65
   \   000000F6   0x2906             CMP      R1,#+6
   \   000000F8   0xD22B             BCS.N    ??RxHexStrData_15
   2017                  if(RxHexStrCnt%2 == 0) RxBinData = 0;
   \                     ??RxHexStrData_14: (+1)
   \   000000FA   0x8A21             LDRH     R1,[R4, #+16]
   \   000000FC   0xEB01 0x75D1      ADD      R5,R1,R1, LSR #+31
   \   00000100   0x106D             ASRS     R5,R5,#+1
   \   00000102   0xEBB1 0x0545      SUBS     R5,R1,R5, LSL #+1
   \   00000106   0xD101             BNE.N    ??RxHexStrData_16
   \   00000108   0x2500             MOVS     R5,#+0
   \   0000010A   0x7065             STRB     R5,[R4, #+1]
   2018                  if(r >= '0' && r <= '9') RxBinData = RxBinData*0x10+(r-'0');
   \                     ??RxHexStrData_16: (+1)
   \   0000010C   0x2B0A             CMP      R3,#+10
   \   0000010E   0xD205             BCS.N    ??RxHexStrData_17
   \   00000110   0x7862             LDRB     R2,[R4, #+1]
   \   00000112   0xEB00 0x1002      ADD      R0,R0,R2, LSL #+4
   \   00000116   0x3830             SUBS     R0,R0,#+48
   \   00000118   0x7060             STRB     R0,[R4, #+1]
   \   0000011A   0xE007             B.N      ??RxHexStrData_18
   2019                  else if(r >= 'A' && r <= 'F') RxBinData = RxBinData*0x10+(r-'A'+0x0A);
   \                     ??RxHexStrData_17: (+1)
   \   0000011C   0x3A41             SUBS     R2,R2,#+65
   \   0000011E   0x2A06             CMP      R2,#+6
   \   00000120   0xD204             BCS.N    ??RxHexStrData_18
   \   00000122   0x7862             LDRB     R2,[R4, #+1]
   \   00000124   0xEB00 0x1002      ADD      R0,R0,R2, LSL #+4
   \   00000128   0x3837             SUBS     R0,R0,#+55
   \   0000012A   0x7060             STRB     R0,[R4, #+1]
   2020                  RxHexStrCnt++;
   \                     ??RxHexStrData_18: (+1)
   \   0000012C   0x1C48             ADDS     R0,R1,#+1
   \   0000012E   0x8220             STRH     R0,[R4, #+16]
   2021                  if(RxHexStrCnt > RxHexStrLen) RxHexStrStep = 0;
   \   00000130   0x8A61             LDRH     R1,[R4, #+18]
   \   00000132   0x4602             MOV      R2,R0
   \   00000134   0xB292             UXTH     R2,R2
   \   00000136   0x4291             CMP      R1,R2
   \   00000138   0xD202             BCS.N    ??RxHexStrData_19
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x7020             STRB     R0,[R4, #+0]
   \   0000013E   0xE00D             B.N      ??RxHexStrData_2
   2022                  else if(RxHexStrCnt%2 == 0) return RxBinData;
   \                     ??RxHexStrData_19: (+1)
   \   00000140   0xB280             UXTH     R0,R0
   \   00000142   0xEB00 0x71D0      ADD      R1,R0,R0, LSR #+31
   \   00000146   0x1049             ASRS     R1,R1,#+1
   \   00000148   0xEBB0 0x0041      SUBS     R0,R0,R1, LSL #+1
   \   0000014C   0xD106             BNE.N    ??RxHexStrData_2
   \   0000014E   0x7860             LDRB     R0,[R4, #+1]
   \   00000150   0xBD32             POP      {R1,R4,R5,PC}
   2023                }
   2024                else if(RxHexStrCnt > 0) RxHexStrStep = 0;
   \                     ??RxHexStrData_15: (+1)
   \   00000152   0x8A20             LDRH     R0,[R4, #+16]
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD001             BEQ.N    ??RxHexStrData_2
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x7020             STRB     R0,[R4, #+0]
   2025                break;
   2026            }
   2027            return 0xFFFF;
   \                     ??RxHexStrData_2: (+1)
   \   0000015C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000160   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2028          }

   \                                 In section .bss, align 4
   \   __absolute u8 MtTxAPNFlag
   \                     MtTxAPNFlag:
   \   00000000                      DS8 1
   \   __absolute u8 MtReadAPNFlag
   \                     MtReadAPNFlag:
   \   00000001                      DS8 1
   \   __absolute u8 MtChangeAPNFlag
   \                     MtChangeAPNFlag:
   \   00000002                      DS8 1
   \   __absolute u8 COM_Command_Char
   \                     COM_Command_Char:
   \   00000003                      DS8 1
   \   __absolute u8 DataServerFlag
   \                     DataServerFlag:
   \   00000004                      DS8 1
   \   __absolute u8 ModemOffFlag
   \                     ModemOffFlag:
   \   00000005                      DS8 1
   \   __absolute u8 ModemReadyFlag
   \                     ModemReadyFlag:
   \   00000006                      DS8 1
   \   __absolute u8 ModemPowerOnFlag
   \                     ModemPowerOnFlag:
   \   00000007                      DS8 1
   \   __absolute u8 TCP_Open
   \                     TCP_Open:
   \   00000008                      DS8 1
   \   __absolute u8 TcpState
   \                     TcpState:
   \   00000009                      DS8 1
   \   __absolute u8 ModemStep
   \                     ModemStep:
   \   0000000A                      DS8 1
   \   __absolute u8 FotaRespFlag
   \                     FotaRespFlag:
   \   0000000B                      DS8 1
   \   __absolute u8 SocketConnectStep
   \                     SocketConnectStep:
   \   0000000C                      DS8 1
   \   __absolute u8 SocketRetryCnt
   \                     SocketRetryCnt:
   \   0000000D                      DS8 1
   \   __absolute u8 ServerIPCheckFlag
   \                     ServerIPCheckFlag:
   \   0000000E                      DS8 1
   \   __absolute u8 LoopFotaFlag
   \                     LoopFotaFlag:
   \   0000000F                      DS8 1
   \   __absolute u8 LoopFotaStep
   \                     LoopFotaStep:
   \   00000010                      DS8 1
   \                     ModemInitCnt:
   \   00000011                      DS8 1
   \                     Modem_FotaFlag:
   \   00000012                      DS8 1
   \                     TellRespFlag:
   \   00000013                      DS8 1
   \                     NetRespFlag:
   \   00000014                      DS8 1
   \                     UsimState:
   \   00000015                      DS8 1
   \                     PppState:
   \   00000016                      DS8 1
   \                     TldState:
   \   00000017                      DS8 1
   \                     SmsState:
   \   00000018                      DS8 1
   \                     ModemServiceFaultCnt:
   \   00000019                      DS8 1
   \                     ModemServiceFault:
   \   0000001A                      DS8 1
   2029          
   2030          u8 DmsApnPushRxFlag, DmsApnPushRxCnt;
   \                     DmsApnPushRxFlag:
   \   0000001B                      DS8 1
   \                     DmsApnPushRxCnt:
   \   0000001C                      DS8 1
   \   0000001D                      DS8 1
   \                     KtfState:
   \   0000001E                      DS8 2
   \                     APNProcessCnt:
   \   00000020                      DS8 2
   \   00000022                      DS8 2
   \   __absolute u32 DataAddrToSend
   \                     DataAddrToSend:
   \   00000024                      DS8 4
   \   __absolute u32 ModemWaitCnt
   \                     ModemWaitCnt:
   \   00000028                      DS8 4
   \   __absolute u32 SocketWaitCnt
   \                     SocketWaitCnt:
   \   0000002C                      DS8 4
   \                     SMSDecodeWaitCnt:
   \   00000030                      DS8 4
   \                     TellRespNo:
   \   00000034                      DS8 4
   \                     NetRespNo:
   \   00000038                      DS8 4
   \   __absolute char APN_Name[32]
   \                     APN_Name:
   \   0000003C                      DS8 32
   \   __absolute char ComRxAPN_Name[32]
   \                     ComRxAPN_Name:
   \   0000005C                      DS8 32
   \   __absolute char MdmTmpString[100]
   \                     MdmTmpString:
   \   0000007C                      DS8 100
   \   __absolute tsSMSData SMSData
   \                     SMSData:
   \   000000E0                      DS8 140
   2031          char DmsPushApnName[32];
   \                     DmsPushApnName:
   \   0000016C                      DS8 32

   \                                 In section .bss, align 4
   \   __absolute char ATCmdRxMsg[10][32]
   \                     ATCmdRxMsg:
   \   00000000                      DS8 320
   \   __absolute tsModemInfo ModemInfo
   \                     ModemInfo:
   \   00000140                      DS8 64

   \                                 In section .bss, align 4
   \   __absolute u32 VdisAddrToSend
   \                     VdisAddrToSend:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 DTG_Data_Flash_WriteFlag
   \                     DTG_Data_Flash_WriteFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 DTG_Data_Flash_ReadFlag
   \                     DTG_Data_Flash_ReadFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 VehStateFlag
   \                     VehStateFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 VdisServerFlag
   \                     VdisServerFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute int DataServerRetryCount
   \                     DataServerRetryCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute int VdisServerRetryCount
   \                     VdisServerRetryCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 OnNotiFlag
   \                     OnNotiFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute int OnNotiRetryCount
   \                     OnNotiRetryCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 SvrEventFlag
   \                     SvrEventFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 SvrEventCode
   \                     SvrEventCode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 SvrSvcError
   \                     SvrSvcError:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 Prev_DataFlag
   \                     Prev_DataFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 Prev_VdisFlag
   \                     Prev_VdisFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute u32 Prev_DataAdrrToSend
   \                     Prev_DataAdrrToSend:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute u32 Prev_VdisAdrrToSend
   \                     Prev_VdisAdrrToSend:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 GetServerFlag
   \                     GetServerFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute int GetServerRetryCount
   \                     GetServerRetryCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute u8 ModemBuff[6144]
   \                     ModemBuff:
   \   00000000                      DS8 6144

   \                                 In section .bss, align 4
   \   __absolute tsUrc Urc
   \                     Urc:
   \   00000000                      DS8 120

   \                                 In section .bss, align 1
   \   __absolute u8 DataSvrStep
   \                     DataSvrStep:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 VdisSvrStep
   \                     VdisSvrStep:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute u32 DataSvrWaitCount
   \                     DataSvrWaitCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute u32 VdisSvrWaitCount
   \                     VdisSvrWaitCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 GetSvrStep
   \                     GetSvrStep:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute u32 GetSvrWaitCount
   \                     GetSvrWaitCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 OnNotiStep
   \                     OnNotiStep:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute int OnNotiWaitCount
   \                     OnNotiWaitCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 OnNotiRespFlag
   \                     OnNotiRespFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute u8 ModemVer[20]
   \                     ModemVer:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \   __absolute char ModemCTN[11]
   \                     ModemCTN:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \   __absolute char AT_Response[256]
   \                     AT_Response:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
   \   __absolute tsSvrInfo HostSvr
   \                     HostSvr:
   \   00000000                      DS8 64
   \   __absolute u32 SendData_StartTime
   \                     SendData_StartTime:
   \   00000040                      DS8 4
   \                     Loop_SendTimeCnt:
   \   00000044                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute tsSvrInfo FWDN_Svr
   \                     FWDN_Svr:
   \   00000000                      DS8 64

   \                                 In section .bss, align 1
   \   __absolute u8 RxBuffEmpty
   \                     RxBuffEmpty:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute u32 ProgressFotaRxByte
   \                     ProgressFotaRxByte:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 FotaFlag
   \                     FotaFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 FotaEnable
   \                     FotaEnable:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute u32 SendData_EndTime
   \                     SendData_EndTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute u8 SendSettingFlag
   \                     SendSettingFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute u8 SendDailyDataFlag
   \                     SendDailyDataFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _millisCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \                     NotiRespFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     NotiRespNo:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ModemCommBuf:
   \   00000000                      DS8 4364

   \                                 In section .bss, align 4
   \                     TxResp:
   \   00000000                      DS8 1
   \                     TxRespStep:
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \                     TxMsgLen:
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     RxHexStrStep:
   \   00000000                      DS8 1
   \                     RxBinData:
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \                     RxHexStr:
   \   00000004                      DS8 12
   \                     RxHexStrCnt:
   \   00000010                      DS8 2
   \                     RxHexStrLen:
   \   00000012                      DS8 2

   \                                 In section .text, align 2, keep-with-next
   2032          void Modem_URC_Parser(unsigned char r) //interrupt msg procedure
   2033          {
   \                     Modem_URC_Parser: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   2034            unsigned int rdata;
   2035            //u16 addr;
   2036            
   2037          //  if(ModemStep > MODEM_SOCKET_STAT)  return;
   2038          //  put_ch_console(r);
   2039            switch(Urc.Mode) {
   \   00000004   0x....             LDR.N    R4,??DataTable153_1
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable160
   \   0000000A   0x6F70             LDR      R0,[R6, #+116]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD002             BEQ.N    ??Modem_URC_Parser_0
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD040             BEQ.N    ??Modem_URC_Parser_1
   \   00000014   0xE00C             B.N      ??Modem_URC_Parser_2
   2040              case URCMODE_IDLE:
   2041                //idle
   2042                break;
   2043                
   2044              case URCMODE_SMS:
   2045                if(Urc.RespFlag)
   \                     ??Modem_URC_Parser_0: (+1)
   \   00000016   0x6F30             LDR      R0,[R6, #+112]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??Modem_URC_Parser_3
   2046                  SMS_Process(r);
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SMS_Process
   2047                SMSDecodeWaitCnt++;
   \                     ??Modem_URC_Parser_3: (+1)
   \   00000022   0x6B20             LDR      R0,[R4, #+48]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x6320             STR      R0,[R4, #+48]
   2048                if(SMSDecodeWaitCnt > 10000) {
   \   00000028   0xF242 0x7111      MOVW     R1,#+10001
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD237             BCS.N    ??Modem_URC_Parser_4
   2049                  Urc.Mode = URCMODE_IDLE;
   2050                  Urc.RespFlag = 0;
   2051                  Urc.Cnt = 0;
   2052                }
   2053                break;
   2054                
   2055              case URCMODE_LOOP:
   2056                if(ModemStep != MODEM_DATA_SERVER && ModemStep != MODEM_LOOP_FOTA) {
   2057                  Urc.Mode = URCMODE_IDLE;
   2058                  Urc.RespFlag = 0;
   2059                  Urc.Cnt = 0;
   2060                }
   2061                else if(Urc.RespFlag) {
   2062                  if(Setting.ExtModemModel == 2) {
   2063                    rdata = RxHexStrData(r);
   2064                    if(rdata != 0xFFFF) {
   2065                      r = rdata&0xff;
   2066                      Modem_RxChar_Loop(r);
   2067                    }
   2068                  }
   2069                  else
   2070                    Modem_RxChar_Loop(r);
   2071                  return;
   2072                }
   2073                break;
   2074            }  
   2075          
   2076            if(r == '\r' || r == '\n') {
   \                     ??Modem_URC_Parser_2: (+1)
   \   00000030   0x462F             MOV      R7,R5
   \   00000032   0x2F0D             CMP      R7,#+13
   \   00000034   0xD001             BEQ.N    ??Modem_URC_Parser_5
   \   00000036   0x2F0A             CMP      R7,#+10
   \   00000038   0xD151             BNE.N    ??Modem_URC_Parser_6
   2077              Urc.Cnt = 0;
   \                     ??Modem_URC_Parser_5: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x66B0             STR      R0,[R6, #+104]
   2078              if(r == '\n')
   \   0000003E   0x2F0A             CMP      R7,#+10
   \   00000040   0xD104             BNE.N    ??Modem_URC_Parser_7
   2079                memset(Urc.Buff,0, URC_BUFF_MAX);
   \   00000042   0x4602             MOV      R2,R0
   \   00000044   0x2164             MOVS     R1,#+100
   \   00000046   0x1D30             ADDS     R0,R6,#+4
   \   00000048   0x.... 0x....      BL       __aeabi_memset4
   2080              if(DmsApnPushRxFlag) {
   \                     ??Modem_URC_Parser_7: (+1)
   \   0000004C   0x7EE0             LDRB     R0,[R4, #+27]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xF000 0x813C      BEQ.W    ??Modem_URC_Parser_8
   2081                if(DmsApnPushRxCnt > 0) {
   \   00000054   0x7F25             LDRB     R5,[R4, #+28]
   \   00000056   0x....             ADR.N    R6,??DataTable153  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xD015             BEQ.N    ??Modem_URC_Parser_9
   2082                  memset((u8*)ComRxAPN_Name, 0, sizeof(ComRxAPN_Name));
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0xF104 0x005C      ADD      R0,R4,#+92
   \   00000064   0x.... 0x....      BL       __aeabi_memset
   2083                  memcpy((u8*)ComRxAPN_Name, DmsPushApnName, DmsApnPushRxCnt);
   \   00000068   0x462A             MOV      R2,R5
   \   0000006A   0xF44F 0x70B6      MOV      R0,#+364
   \   0000006E   0x1821             ADDS     R1,R4,R0
   \   00000070   0xF104 0x005C      ADD      R0,R4,#+92
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy
   2084                  printk("\r\n");
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0x.... 0x....      BL       printk
   2085                  APNProcess(2);  
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x.... 0x....      BL       APNProcess
   2086                  ModemStep = MODEM_DATA_IDLE;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x72A0             STRB     R0,[R4, #+10]
   2087                }
   2088                DmsApnPushRxFlag = 0;
   \                     ??Modem_URC_Parser_9: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x76E0             STRB     R0,[R4, #+27]
   2089                printk("\r\n");
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000092   0x.... 0x....      B.W      printk
   2090              }
   2091            }
   \                     ??Modem_URC_Parser_1: (+1)
   \   00000096   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000098   0x2808             CMP      R0,#+8
   \   0000009A   0xD006             BEQ.N    ??Modem_URC_Parser_10
   \   0000009C   0x280D             CMP      R0,#+13
   \   0000009E   0xD004             BEQ.N    ??Modem_URC_Parser_10
   \                     ??Modem_URC_Parser_4: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x6770             STR      R0,[R6, #+116]
   \   000000A4   0x6730             STR      R0,[R6, #+112]
   \   000000A6   0x66B0             STR      R0,[R6, #+104]
   \   000000A8   0xE7C2             B.N      ??Modem_URC_Parser_2
   \                     ??Modem_URC_Parser_10: (+1)
   \   000000AA   0x6F30             LDR      R0,[R6, #+112]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD0BF             BEQ.N    ??Modem_URC_Parser_2
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable161_1
   \   000000B4   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   000000B8   0x2802             CMP      R0,#+2
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0xD10B             BNE.N    ??Modem_URC_Parser_11
   \   000000BE   0x.... 0x....      BL       RxHexStrData
   \   000000C2   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xF000 0x8100      BEQ.W    ??Modem_URC_Parser_8
   \   000000CC   0xB2C0             UXTB     R0,R0
   \   000000CE   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000D2   0x.... 0x....      B.W      Modem_RxChar_Loop
   \                     ??Modem_URC_Parser_11: (+1)
   \   000000D6   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000DA   0x.... 0x....      B.W      Modem_RxChar_Loop
   2092            else if(Urc.Cnt < URC_BUFF_MAX && !FotaRespFlag) {
   \                     ??Modem_URC_Parser_6: (+1)
   \   000000DE   0x6EB0             LDR      R0,[R6, #+104]
   \   000000E0   0x2864             CMP      R0,#+100
   \   000000E2   0xF280 0x80F3      BGE.W    ??Modem_URC_Parser_8
   \   000000E6   0x7AE1             LDRB     R1,[R4, #+11]
   \   000000E8   0x2900             CMP      R1,#+0
   \   000000EA   0xF040 0x80EF      BNE.W    ??Modem_URC_Parser_8
   2093              Urc.Buff[Urc.Cnt++] = r;
   \   000000EE   0x4430             ADD      R0,R6,R0
   \   000000F0   0x7105             STRB     R5,[R0, #+4]
   \   000000F2   0x6EB0             LDR      R0,[R6, #+104]
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \   000000F6   0x66B0             STR      R0,[R6, #+104]
   2094              if(!Urc.RespFlag || Modem_FotaFlag) {
   \   000000F8   0x6F30             LDR      R0,[R6, #+112]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD003             BEQ.N    ??Modem_URC_Parser_12
   \   000000FE   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xF000 0x80E3      BEQ.W    ??Modem_URC_Parser_8
   2095                if (strstr(Urc.Buff, "+CMTI: ") != NULL)
   \                     ??Modem_URC_Parser_12: (+1)
   \   00000106   0x.... 0x....      ADR.W    R1,?_97
   \   0000010A   0x1D30             ADDS     R0,R6,#+4
   \   0000010C   0x.... 0x....      BL       strstr
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD014             BEQ.N    ??Modem_URC_Parser_13
   2096                {
   2097                  if(Modem_FotaFlag == 0) {
   \   00000114   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xF040 0x80D8      BNE.W    ??Modem_URC_Parser_8
   2098                    Urc.Mode = URCMODE_SMS;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x6770             STR      R0,[R6, #+116]
   2099                    Urc.RespFlag = 1;
   \   00000120   0x6730             STR      R0,[R6, #+112]
   2100                    memset(&SMSData,0, sizeof(tsSMSData));
   \   00000122   0x2200             MOVS     R2,#+0
   \   00000124   0x218C             MOVS     R1,#+140
   \   00000126   0xF104 0x00E0      ADD      R0,R4,#+224
   \   0000012A   0x.... 0x....      BL       __aeabi_memset
   2101                    memset(Urc.Buff,0, URC_BUFF_MAX);
   \   0000012E   0x2200             MOVS     R2,#+0
   \   00000130   0x2164             MOVS     R1,#+100
   \   00000132   0x1D30             ADDS     R0,R6,#+4
   \   00000134   0x.... 0x....      BL       __aeabi_memset4
   2102                    SMSDecodeWaitCnt = 0;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x6320             STR      R0,[R4, #+48]
   2103                  }
   2104                  return;
   \   0000013C   0xBDF1             POP      {R0,R4-R7,PC}
   2105                }
   2106                else if (strstr(Urc.Buff, "$$NOTI:34") != NULL || strstr(Urc.Buff, "$$A_BOOT_ALERT") != NULL)  
   \                     ??Modem_URC_Parser_13: (+1)
   \   0000013E   0x.... 0x....      ADR.W    R1,?_98
   \   00000142   0x1D30             ADDS     R0,R6,#+4
   \   00000144   0x.... 0x....      BL       strstr
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD106             BNE.N    ??Modem_URC_Parser_14
   \   0000014C   0x.... 0x....      ADR.W    R1,?_99
   \   00000150   0x1D30             ADDS     R0,R6,#+4
   \   00000152   0x.... 0x....      BL       strstr
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD015             BEQ.N    ??Modem_URC_Parser_15
   2107                {
   2108                  Setting.ExtModemModel = 1;
   \                     ??Modem_URC_Parser_14: (+1)
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable161_1
   \   00000160   0xF881 0x00B7      STRB     R0,[R1, #+183]
   2109                  TldState = 1;   //Boot up
   \   00000164   0x75E0             STRB     R0,[R4, #+23]
   2110                  ModemStep = MODEM_POWER_ON_IDLE;  
   \   00000166   0x72A0             STRB     R0,[R4, #+10]
   2111                  if(ModemPowerOnFlag) ModemWaitCnt = 0;
   \   00000168   0x79E0             LDRB     R0,[R4, #+7]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD001             BEQ.N    ??Modem_URC_Parser_16
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x62A0             STR      R0,[R4, #+40]
   2112                  ModemPowerOnFlag = 1;
   \                     ??Modem_URC_Parser_16: (+1)
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0x71E0             STRB     R0,[R4, #+7]
   2113                  memset(Urc.Buff,0, URC_BUFF_MAX);
   \   00000176   0x2200             MOVS     R2,#+0
   \   00000178   0x2164             MOVS     R1,#+100
   \   0000017A   0x1D30             ADDS     R0,R6,#+4
   \   0000017C   0x.... 0x....      BL       __aeabi_memset4
   2114                  Urc.Cnt = 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x66B0             STR      R0,[R6, #+104]
   2115                  return;
   \   00000184   0xBDF1             POP      {R0,R4-R7,PC}
   2116                }
   2117                else if (strstr(Urc.Buff, "@NOTI:34") != NULL)  
   \                     ??Modem_URC_Parser_15: (+1)
   \   00000186   0x.... 0x....      ADR.W    R1,?_100
   \   0000018A   0x1D30             ADDS     R0,R6,#+4
   \   0000018C   0x.... 0x....      BL       strstr
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xD016             BEQ.N    ??Modem_URC_Parser_17
   2118                {
   2119                  Setting.ExtModemModel = 2;
   \   00000194   0x2002             MOVS     R0,#+2
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable161_1
   \   0000019A   0xF881 0x00B7      STRB     R0,[R1, #+183]
   2120                  TldState = 1;   //Boot up
   \   0000019E   0x2001             MOVS     R0,#+1
   \   000001A0   0x75E0             STRB     R0,[R4, #+23]
   2121                  ModemStep = MODEM_POWER_ON_IDLE;  
   \   000001A2   0x72A0             STRB     R0,[R4, #+10]
   2122                  if(ModemPowerOnFlag) ModemWaitCnt = 0;
   \   000001A4   0x79E0             LDRB     R0,[R4, #+7]
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD001             BEQ.N    ??Modem_URC_Parser_18
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0x62A0             STR      R0,[R4, #+40]
   2123                  ModemPowerOnFlag = 1;
   \                     ??Modem_URC_Parser_18: (+1)
   \   000001AE   0x2001             MOVS     R0,#+1
   \   000001B0   0x71E0             STRB     R0,[R4, #+7]
   2124                  memset(Urc.Buff,0, URC_BUFF_MAX);
   \   000001B2   0x2200             MOVS     R2,#+0
   \   000001B4   0x2164             MOVS     R1,#+100
   \   000001B6   0x1D30             ADDS     R0,R6,#+4
   \   000001B8   0x.... 0x....      BL       __aeabi_memset4
   2125                  Urc.Cnt = 0;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x66B0             STR      R0,[R6, #+104]
   2126                  return;
   \   000001C0   0xBDF1             POP      {R0,R4-R7,PC}
   2127                }
   2128                else if (strstr(Urc.Buff, "@SOCKOPEN:0,0") != NULL)  
   \                     ??Modem_URC_Parser_17: (+1)
   \   000001C2   0x.... 0x....      ADR.W    R1,?_101
   \   000001C6   0x1D30             ADDS     R0,R6,#+4
   \   000001C8   0x.... 0x....      BL       strstr
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD009             BEQ.N    ??Modem_URC_Parser_19
   2129                {
   2130                  TcpState = 1;
   \   000001D0   0x2001             MOVS     R0,#+1
   \   000001D2   0x7260             STRB     R0,[R4, #+9]
   2131                  memset(Urc.Buff,0, URC_BUFF_MAX);
   \   000001D4   0x2200             MOVS     R2,#+0
   \   000001D6   0x2164             MOVS     R1,#+100
   \   000001D8   0x1D30             ADDS     R0,R6,#+4
   \   000001DA   0x.... 0x....      BL       __aeabi_memset4
   2132                  Urc.Cnt = 0;
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0x66B0             STR      R0,[R6, #+104]
   2133                  return;
   \   000001E2   0xBDF1             POP      {R0,R4-R7,PC}
   2134                }
   2135                else if (strstr(Urc.Buff, "@SOCKOPEN:0,1") != NULL)  
   \                     ??Modem_URC_Parser_19: (+1)
   \   000001E4   0x.... 0x....      ADR.W    R1,?_102
   \   000001E8   0x1D30             ADDS     R0,R6,#+4
   \   000001EA   0x.... 0x....      BL       strstr
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD009             BEQ.N    ??Modem_URC_Parser_20
   2136                {
   2137                  TcpState = 2;
   \   000001F2   0x2002             MOVS     R0,#+2
   \   000001F4   0x7260             STRB     R0,[R4, #+9]
   2138                  memset(Urc.Buff,0, URC_BUFF_MAX);
   \   000001F6   0x2200             MOVS     R2,#+0
   \   000001F8   0x2164             MOVS     R1,#+100
   \   000001FA   0x1D30             ADDS     R0,R6,#+4
   \   000001FC   0x.... 0x....      BL       __aeabi_memset4
   2139                  Urc.Cnt = 0;
   \   00000200   0x2000             MOVS     R0,#+0
   \   00000202   0x66B0             STR      R0,[R6, #+104]
   2140                  return;
   \   00000204   0xBDF1             POP      {R0,R4-R7,PC}
   2141                }
   2142                else if (strstr(Urc.Buff, "@SOCKCLOSED:0,0") != NULL)  
   \                     ??Modem_URC_Parser_20: (+1)
   \   00000206   0x.... 0x....      ADR.W    R1,?_103
   \   0000020A   0x1D30             ADDS     R0,R6,#+4
   \   0000020C   0x.... 0x....      BL       strstr
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xD009             BEQ.N    ??Modem_URC_Parser_21
   2143                {
   2144                  TcpState = 3;
   \   00000214   0x2003             MOVS     R0,#+3
   \   00000216   0x7260             STRB     R0,[R4, #+9]
   2145                  memset(Urc.Buff,0, URC_BUFF_MAX);
   \   00000218   0x2200             MOVS     R2,#+0
   \   0000021A   0x2164             MOVS     R1,#+100
   \   0000021C   0x1D30             ADDS     R0,R6,#+4
   \   0000021E   0x.... 0x....      BL       __aeabi_memset4
   2146                  Urc.Cnt = 0;
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0x66B0             STR      R0,[R6, #+104]
   2147                  return;
   \   00000226   0xBDF1             POP      {R0,R4-R7,PC}
   2148                }
   2149                if (TellRespFlag == 0)   {
   \                     ??Modem_URC_Parser_21: (+1)
   \   00000228   0x7CE0             LDRB     R0,[R4, #+19]
   \   0000022A   0x0001             MOVS     R1,R0
   \   0000022C   0xD10C             BNE.N    ??Modem_URC_Parser_22
   2150                  if(strstr(Urc.Buff, "$$TELL: ") != NULL) {
   \   0000022E   0x.... 0x....      ADR.W    R1,?_104
   \   00000232   0x1D30             ADDS     R0,R6,#+4
   \   00000234   0x.... 0x....      BL       strstr
   \   00000238   0x2800             CMP      R0,#+0
   \   0000023A   0xD021             BEQ.N    ??Modem_URC_Parser_23
   2151                    TellRespFlag = 1;
   \   0000023C   0x2001             MOVS     R0,#+1
   \   0000023E   0x74E0             STRB     R0,[R4, #+19]
   2152                    TellRespNo = 0;
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0x6360             STR      R0,[R4, #+52]
   2153                    Urc.Cnt = 0;
   \   00000244   0x66B0             STR      R0,[R6, #+104]
   \   00000246   0xE01B             B.N      ??Modem_URC_Parser_23
   2154                  }
   2155                }    
   2156                else if(TellRespFlag) {
   2157                  if(TellRespFlag < 5) {
   \                     ??Modem_URC_Parser_22: (+1)
   \   00000248   0x2905             CMP      R1,#+5
   \   0000024A   0xDA17             BGE.N    ??Modem_URC_Parser_24
   2158                    if(r >= '0' && r <='9' && TellRespNo < 1000) {
   \   0000024C   0xF1A5 0x0230      SUB      R2,R5,#+48
   \   00000250   0x2A0A             CMP      R2,#+10
   \   00000252   0xD20C             BCS.N    ??Modem_URC_Parser_25
   \   00000254   0x6B62             LDR      R2,[R4, #+52]
   \   00000256   0xF5B2 0x7F7A      CMP      R2,#+1000
   \   0000025A   0xDA08             BGE.N    ??Modem_URC_Parser_25
   2159                      TellRespNo = TellRespNo*10 + (r-'0');
   \   0000025C   0xEB02 0x0182      ADD      R1,R2,R2, LSL #+2
   \   00000260   0xEB07 0x0141      ADD      R1,R7,R1, LSL #+1
   \   00000264   0x3930             SUBS     R1,R1,#+48
   \   00000266   0x6361             STR      R1,[R4, #+52]
   2160                      TellRespFlag++;
   \   00000268   0x1C40             ADDS     R0,R0,#+1
   \   0000026A   0x74E0             STRB     R0,[R4, #+19]
   \   0000026C   0xE008             B.N      ??Modem_URC_Parser_23
   2161                    }
   2162                    else if(r == ','  && TellRespFlag > 1) {
   \                     ??Modem_URC_Parser_25: (+1)
   \   0000026E   0x2F2C             CMP      R7,#+44
   \   00000270   0xD106             BNE.N    ??Modem_URC_Parser_23
   \   00000272   0x2902             CMP      R1,#+2
   \   00000274   0xDB04             BLT.N    ??Modem_URC_Parser_23
   2163                      TellRespDecode();
   \   00000276   0x.... 0x....      BL       TellRespDecode
   \   0000027A   0xE001             B.N      ??Modem_URC_Parser_23
   2164                    }
   2165                  }
   2166                  else  TellRespFlag = 0;
   \                     ??Modem_URC_Parser_24: (+1)
   \   0000027C   0x2000             MOVS     R0,#+0
   \   0000027E   0x74E0             STRB     R0,[R4, #+19]
   2167                }
   2168                if (NetRespFlag == 0)   {
   \                     ??Modem_URC_Parser_23: (+1)
   \   00000280   0x7D20             LDRB     R0,[R4, #+20]
   \   00000282   0x2800             CMP      R0,#+0
   \   00000284   0xD10C             BNE.N    ??Modem_URC_Parser_26
   2169                  if(strstr(Urc.Buff, "@NETSTI:") != NULL) {
   \   00000286   0x.... 0x....      ADR.W    R1,?_105
   \   0000028A   0x1D30             ADDS     R0,R6,#+4
   \   0000028C   0x.... 0x....      BL       strstr
   \   00000290   0x2800             CMP      R0,#+0
   \   00000292   0xD01B             BEQ.N    ??Modem_URC_Parser_8
   2170                    NetRespFlag = 1;
   \   00000294   0x2001             MOVS     R0,#+1
   \   00000296   0x7520             STRB     R0,[R4, #+20]
   2171                    NetRespNo = 0;
   \   00000298   0x2000             MOVS     R0,#+0
   \   0000029A   0x63A0             STR      R0,[R4, #+56]
   2172                    Urc.Cnt = 0;
   \   0000029C   0x66B0             STR      R0,[R6, #+104]
   \   0000029E   0xBDF1             POP      {R0,R4-R7,PC}
   2173                  }
   2174                }    
   2175                else if(NetRespFlag) {
   2176                  if(r >= '0' && r <='9') {
   \                     ??Modem_URC_Parser_26: (+1)
   \   000002A0   0xF1A5 0x0030      SUB      R0,R5,#+48
   \   000002A4   0x280A             CMP      R0,#+10
   \   000002A6   0xD20F             BCS.N    ??Modem_URC_Parser_27
   2177                    NetRespNo =  (r-'0');
   \   000002A8   0xF1B7 0x0030      SUBS     R0,R7,#+48
   \   000002AC   0x63A0             STR      R0,[R4, #+56]
   2178                    if(NetRespNo == 0 || NetRespNo == 1) PppState = 3;
   \   000002AE   0xD001             BEQ.N    ??Modem_URC_Parser_28
   \   000002B0   0x2801             CMP      R0,#+1
   \   000002B2   0xD101             BNE.N    ??Modem_URC_Parser_29
   \                     ??Modem_URC_Parser_28: (+1)
   \   000002B4   0x2103             MOVS     R1,#+3
   \   000002B6   0x75A1             STRB     R1,[R4, #+22]
   2179                    if(NetRespNo == 2) PppState = 0;
   \                     ??Modem_URC_Parser_29: (+1)
   \   000002B8   0x2802             CMP      R0,#+2
   \   000002BA   0xD101             BNE.N    ??Modem_URC_Parser_30
   \   000002BC   0x2100             MOVS     R1,#+0
   \   000002BE   0x75A1             STRB     R1,[R4, #+22]
   2180                    if(NetRespNo == 3) PppState = 1;
   \                     ??Modem_URC_Parser_30: (+1)
   \   000002C0   0x2803             CMP      R0,#+3
   \   000002C2   0xD101             BNE.N    ??Modem_URC_Parser_27
   \   000002C4   0x2001             MOVS     R0,#+1
   \   000002C6   0x75A0             STRB     R0,[R4, #+22]
   2181                  }
   2182                  NetRespFlag = 0;
   \                     ??Modem_URC_Parser_27: (+1)
   \   000002C8   0x2000             MOVS     R0,#+0
   \   000002CA   0x7520             STRB     R0,[R4, #+20]
   2183                }
   2184              }
   2185            }
   2186            
   2187            return;
   \                     ??Modem_URC_Parser_8: (+1)
   \   000002CC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2188          }
   2189          
   2190          /*
   2191          ********************************************************************************
   2192          * Description : Modem_parse_proc
   2193          * Arguments   : 
   2194          * Return      : none
   2195          * Note        : Modem Rx data Parser
   2196          ******************************************************************************** 
   2197          */

   \                                 In section .text, align 2, keep-with-next
   2198          void Modem_parse_proc(void)	
   2199          {
   \                     Modem_parse_proc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2200          	INT8U err;
   2201          	char data = 0;
   \   00000002   0xE001             B.N      ??Modem_parse_proc_0
   2202               
   2203          	while( 1 ) {
   2204          		data = ModemCommGetChar(&err);
   2205          		if ( err == COMM_NO_ERR ) {
   2206                Modem_URC_Parser(data);
   \                     ??Modem_parse_proc_1: (+1)
   \   00000004   0x.... 0x....      BL       Modem_URC_Parser
   2207              }
   \                     ??Modem_parse_proc_0: (+1)
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       ModemCommGetChar
   \   0000000E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD0F6             BEQ.N    ??Modem_parse_proc_1
   2208          		else break;
   2209          	}
   2210          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   2211          
   2212          /*
   2213          ********************************************************************************
   2214          * Description : Modem_StatusCheck
   2215          * Arguments   : none
   2216          * Return      : 
   2217          * Note        : rx modem data decode
   2218          ******************************************************************************** 
   2219          */

   \                                 In section .text, align 4, keep-with-next
   2220          void Modem_SocketConnect(char* svr_name, u16 port, u8 mode)
   2221          {
   \                     Modem_SocketConnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2222          //  if(socket == 0 && SocketConnectStep == SOCKET_CONNECT_START) {
   2223          //      SocketConnectStep = SOCKET_STATUS_CHECK;
   2224          //      SocketWaitCnt = 0;
   2225          //  }
   2226            
   2227            switch(SocketConnectStep) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable161_2
   \   00000006   0x7B23             LDRB     R3,[R4, #+12]
   \   00000008   0x2B0A             CMP      R3,#+10
   \   0000000A   0xF200 0x80E1      BHI.W    ??Modem_SocketConnect_1
   \   0000000E   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??Modem_SocketConnect_0:
   \   00000012   0x06 0x13          DC8      0x6,0x13,0x37,0x6E
   \              0x37 0x6E    
   \   00000016   0x90 0xB4          DC8      0x90,0xB4,0xD3,0xD6
   \              0xD3 0xD6    
   \   0000001A   0xD9 0xE1          DC8      0xD9,0xE1,0xDC,0x0
   \              0xDC 0x00    
   2228              case SOCKET_CONNECT_START:
   2229                SocketWaitCnt++;
   \                     ??Modem_SocketConnect_2: (+1)
   \   0000001E   0x6AE3             LDR      R3,[R4, #+44]
   \   00000020   0x1C58             ADDS     R0,R3,#+1
   \   00000022   0x62E0             STR      R0,[R4, #+44]
   2230                if(SocketWaitCnt >= 2000) {
   \   00000024   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000028   0xF0C0 0x80D4      BCC.W    ??Modem_SocketConnect_3
   2231                  SocketWaitCnt = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x62E0             STR      R0,[R4, #+44]
   2232                  SocketRetryCnt = 0;
   \   00000030   0x7360             STRB     R0,[R4, #+13]
   2233                  SocketConnectStep = SOCKET_CREG_CHECK;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7320             STRB     R0,[R4, #+12]
   \   00000036   0xBD10             POP      {R4,PC}
   2234                }
   2235                break;
   2236                
   2237              case SOCKET_CREG_CHECK:
   2238                if(SocketWaitCnt == 0) {
   \                     ??Modem_SocketConnect_4: (+1)
   \   00000038   0x6AE3             LDR      R3,[R4, #+44]
   \   0000003A   0x2B00             CMP      R3,#+0
   \   0000003C   0xD10C             BNE.N    ??Modem_SocketConnect_5
   2239                  if(Modem_CREG_Check()==1) {
   \   0000003E   0x.... 0x....      BL       Modem_CREG_Check
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD105             BNE.N    ??Modem_SocketConnect_6
   2240                    SocketRetryCnt = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x7360             STRB     R0,[R4, #+13]
   2241                    SocketWaitCnt = 0;
   \   0000004A   0x62E0             STR      R0,[R4, #+44]
   2242                    SocketConnectStep = SOCKET_CSQ_CHECK;
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x7320             STRB     R0,[R4, #+12]
   \   00000050   0xBD10             POP      {R4,PC}
   2243                  }
   2244                  else 
   2245                    SocketWaitCnt = 1;
   \                     ??Modem_SocketConnect_6: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x62E0             STR      R0,[R4, #+44]
   \   00000056   0xBD10             POP      {R4,PC}
   2246                }
   2247                else {
   2248                  SocketWaitCnt++;
   \                     ??Modem_SocketConnect_5: (+1)
   \   00000058   0x1C58             ADDS     R0,R3,#+1
   \   0000005A   0x62E0             STR      R0,[R4, #+44]
   2249                  if(SocketWaitCnt >= 1000) {
   \   0000005C   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000060   0xF0C0 0x80B8      BCC.W    ??Modem_SocketConnect_3
   2250                    SocketWaitCnt = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x62E0             STR      R0,[R4, #+44]
   2251                    SocketRetryCnt++;
   \   00000068   0x7B60             LDRB     R0,[R4, #+13]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x7360             STRB     R0,[R4, #+13]
   2252                    if(SocketRetryCnt > 2) {
   \   0000006E   0xB2C0             UXTB     R0,R0
   \   00000070   0x2803             CMP      R0,#+3
   \   00000072   0xF2C0 0x80AF      BLT.W    ??Modem_SocketConnect_3
   2253                      SocketRetryCnt = 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x7360             STRB     R0,[R4, #+13]
   2254                      SocketConnectStep = SOCKET_CREG_FAIL;
   \   0000007A   0x2006             MOVS     R0,#+6
   \   0000007C   0x7320             STRB     R0,[R4, #+12]
   \   0000007E   0xBD10             POP      {R4,PC}
   2255                    }
   2256                  }
   2257                }
   2258                break;
   2259              
   2260              case SOCKET_CSQ_CHECK:
   2261                if(SocketWaitCnt == 0) {
   \                     ??Modem_SocketConnect_7: (+1)
   \   00000080   0x6AE3             LDR      R3,[R4, #+44]
   \   00000082   0x2B00             CMP      R3,#+0
   \   00000084   0xD120             BNE.N    ??Modem_SocketConnect_8
   2262          //        if(Modem_CSQ_Check()==1) {
   2263                  if(Modem_State_Check()==1) {
   \   00000086   0x.... 0x....      BL       Modem_State_Check
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD119             BNE.N    ??Modem_SocketConnect_9
   2264                    SocketRetryCnt = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x7360             STRB     R0,[R4, #+13]
   2265                    SocketWaitCnt = 0;
   \   00000092   0x62E0             STR      R0,[R4, #+44]
   2266                    if(RSSI >= 5 && RSSI < 40)  {
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x1F40             SUBS     R0,R0,#+5
   \   0000009C   0x2823             CMP      R0,#+35
   \   0000009E   0xD20D             BCS.N    ??Modem_SocketConnect_10
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable161_1
   \   000000A4   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \   000000A8   0x0001             MOVS     R1,R0
   \   000000AA   0xD001             BEQ.N    ??Modem_SocketConnect_11
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD102             BNE.N    ??Modem_SocketConnect_12
   2267                      if(Setting.ExtModemModel == 0 || Setting.ExtModemModel == 1)
   2268                        SocketConnectStep = SOCKET_STATUS_CHECK; //SOCKET_OPEN;//SOCKET_STATUS_CHECK;
   \                     ??Modem_SocketConnect_11: (+1)
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0x7320             STRB     R0,[R4, #+12]
   \   000000B4   0xBD10             POP      {R4,PC}
   2269                      else
   2270                        SocketConnectStep = SOCKET_OPEN;//SOCKET_STATUS_CHECK;
   \                     ??Modem_SocketConnect_12: (+1)
   \   000000B6   0x2004             MOVS     R0,#+4
   \   000000B8   0x7320             STRB     R0,[R4, #+12]
   \   000000BA   0xBD10             POP      {R4,PC}
   2271                    }
   2272                    else 
   2273                      SocketConnectStep = SOCKET_CSQ_FAIL;
   \                     ??Modem_SocketConnect_10: (+1)
   \   000000BC   0x2007             MOVS     R0,#+7
   \   000000BE   0x7320             STRB     R0,[R4, #+12]
   \   000000C0   0xBD10             POP      {R4,PC}
   2274                  }
   2275                  else 
   2276                    SocketWaitCnt = 1;
   \                     ??Modem_SocketConnect_9: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x62E0             STR      R0,[R4, #+44]
   \   000000C6   0xBD10             POP      {R4,PC}
   2277                }
   2278                else {
   2279                  SocketWaitCnt++;
   \                     ??Modem_SocketConnect_8: (+1)
   \   000000C8   0x1C58             ADDS     R0,R3,#+1
   \   000000CA   0x62E0             STR      R0,[R4, #+44]
   2280                  if(SocketWaitCnt >= 1000) {
   \   000000CC   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000D0   0xF0C0 0x8080      BCC.W    ??Modem_SocketConnect_3
   2281                    SocketWaitCnt = 0;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x62E0             STR      R0,[R4, #+44]
   2282                    SocketRetryCnt++;
   \   000000D8   0x7B60             LDRB     R0,[R4, #+13]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x7360             STRB     R0,[R4, #+13]
   2283                    if(SocketRetryCnt > 0) {
   \   000000DE   0xB2C0             UXTB     R0,R0
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD077             BEQ.N    ??Modem_SocketConnect_3
   2284                      SocketRetryCnt = 0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x7360             STRB     R0,[R4, #+13]
   2285                      SocketConnectStep = SOCKET_CSQ_FAIL;
   \   000000E8   0x2007             MOVS     R0,#+7
   \   000000EA   0x7320             STRB     R0,[R4, #+12]
   \   000000EC   0xBD10             POP      {R4,PC}
   2286                    }
   2287                  }
   2288                }
   \                     ??Modem_SocketConnect_13: (+1)
   \   000000EE   0x7DA1             LDRB     R1,[R4, #+22]
   \   000000F0   0x6AE3             LDR      R3,[R4, #+44]
   \   000000F2   0x2B00             CMP      R3,#+0
   \   000000F4   0xD109             BNE.N    ??Modem_SocketConnect_14
   2289                break;
   2290                
   2291              case SOCKET_STATUS_CHECK:
   2292                if(SocketWaitCnt == 0) {
   2293                  if(PppState  != 1) {
   \   000000F6   0x2901             CMP      R1,#+1
   \   000000F8   0xD004             BEQ.N    ??Modem_SocketConnect_15
   2294                    Modem_PPPOpen();
   \   000000FA   0x.... 0x....      BL       Modem_PPPOpen
   2295                    SocketWaitCnt = 1;
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x62E0             STR      R0,[R4, #+44]
   \   00000102   0xBD10             POP      {R4,PC}
   2296                  }
   2297                  else {
   2298                    SocketConnectStep = SOCKET_OPEN;
   \                     ??Modem_SocketConnect_15: (+1)
   \   00000104   0x2004             MOVS     R0,#+4
   \   00000106   0x7320             STRB     R0,[R4, #+12]
   2299                    SocketWaitCnt = 0;
   \   00000108   0xBD10             POP      {R4,PC}
   2300                  }
   2301                }
   2302                else {
   2303                  SocketWaitCnt++;
   \                     ??Modem_SocketConnect_14: (+1)
   \   0000010A   0x1C58             ADDS     R0,R3,#+1
   \   0000010C   0x62E0             STR      R0,[R4, #+44]
   2304                  if(PppState == 1) {  
   \   0000010E   0x2901             CMP      R1,#+1
   \   00000110   0xD105             BNE.N    ??Modem_SocketConnect_16
   2305                    SocketWaitCnt = 0;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x62E0             STR      R0,[R4, #+44]
   2306                    SocketRetryCnt = 0;
   \   00000116   0x7360             STRB     R0,[R4, #+13]
   2307                    SocketConnectStep = SOCKET_OPEN;
   \   00000118   0x2004             MOVS     R0,#+4
   \   0000011A   0x7320             STRB     R0,[R4, #+12]
   \   0000011C   0xBD10             POP      {R4,PC}
   2308                  }
   2309                  else if(SocketWaitCnt >= 10000) {
   \                     ??Modem_SocketConnect_16: (+1)
   \   0000011E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD356             BCC.N    ??Modem_SocketConnect_3
   2310                    SocketWaitCnt = 0;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x62E0             STR      R0,[R4, #+44]
   2311                    SocketRetryCnt = 0;
   \   0000012A   0x7360             STRB     R0,[R4, #+13]
   2312                    SocketConnectStep = SOCKET_FAIL;
   \   0000012C   0x200A             MOVS     R0,#+10
   \   0000012E   0x7320             STRB     R0,[R4, #+12]
   \   00000130   0xBD10             POP      {R4,PC}
   2313                  }
   2314                }
   2315                break;
   2316                
   2317              case SOCKET_OPEN:
   2318                if(SocketWaitCnt == 0) {
   \                     ??Modem_SocketConnect_17: (+1)
   \   00000132   0x6AE3             LDR      R3,[R4, #+44]
   \   00000134   0x2B00             CMP      R3,#+0
   \   00000136   0xD10E             BNE.N    ??Modem_SocketConnect_18
   2319                  TcpState = 0;
   \   00000138   0x2300             MOVS     R3,#+0
   \   0000013A   0x7263             STRB     R3,[R4, #+9]
   2320                  if(Modem_SocketOpenSvrName(svr_name, port, mode)) {
   \   0000013C   0x.... 0x....      BL       Modem_SocketOpenSvrName
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD005             BEQ.N    ??Modem_SocketConnect_19
   2321                    SocketRetryCnt = 0;
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x7360             STRB     R0,[R4, #+13]
   2322                    SocketWaitCnt = 0;
   \   00000148   0x62E0             STR      R0,[R4, #+44]
   2323                    SocketConnectStep = SOCKET_OPEN_WAIT;//SOCKET_CONNECT;
   \   0000014A   0x2005             MOVS     R0,#+5
   \   0000014C   0x7320             STRB     R0,[R4, #+12]
   \   0000014E   0xBD10             POP      {R4,PC}
   2324                  }
   2325                  else 
   2326                    SocketWaitCnt = 1;
   \                     ??Modem_SocketConnect_19: (+1)
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0x62E0             STR      R0,[R4, #+44]
   \   00000154   0xBD10             POP      {R4,PC}
   2327                }
   2328                else {
   2329                  SocketWaitCnt++;
   \                     ??Modem_SocketConnect_18: (+1)
   \   00000156   0x1C58             ADDS     R0,R3,#+1
   \   00000158   0x62E0             STR      R0,[R4, #+44]
   2330                  if(SocketWaitCnt >= 1000) {
   \   0000015A   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000015E   0xD339             BCC.N    ??Modem_SocketConnect_3
   2331                    SocketWaitCnt = 0;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x62E0             STR      R0,[R4, #+44]
   2332                    SocketRetryCnt++;
   \   00000164   0x7B60             LDRB     R0,[R4, #+13]
   \   00000166   0x1C40             ADDS     R0,R0,#+1
   \   00000168   0x7360             STRB     R0,[R4, #+13]
   2333                    if(SocketRetryCnt > 0) {
   \   0000016A   0xB2C0             UXTB     R0,R0
   \   0000016C   0x2800             CMP      R0,#+0
   \   0000016E   0xD031             BEQ.N    ??Modem_SocketConnect_3
   2334                      SocketRetryCnt = 0;
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x7360             STRB     R0,[R4, #+13]
   2335                      SocketConnectStep = SOCKET_FAIL;
   \   00000174   0x200A             MOVS     R0,#+10
   \   00000176   0x7320             STRB     R0,[R4, #+12]
   \   00000178   0xBD10             POP      {R4,PC}
   2336                    }
   2337                  }
   2338                }
   2339                break;
   2340                
   2341              case SOCKET_OPEN_WAIT:
   2342                SocketWaitCnt++;
   \                     ??Modem_SocketConnect_20: (+1)
   \   0000017A   0x6AE3             LDR      R3,[R4, #+44]
   \   0000017C   0x1C58             ADDS     R0,R3,#+1
   \   0000017E   0x62E0             STR      R0,[R4, #+44]
   \   00000180   0x7A61             LDRB     R1,[R4, #+9]
   \   00000182   0x2901             CMP      R1,#+1
   \   00000184   0xD003             BEQ.N    ??Modem_SocketConnect_21
   \   00000186   0x2902             CMP      R1,#+2
   \   00000188   0xD001             BEQ.N    ??Modem_SocketConnect_21
   \   0000018A   0x2903             CMP      R1,#+3
   \   0000018C   0xD10A             BNE.N    ??Modem_SocketConnect_22
   2343                if(TcpState == 1 || TcpState == 2 || TcpState == 3) {
   2344                  SocketRetryCnt = 0;
   \                     ??Modem_SocketConnect_21: (+1)
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0x7360             STRB     R0,[R4, #+13]
   2345                  SocketWaitCnt = 0;
   \   00000192   0x62E0             STR      R0,[R4, #+44]
   2346                  if(TcpState == 1 )
   \   00000194   0x2901             CMP      R1,#+1
   \   00000196   0xD102             BNE.N    ??Modem_SocketConnect_23
   2347                    SocketConnectStep = SOCKET_CONNECT;
   \   00000198   0x2008             MOVS     R0,#+8
   \   0000019A   0x7320             STRB     R0,[R4, #+12]
   \   0000019C   0xBD10             POP      {R4,PC}
   2348                  else
   2349                    SocketConnectStep = SOCKET_FAIL;
   \                     ??Modem_SocketConnect_23: (+1)
   \   0000019E   0x200A             MOVS     R0,#+10
   \   000001A0   0x7320             STRB     R0,[R4, #+12]
   \   000001A2   0xBD10             POP      {R4,PC}
   2350                }
   2351                else if(SocketWaitCnt >= 30000) {
   \                     ??Modem_SocketConnect_22: (+1)
   \   000001A4   0xF247 0x5130      MOVW     R1,#+30000
   \   000001A8   0x4288             CMP      R0,R1
   \   000001AA   0xD313             BCC.N    ??Modem_SocketConnect_3
   2352                  SocketRetryCnt = 0;
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0x7360             STRB     R0,[R4, #+13]
   2353                  SocketWaitCnt = 0;
   \   000001B0   0x62E0             STR      R0,[R4, #+44]
   2354                  SocketConnectStep = SOCKET_FAIL;
   \   000001B2   0x200A             MOVS     R0,#+10
   \   000001B4   0x7320             STRB     R0,[R4, #+12]
   \   000001B6   0xBD10             POP      {R4,PC}
   2355                }
   2356                break;
   2357                
   2358              case SOCKET_CREG_FAIL:
   2359                COM_Command_Char = 'G';
   \                     ??Modem_SocketConnect_24: (+1)
   \   000001B8   0x2047             MOVS     R0,#+71
   \   000001BA   0x70E0             STRB     R0,[R4, #+3]
   2360                break;
   \   000001BC   0xBD10             POP      {R4,PC}
   2361          
   2362              case SOCKET_CSQ_FAIL:
   2363                COM_Command_Char = 'Q';
   \                     ??Modem_SocketConnect_25: (+1)
   \   000001BE   0x2051             MOVS     R0,#+81
   \   000001C0   0x70E0             STRB     R0,[R4, #+3]
   2364                break;
   \   000001C2   0xBD10             POP      {R4,PC}
   2365          
   2366              case SOCKET_CONNECT:      
   2367                COM_Command_Char = 'C';
   \                     ??Modem_SocketConnect_26: (+1)
   \   000001C4   0x2043             MOVS     R0,#+67
   \   000001C6   0x70E0             STRB     R0,[R4, #+3]
   2368                break;
   \   000001C8   0xBD10             POP      {R4,PC}
   2369          
   2370              case SOCKET_CLOSE:
   2371                break;
   2372                
   2373              case SOCKET_FAIL:      
   2374                COM_Command_Char = 'T';
   \                     ??Modem_SocketConnect_27: (+1)
   \   000001CA   0x2054             MOVS     R0,#+84
   \   000001CC   0x70E0             STRB     R0,[R4, #+3]
   2375                break;
   \   000001CE   0xBD10             POP      {R4,PC}
   2376          
   2377              default : 
   2378                SocketConnectStep = SOCKET_FAIL;
   \                     ??Modem_SocketConnect_1: (+1)
   \   000001D0   0x200A             MOVS     R0,#+10
   \   000001D2   0x7320             STRB     R0,[R4, #+12]
   2379                break;  
   2380            }                         
   2381          }
   \                     ??Modem_SocketConnect_3: (+1)
   \   000001D4   0xBD10             POP      {R4,PC}          ;; return
   2382          
   2383          /*
   2384          ********************************************************************************
   2385          * Description : Modem_ResetProcess
   2386          * Arguments   : none
   2387          * Return      : 
   2388          * Note        : rx modem data decode
   2389          ******************************************************************************** 
   2390          */
   2391          

   \                                 In section .text, align 2, keep-with-next
   2392          void Modem_ResetProcess(void)
   2393          {
   \                     Modem_ResetProcess: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2394            u8 resp = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable161_1
   \   00000008   0xF891 0x10B7      LDRB     R1,[R1, #+183]
   \   0000000C   0x000A             MOVS     R2,R1
   \   0000000E   0xD109             BNE.N    ??Modem_ResetProcess_0
   2395          
   2396            if(Setting.ExtModemModel == 0)   
   2397              resp = sendATcommand("AT$$MODE=3\r", "OK", "ERROR", 10000);
   \   00000010   0xF242 0x7310      MOVW     R3,#+10000
   \   00000014   0x.... 0x....      ADR.W    R2,?_9
   \   00000018   0x....             ADR.N    R1,??DataTable156  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000001A   0x.... 0x....      ADR.W    R0,?_106
   \   0000001E   0x.... 0x....      BL       sendATcommand
   \   00000022   0xE016             B.N      ??Modem_ResetProcess_1
   2398            else if(Setting.ExtModemModel == 1)   
   \                     ??Modem_ResetProcess_0: (+1)
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD109             BNE.N    ??Modem_ResetProcess_2
   2399              resp = sendATcommand("AT$$RESET\r", "OK", "ERROR", 1000);
   \   00000028   0xF44F 0x737A      MOV      R3,#+1000
   \   0000002C   0x.... 0x....      ADR.W    R2,?_9
   \   00000030   0x....             ADR.N    R1,??DataTable156  ;; 0x4F, 0x4B, 0x00, 0x00
   \   00000032   0x.... 0x....      ADR.W    R0,?_107
   \   00000036   0x.... 0x....      BL       sendATcommand
   \   0000003A   0xE00A             B.N      ??Modem_ResetProcess_1
   2400            else if(Setting.ExtModemModel == 2)   
   \                     ??Modem_ResetProcess_2: (+1)
   \   0000003C   0x2902             CMP      R1,#+2
   \   0000003E   0xD108             BNE.N    ??Modem_ResetProcess_1
   2401              resp = sendATcommand("AT@HWRESET\r", "OK", "ERROR", 1000);
   \   00000040   0xF44F 0x737A      MOV      R3,#+1000
   \   00000044   0x.... 0x....      ADR.W    R2,?_9
   \   00000048   0x....             ADR.N    R1,??DataTable156  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000004A   0x.... 0x....      ADR.W    R0,?_108
   \   0000004E   0x.... 0x....      BL       sendATcommand
   2402            if(resp == 1) {
   \                     ??Modem_ResetProcess_1: (+1)
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable161_2
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xD10C             BNE.N    ??Modem_ResetProcess_3
   2403              ModemPowerOnFlag = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x71C8             STRB     R0,[R1, #+7]
   2404              ModemInitCnt = 0;
   \   0000005E   0x7448             STRB     R0,[R1, #+17]
   2405              ModemWaitCnt = 0;
   \   00000060   0x6288             STR      R0,[R1, #+40]
   2406              Urc.Mode = URCMODE_IDLE;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable161_4
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x6742             STR      R2,[R0, #+116]
   2407              Urc.RespFlag = 0;
   \   0000006A   0x6702             STR      R2,[R0, #+112]
   2408              Urc.Cnt = 0;
   \   0000006C   0x6682             STR      R2,[R0, #+104]
   2409              ModemStep = MODEM_POWER_ON_IDLE;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x7288             STRB     R0,[R1, #+10]
   \   00000072   0xBD01             POP      {R0,PC}
   2410            }
   2411            else
   2412              ModemStep = MODEM_POWER_ON;
   \                     ??Modem_ResetProcess_3: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x7288             STRB     R0,[R1, #+10]
   2413          }
   \   00000078   0xBD01             POP      {R0,PC}          ;; return
   2414          
   2415          
   2416          /*******************************************************************************
   2417          * Function Name  : Modem_Parameter_Reset
   2418          * Description    : None
   2419          * Input          : None
   2420          * Output         : None
   2421          * Return         : None
   2422          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2423          void Modem_Parameter_Reset(void)
   2424          {
   \                     Modem_Parameter_Reset: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   2425            u8 ip[4];
   2426            u16 addr;
   2427          
   2428            Setting.ExtModemMode = EXT_MODEM_PROTOCOL_TYPE;  
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable161_1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF880 0x10B5      STRB     R1,[R0, #+181]
   2429            addr = DRV_SETTING_PARM + offsetof(st_Setting,ExtModemMode); 
   2430            FRAMMultiWrite((u8 *)&Setting.ExtModemMode, addr, sizeof(Setting.ExtModemMode));   
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF240 0x11B5      MOVW     R1,#+437
   \   00000012   0x30B5             ADDS     R0,R0,#+181
   \   00000014   0x.... 0x....      BL       FRAMMultiWrite
   2431          
   2432            ModemInfo.DataServerInterval = 60;
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable161_5
   \   0000001C   0xF44F 0x70AD      MOV      R0,#+346
   \   00000020   0x1835             ADDS     R5,R6,R0
   \   00000022   0x203C             MOVS     R0,#+60
   \   00000024   0x8028             STRH     R0,[R5, #+0]
   2433          
   2434            FRAMMultiWrite((u8 *)&ModemInfo.DataServerInterval, MODEM_INFO + (u8 *)&ModemInfo.DataServerInterval - (u8 *)&ModemInfo, sizeof(ModemInfo.DataServerInterval));          
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0xF240 0x215A      MOVW     R1,#+602
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       FRAMMultiWrite
   2435          
   2436            ModemInfo.DataInterval = 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF8A6 0x016D      STRH     R0,[R6, #+365]
   2437            FRAMMultiWrite((u8 *)&ModemInfo.DataInterval, MODEM_INFO + (u8 *)&ModemInfo.DataInterval - (u8 *)&ModemInfo, sizeof(ModemInfo.DataInterval));          
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0xF240 0x216D      MOVW     R1,#+621
   \   0000003E   0xF206 0x106D      ADDW     R0,R6,#+365
   \   00000042   0x.... 0x....      BL       FRAMMultiWrite
   2438          
   2439            ModemInfo.FactoryInit = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x7428             STRB     R0,[R5, #+16]
   2440            FRAMMultiWrite((u8 *)&ModemInfo.FactoryInit, MODEM_INFO + (u8 *)&ModemInfo.FactoryInit - (u8 *)&ModemInfo, sizeof(ModemInfo.FactoryInit));          
   \   0000004A   0x4602             MOV      R2,R0
   \   0000004C   0xF240 0x216A      MOVW     R1,#+618
   \   00000050   0xF44F 0x70B5      MOV      R0,#+362
   \   00000054   0x4430             ADD      R0,R6,R0
   \   00000056   0x.... 0x....      BL       FRAMMultiWrite
   2441           
   2442            memset(HostSvr.SvrName, 0, sizeof(HostSvr.SvrName));
   \   0000005A   0x.... 0x....      LDR.W    R4,??DataTable161_6
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x213C             MOVS     R1,#+60
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       __aeabi_memset4
   2443            sprintf(HostSvr.SvrName,"data.scr-monitor.com");
   \   00000068   0x.... 0x....      ADR.W    R1,?_109
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       sprintf
   2444            HostSvr.SvrPort = 3000;
   \   00000072   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000076   0x63E0             STR      R0,[R4, #+60]
   2445            FRAMMultiWrite((u8 *)&HostSvr, DATA_SERVER_INFO, sizeof(tsSvrInfo));
   \   00000078   0x2240             MOVS     R2,#+64
   \   0000007A   0xF44F 0x7128      MOV      R1,#+672
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       FRAMMultiWrite
   2446          
   2447            ip[0] = 15; ip[1] = 165; ip[2] = 61; ip[3] = 179;     // Loop server
   \   00000084   0x200F             MOVS     R0,#+15
   \   00000086   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000008A   0x4668             MOV      R0,SP
   \   0000008C   0x21A5             MOVS     R1,#+165
   \   0000008E   0x7041             STRB     R1,[R0, #+1]
   \   00000090   0x213D             MOVS     R1,#+61
   \   00000092   0x7081             STRB     R1,[R0, #+2]
   \   00000094   0x20B3             MOVS     R0,#+179
   \   00000096   0xF88D 0x0003      STRB     R0,[SP, #+3]
   2448            
   2449            memcpy(&ModemInfo.LpIP, ip, 4);
   \   0000009A   0xF44F 0x70B0      MOV      R0,#+352
   \   0000009E   0x4406             ADD      R6,R6,R0
   \   000000A0   0x2204             MOVS     R2,#+4
   \   000000A2   0x4669             MOV      R1,SP
   \   000000A4   0x4630             MOV      R0,R6
   \   000000A6   0x.... 0x....      BL       __aeabi_memcpy4
   2450            ModemInfo.LpPort = 7777;
   \   000000AA   0xF641 0x6761      MOVW     R7,#+7777
   \   000000AE   0x816F             STRH     R7,[R5, #+10]
   2451            FRAMMultiWrite((u8 *)&ModemInfo.LpIP, MODEM_INFO + (u8 *)&ModemInfo.LpIP - (u8 *)&ModemInfo, sizeof(ModemInfo.LpIP)+sizeof(ModemInfo.LpPort));
   \   000000B0   0x2206             MOVS     R2,#+6
   \   000000B2   0xF44F 0x7118      MOV      R1,#+608
   \   000000B6   0x4630             MOV      R0,R6
   \   000000B8   0x.... 0x....      BL       FRAMMultiWrite
   2452          
   2453            memset(FWDN_Svr.SvrName,0,60);
   \   000000BC   0x.... 0x....      LDR.W    R5,??DataTable161_7
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x213C             MOVS     R1,#+60
   \   000000C4   0x4628             MOV      R0,R5
   \   000000C6   0x.... 0x....      BL       __aeabi_memset4
   2454            sprintf(FWDN_Svr.SvrName, "lb.loop-ota.com");
   \   000000CA   0x.... 0x....      ADR.W    R1,?_110
   \   000000CE   0x4628             MOV      R0,R5
   \   000000D0   0x.... 0x....      BL       sprintf
   2455            FWDN_Svr.SvrPort = 7777;
   \   000000D4   0x63EF             STR      R7,[R5, #+60]
   2456          
   2457            FRAMMultiWrite((u8 *)&FWDN_Svr, OTA_FWDN_SVR, sizeof(tsSvrInfo));
   \   000000D6   0x2240             MOVS     R2,#+64
   \   000000D8   0xF44F 0x6160      MOV      R1,#+3584
   \   000000DC   0x4628             MOV      R0,R5
   \   000000DE   0x.... 0x....      BL       FRAMMultiWrite
   2458            
   2459          //  FRAMMultiRead((u8 *)&DataSaveAddr, DRV_SAVE_ADDR, sizeof(DataSaveAddr));
   2460            Loop_SendTimeCnt = 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x6460             STR      R0,[R4, #+68]
   2461            DataSaveAddr = 0;
   \   000000E6   0x.... 0x....      LDR.W    R5,??DataTable161_8
   \   000000EA   0x6028             STR      R0,[R5, #+0]
   2462            FRAMMultiWrite((u8 *)&DataSaveAddr, DRV_SAVE_ADDR, sizeof(DataSaveAddr));
   \   000000EC   0x2204             MOVS     R2,#+4
   \   000000EE   0xF44F 0x7100      MOV      R1,#+512
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x.... 0x....      BL       FRAMMultiWrite
   2463            DataSentAddr = DataSaveAddr;
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable161_9
   \   000000FC   0x6829             LDR      R1,[R5, #+0]
   \   000000FE   0x6001             STR      R1,[R0, #+0]
   2464            FRAMMultiWrite((u8 *)&DataSentAddr, DRV_SENT_ADDR, sizeof(DataSentAddr));
   \   00000100   0x2204             MOVS     R2,#+4
   \   00000102   0xF44F 0x7101      MOV      R1,#+516
   \   00000106   0x.... 0x....      BL       FRAMMultiWrite
   2465            
   2466            SendData_StartTime = 0;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x6420             STR      R0,[R4, #+64]
   2467            FRAMMultiWrite((u8*)&SendData_StartTime, LAST_SENT_DAY, sizeof(SendData_StartTime));
   \   0000010E   0x2204             MOVS     R2,#+4
   \   00000110   0xF44F 0x7103      MOV      R1,#+524
   \   00000114   0xF104 0x0040      ADD      R0,R4,#+64
   \   00000118   0x.... 0x....      BL       FRAMMultiWrite
   2468          
   2469          }
   \   0000011C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2470          
   2471          /*
   2472          ********************************************************************************
   2473          * Description : ModemInit
   2474          * Arguments   : none
   2475          * Return      : 
   2476          * Note        : 
   2477          ******************************************************************************** 
   2478          */

   \                                 In section .text, align 2, keep-with-next
   2479          void ModemInit(void)
   2480          {
   \                     ModemInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   2481            u8 ip[4];
   2482            
   2483            FRAMMultiRead((u8 *)&ModemInfo, MODEM_INFO, sizeof(tsModemInfo));
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable161_5
   \   00000008   0x2240             MOVS     R2,#+64
   \   0000000A   0xF44F 0x7110      MOV      R1,#+576
   \   0000000E   0xF44F 0x70A0      MOV      R0,#+320
   \   00000012   0x4420             ADD      R0,R4,R0
   \   00000014   0x.... 0x....      BL       FRAMMultiRead
   2484          
   2485            if(ModemInfo.DataServerInterval < 10 || ModemInfo.DataServerInterval > 3600) {
   \   00000018   0xF8B4 0x015A      LDRH     R0,[R4, #+346]
   \   0000001C   0xF1A0 0x010A      SUB      R1,R0,#+10
   \   00000020   0xF640 0x6207      MOVW     R2,#+3591
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD310             BCC.N    ??ModemInit_0
   2486              if(ModemInfo.DataServerInterval < 10 ) ModemInfo.DataServerInterval = 10;
   \   00000028   0x280A             CMP      R0,#+10
   \   0000002A   0xDA03             BGE.N    ??ModemInit_1
   \   0000002C   0x200A             MOVS     R0,#+10
   \   0000002E   0xF8A4 0x015A      STRH     R0,[R4, #+346]
   \   00000032   0xE002             B.N      ??ModemInit_2
   2487              else ModemInfo.DataServerInterval = 60;
   \                     ??ModemInit_1: (+1)
   \   00000034   0x203C             MOVS     R0,#+60
   \   00000036   0xF8A4 0x015A      STRH     R0,[R4, #+346]
   2488              FRAMMultiWrite((u8 *)&ModemInfo.DataServerInterval, MODEM_INFO + (u8 *)&ModemInfo.DataServerInterval - (u8 *)&ModemInfo, sizeof(ModemInfo.DataServerInterval));          
   \                     ??ModemInit_2: (+1)
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0xF240 0x215A      MOVW     R1,#+602
   \   00000040   0xF44F 0x70AD      MOV      R0,#+346
   \   00000044   0x4420             ADD      R0,R4,R0
   \   00000046   0x.... 0x....      BL       FRAMMultiWrite
   2489            }
   2490          
   2491            if(ModemInfo.DataInterval == 0 || ModemInfo.DataInterval > 60) {
   \                     ??ModemInit_0: (+1)
   \   0000004A   0xF8B4 0x016D      LDRH     R0,[R4, #+365]
   \   0000004E   0x0001             MOVS     R1,R0
   \   00000050   0xD001             BEQ.N    ??ModemInit_3
   \   00000052   0x283D             CMP      R0,#+61
   \   00000054   0xDB0F             BLT.N    ??ModemInit_4
   2492              if(ModemInfo.DataInterval == 0 ) ModemInfo.DataInterval = 1;
   \                     ??ModemInit_3: (+1)
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD103             BNE.N    ??ModemInit_5
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF8A4 0x016D      STRH     R0,[R4, #+365]
   \   00000060   0xE002             B.N      ??ModemInit_6
   2493              else ModemInfo.DataInterval = 60;
   \                     ??ModemInit_5: (+1)
   \   00000062   0x203C             MOVS     R0,#+60
   \   00000064   0xF8A4 0x016D      STRH     R0,[R4, #+365]
   2494              FRAMMultiWrite((u8 *)&ModemInfo.DataInterval, MODEM_INFO + (u8 *)&ModemInfo.DataInterval - (u8 *)&ModemInfo, sizeof(ModemInfo.DataInterval));          
   \                     ??ModemInit_6: (+1)
   \   00000068   0x2202             MOVS     R2,#+2
   \   0000006A   0xF240 0x216D      MOVW     R1,#+621
   \   0000006E   0xF204 0x106D      ADDW     R0,R4,#+365
   \   00000072   0x.... 0x....      BL       FRAMMultiWrite
   2495            }
   2496            
   2497            if(ModemInfo.LpIP == 0 || ModemInfo.LpIP == 0xffffffff) {
   \                     ??ModemInit_4: (+1)
   \   00000076   0xF44F 0x70B0      MOV      R0,#+352
   \   0000007A   0x4404             ADD      R4,R4,R0
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R5,??DataTable161_6
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD002             BEQ.N    ??ModemInit_7
   \   00000086   0xF110 0x0F01      CMN      R0,#+1
   \   0000008A   0xD135             BNE.N    ??ModemInit_8
   2498              ip[0] = 14; ip[1] = 63; ip[2] = 216; ip[3] = 18; 
   \                     ??ModemInit_7: (+1)
   \   0000008C   0x200E             MOVS     R0,#+14
   \   0000008E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000092   0xAE02             ADD      R6,SP,#+8
   \   00000094   0x203F             MOVS     R0,#+63
   \   00000096   0x7070             STRB     R0,[R6, #+1]
   \   00000098   0x20D8             MOVS     R0,#+216
   \   0000009A   0x70B0             STRB     R0,[R6, #+2]
   \   0000009C   0x2012             MOVS     R0,#+18
   \   0000009E   0x70F0             STRB     R0,[R6, #+3]
   2499              
   2500              memcpy(&ModemInfo.LpIP, ip, 4);
   \   000000A0   0x2204             MOVS     R2,#+4
   \   000000A2   0xA902             ADD      R1,SP,#+8
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       __aeabi_memcpy4
   2501              ModemInfo.LpPort = 7777;
   \   000000AA   0xF641 0x6061      MOVW     R0,#+7777
   \   000000AE   0x80A0             STRH     R0,[R4, #+4]
   2502              FRAMMultiWrite((u8 *)&ModemInfo.LpIP, MODEM_INFO + (u8 *)&ModemInfo.LpIP - (u8 *)&ModemInfo, sizeof(ModemInfo.LpIP)+sizeof(ModemInfo.LpPort));          
   \   000000B0   0x2206             MOVS     R2,#+6
   \   000000B2   0xF44F 0x7118      MOV      R1,#+608
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       FRAMMultiWrite
   2503              memset(HostSvr.SvrName, 0, sizeof(HostSvr.SvrName));
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x213C             MOVS     R1,#+60
   \   000000C0   0x4628             MOV      R0,R5
   \   000000C2   0x.... 0x....      BL       __aeabi_memset4
   2504              memcpy(ip, &ModemInfo.LpIP, 4);
   \   000000C6   0x2204             MOVS     R2,#+4
   \   000000C8   0x4621             MOV      R1,R4
   \   000000CA   0xA802             ADD      R0,SP,#+8
   \   000000CC   0x.... 0x....      BL       __aeabi_memcpy
   2505              sprintf(HostSvr.SvrName,"%u.%u.%u.%u", ip[0], ip[1], ip[2], ip[3]);
   \   000000D0   0x78F0             LDRB     R0,[R6, #+3]
   \   000000D2   0x9001             STR      R0,[SP, #+4]
   \   000000D4   0x78B0             LDRB     R0,[R6, #+2]
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x7873             LDRB     R3,[R6, #+1]
   \   000000DA   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   000000DE   0x.... 0x....      ADR.W    R1,?_111
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0x.... 0x....      BL       sprintf
   2506              HostSvr.SvrPort = ModemInfo.LpPort;
   \   000000E8   0x88A0             LDRH     R0,[R4, #+4]
   \   000000EA   0x63E8             STR      R0,[R5, #+60]
   2507              FRAMMultiWrite((u8 *)&HostSvr, DATA_SERVER_INFO, sizeof(tsSvrInfo));
   \   000000EC   0x2240             MOVS     R2,#+64
   \   000000EE   0xF44F 0x7128      MOV      R1,#+672
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x.... 0x....      BL       FRAMMultiWrite
   2508            }
   2509          
   2510            FRAMMultiRead((u8 *)&HostSvr, DATA_SERVER_INFO, sizeof(tsSvrInfo));
   \                     ??ModemInit_8: (+1)
   \   000000F8   0x2240             MOVS     R2,#+64
   \   000000FA   0xF44F 0x7128      MOV      R1,#+672
   \   000000FE   0x4628             MOV      R0,R5
   \   00000100   0x.... 0x....      BL       FRAMMultiRead
   2511            if(HostSvr.SvrName[0] <= ' ' || HostSvr.SvrName[0] > 'z' || HostSvr.SvrPort == 0 || HostSvr.SvrPort >= 100000) {
   \   00000104   0x7828             LDRB     R0,[R5, #+0]
   \   00000106   0x3821             SUBS     R0,R0,#+33
   \   00000108   0x285A             CMP      R0,#+90
   \   0000010A   0xD206             BCS.N    ??ModemInit_9
   \   0000010C   0x6BE8             LDR      R0,[R5, #+60]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD003             BEQ.N    ??ModemInit_9
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable161_10  ;; 0x186a0
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xD31E             BCC.N    ??ModemInit_10
   2512              memset(HostSvr.SvrName, 0, sizeof(HostSvr.SvrName));
   \                     ??ModemInit_9: (+1)
   \   0000011A   0x2200             MOVS     R2,#+0
   \   0000011C   0x213C             MOVS     R1,#+60
   \   0000011E   0x4628             MOV      R0,R5
   \   00000120   0x.... 0x....      BL       __aeabi_memset4
   2513              memcpy(ip, &ModemInfo.LpIP, 4);
   \   00000124   0x2204             MOVS     R2,#+4
   \   00000126   0x4621             MOV      R1,R4
   \   00000128   0xA802             ADD      R0,SP,#+8
   \   0000012A   0x.... 0x....      BL       __aeabi_memcpy
   2514              sprintf(HostSvr.SvrName,"%u.%u.%u.%u", ip[0], ip[1], ip[2], ip[3]);
   \   0000012E   0xAE02             ADD      R6,SP,#+8
   \   00000130   0x78F0             LDRB     R0,[R6, #+3]
   \   00000132   0x9001             STR      R0,[SP, #+4]
   \   00000134   0x78B0             LDRB     R0,[R6, #+2]
   \   00000136   0x9000             STR      R0,[SP, #+0]
   \   00000138   0x7873             LDRB     R3,[R6, #+1]
   \   0000013A   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000013E   0x.... 0x....      ADR.W    R1,?_111
   \   00000142   0x4628             MOV      R0,R5
   \   00000144   0x.... 0x....      BL       sprintf
   2515              HostSvr.SvrPort = ModemInfo.LpPort;
   \   00000148   0x88A0             LDRH     R0,[R4, #+4]
   \   0000014A   0x63E8             STR      R0,[R5, #+60]
   2516              FRAMMultiWrite((u8 *)&HostSvr, DATA_SERVER_INFO, sizeof(tsSvrInfo));
   \   0000014C   0x2240             MOVS     R2,#+64
   \   0000014E   0xF44F 0x7128      MOV      R1,#+672
   \   00000152   0x4628             MOV      R0,R5
   \   00000154   0x.... 0x....      BL       FRAMMultiWrite
   2517            }
   2518            
   2519            memset(HostSvr.SvrName, 0, sizeof(HostSvr.SvrName));
   \                     ??ModemInit_10: (+1)
   \   00000158   0x2200             MOVS     R2,#+0
   \   0000015A   0x213C             MOVS     R1,#+60
   \   0000015C   0x4628             MOV      R0,R5
   \   0000015E   0x.... 0x....      BL       __aeabi_memset4
   2520            sprintf(HostSvr.SvrName,"data.scr-monitor.com");
   \   00000162   0x.... 0x....      ADR.W    R1,?_109
   \   00000166   0x4628             MOV      R0,R5
   \   00000168   0x.... 0x....      BL       sprintf
   2521            HostSvr.SvrPort = 3000;
   \   0000016C   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000170   0x63E8             STR      R0,[R5, #+60]
   2522          
   2523            ip[0] = 15; ip[1] = 165; ip[2] = 61; ip[3] = 179;     // Loop server
   2524            
   2525            FRAMMultiRead((u8 *)&FWDN_Svr, OTA_FWDN_SVR, sizeof(tsSvrInfo));
   \   00000172   0x....             LDR.N    R4,??DataTable161_7
   \   00000174   0x2240             MOVS     R2,#+64
   \   00000176   0xF44F 0x6160      MOV      R1,#+3584
   \   0000017A   0x4620             MOV      R0,R4
   \   0000017C   0x.... 0x....      BL       FRAMMultiRead
   2526            if(FWDN_Svr.SvrName[0] <= ' ' || FWDN_Svr.SvrName[0] > 'z' || FWDN_Svr.SvrPort == 0 || FWDN_Svr.SvrPort >= 100000) {
   \   00000180   0x7820             LDRB     R0,[R4, #+0]
   \   00000182   0x3821             SUBS     R0,R0,#+33
   \   00000184   0x285A             CMP      R0,#+90
   \   00000186   0xD205             BCS.N    ??ModemInit_11
   \   00000188   0x6BE0             LDR      R0,[R4, #+60]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD002             BEQ.N    ??ModemInit_11
   \   0000018E   0x....             LDR.N    R1,??DataTable161_10  ;; 0x186a0
   \   00000190   0x4288             CMP      R0,R1
   \   00000192   0xD312             BCC.N    ??ModemInit_12
   2527              memset(FWDN_Svr.SvrName,0,60);
   \                     ??ModemInit_11: (+1)
   \   00000194   0x2200             MOVS     R2,#+0
   \   00000196   0x213C             MOVS     R1,#+60
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       __aeabi_memset4
   2528              sprintf(FWDN_Svr.SvrName, "lb.loop-ota.com");
   \   0000019E   0x.... 0x....      ADR.W    R1,?_110
   \   000001A2   0x4620             MOV      R0,R4
   \   000001A4   0x.... 0x....      BL       sprintf
   2529              FWDN_Svr.SvrPort = 7777;
   \   000001A8   0xF641 0x6061      MOVW     R0,#+7777
   \   000001AC   0x63E0             STR      R0,[R4, #+60]
   2530              FRAMMultiWrite((u8 *)&FWDN_Svr, OTA_FWDN_SVR, sizeof(tsSvrInfo));
   \   000001AE   0x2240             MOVS     R2,#+64
   \   000001B0   0xF44F 0x6160      MOV      R1,#+3584
   \   000001B4   0x4620             MOV      R0,R4
   \   000001B6   0x.... 0x....      BL       FRAMMultiWrite
   2531            }
   2532          
   2533            FRAMMultiRead((u8 *)&APN_Name, APN_NAME_INFO, sizeof(APN_Name));
   \                     ??ModemInit_12: (+1)
   \   000001BA   0x....             LDR.N    R4,??DataTable161_2
   \   000001BC   0x2220             MOVS     R2,#+32
   \   000001BE   0xF44F 0x7120      MOV      R1,#+640
   \   000001C2   0xF104 0x003C      ADD      R0,R4,#+60
   \   000001C6   0x.... 0x....      BL       FRAMMultiRead
   2534            sprintf(Fota_FW_Ver,"%1u.%1u.%1u.%1u", MAJOR, MINOR, RELEASE, BUILD);
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x9001             STR      R0,[SP, #+4]
   \   000001CE   0x9000             STR      R0,[SP, #+0]
   \   000001D0   0x4603             MOV      R3,R0
   \   000001D2   0x2202             MOVS     R2,#+2
   \   000001D4   0x.... 0x....      ADR.W    R1,?_112
   \   000001D8   0x....             LDR.N    R0,??DataTable161_11
   \   000001DA   0x.... 0x....      BL       sprintf
   2535            
   2536            Modem_Init_Loop();
   \   000001DE   0x.... 0x....      BL       Modem_Init_Loop
   2537          
   2538            ModemCommInit();
   \   000001E2   0x.... 0x....      BL       ModemCommInit
   2539            
   2540            ModemStep = MODEM_POWER_ON;
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0x72A0             STRB     R0,[R4, #+10]
   2541          
   2542            DataAddrToSend = DataSentAddr;  
   \   000001EA   0x....             LDR.N    R0,??DataTable161_9
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \   000001EE   0x6260             STR      R0,[R4, #+36]
   2543            
   2544          #ifdef LOOP_OTA_SERVER_ENABLE  
   2545            LoopFotaFlag = 1;
   \   000001F0   0x2001             MOVS     R0,#+1
   \   000001F2   0x73E0             STRB     R0,[R4, #+15]
   2546          #endif  
   2547          }
   \   000001F4   0xBD7F             POP      {R0-R6,PC}       ;; return
   2548          
   2549          /*
   2550          ********************************************************************************
   2551          * Description : CheckAPNChange
   2552          * Arguments   : none
   2553          * Return      : 
   2554          * Note        : 
   2555          ******************************************************************************** 
   2556          */

   \                                 In section .text, align 2, keep-with-next
   2557          void CheckAPNChange(void)
   2558          {
   \                     CheckAPNChange: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2559            if(MtReadAPNFlag) {
   \   00000002   0x....             LDR.N    R4,??DataTable161_2
   \   00000004   0x7860             LDRB     R0,[R4, #+1]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??CheckAPNChange_0
   2560              APNProcess(0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       APNProcess
   2561              MtReadAPNFlag = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7060             STRB     R0,[R4, #+1]
   \   00000014   0xBD10             POP      {R4,PC}
   2562            }
   2563            else if(MtChangeAPNFlag) {
   \                     ??CheckAPNChange_0: (+1)
   \   00000016   0x78A0             LDRB     R0,[R4, #+2]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??CheckAPNChange_1
   2564              APNProcess(1);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       APNProcess
   2565              MtChangeAPNFlag = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x70A0             STRB     R0,[R4, #+2]
   2566            }
   2567          }
   \                     ??CheckAPNChange_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   2568          
   2569          /*
   2570          ********************************************************************************
   2571          * Description : Modem_KeyOffProcess
   2572          * Arguments   : none
   2573          * Return      : 
   2574          * Note        : 
   2575          ******************************************************************************** 
   2576          */

   \                                 In section .text, align 2, keep-with-next
   2577          void  Modem_KeyOffProcess(void)
   2578          {
   2579            if(Setting.ExtModemMode == LOOP_PROTOCOL)  {
   \                     Modem_KeyOffProcess: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable161_1
   \   00000002   0xF890 0x00B5      LDRB     R0,[R0, #+181]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD105             BNE.N    ??Modem_KeyOffProcess_0
   2580              DataServerFlag = 2;
   \   0000000A   0x....             LDR.N    R0,??DataTable161_2
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x7101             STRB     R1,[R0, #+4]
   2581              DataAddrToSend = DataSaveAddr;
   \   00000010   0x....             LDR.N    R1,??DataTable161_8
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6241             STR      R1,[R0, #+36]
   2582            }
   2583          }
   \                     ??Modem_KeyOffProcess_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
   2584          
   2585          /*
   2586          ********************************************************************************
   2587          * Description : Modem_SecIntProcess
   2588          * Arguments   : none
   2589          * Return      : 
   2590          * Note        : 
   2591          ******************************************************************************** 
   2592          */

   \                                 In section .text, align 2, keep-with-next
   2593          void Modem_SecIntProcess(void)
   2594          {
   2595            if(Start_Flag && Flags.SecIntFlag) {
   \                     Modem_SecIntProcess: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable161_12
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00A             BEQ.N    ??Modem_SecIntProcess_0
   \   00000008   0x....             LDR.N    R0,??DataTable161_13
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x0BC0             LSRS     R0,R0,#+15
   \   0000000E   0xD006             BEQ.N    ??Modem_SecIntProcess_0
   2596              if(Setting.ExtModemMode == LOOP_PROTOCOL)  
   \   00000010   0x....             LDR.N    R0,??DataTable161_1
   \   00000012   0xF890 0x00B5      LDRB     R0,[R0, #+181]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??Modem_SecIntProcess_0
   2597                Modem_SecInt_Loop();
   \   0000001A   0x.... 0x....      B.W      Modem_SecInt_Loop
   2598            }
   2599          }
   \                     ??Modem_SecIntProcess_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   2600          
   2601          /*
   2602          ********************************************************************************
   2603          * Description : Task_MOD
   2604          * Arguments   : none
   2605          * Return      : 
   2606          * Note        : task for modem
   2607          ******************************************************************************** 
   2608          */
   2609          //unsigned char sbuf[640];

   \                                 In section .text, align 4, keep-with-next
   2610          void Task_MOD(void *p_arg)
   2611          {
   \                     Task_MOD: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2612            sysinfo_t *s = (sysinfo_t *)p_arg;
   2613            
   2614          	BSP_UART2RX_IntEnable(ENABLE);
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       BSP_UART2RX_IntEnable
   2615            Flags.SecIntFlag = 1;
   \   0000000A   0x....             LDR.N    R0,??DataTable161_13
   \   0000000C   0x8801             LDRH     R1,[R0, #+0]
   \   0000000E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000012   0x8001             STRH     R1,[R0, #+0]
   \   00000014   0x....             LDR.N    R5,??DataTable161_2
   \   00000016   0xE008             B.N      ??Task_MOD_1
   2616            for(;;)	{
   2617              s->twatchModFlag = 1;
   2618          //    Modem_parse_proc();
   2619              if(Start_Flag) {
   2620                Modem_parse_proc();         
   2621                
   2622                switch(ModemStep) {
   2623                  case MODEM_POWER_ON:
   2624                    ModemPowerOnFlag = 0;
   2625                    ModemInitCnt = 0;
   2626                    Urc.Mode = URCMODE_IDLE;
   2627                    Urc.RespFlag = 0;
   2628                    Urc.Cnt = 0;
   2629                    Modem_FotaFlag = 0;
   2630                    Modem_PowerOn();
   2631                    ModemStep = MODEM_POWER_ON_IDLE;
   2632                    ModemWaitCnt = 0;
   2633                    break;
   2634                    
   2635                  case MODEM_POWER_ON_IDLE:
   2636                    ModemWaitCnt++;
   2637                    if(ModemWaitCnt < 300000) {  
   2638                      if(ModemWaitCnt > 30000) {
   2639                        if(ModemPowerOnFlag) {
   2640                          ModemWaitCnt = 0;
   2641                          ModemInitCnt = 0;
   2642                          ModemStep = MODEM_INITIALIZE;
   2643                        }
   2644                        else if((ModemWaitCnt %10000) == 0){
   2645                          if(Modem_PowerOnCheck())
   2646                            ModemPowerOnFlag = 1;
   2647                        }
   2648                      }
   2649                      if((ModemWaitCnt%10000) == 0)  //1sec
   2650                        printk("\r\nMODEM : Power idle %u\r\n",ModemWaitCnt/1000);
   2651                    }
   2652                    break;
   2653                    
   2654                  case MODEM_INITIALIZE:
   2655                    if(ModemWaitCnt == 0) {
   2656                      if(Modem_Initialize()==1) {
   2657                        ModemWaitCnt = 0;
   2658                        ModemInitCnt = 0;
   2659                        ModemReadyFlag = 1;
   2660                        ModemStep = MODEM_DATA_IDLE;
   2661                      }
   2662                      else {
   2663                        ModemWaitCnt = 1;
   2664                      }
   2665                    }
   2666                    else {
   2667                      ModemWaitCnt++;
   2668                      if(ModemInitCnt < 2 && ModemWaitCnt > 10000) {           // 10초 후  추가 2회시도...
   2669                        ModemWaitCnt = 0;
   2670                        ModemInitCnt++;
   2671                      }
   2672                    }
   2673                    break;
   2674                    
   2675                  case MODEM_DATA_IDLE:
   2676                    SocketConnectStep = SOCKET_CONNECT_START; 
   2677                    CheckAPNChange();
   2678                    
   2679                    if(!ModemServiceFault) {
   2680                      if(LoopFotaFlag) {
   2681                        LoopFotaStep = LOOP_FOTA_CONNECT;
   2682                        ModemStep = MODEM_LOOP_FOTA;
   2683                      }
   2684                      else {
   2685                        if(Setting.ExtModemMode == LOOP_PROTOCOL) 
   2686                          Modem_DataIdleProcess_Loop();          
   2687                      }
   2688                    }
   2689                    
   2690                    if(ModemStep == MODEM_DATA_IDLE) {
   2691                      ModemWaitCnt++;
   2692                      if((ModemWaitCnt % 10000) == 0) { //10sec
   2693                        printk("\r\nMODEM : Data idle %u\n",ModemWaitCnt/1000);
   2694                        Modem_CSQ_Check();
   2695                      }
   2696                    }
   2697                    else ModemWaitCnt = 0;
   2698                    break;
   2699                    
   2700                  case MODEM_DATA_SERVER:
   2701                    if(Setting.ExtModemMode == LOOP_PROTOCOL)
   2702                      Modem_DataSvrProcess_Loop();
   2703                    else {
   2704                      ModemStep = MODEM_DATA_IDLE;
   2705                      DataServerFlag = 0;
   2706                    }
   2707                    break;
   2708                    
   2709                  case MODEM_LOOP_FOTA:
   2710                    Modem_LoopFotaProcess();
   2711                    break;
   2712                    
   2713                  case MODEM_POWER_OFF:
   2714                    if(!ReadValue.Sig.KeyOn) {
   2715                      Modem_PowerOff();
   2716                      ModemWaitCnt = 0;
   2717                      ModemOffFlag = 1;
   2718                    }
   2719                    ModemStep = MODEM_POWER_OFF_IDLE;
   2720                    break;
   2721          
   2722                  case MODEM_POWER_OFF_IDLE:
   2723                    if(ReadValue.Sig.KeyOn) {
   2724                      ModemStep = MODEM_POWER_ON;
   2725                    }
   2726                    break;
   2727                    
   2728                  case MODEM_RESET_REQ:
   2729                    Modem_ResetProcess();
   2730                    break;
   2731          
   2732                  case MODEM_IDLE:
   2733                    ModemWaitCnt++;
   2734                    if(ModemWaitCnt > 30000) {  //30sec
   2735                      ModemWaitCnt = 0;
   2736                      ModemStep = MODEM_DATA_IDLE;    
   2737                    }
   2738                    break;
   2739                    
   2740                  case MODEM_FOTA_IDLE:
   2741                    ModemWaitCnt++;
   2742                    if(ModemWaitCnt > 180000) {  //180sec
   2743                      ModemWaitCnt = 0;
   2744                      Modem_FotaFlag = 0;
   2745                      Modem_ResetProcess();
   2746                    }
   2747                    else if(Modem_FotaFlag == 0) 
   2748                      Modem_FotaFlag = 1;
   2749                    break;
   2750                    
   2751                  default : //loop n~ err? = led red?
   2752                    ModemWaitCnt = 0;
   \                     ??Task_MOD_2: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x62A8             STR      R0,[R5, #+40]
   2753                    ModemStep = MODEM_POWER_ON_IDLE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x72A8             STRB     R0,[R5, #+10]
   2754                    break;
   2755                    
   2756                }    
   2757              }
   2758              s->twatchModFlag = 0;
   \                     ??Task_MOD_3: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x73E0             STRB     R0,[R4, #+15]
   2759              vTaskDelay(1);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       vTaskDelay
   \                     ??Task_MOD_1: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x73E0             STRB     R0,[R4, #+15]
   \   0000002E   0x....             LDR.N    R0,??DataTable161_12
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F4             BEQ.N    ??Task_MOD_3
   \   00000036   0x.... 0x....      BL       Modem_parse_proc
   \   0000003A   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000003C   0x2816             CMP      R0,#+22
   \   0000003E   0xD8EB             BHI.N    ??Task_MOD_2
   \   00000040   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??Task_MOD_0:
   \   00000044   0x0D 0x1E          DC8      0xD,0x1E,0x55,0x77
   \              0x55 0x77    
   \   00000048   0x0C 0x0C          DC8      0xC,0xC,0xC,0xC
   \              0x0C 0x0C    
   \   0000004C   0xAC 0x0C          DC8      0xAC,0xC,0xC,0xC
   \              0x0C 0x0C    
   \   00000050   0x0C 0xB9          DC8      0xC,0xB9,0xC,0xC
   \              0x0C 0x0C    
   \   00000054   0x0C 0x0C          DC8      0xC,0xC,0xBC,0xCC
   \              0xBC 0xCC    
   \   00000058   0xD7 0xDA          DC8      0xD7,0xDA,0xE7,0x0
   \              0xE7 0x00    
   \                     ??Task_MOD_4: (+1)
   \   0000005C   0xE7DC             B.N      ??Task_MOD_2
   \                     ??Task_MOD_5: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x71E8             STRB     R0,[R5, #+7]
   \   00000062   0x7468             STRB     R0,[R5, #+17]
   \   00000064   0x....             LDR.N    R0,??DataTable161_4
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x6741             STR      R1,[R0, #+116]
   \   0000006A   0x6701             STR      R1,[R0, #+112]
   \   0000006C   0x6681             STR      R1,[R0, #+104]
   \   0000006E   0x4608             MOV      R0,R1
   \   00000070   0x74A8             STRB     R0,[R5, #+18]
   \   00000072   0x.... 0x....      BL       Modem_PowerOn
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x72A8             STRB     R0,[R5, #+10]
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x62A8             STR      R0,[R5, #+40]
   \   0000007E   0xE7CF             B.N      ??Task_MOD_3
   \                     ??Task_MOD_6: (+1)
   \   00000080   0x6AA8             LDR      R0,[R5, #+40]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x62A8             STR      R0,[R5, #+40]
   \   00000086   0x....             LDR.N    R1,??DataTable161_14  ;; 0x493e0
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xD2C9             BCS.N    ??Task_MOD_3
   \   0000008C   0xF247 0x5131      MOVW     R1,#+30001
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD318             BCC.N    ??Task_MOD_7
   \   00000094   0x79E9             LDRB     R1,[R5, #+7]
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD005             BEQ.N    ??Task_MOD_8
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x62A8             STR      R0,[R5, #+40]
   \   0000009E   0x7468             STRB     R0,[R5, #+17]
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x72A8             STRB     R0,[R5, #+10]
   \   000000A4   0xE00F             B.N      ??Task_MOD_7
   \                     ??Task_MOD_8: (+1)
   \   000000A6   0xF242 0x7110      MOVW     R1,#+10000
   \   000000AA   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000AE   0xF242 0x7210      MOVW     R2,#+10000
   \   000000B2   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD105             BNE.N    ??Task_MOD_7
   \   000000BA   0x.... 0x....      BL       Modem_PowerOnCheck
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD001             BEQ.N    ??Task_MOD_7
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x71E8             STRB     R0,[R5, #+7]
   \                     ??Task_MOD_7: (+1)
   \   000000C6   0x6AA8             LDR      R0,[R5, #+40]
   \   000000C8   0xF242 0x7110      MOVW     R1,#+10000
   \   000000CC   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000D0   0xF242 0x7210      MOVW     R2,#+10000
   \   000000D4   0xFB02 0x0111      MLS      R1,R2,R1,R0
   \   000000D8   0x2900             CMP      R1,#+0
   \   000000DA   0xD1A1             BNE.N    ??Task_MOD_3
   \   000000DC   0xF44F 0x717A      MOV      R1,#+1000
   \   000000E0   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000E4   0x.... 0x....      ADR.W    R0,?_113
   \   000000E8   0x.... 0x....      BL       printk
   \   000000EC   0xE798             B.N      ??Task_MOD_3
   \                     ??Task_MOD_9: (+1)
   \   000000EE   0x6AA8             LDR      R0,[R5, #+40]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD10E             BNE.N    ??Task_MOD_10
   \   000000F4   0x.... 0x....      BL       Modem_Initialize
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD107             BNE.N    ??Task_MOD_11
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x62A8             STR      R0,[R5, #+40]
   \   00000100   0x7468             STRB     R0,[R5, #+17]
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x71A8             STRB     R0,[R5, #+6]
   \   00000106   0x2003             MOVS     R0,#+3
   \   00000108   0x72A8             STRB     R0,[R5, #+10]
   \   0000010A   0xE789             B.N      ??Task_MOD_3
   \                     ??Task_MOD_11: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x62A8             STR      R0,[R5, #+40]
   \   00000110   0xE786             B.N      ??Task_MOD_3
   \                     ??Task_MOD_10: (+1)
   \   00000112   0x1C40             ADDS     R0,R0,#+1
   \   00000114   0x62A8             STR      R0,[R5, #+40]
   \   00000116   0x7C69             LDRB     R1,[R5, #+17]
   \   00000118   0x2902             CMP      R1,#+2
   \   0000011A   0xF6BF 0xAF81      BGE.W    ??Task_MOD_3
   \   0000011E   0xF242 0x7211      MOVW     R2,#+10001
   \   00000122   0x4290             CMP      R0,R2
   \   00000124   0xF4FF 0xAF7C      BCC.W    ??Task_MOD_3
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x62A8             STR      R0,[R5, #+40]
   \   0000012C   0x1C48             ADDS     R0,R1,#+1
   \   0000012E   0x7468             STRB     R0,[R5, #+17]
   \   00000130   0xE776             B.N      ??Task_MOD_3
   \                     ??Task_MOD_12: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x7328             STRB     R0,[R5, #+12]
   \   00000136   0x.... 0x....      BL       CheckAPNChange
   \   0000013A   0x7EA8             LDRB     R0,[R5, #+26]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD10E             BNE.N    ??Task_MOD_13
   \   00000140   0x7BE8             LDRB     R0,[R5, #+15]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD004             BEQ.N    ??Task_MOD_14
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x7428             STRB     R0,[R5, #+16]
   \   0000014A   0x200D             MOVS     R0,#+13
   \   0000014C   0x72A8             STRB     R0,[R5, #+10]
   \   0000014E   0xE006             B.N      ??Task_MOD_13
   \                     ??Task_MOD_14: (+1)
   \   00000150   0x....             LDR.N    R0,??DataTable161_1
   \   00000152   0xF890 0x00B5      LDRB     R0,[R0, #+181]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD101             BNE.N    ??Task_MOD_13
   \   0000015A   0x.... 0x....      BL       Modem_DataIdleProcess_Loop
   \                     ??Task_MOD_13: (+1)
   \   0000015E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000160   0x2803             CMP      R0,#+3
   \   00000162   0xD118             BNE.N    ??Task_MOD_15
   \   00000164   0x6AA8             LDR      R0,[R5, #+40]
   \   00000166   0x1C40             ADDS     R0,R0,#+1
   \   00000168   0x62A8             STR      R0,[R5, #+40]
   \   0000016A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000016E   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000172   0xF242 0x7210      MOVW     R2,#+10000
   \   00000176   0xFB02 0x0111      MLS      R1,R2,R1,R0
   \   0000017A   0x2900             CMP      R1,#+0
   \   0000017C   0xF47F 0xAF50      BNE.W    ??Task_MOD_3
   \   00000180   0xF44F 0x717A      MOV      R1,#+1000
   \   00000184   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000188   0x.... 0x....      ADR.W    R0,?_114
   \   0000018C   0x.... 0x....      BL       printk
   \   00000190   0x.... 0x....      BL       Modem_CSQ_Check
   \   00000194   0xE744             B.N      ??Task_MOD_3
   \                     ??Task_MOD_15: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x62A8             STR      R0,[R5, #+40]
   \   0000019A   0xE741             B.N      ??Task_MOD_3
   \                     ??Task_MOD_16: (+1)
   \   0000019C   0x....             LDR.N    R0,??DataTable161_1
   \   0000019E   0xF890 0x00B5      LDRB     R0,[R0, #+181]
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD102             BNE.N    ??Task_MOD_17
   \   000001A6   0x.... 0x....      BL       Modem_DataSvrProcess_Loop
   \   000001AA   0xE739             B.N      ??Task_MOD_3
   \                     ??Task_MOD_17: (+1)
   \   000001AC   0x2003             MOVS     R0,#+3
   \   000001AE   0x72A8             STRB     R0,[R5, #+10]
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x7128             STRB     R0,[R5, #+4]
   \   000001B4   0xE734             B.N      ??Task_MOD_3
   \                     ??Task_MOD_18: (+1)
   \   000001B6   0x.... 0x....      BL       Modem_LoopFotaProcess
   \   000001BA   0xE731             B.N      ??Task_MOD_3
   \                     ??Task_MOD_19: (+1)
   \   000001BC   0x....             LDR.N    R0,??DataTable161_15
   \   000001BE   0xF8B0 0x005A      LDRH     R0,[R0, #+90]
   \   000001C2   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   000001C6   0x2800             CMP      R0,#+0
   \   000001C8   0xD105             BNE.N    ??Task_MOD_20
   \   000001CA   0x.... 0x....      BL       Modem_PowerOff
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0x62A8             STR      R0,[R5, #+40]
   \   000001D2   0x2001             MOVS     R0,#+1
   \   000001D4   0x7168             STRB     R0,[R5, #+5]
   \                     ??Task_MOD_20: (+1)
   \   000001D6   0x2013             MOVS     R0,#+19
   \   000001D8   0x72A8             STRB     R0,[R5, #+10]
   \   000001DA   0xE721             B.N      ??Task_MOD_3
   \                     ??Task_MOD_21: (+1)
   \   000001DC   0x....             LDR.N    R0,??DataTable161_15
   \   000001DE   0xF8B0 0x005A      LDRH     R0,[R0, #+90]
   \   000001E2   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xF43F 0xAF1A      BEQ.W    ??Task_MOD_3
   \   000001EC   0x2000             MOVS     R0,#+0
   \   000001EE   0x72A8             STRB     R0,[R5, #+10]
   \   000001F0   0xE716             B.N      ??Task_MOD_3
   \                     ??Task_MOD_22: (+1)
   \   000001F2   0x.... 0x....      BL       Modem_ResetProcess
   \   000001F6   0xE713             B.N      ??Task_MOD_3
   \                     ??Task_MOD_23: (+1)
   \   000001F8   0x6AA8             LDR      R0,[R5, #+40]
   \   000001FA   0x1C40             ADDS     R0,R0,#+1
   \   000001FC   0x62A8             STR      R0,[R5, #+40]
   \   000001FE   0xF247 0x5131      MOVW     R1,#+30001
   \   00000202   0x4288             CMP      R0,R1
   \   00000204   0xF4FF 0xAF0C      BCC.W    ??Task_MOD_3
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0x62A8             STR      R0,[R5, #+40]
   \   0000020C   0x2003             MOVS     R0,#+3
   \   0000020E   0x72A8             STRB     R0,[R5, #+10]
   \   00000210   0xE706             B.N      ??Task_MOD_3
   \                     ??Task_MOD_24: (+1)
   \   00000212   0x6AA8             LDR      R0,[R5, #+40]
   \   00000214   0x1C40             ADDS     R0,R0,#+1
   \   00000216   0x62A8             STR      R0,[R5, #+40]
   \   00000218   0x....             LDR.N    R1,??DataTable161_16  ;; 0x2bf21
   \   0000021A   0x4288             CMP      R0,R1
   \   0000021C   0xD305             BCC.N    ??Task_MOD_25
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0x62A8             STR      R0,[R5, #+40]
   \   00000222   0x74A8             STRB     R0,[R5, #+18]
   \   00000224   0x.... 0x....      BL       Modem_ResetProcess
   \   00000228   0xE6FA             B.N      ??Task_MOD_3
   \                     ??Task_MOD_25: (+1)
   \   0000022A   0x7CA8             LDRB     R0,[R5, #+18]
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xF47F 0xAEF7      BNE.W    ??Task_MOD_3
   \   00000232   0x2001             MOVS     R0,#+1
   \   00000234   0x74A8             STRB     R0,[R5, #+18]
   \   00000236   0xE6F3             B.N      ??Task_MOD_3
   2760            }
   2761          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x41 0x54          DC8 "AT@SOCKSND=0,1,\""
   \              0x40 0x53    
   \              0x4F 0x43    
   \              0x4B 0x53    
   \              0x4E 0x44    
   \              0x3D 0x30    
   \              0x2C 0x31    
   \              0x2C 0x22    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x40 0x53          DC8 "@SOCKSND:"
   \              0x4F 0x43    
   \              0x4B 0x53    
   \              0x4E 0x44    
   \              0x3A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x22 0x0D          DC8 "\"\015"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x4F 0x4B          DC8 "OK"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Send TCP DATA ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x53 0x65    
   \              0x6E 0x64    
   \              0x20 0x54    
   \              0x43 0x50    
   \              0x20 0x44    
   \              0x41 0x54    
   \              0x41 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_1:
   \   00000000   0x22 0x0D          DC8      0x22, 0x0D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : sendATcommand 256 bytes over ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x41 0x54    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x32 0x35    
   \              0x36 0x20    
   \              0x62 0x79    
   \              0x74 0x65    
   \              0x73 0x20    
   \              0x6F 0x76    
   \              0x65 0x72    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : power off\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x70 0x6F    
   \              0x77 0x65    
   \              0x72 0x20    
   \              0x6F 0x66    
   \              0x66 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x41 0x54          DC8 "AT$$MODE=2\015"
   \              0x24 0x24    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x3D 0x32    
   \              0x0D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x41 0x54          DC8 "AT$$HWRESET\015"
   \              0x24 0x24    
   \              0x48 0x57    
   \              0x52 0x45    
   \              0x53 0x45    
   \              0x54 0x0D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x41 0x54          DC8 "AT+CFUN=7\015\012"
   \              0x2B 0x43    
   \              0x46 0x55    
   \              0x4E 0x3D    
   \              0x37 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Check Modem on\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x68    
   \              0x65 0x63    
   \              0x6B 0x20    
   \              0x4D 0x6F    
   \              0x64 0x65    
   \              0x6D 0x20    
   \              0x6F 0x6E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x41 0x54          DC8 "AT\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : power on\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x70 0x6F    
   \              0x77 0x65    
   \              0x72 0x20    
   \              0x6F 0x6E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x2B 0x43          DC8 "+CNUM: "
   \              0x4E 0x55    
   \              0x4D 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x41 0x54          DC8 "AT+CNUM\015\012"
   \              0x2B 0x43    
   \              0x4E 0x55    
   \              0x4D 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135_1:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135_2:
   \   00000000   0x........         DC32     RxBuffEmpty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135_3:
   \   00000000   0x........         DC32     ModemCommBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : simcard \015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x73 0x69    
   \              0x6D 0x63    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x2B 0x43          DC8 "+CREG: "
   \              0x52 0x45    
   \              0x47 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x41 0x54          DC8 "AT+CREG?\015\012"
   \              0x2B 0x43    
   \              0x52 0x45    
   \              0x47 0x3F    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \   00000000   0x2B 0x43          DC8 "+CGREG: "
   \              0x47 0x52    
   \              0x45 0x47    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x41 0x54          DC8 "AT+CGREG?\015\012"
   \              0x2B 0x43    
   \              0x47 0x52    
   \              0x45 0x47    
   \              0x3F 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CREG ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x52    
   \              0x45 0x47    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Check CREG status %u / %u,%u\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x68    
   \              0x65 0x63    
   \              0x6B 0x20    
   \              0x43 0x52    
   \              0x45 0x47    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x20    
   \              0x25 0x75    
   \              0x20 0x2F    
   \              0x20 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x0D 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \   00000000   0x2B 0x43          DC8 "+CSQ: "
   \              0x53 0x51    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \   00000000   0x41 0x54          DC8 "AT+CSQ\015\012"
   \              0x2B 0x43    
   \              0x53 0x51    
   \              0x0D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CSQ ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x53    
   \              0x51 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_30:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Check CSQ status %u / %u\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x68    
   \              0x65 0x63    
   \              0x6B 0x20    
   \              0x43 0x53    
   \              0x51 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x20 0x25    
   \              0x75 0x20    
   \              0x2F 0x20    
   \              0x25 0x75    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable138:
   \   00000000   0x........         DC32     _millisCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \   00000000   0x24 0x24          DC8 "$$MODEM_STATE: "
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x5F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x45 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \   00000000   0x41 0x54          DC8 "AT$$MODEM_STATE?\015"
   \              0x24 0x24    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x5F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x45 0x3F    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM_STATE ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x5F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x45 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \   00000000   0x0D 0x0A          DC8 0DH, 0AH, 4DH, 4FH, 44H, 45H, 4DH, 20H
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \   00000008   0x3A 0x20          DC8 3AH, 20H, 43H, 68H, 65H, 63H, 6BH, 20H
   \              0x43 0x68    
   \              0x65 0x63    
   \              0x6B 0x20    
   \   00000010   0x6D 0x6F          DC8 6DH, 6FH, 64H, 65H, 6DH, 20H, 73H, 74H
   \              0x64 0x65    
   \              0x6D 0x20    
   \              0x73 0x74    
   \   00000018   0x61 0x74          DC8 61H, 74H, 75H, 73H, 20H, 25H, 75H, 2CH
   \              0x75 0x73    
   \              0x20 0x25    
   \              0x75 0x2C    
   \   00000020   0x25 0x75          DC8 25H, 75H, 2CH, 25H, 75H, 2CH, 25H, 75H
   \              0x2C 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \   00000028   0x2C 0x25          DC8 2CH, 25H, 75H, 2CH, 25H, 75H, 2CH, 25H
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x2C 0x25    
   \   00000030   0x75 0x0D          DC8 75H, 0DH, 0AH, 0
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139:
   \   00000000   0x........         DC32     Setting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_1:
   \   00000000   0x........         DC32     MtTxAPNFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_2:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_3:
   \   00000000   0x........         DC32     AT_Response

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \   00000000   0x24 0x24          DC8 "$$TCP_PPPOP: "
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x50 0x50    
   \              0x50 0x4F    
   \              0x50 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_PPPOP\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x50 0x50    
   \              0x50 0x4F    
   \              0x50 0x0D    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_37:
   \   00000000   0x41 0x54          DC8 "AT@NETCONN=1\015"
   \              0x40 0x4E    
   \              0x45 0x54    
   \              0x43 0x4F    
   \              0x4E 0x4E    
   \              0x3D 0x31    
   \              0x0D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140:
   \   00000000   0x........         DC32     TxResp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_1:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_39:
   \   00000000   0x24 0x24          DC8 "$$TCP_PPPCL: "
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x50 0x50    
   \              0x50 0x43    
   \              0x4C 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_PPPCL\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x50 0x50    
   \              0x50 0x43    
   \              0x4C 0x0D    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141:
   \   00000000   0x........         DC32     ATCmdRxMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141_1:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_42:
   \   00000000   0x2B 0x43          DC8 "+CGDCONT: "
   \              0x47 0x44    
   \              0x43 0x4F    
   \              0x4E 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_41:
   \   00000000   0x41 0x54          DC8 "AT+CGDCONT?\015\012"
   \              0x2B 0x43    
   \              0x47 0x44    
   \              0x43 0x4F    
   \              0x4E 0x54    
   \              0x3F 0x0D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_43:
   \   00000000   0x41 0x54          DC8 "AT+CGDCONT=1,\"IPV4V6\",\"%s\"\015\012"
   \              0x2B 0x43    
   \              0x47 0x44    
   \              0x43 0x4F    
   \              0x4E 0x54    
   \              0x3D 0x31    
   \              0x2C 0x22    
   \              0x49 0x50    
   \              0x56 0x34    
   \              0x56 0x36    
   \              0x22 0x2C    
   \              0x22 0x25    
   \              0x73 0x22    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_44:
   \   00000000   0x41 0x54          DC8 "AT+CGDCONT=1,\"IP\",\"%s\"\015\012"
   \              0x2B 0x43    
   \              0x47 0x44    
   \              0x43 0x4F    
   \              0x4E 0x54    
   \              0x3D 0x31    
   \              0x2C 0x22    
   \              0x49 0x50    
   \              0x22 0x2C    
   \              0x22 0x25    
   \              0x73 0x22    
   \              0x0D 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_45:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CGDCONT ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x47    
   \              0x44 0x43    
   \              0x4F 0x4E    
   \              0x54 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ?_47:
   \   00000000   0x2B 0x43          DC8 "+CGEQREQ: "
   \              0x47 0x45    
   \              0x51 0x52    
   \              0x45 0x51    
   \              0x3A 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_46:
   \   00000000   0x41 0x54          DC8 "AT+CGEQREQ?\015\012"
   \              0x2B 0x43    
   \              0x47 0x45    
   \              0x51 0x52    
   \              0x45 0x51    
   \              0x3F 0x0D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_49:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CGEQREQ Upload ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x47    
   \              0x45 0x51    
   \              0x52 0x45    
   \              0x51 0x20    
   \              0x55 0x70    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_48:
   \   00000000   0x41 0x54          DC8 "AT+CGEQREQ=%u,%u,%u,%u\015\012"
   \              0x2B 0x43    
   \              0x47 0x45    
   \              0x51 0x52    
   \              0x45 0x51    
   \              0x3D 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x2C 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x0D 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_50:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CGEQREQ Dnload ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x47    
   \              0x45 0x51    
   \              0x52 0x45    
   \              0x51 0x20    
   \              0x44 0x6E    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_53:
   \   00000000   0x5B 0x30          DC8 "[0] "
   \              0x5D 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_52:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_ADDR?\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x3F 0x0D    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_1:
   \   00000000   0x........         DC32     MtTxAPNFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_2:
   \   00000000   0x........         DC32     ModemCTN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_3:
   \   00000000   0x3B9ACA01         DC32     0x3b9aca01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_4:
   \   00000000   0x........         DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_5:
   \   00000000   0x........         DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_6:
   \   00000000   0x........         DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_7:
   \   00000000   0x........         DC32     ReadValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_8:
   \   00000000   0x53 0x4B          DC8      0x53, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_9:
   \   00000000   0x4C 0x47          DC8      0x4C, 0x47, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_10:
   \   00000000   0x........         DC32     RSSI

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_11:
   \   00000000   0x........         DC32     ATCmdRxMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ?_55:
   \   00000000   0x2B 0x43          DC8 "+COPS: "
   \              0x4F 0x50    
   \              0x53 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_54:
   \   00000000   0x41 0x54          DC8 "AT+COPS?\015\012"
   \              0x2B 0x43    
   \              0x4F 0x50    
   \              0x53 0x3F    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_56:
   \   00000000   0x6F 0x6C          DC8 "olleh"
   \              0x6C 0x65    
   \              0x68 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_1:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_2:
   \   00000000   0x........         DC32     Setting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_3:
   \   00000000   0x........         DC32     MtTxAPNFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_4:
   \   00000000   0x........         DC32     ?_40

   \                                 In section .text, align 4, keep-with-next
   \                     ?_59:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Initialize Start\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x65    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_60:
   \   00000000   0x41 0x54          DC8 "ATE0\015\012"
   \              0x45 0x30    
   \              0x0D 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_61:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : ATE0 ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x41 0x54    
   \              0x45 0x30    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_62:
   \   00000000   0x41 0x54          DC8 "AT+GMM\015\012"
   \              0x2B 0x47    
   \              0x4D 0x4D    
   \              0x0D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_63:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : GMM ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x47 0x4D    
   \              0x4D 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_64:
   \   00000000   0x41 0x54          DC8 "AT+IPR=115200\015\012"
   \              0x2B 0x49    
   \              0x50 0x52    
   \              0x3D 0x31    
   \              0x31 0x35    
   \              0x32 0x30    
   \              0x30 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_65:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : IPR ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x49 0x50    
   \              0x52 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \   00000000   0x2B 0x43          DC8 "+CPIN: NOT INSERTED"
   \              0x50 0x49    
   \              0x4E 0x3A    
   \              0x20 0x4E    
   \              0x4F 0x54    
   \              0x20 0x49    
   \              0x4E 0x53    
   \              0x45 0x52    
   \              0x54 0x45    
   \              0x44 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x2B 0x43          DC8 "+CPIN: READY"
   \              0x50 0x49    
   \              0x4E 0x3A    
   \              0x20 0x52    
   \              0x45 0x41    
   \              0x44 0x59    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x41 0x54          DC8 "AT+CPIN?\015\012"
   \              0x2B 0x43    
   \              0x50 0x49    
   \              0x4E 0x3F    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_66:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CPIN ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x50    
   \              0x49 0x4E    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_67:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CNUM ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x4E    
   \              0x55 0x4D    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_68:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CNUM %u / %u \015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x4E    
   \              0x55 0x4D    
   \              0x20 0x25    
   \              0x75 0x20    
   \              0x2F 0x20    
   \              0x25 0x75    
   \              0x20 0x0D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_69:
   \   00000000   0x41 0x54          DC8 "AT+CNMI=2,1\015\012"
   \              0x2B 0x43    
   \              0x4E 0x4D    
   \              0x49 0x3D    
   \              0x32 0x2C    
   \              0x31 0x0D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_70:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CNMI ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x4E    
   \              0x4D 0x49    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_71:
   \   00000000   0x41 0x54          DC8 "AT+CMGF=1\015\012"
   \              0x2B 0x43    
   \              0x4D 0x47    
   \              0x46 0x3D    
   \              0x31 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_72:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : CMGF ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x43 0x4D    
   \              0x47 0x46    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_73:
   \   00000000   0x41 0x54          DC8 "AT$$SPC_LOCK=000000\015\012"
   \              0x24 0x24    
   \              0x53 0x50    
   \              0x43 0x5F    
   \              0x4C 0x4F    
   \              0x43 0x4B    
   \              0x3D 0x30    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x30 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_74:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : SPC_LOCK ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x53 0x50    
   \              0x43 0x5F    
   \              0x4C 0x4F    
   \              0x43 0x4B    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_75:
   \   00000000   0x41 0x54          DC8 "AT$$NETWORK_MODE=1\015\012"
   \              0x24 0x24    
   \              0x4E 0x45    
   \              0x54 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5F    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x3D 0x31    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_76:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : NETWORK_MODE ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4E 0x45    
   \              0x54 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5F    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_77:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_DNIP=%s\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x44 0x4E    
   \              0x49 0x50    
   \              0x3D 0x25    
   \              0x73 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_78:
   \   00000000   0x24 0x24          DC8 "$$TCP_DNIP: "
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x44 0x4E    
   \              0x49 0x50    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_79:
   \   00000000   0x41 0x54          DC8 "AT@DNSQ=%s\015"
   \              0x40 0x44    
   \              0x4E 0x53    
   \              0x51 0x3D    
   \              0x25 0x73    
   \              0x0D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_80:
   \   00000000   0x40 0x44          DC8 "@DNSQUERY:"
   \              0x4E 0x53    
   \              0x51 0x55    
   \              0x45 0x52    
   \              0x59 0x3A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_81:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Socket Open ip:%u.%u.%u.%u port: %u\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x53 0x6F    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x4F    
   \              0x70 0x65    
   \              0x6E 0x20    
   \              0x69 0x70    
   \              0x3A 0x25    
   \              0x75 0x2E    
   \              0x25 0x75    
   \              0x2E 0x25    
   \              0x75 0x2E    
   \              0x25 0x75    
   \              0x20 0x70    
   \              0x6F 0x72    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x75 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_82:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_ADDR=0,%u,%u,%u,%u,%u\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x3D 0x30    
   \              0x2C 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x2C 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x2C 0x25    
   \              0x75 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_83:
   \   00000000   0x24 0x24          DC8 "$$TCP_ADDR: "
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_85:
   \   00000000   0x24 0x24          DC8 "$$TCP_SCOP: "
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x53 0x43    
   \              0x4F 0x50    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_84:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_SCOP\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x53 0x43    
   \              0x4F 0x50    
   \              0x0D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_86:
   \   00000000   0x41 0x54          DC8 "AT@SOCKOPEN=0,0,1,%u.%u.%u.%u,%u\015"
   \              0x40 0x53    
   \              0x4F 0x43    
   \              0x4B 0x4F    
   \              0x50 0x45    
   \              0x4E 0x3D    
   \              0x30 0x2C    
   \              0x30 0x2C    
   \              0x31 0x2C    
   \              0x25 0x75    
   \              0x2E 0x25    
   \              0x75 0x2E    
   \              0x25 0x75    
   \              0x2E 0x25    
   \              0x75 0x2C    
   \              0x25 0x75    
   \              0x0D 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_88:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Socket Open Start  %s, %u\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x53 0x6F    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x4F    
   \              0x70 0x65    
   \              0x6E 0x20    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x20 0x25    
   \              0x73 0x2C    
   \              0x20 0x25    
   \              0x75 0x0D    
   \              0x0A 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150_1:
   \   00000000   0x........         DC32     Setting+0xB5

   \                                 In section .text, align 4, keep-with-next
   \                     ?_89:
   \   00000000   0x41 0x54          DC8 "AT$$TCP_SCCL\015"
   \              0x24 0x24    
   \              0x54 0x43    
   \              0x50 0x5F    
   \              0x53 0x43    
   \              0x43 0x4C    
   \              0x0D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_40:
   \   00000000   0x41 0x54          DC8 "AT@SOCKCLOSE=0\015"
   \              0x40 0x53    
   \              0x4F 0x43    
   \              0x4B 0x43    
   \              0x4C 0x4F    
   \              0x53 0x45    
   \              0x3D 0x30    
   \              0x0D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151:
   \   00000000   0x........         DC32     ATCmdRxMsg+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ?_90:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM FOTA SMS\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x46 0x4F    
   \              0x54 0x41    
   \              0x20 0x53    
   \              0x4D 0x53    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_91:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM FOTA START\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x46 0x4F    
   \              0x54 0x41    
   \              0x20 0x53    
   \              0x54 0x41    
   \              0x52 0x54    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_92:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM DOWNLOAD START\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x44 0x4F    
   \              0x57 0x4E    
   \              0x4C 0x4F    
   \              0x41 0x44    
   \              0x20 0x53    
   \              0x54 0x41    
   \              0x52 0x54    
   \              0x0D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_93:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM FOTA RESET\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x46 0x4F    
   \              0x54 0x41    
   \              0x20 0x52    
   \              0x45 0x53    
   \              0x45 0x54    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_94:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM FOTA ERROR\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x46 0x4F    
   \              0x54 0x41    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_95:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : MODEM FOTA FAIL\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x46 0x4F    
   \              0x54 0x41    
   \              0x20 0x46    
   \              0x41 0x49    
   \              0x4C 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152_1:
   \   00000000   0x........         DC32     ATCmdRxMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152_2:
   \   00000000   0x........         DC32     ModemVer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152_3:
   \   00000000   0x........         DC32     Setting+0xB6

   \                                 In section .text, align 4, keep-with-next
   \                     ?_96:
   \   00000000   0x53 0x4F          DC8 "SOCKRCV"
   \              0x43 0x4B    
   \              0x52 0x43    
   \              0x56 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153_1:
   \   00000000   0x........         DC32     MtTxAPNFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153_2:
   \   00000000   0x........         DC32     Setting

   \                                 In section .text, align 4, keep-with-next
   \                     ?_97:
   \   00000000   0x2B 0x43          DC8 "+CMTI: "
   \              0x4D 0x54    
   \              0x49 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_98:
   \   00000000   0x24 0x24          DC8 "$$NOTI:34"
   \              0x4E 0x4F    
   \              0x54 0x49    
   \              0x3A 0x33    
   \              0x34 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_99:
   \   00000000   0x24 0x24          DC8 "$$A_BOOT_ALERT"
   \              0x41 0x5F    
   \              0x42 0x4F    
   \              0x4F 0x54    
   \              0x5F 0x41    
   \              0x4C 0x45    
   \              0x52 0x54    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_100:
   \   00000000   0x40 0x4E          DC8 "@NOTI:34"
   \              0x4F 0x54    
   \              0x49 0x3A    
   \              0x33 0x34    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_101:
   \   00000000   0x40 0x53          DC8 "@SOCKOPEN:0,0"
   \              0x4F 0x43    
   \              0x4B 0x4F    
   \              0x50 0x45    
   \              0x4E 0x3A    
   \              0x30 0x2C    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_102:
   \   00000000   0x40 0x53          DC8 "@SOCKOPEN:0,1"
   \              0x4F 0x43    
   \              0x4B 0x4F    
   \              0x50 0x45    
   \              0x4E 0x3A    
   \              0x30 0x2C    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160:
   \   00000000   0x........         DC32     Urc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161:
   \   00000000   0x........         DC32     RxHexStrStep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_1:
   \   00000000   0x........         DC32     Setting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_2:
   \   00000000   0x........         DC32     MtTxAPNFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_3:
   \   00000000   0x........         DC32     RSSI

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_4:
   \   00000000   0x........         DC32     Urc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_5:
   \   00000000   0x........         DC32     ATCmdRxMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_6:
   \   00000000   0x........         DC32     HostSvr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_7:
   \   00000000   0x........         DC32     FWDN_Svr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_8:
   \   00000000   0x........         DC32     DataSaveAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_9:
   \   00000000   0x........         DC32     DataSentAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_10:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_11:
   \   00000000   0x........         DC32     Fota_FW_Ver

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_12:
   \   00000000   0x........         DC32     Start_Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_13:
   \   00000000   0x........         DC32     Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_14:
   \   00000000   0x000493E0         DC32     0x493e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_15:
   \   00000000   0x........         DC32     ReadValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_16:
   \   00000000   0x0002BF21         DC32     0x2bf21

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x45 0x52          DC8 "ERROR"
   \              0x52 0x4F    
   \              0x52 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_103:
   \   00000000   0x40 0x53          DC8 "@SOCKCLOSED:0,0"
   \              0x4F 0x43    
   \              0x4B 0x43    
   \              0x4C 0x4F    
   \              0x53 0x45    
   \              0x44 0x3A    
   \              0x30 0x2C    
   \              0x30 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_104:
   \   00000000   0x24 0x24          DC8 "$$TELL: "
   \              0x54 0x45    
   \              0x4C 0x4C    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_105:
   \   00000000   0x40 0x4E          DC8 "@NETSTI:"
   \              0x45 0x54    
   \              0x53 0x54    
   \              0x49 0x3A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_106:
   \   00000000   0x41 0x54          DC8 "AT$$MODE=3\015"
   \              0x24 0x24    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x3D 0x33    
   \              0x0D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_107:
   \   00000000   0x41 0x54          DC8 "AT$$RESET\015"
   \              0x24 0x24    
   \              0x52 0x45    
   \              0x53 0x45    
   \              0x54 0x0D    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_108:
   \   00000000   0x41 0x54          DC8 "AT@HWRESET\015"
   \              0x40 0x48    
   \              0x57 0x52    
   \              0x45 0x53    
   \              0x45 0x54    
   \              0x0D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_109:
   \   00000000   0x64 0x61          DC8 "data.scr-monitor.com"
   \              0x74 0x61    
   \              0x2E 0x73    
   \              0x63 0x72    
   \              0x2D 0x6D    
   \              0x6F 0x6E    
   \              0x69 0x74    
   \              0x6F 0x72    
   \              0x2E 0x63    
   \              0x6F 0x6D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_110:
   \   00000000   0x6C 0x62          DC8 "lb.loop-ota.com"
   \              0x2E 0x6C    
   \              0x6F 0x6F    
   \              0x70 0x2D    
   \              0x6F 0x74    
   \              0x61 0x2E    
   \              0x63 0x6F    
   \              0x6D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_111:
   \   00000000   0x25 0x75          DC8 "%u.%u.%u.%u"
   \              0x2E 0x25    
   \              0x75 0x2E    
   \              0x25 0x75    
   \              0x2E 0x25    
   \              0x75 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_112:
   \   00000000   0x25 0x31          DC8 "%1u.%1u.%1u.%1u"
   \              0x75 0x2E    
   \              0x25 0x31    
   \              0x75 0x2E    
   \              0x25 0x31    
   \              0x75 0x2E    
   \              0x25 0x31    
   \              0x75 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_113:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Power idle %u\015\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x50 0x6F    
   \              0x77 0x65    
   \              0x72 0x20    
   \              0x69 0x64    
   \              0x6C 0x65    
   \              0x20 0x25    
   \              0x75 0x0D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_114:
   \   00000000   0x0D 0x0A          DC8 "\015\012MODEM : Data idle %u\012"
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x20    
   \              0x3A 0x20    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x20 0x69    
   \              0x64 0x6C    
   \              0x65 0x20    
   \              0x25 0x75    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_51:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_57:
   \   00000000   0x53 0x4B          DC8 "SK"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_58:
   \   00000000   0x4C 0x47          DC8 "LG"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_87:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   APNProcess
        24   -> AT_SendWithRecieveData
        24   -> FRAMMultiWrite
        24   -> IsSameString
        24   -> Modem_PPPClose
        24   -> Modem_PPPOpen
        24   -> StringLen
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset4
        24   -> printk
        24   -> sendATcommand
        24   -> sprintf
        24   -> vTaskDelay
      32   AT_SendWithRecieveCNUM
        32   -> AT_SendWithRecieveData
        32   -> FRAMMultiWrite
        32   -> __aeabi_memcpy
      56   AT_SendWithRecieveData
        56   -> ModemCommGetChar
        56   -> ModemCommInit
        56   -> TxStrToModem
        56   -> __aeabi_memset
        56   -> __aeabi_memset4
        56   -> init_millis
        56   -> millis
        56   -> printk
        56   -> strstr
        56   -> vTaskDelay
      56   AT_SendWithRecieveData2
        56   -> ModemCommGetChar
        56   -> ModemCommInit
        56   -> TxStrToModem
        56   -> __aeabi_memset
        56   -> __aeabi_memset4
        56   -> init_millis
        56   -> millis
        56   -> printk
        56   -> strstr
        56   -> vTaskDelay
      56   AT_SendWithRecieveMultiRowData
        56   -> ModemCommGetChar
        56   -> ModemCommInit
        56   -> TxStrToModem
        56   -> __aeabi_memset
        56   -> __aeabi_memset4
        56   -> init_millis
        56   -> millis
        56   -> printk
        56   -> strstr
        56   -> vTaskDelay
       8   AsciiToVal
       8   CheckAPNChange
         8   -> APNProcess
      16   IsSamePassWord
       8   IsSameString
      16   IsSameString2
       0   ModemCommBuffCheck
       4   ModemCommGetChar
       0   ModemCommInit
       0   ModemCommPutRxChar
      32   ModemInit
        32   -> FRAMMultiRead
        32   -> FRAMMultiWrite
        32   -> ModemCommInit
        32   -> Modem_Init_Loop
        32   -> __aeabi_memcpy
        32   -> __aeabi_memcpy4
        32   -> __aeabi_memset4
        32   -> sprintf
      16   Modem_CREG_Check
        16   -> AT_SendWithRecieveData
        16   -> AsciiToVal
        16   -> Modem_SocketClose
        16   -> printk
      16   Modem_CSQ_Check
        16   -> AT_SendWithRecieveData
        16   -> AsciiToVal
        16   -> Modem_SocketClose
        16   -> printk
       8   Modem_CheckConnectIP
         0   -> FRAMMultiWrite
       8   Modem_CheckTelecom
         8   -> AT_SendWithRecieveData
         8   -> FRAMMultiWrite
         8   -> strstr
      32   Modem_GetIP
        32   -> AT_SendWithRecieveData
        32   -> StringLen
        32   -> __aeabi_memcpy4
        32   -> __aeabi_memset
        32   -> sprintf
      24   Modem_Initialize
        24   -> APNProcess
        24   -> AT_SendWithRecieveCNUM
        24   -> AT_SendWithRecieveData2
        24   -> Modem_CheckTelecom
        24   -> Modem_SMS_ReadAll
        24   -> Modem_SocketClose
        24   -> StringLen
        24   -> __aeabi_memcpy4
        24   -> printk
        24   -> sendATcommand
        24   -> vTaskDelay
       0   Modem_KeyOffProcess
       8   Modem_PPPClose
         8   -> AT_SendWithRecieveData
         8   -> sendATcommand
         8   -> vTaskDelay
      16   Modem_PPPOpen
        16   -> AT_SendWithRecieveData
        16   -> sendATcommand
        16   -> vTaskDelay
      24   Modem_Parameter_Reset
        24   -> FRAMMultiWrite
        24   -> __aeabi_memcpy4
        24   -> __aeabi_memset4
        24   -> sprintf
       8   Modem_PowerOff
         8   -> printk
         8   -> sendATcommand
         0   -> vTaskDelay
       8   Modem_PowerOn
         8   -> printk
         8   -> vTaskDelay
      16   Modem_PowerOnCheck
        16   -> printk
        16   -> sendATcommand
        16   -> vTaskDelay
       8   Modem_ResetProcess
         8   -> sendATcommand
       0   Modem_SecIntProcess
         0   -> Modem_SecInt_Loop
      16   Modem_SimCard
        16   -> printk
        16   -> sendATcommand
        16   -> vTaskDelay
      16   Modem_SocketClose
        16   -> ModemCommInit
        16   -> Modem_PPPClose
        16   -> TxStrToModem
        16   -> sendATcommand
        16   -> vTaskDelay
       8   Modem_SocketConnect
         8   -> Modem_CREG_Check
         8   -> Modem_PPPOpen
         8   -> Modem_SocketOpenSvrName
         8   -> Modem_State_Check
      32   Modem_SocketOpenIP
        32   -> AT_SendWithRecieveData
        32   -> __aeabi_memset
        32   -> printk
        32   -> sendATcommand
        32   -> sprintf
        32   -> vTaskDelay
      24   Modem_SocketOpenSvrName
        24   -> Modem_CheckConnectIP
        24   -> Modem_GetIP
        24   -> Modem_SocketOpenIP
        24   -> __aeabi_memcpy
        24   -> __aeabi_memcpy4
        24   -> printk
        24   -> vTaskDelay
      40   Modem_State_Check
        40   -> AT_SendWithRecieveData
        40   -> AsciiToVal
        40   -> Modem_CSQ_Check
        40   -> printk
      24   Modem_URC_Parser
        24   -> APNProcess
         0   -> Modem_RxChar_Loop
        24   -> RxHexStrData
        24   -> SMS_Process
        24   -> TellRespDecode
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> __aeabi_memset4
         0   -> printk
        24   -> printk
        24   -> strstr
       8   Modem_parse_proc
         8   -> ModemCommGetChar
         8   -> Modem_URC_Parser
       0   NVIC_SystemReset
      40   QoSAdust
        40   -> AT_SendWithRecieveData
        40   -> AsciiToVal
        40   -> __aeabi_memset
        40   -> printk
        40   -> sendATcommand
        40   -> sprintf
        40   -> vTaskDelay
      16   RxHexStrData
        16   -> __aeabi_memset4
        16   -> strstr
      40   ServerIPCheck
        40   -> AT_SendWithRecieveData
        40   -> __aeabi_memcpy
       0   StringLen
      16   Task_MOD
        16   -> BSP_UART2RX_IntEnable
        16   -> CheckAPNChange
        16   -> Modem_CSQ_Check
        16   -> Modem_DataIdleProcess_Loop
        16   -> Modem_DataSvrProcess_Loop
        16   -> Modem_Initialize
        16   -> Modem_LoopFotaProcess
        16   -> Modem_PowerOff
        16   -> Modem_PowerOn
        16   -> Modem_PowerOnCheck
        16   -> Modem_ResetProcess
        16   -> Modem_parse_proc
        16   -> printk
        16   -> vTaskDelay
       8   TellRespDecode
         8   -> NVIC_SystemReset
         8   -> printk
      16   TxCharToModem
        16   -> USART_GetFlagStatus
         0   -> USART_SendData
       0   TxDataStrToModem
         0   -> TxHexStrToModem
         0   -> modem_sendstr
      64   TxHexStrToModem
        64   -> ModemCommGetChar
        64   -> ModemCommInit
        64   -> TxCharToModem
        64   -> TxStrToModem
        64   -> __aeabi_memset4
        64   -> init_millis
        64   -> millis
        64   -> printk
        64   -> strstr
        64   -> vTaskDelay
       8   TxStrToModem
         8   -> StringLen
         0   -> modem_sendstr
      12   getcrc16
       0   getcrc16c
       0   init_millis
       0   millis
       0   modem_sendstr
         0   -> modemPutCharStr
      40   sendATcommand
        40   -> ModemCommGetChar
        40   -> ModemCommInit
        40   -> TxStrToModem
        40   -> __aeabi_memset4
        40   -> init_millis
        40   -> millis
        40   -> printk
        40   -> strstr
        40   -> vTaskDelay
      40   sendATcommand2
        40   -> ModemCommGetChar
        40   -> ModemCommInit
        40   -> TxStrToModem
        40   -> __aeabi_memset4
        40   -> init_millis
        40   -> millis
        40   -> printk
        40   -> strstr
        40   -> vTaskDelay
       0   strstr
         0   -> __iar_Strstr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable127
       4  ??DataTable127_1
       4  ??DataTable135
       4  ??DataTable135_1
       4  ??DataTable135_2
       4  ??DataTable135_3
       4  ??DataTable136
       4  ??DataTable138
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable139_2
       4  ??DataTable139_3
       4  ??DataTable140
       4  ??DataTable140_1
       4  ??DataTable141
       4  ??DataTable141_1
       4  ??DataTable142
       4  ??DataTable144
       4  ??DataTable144_1
       4  ??DataTable144_10
       4  ??DataTable144_11
       4  ??DataTable144_2
       4  ??DataTable144_3
       4  ??DataTable144_4
       4  ??DataTable144_5
       4  ??DataTable144_6
       4  ??DataTable144_7
       4  ??DataTable144_8
       4  ??DataTable144_9
       4  ??DataTable145
       4  ??DataTable145_1
       4  ??DataTable145_2
       4  ??DataTable145_3
       4  ??DataTable145_4
       4  ??DataTable150
       4  ??DataTable150_1
       4  ??DataTable151
       4  ??DataTable152
       4  ??DataTable152_1
       4  ??DataTable152_2
       4  ??DataTable152_3
       4  ??DataTable153
       4  ??DataTable153_1
       4  ??DataTable153_2
       4  ??DataTable156
       4  ??DataTable160
       4  ??DataTable161
       4  ??DataTable161_1
       4  ??DataTable161_10
       4  ??DataTable161_11
       4  ??DataTable161_12
       4  ??DataTable161_13
       4  ??DataTable161_14
       4  ??DataTable161_15
       4  ??DataTable161_16
       4  ??DataTable161_2
       4  ??DataTable161_3
       4  ??DataTable161_4
       4  ??DataTable161_5
       4  ??DataTable161_6
       4  ??DataTable161_7
       4  ??DataTable161_8
       4  ??DataTable161_9
       4  ?_0
      20  ?_1
      16  ?_10
      12  ?_100
      16  ?_101
      16  ?_102
      16  ?_103
      12  ?_104
      12  ?_105
      12  ?_106
      12  ?_107
      12  ?_108
      24  ?_109
      12  ?_11
      16  ?_110
      12  ?_111
      16  ?_112
      28  ?_113
      24  ?_114
      28  ?_12
       8  ?_13
      24  ?_14
      12  ?_15
       8  ?_16
      24  ?_17
      12  ?_18
      16  ?_19
       4  ?_2
      20  ?_20
      12  ?_21
       8  ?_22
      12  ?_23
      12  ?_24
      24  ?_25
      44  ?_26
      12  ?_27
       8  ?_28
      24  ?_29
      12  ?_3
      40  ?_30
      20  ?_31
      16  ?_32
      32  ?_33
      52  ?_34
      16  ?_35
      16  ?_36
      16  ?_37
      16  ?_38
      16  ?_39
      32  ?_4
      16  ?_40
      16  ?_41
      12  ?_42
      32  ?_43
      28  ?_44
      28  ?_45
      16  ?_46
      12  ?_47
      28  ?_48
      36  ?_49
      48  ?_5
      36  ?_50
       4  ?_51
      16  ?_52
       8  ?_53
      12  ?_54
       8  ?_55
       8  ?_56
       4  ?_57
       4  ?_58
      32  ?_59
      24  ?_6
       8  ?_60
      24  ?_61
      12  ?_62
      24  ?_63
      16  ?_64
      24  ?_65
      24  ?_66
      24  ?_67
      28  ?_68
      16  ?_69
      12  ?_7
      24  ?_70
      12  ?_71
      24  ?_72
      24  ?_73
      28  ?_74
      24  ?_75
      32  ?_76
      20  ?_77
      16  ?_78
      12  ?_79
       4  ?_8
      12  ?_80
      48  ?_81
      32  ?_82
      16  ?_83
      16  ?_84
      16  ?_85
      36  ?_86
       4  ?_87
      40  ?_88
      16  ?_89
       8  ?_9
      28  ?_90
      32  ?_91
      36  ?_92
      32  ?_93
      32  ?_94
      28  ?_95
       8  ?_96
       8  ?_97
      12  ?_98
      16  ?_99
     630  APNProcess
     384  ATCmdRxMsg
          ModemInfo
     256  AT_Response
     190  AT_SendWithRecieveCNUM
     246  AT_SendWithRecieveData
     268  AT_SendWithRecieveData2
     234  AT_SendWithRecieveMultiRowData
      84  AsciiToVal
      40  CheckAPNChange
       1  DTG_Data_Flash_ReadFlag
       1  DTG_Data_Flash_WriteFlag
       4  DataServerRetryCount
       1  DataSvrStep
       4  DataSvrWaitCount
      64  FWDN_Svr
       1  FotaEnable
       1  FotaFlag
       1  GetServerFlag
       4  GetServerRetryCount
       1  GetSvrStep
       4  GetSvrWaitCount
      72  HostSvr
          SendData_StartTime
          Loop_SendTimeCnt
      74  IsSamePassWord
      30  IsSameString
      54  IsSameString2
    6144  ModemBuff
      12  ModemCTN
    4364  ModemCommBuf
      28  ModemCommBuffCheck
      64  ModemCommGetChar
      18  ModemCommInit
      44  ModemCommPutRxChar
     502  ModemInit
   40960  ModemTxBuff
      20  ModemVer
     186  Modem_CREG_Check
     146  Modem_CSQ_Check
     122  Modem_CheckConnectIP
     216  Modem_CheckTelecom
     338  Modem_GetIP
     908  Modem_Initialize
      24  Modem_KeyOffProcess
     140  Modem_PPPClose
     140  Modem_PPPOpen
     286  Modem_Parameter_Reset
     122  Modem_PowerOff
      28  Modem_PowerOn
      56  Modem_PowerOnCheck
     122  Modem_ResetProcess
      32  Modem_SecIntProcess
      58  Modem_SimCard
     138  Modem_SocketClose
     470  Modem_SocketConnect
     254  Modem_SocketOpenIP
     100  Modem_SocketOpenSvrName
     234  Modem_State_Check
     718  Modem_URC_Parser
      24  Modem_parse_proc
     396  MtTxAPNFlag
          MtReadAPNFlag
          MtChangeAPNFlag
          COM_Command_Char
          DataServerFlag
          ModemOffFlag
          ModemReadyFlag
          ModemPowerOnFlag
          TCP_Open
          TcpState
          ModemStep
          FotaRespFlag
          SocketConnectStep
          SocketRetryCnt
          ServerIPCheckFlag
          LoopFotaFlag
          LoopFotaStep
          ModemInitCnt
          Modem_FotaFlag
          TellRespFlag
          NetRespFlag
          UsimState
          PppState
          TldState
          SmsState
          ModemServiceFaultCnt
          ModemServiceFault
          DmsApnPushRxFlag
          DmsApnPushRxCnt
          KtfState
          APNProcessCnt
          DataAddrToSend
          ModemWaitCnt
          SocketWaitCnt
          SMSDecodeWaitCnt
          TellRespNo
          NetRespNo
          APN_Name
          ComRxAPN_Name
          MdmTmpString
          SMSData
          DmsPushApnName
      30  NVIC_SystemReset
       1  NotiRespFlag
       4  NotiRespNo
       1  OnNotiFlag
       1  OnNotiRespFlag
       4  OnNotiRetryCount
       1  OnNotiStep
       4  OnNotiWaitCount
       4  Prev_DataAdrrToSend
       1  Prev_DataFlag
       4  Prev_VdisAdrrToSend
       1  Prev_VdisFlag
       4  ProgressFotaRxByte
     314  QoSAdust
       1  RxBuffEmpty
     354  RxHexStrData
      20  RxHexStrStep
          RxBinData
          RxHexStr
          RxHexStrCnt
          RxHexStrLen
       1  SendDailyDataFlag
       4  SendData_EndTime
       1  SendSettingFlag
     300  ServerIPCheck
      24  StringLen
       1  SvrEventCode
       1  SvrEventFlag
       1  SvrSvcError
     568  Task_MOD
     350  TellRespDecode
      32  TxCharToModem
      26  TxDataStrToModem
     432  TxHexStrToModem
       8  TxResp
          TxRespStep
          TxMsgLen
      22  TxStrToModem
     120  Urc
       4  VdisAddrToSend
       1  VdisServerFlag
       4  VdisServerRetryCount
       1  VdisSvrStep
       4  VdisSvrWaitCount
       1  VehStateFlag
       4  _millisCounter
     512  crc16tab
      42  getcrc16
      22  getcrc16c
      10  init_millis
       8  millis
       4  modem_sendstr
     156  sendATcommand
     150  sendATcommand2
       4  strstr

 
 11 942 bytes in section .bss
     28 bytes in section .rodata
 13 176 bytes in section .text
 40 960 bytes in section EXTCCRAM
 
 13 172 bytes of CODE  memory (+ 4 bytes shared)
     28 bytes of CONST memory
 52 902 bytes of DATA  memory

Errors: none
Warnings: none
