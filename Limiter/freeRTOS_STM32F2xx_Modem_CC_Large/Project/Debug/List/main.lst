###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\cpu\main.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\cpu\main.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\main.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\main.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\cpu\main.c
      1          /**
      2            ******************************************************************************
      3            * @file    main.c
      4            * @author  MCU Application Team
      5            * @version V1.1.0
      6            * @date    07/10/2014
      7            * @brief   Main program body
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "includes.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0x0109             LSLS     R1,R1,#+4
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD507             BPL.N    ??NVIC_SetPriority_0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable24_2  ;; 0xe000ed18
   \   0000000A   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000E   0x4410             ADD      R0,R2,R0
   \   00000010   0xF800 0x1C04      STRB     R1,[R0, #-4]
   \   00000014   0x4770             BX       LR
   \                     ??NVIC_SetPriority_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable24_3  ;; 0xe000e400
   \   0000001A   0x5411             STRB     R1,[R2, R0]
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000008   0xD301             BCC.N    ??SysTick_Config_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD10             POP      {R4,PC}
   \                     ??SysTick_Config_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable24_4  ;; 0xe000e010
   \   00000012   0x6060             STR      R0,[R4, #+4]
   \   00000014   0x210F             MOVS     R1,#+15
   \   00000016   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001A   0x.... 0x....      BL       NVIC_SetPriority
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x60A0             STR      R0,[R4, #+8]
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0x6020             STR      R0,[R4, #+0]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     24          

   \                                 In section .bss, align 4
     25          FATFS USB_Fs,  SD_Fs; 
   \                     USB_Fs:
   \   00000000                      DS8 564

   \                                 In section .bss, align 4
   \                     SD_Fs:
   \   00000000                      DS8 564

   \                                 In section .bss, align 4
     26          FIL   USB_Fil, SD_Fil;
   \                     USB_Fil:
   \   00000000                      DS8 548

   \                                 In section .bss, align 4
   \                     SD_Fil:
   \   00000000                      DS8 548
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private semaphore ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     31          xSemaphoreHandle SpiFlashDevSem = NULL;
   \                     SpiFlashDevSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     32          xSemaphoreHandle BSP_SaveSem	  = NULL;
   \                     BSP_SaveSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     33          xSemaphoreHandle BSP_I2C1Sem	  = NULL;
   \                     BSP_I2C1Sem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     34          xSemaphoreHandle BSP_NANDSem	  = NULL;
   \                     BSP_NANDSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     35          xSemaphoreHandle BSP_BKSramSem	= NULL;
   \                     BSP_BKSramSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     36          xSemaphoreHandle BSP_BKRtcSem	  = NULL;
   \                     BSP_BKRtcSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     37          xSemaphoreHandle BSP_CanSem     = NULL;
   \                     BSP_CanSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     38          xSemaphoreHandle BSP_KeySem     = NULL;
   \                     BSP_KeySem:
   \   00000000                      DS8 4
     39          
     40          /* Private macro -------------------------------------------------------------*/
     41          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     42          int errno;
   \                     errno:
   \   00000000                      DS8 4
     43          
     44          /* Private function prototypes -----------------------------------------------*/
     45          //void Event_Proc(void * pvParameters);
     46          static void prvTimerCallback(xTimerHandle xTimer);
     47          static void prvTimerCallback1000msec(xTimerHandle xTimer);
     48          static void prvwatchdogCallback(xTimerHandle xTimer);
     49          static void prvTimerCallbackFND(xTimerHandle xTimer);
     50          

   \                                 In section .bss, align 4
     51          xTimerHandle xTimer01	= NULL;
   \                     xTimer01:
   \   00000000                      DS8 4
     52          xTimerHandle xTimer02	= NULL;
   \                     xTimer02:
   \   00000004                      DS8 4
     53          xTimerHandle xTimer03	= NULL;
   \                     xTimer03:
   \   00000008                      DS8 4
     54          xTimerHandle xTimer04	= NULL;
   \                     xTimer04:
   \   0000000C                      DS8 4
     55          
     56          /**
     57            * @brief  Main program.
     58            * @param  None
     59            * @retval None
     60            */
     61             

   \                                 In section .text, align 2, keep-with-next
     62           int main(void)
     63          {
   \                     main: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
     64            RCC_ClocksTypeDef rcc_clocks;
     65              
     66          	BSP_Lowlevel_Init();
   \   00000004   0x.... 0x....      BL       BSP_Lowlevel_Init
     67          
     68          	RCC_GetClocksFreq(&rcc_clocks);
   \   00000008   0xA804             ADD      R0,SP,#+16
   \   0000000A   0x.... 0x....      BL       RCC_GetClocksFreq
     69          
     70          	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       SysTick_CLKSourceConfig
     71          	SysTick_Config( rcc_clocks.HCLK_Frequency / 100 ); 
   \   00000014   0x9805             LDR      R0,[SP, #+20]
   \   00000016   0x2164             MOVS     R1,#+100
   \   00000018   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001C   0x.... 0x....      BL       SysTick_Config
     72          
     73          	CommInit();                     //rs232 
   \   00000020   0x.... 0x....      BL       CommInit
     74            KeypadInit();                   //key
   \   00000024   0x.... 0x....      BL       KeypadInit
     75          	sys_struct_init();
   \   00000028   0x.... 0x....      BL       sys_struct_init
     76          	CLI_SetConsolPort(DEBUG_PORT);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       CLI_SetConsolPort
     77            DisplayLogo();
   \   00000032   0x.... 0x....      BL       DisplayLogo
     78            
     79          	/* Semaphore init */  
     80          	flashSemaphore_Init();
   \   00000036   0x.... 0x....      BL       flashSemaphore_Init
     81            framSemaphore_Init();
   \   0000003A   0x.... 0x....      BL       framSemaphore_Init
     82          	nvxSemaphore_init();
   \   0000003E   0x.... 0x....      BL       nvxSemaphore_init
     83          	BSRAMSemaphore_Init();
   \   00000042   0x.... 0x....      BL       BSRAMSemaphore_Init
     84          
     85          #if SCR_USE_NAND > 0
     86          	NandSemaphore_Init();
     87          	FSMC_NAND_Reset();
     88          	Nand_Make_Badblock_Table();
     89          	Nand_Read_BadblockData();
     90          #endif
     91          
     92          #if WATCHDOG_ENABLE > 0
     93          	IWDG_ReloadCounter();  
   \   00000046   0x.... 0x....      BL       IWDG_ReloadCounter
     94          #endif
     95            
     96          	/* Task Init */
     97          	xTaskCreate( Task_CLI, 	(signed portCHAR*)CLITASK_NAME,	configMINIMAL_STACK_SIZE*2,	(void *)&_sysinfo,	CLI_TASK_PRIO,	NULL);
   \   0000004A   0x.... 0x....      LDR.W    R4,??DataTable24_5
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x9003             STR      R0,[SP, #+12]
   \   00000052   0x9002             STR      R0,[SP, #+8]
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0x4623             MOV      R3,R4
   \   0000005C   0xF44F 0x7280      MOV      R2,#+256
   \   00000060   0x....             ADR.N    R1,??DataTable23  ;; "CLI"
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable24_6
   \   00000066   0x.... 0x....      BL       xTaskGenericCreate
     98          	xTaskCreate( TmrTask, 	(signed portCHAR*)TMRTASK_NAME,	configMINIMAL_STACK_SIZE*2,	(void *)&_sysinfo,	TMR_TASK_PRIO,	NULL);
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9003             STR      R0,[SP, #+12]
   \   0000006E   0x9002             STR      R0,[SP, #+8]
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x4623             MOV      R3,R4
   \   00000078   0xF44F 0x7280      MOV      R2,#+256
   \   0000007C   0x....             ADR.N    R1,??DataTable23_1  ;; "TMR"
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   00000082   0x.... 0x....      BL       xTaskGenericCreate
     99            xTaskCreate( Task_MOD,  (signed portCHAR*)MODTASK_NAME,	configMINIMAL_STACK_SIZE*4, (void *)&_sysinfo,	MOD_TASK_PRIO,	NULL);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9003             STR      R0,[SP, #+12]
   \   0000008A   0x9002             STR      R0,[SP, #+8]
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0x4623             MOV      R3,R4
   \   00000094   0xF44F 0x7200      MOV      R2,#+512
   \   00000098   0x....             ADR.N    R1,??DataTable23_2  ;; "MOD"
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable24_8
   \   0000009E   0x.... 0x....      BL       xTaskGenericCreate
    100          	xTaskCreate( Task_CAN,  (signed portCHAR*)CANTASK_NAME,	configMINIMAL_STACK_SIZE*2, (void *)&_sysinfo,	CAN_TASK_PRIO,	&xHandle_can);
   \   000000A2   0x.... 0x....      LDR.W    R5,??DataTable24_9
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x9003             STR      R0,[SP, #+12]
   \   000000AA   0x9002             STR      R0,[SP, #+8]
   \   000000AC   0x9501             STR      R5,[SP, #+4]
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0x9000             STR      R0,[SP, #+0]
   \   000000B2   0x4623             MOV      R3,R4
   \   000000B4   0xF44F 0x7280      MOV      R2,#+256
   \   000000B8   0x....             ADR.N    R1,??DataTable23_3  ;; "CAN"
   \   000000BA   0x....             LDR.N    R0,??DataTable24_10
   \   000000BC   0x.... 0x....      BL       xTaskGenericCreate
    101            xTaskCreate( Task_OBD,  (signed portCHAR*)OBDTASK_NAME,	configMINIMAL_STACK_SIZE*2, (void *)&_sysinfo,	OBD_TASK_PRIO,	NULL);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x9003             STR      R0,[SP, #+12]
   \   000000C4   0x9002             STR      R0,[SP, #+8]
   \   000000C6   0x9001             STR      R0,[SP, #+4]
   \   000000C8   0x2004             MOVS     R0,#+4
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x4623             MOV      R3,R4
   \   000000CE   0xF44F 0x7280      MOV      R2,#+256
   \   000000D2   0x....             ADR.N    R1,??DataTable23_4  ;; "OBD"
   \   000000D4   0x....             LDR.N    R0,??DataTable24_11
   \   000000D6   0x.... 0x....      BL       xTaskGenericCreate
    102            xTaskCreate( Task_GPS,  (signed portCHAR*)GPSTASK_NAME,	configMINIMAL_STACK_SIZE*2, (void *)&_sysinfo,	GPS_TASK_PRIO,	NULL);
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x9003             STR      R0,[SP, #+12]
   \   000000DE   0x9002             STR      R0,[SP, #+8]
   \   000000E0   0x9001             STR      R0,[SP, #+4]
   \   000000E2   0x2005             MOVS     R0,#+5
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0x4623             MOV      R3,R4
   \   000000E8   0xF44F 0x7280      MOV      R2,#+256
   \   000000EC   0x....             ADR.N    R1,??DataTable23_5  ;; "GPS"
   \   000000EE   0x....             LDR.N    R0,??DataTable24_12
   \   000000F0   0x.... 0x....      BL       xTaskGenericCreate
    103          	xTaskCreate( Task_KEY,  (signed portCHAR*)KEYTASK_NAME,	configMINIMAL_STACK_SIZE*2, (void *)&_sysinfo,	KEY_TASK_PRIO,	NULL);
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x9003             STR      R0,[SP, #+12]
   \   000000F8   0x9002             STR      R0,[SP, #+8]
   \   000000FA   0x9001             STR      R0,[SP, #+4]
   \   000000FC   0x2006             MOVS     R0,#+6
   \   000000FE   0x9000             STR      R0,[SP, #+0]
   \   00000100   0x4623             MOV      R3,R4
   \   00000102   0xF44F 0x7280      MOV      R2,#+256
   \   00000106   0x....             ADR.N    R1,??DataTable23_6  ;; "KEY"
   \   00000108   0x....             LDR.N    R0,??DataTable24_13
   \   0000010A   0x.... 0x....      BL       xTaskGenericCreate
    104            
    105            vTaskSuspend(xHandle_can); // CAN Task stop
   \   0000010E   0x6828             LDR      R0,[R5, #+0]
   \   00000110   0x.... 0x....      BL       vTaskSuspend
    106            
    107          	/* Timer Calback */
    108          	xTimer01     = xTimerCreate( ( const signed char * ) "led",( 100 / portTICK_RATE_MS ),pdTRUE,( void * ) 0, prvTimerCallback);
   \   00000114   0x.... 0x....      ADR.W    R0,prvTimerCallback
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0x2300             MOVS     R3,#+0
   \   0000011C   0x2201             MOVS     R2,#+1
   \   0000011E   0x2164             MOVS     R1,#+100
   \   00000120   0x....             ADR.N    R0,??DataTable24  ;; "led"
   \   00000122   0x.... 0x....      BL       xTimerCreate
   \   00000126   0x....             LDR.N    R4,??DataTable24_14
   \   00000128   0x6020             STR      R0,[R4, #+0]
    109          	if(xTimer01 != NULL) xTimerStart(xTimer01,0);
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD009             BEQ.N    ??main_0
   \   0000012E   0x.... 0x....      BL       xTaskGetTickCount
   \   00000132   0x4602             MOV      R2,R0
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x9000             STR      R0,[SP, #+0]
   \   00000138   0x4603             MOV      R3,R0
   \   0000013A   0x4601             MOV      R1,R0
   \   0000013C   0x6820             LDR      R0,[R4, #+0]
   \   0000013E   0x.... 0x....      BL       xTimerGenericCommand
    110          	xTimer02     = xTimerCreate( ( const signed char * ) "time",( 1000 / portTICK_RATE_MS ),pdTRUE,( void * ) 0, prvTimerCallback1000msec);
   \                     ??main_0: (+1)
   \   00000142   0x.... 0x....      ADR.W    R0,prvTimerCallback1000msec
   \   00000146   0x9000             STR      R0,[SP, #+0]
   \   00000148   0x2300             MOVS     R3,#+0
   \   0000014A   0x2201             MOVS     R2,#+1
   \   0000014C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000150   0x.... 0x....      ADR.W    R0,?_8
   \   00000154   0x.... 0x....      BL       xTimerCreate
   \   00000158   0x6060             STR      R0,[R4, #+4]
    111          	if(xTimer02 != NULL) xTimerStart(xTimer02,0);
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD008             BEQ.N    ??main_1
   \   0000015E   0x.... 0x....      BL       xTaskGetTickCount
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0x9100             STR      R1,[SP, #+0]
   \   00000166   0x460B             MOV      R3,R1
   \   00000168   0x4602             MOV      R2,R0
   \   0000016A   0x6860             LDR      R0,[R4, #+4]
   \   0000016C   0x.... 0x....      BL       xTimerGenericCommand
    112          	xTimer03     = xTimerCreate( ( const signed char * ) "watch", ( 100 / portTICK_RATE_MS ),pdTRUE,( void * ) 0, prvwatchdogCallback);	
   \                     ??main_1: (+1)
   \   00000170   0x.... 0x....      ADR.W    R0,prvwatchdogCallback
   \   00000174   0x9000             STR      R0,[SP, #+0]
   \   00000176   0x2300             MOVS     R3,#+0
   \   00000178   0x2201             MOVS     R2,#+1
   \   0000017A   0x2164             MOVS     R1,#+100
   \   0000017C   0x.... 0x....      ADR.W    R0,?_9
   \   00000180   0x.... 0x....      BL       xTimerCreate
   \   00000184   0x60A0             STR      R0,[R4, #+8]
    113          	if(xTimer03 != NULL) xTimerStart(xTimer03,0);
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD008             BEQ.N    ??main_2
   \   0000018A   0x.... 0x....      BL       xTaskGetTickCount
   \   0000018E   0x2100             MOVS     R1,#+0
   \   00000190   0x9100             STR      R1,[SP, #+0]
   \   00000192   0x460B             MOV      R3,R1
   \   00000194   0x4602             MOV      R2,R0
   \   00000196   0x68A0             LDR      R0,[R4, #+8]
   \   00000198   0x.... 0x....      BL       xTimerGenericCommand
    114          	xTimer04     = xTimerCreate( ( const signed char * ) "fnd",( 2 / portTICK_RATE_MS ),pdTRUE,( void * ) 0, prvTimerCallbackFND);
   \                     ??main_2: (+1)
   \   0000019C   0x.... 0x....      ADR.W    R0,prvTimerCallbackFND
   \   000001A0   0x9000             STR      R0,[SP, #+0]
   \   000001A2   0x2300             MOVS     R3,#+0
   \   000001A4   0x2201             MOVS     R2,#+1
   \   000001A6   0x2102             MOVS     R1,#+2
   \   000001A8   0x....             ADR.N    R0,??DataTable24_1  ;; "fnd"
   \   000001AA   0x.... 0x....      BL       xTimerCreate
   \   000001AE   0x60E0             STR      R0,[R4, #+12]
    115          	if(xTimer04 != NULL) xTimerStart(xTimer04,0);
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD008             BEQ.N    ??main_3
   \   000001B4   0x.... 0x....      BL       xTaskGetTickCount
   \   000001B8   0x2100             MOVS     R1,#+0
   \   000001BA   0x9100             STR      R1,[SP, #+0]
   \   000001BC   0x460B             MOV      R3,R1
   \   000001BE   0x4602             MOV      R2,R0
   \   000001C0   0x68E0             LDR      R0,[R4, #+12]
   \   000001C2   0x.... 0x....      BL       xTimerGenericCommand
    116          
    117          	/* Start scheduler */
    118          	vTaskStartScheduler();
   \                     ??main_3: (+1)
   \   000001C6   0x.... 0x....      BL       vTaskStartScheduler
    119          
    120            /* We should never get here as control is now taken by the scheduler */
    121              for( ;; )
    122          	{
    123          		vTaskDelay(2000);
   \                     ??main_4: (+1)
   \   000001CA   0xF44F 0x60FA      MOV      R0,#+2000
   \   000001CE   0x.... 0x....      BL       vTaskDelay
   \   000001D2   0xE7FA             B.N      ??main_4
    124          	}
    125          }
    126          

   \                                 In section .text, align 4, keep-with-next
    127          static void prvTimerCallback1000msec(xTimerHandle xTimer)
    128          {
   \                     prvTimerCallback1000msec: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    129            if(Flags.CANWaitFlag == 1)SendSaveFlag();
   \   00000002   0x....             LDR.N    R4,??DataTable24_15
   \   00000004   0xF8B4 0x0001      LDRH     R0,[R4, #+1]
   \   00000008   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??prvTimerCallback1000msec_0
   \   00000010   0x.... 0x....      BL       SendSaveFlag
    130            Flags.KeyOnFlag = 1;
    131            Flags.IntFlag = 1;
   \                     ??prvTimerCallback1000msec_0: (+1)
   \   00000014   0x8820             LDRH     R0,[R4, #+0]
   \   00000016   0xF640 0x0101      MOVW     R1,#+2049
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x8020             STRH     R0,[R4, #+0]
    132            KeyOn_Check();
   \   0000001E   0x....             LDR.N    R4,??DataTable24_16
   \   00000020   0xF44F 0x7180      MOV      R1,#+256
   \   00000024   0x....             LDR.N    R0,??DataTable24_17  ;; 0x40020000
   \   00000026   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
   \   00000030   0xD004             BEQ.N    ??prvTimerCallback1000msec_1
   \   00000032   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000036   0xF8A4 0x005A      STRH     R0,[R4, #+90]
   \   0000003A   0xE004             B.N      ??prvTimerCallback1000msec_2
   \                     ??prvTimerCallback1000msec_1: (+1)
   \   0000003C   0xF64F 0x71FB      MOVW     R1,#+65531
   \   00000040   0x4008             ANDS     R0,R1,R0
   \   00000042   0xF8A4 0x005A      STRH     R0,[R4, #+90]
    133            
    134            //TANK LEVEL 카운터
    135          	if(Flags1.HTLvHCntFlag) HTLvHCnt++;
   \                     ??prvTimerCallback1000msec_2: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable24_18
   \   00000048   0x8801             LDRH     R1,[R0, #+0]
   \   0000004A   0x....             LDR.N    R2,??DataTable24_19
   \   0000004C   0xF3C1 0x03C0      UBFX     R3,R1,#+3,#+1
   \   00000050   0x2B00             CMP      R3,#+0
   \   00000052   0xD003             BEQ.N    ??prvTimerCallback1000msec_3
   \   00000054   0x8813             LDRH     R3,[R2, #+0]
   \   00000056   0x1C5B             ADDS     R3,R3,#+1
   \   00000058   0x8013             STRH     R3,[R2, #+0]
   \   0000005A   0xE001             B.N      ??prvTimerCallback1000msec_4
    136          	else HTLvHCnt = 0;
   \                     ??prvTimerCallback1000msec_3: (+1)
   \   0000005C   0x2300             MOVS     R3,#+0
   \   0000005E   0x8013             STRH     R3,[R2, #+0]
    137          
    138          	if(Flags1.HTLvLCntFlag) HTLvLCnt++;
   \                     ??prvTimerCallback1000msec_4: (+1)
   \   00000060   0x....             LDR.N    R2,??DataTable24_20
   \   00000062   0xF3C1 0x1300      UBFX     R3,R1,#+4,#+1
   \   00000066   0x2B00             CMP      R3,#+0
   \   00000068   0xD003             BEQ.N    ??prvTimerCallback1000msec_5
   \   0000006A   0x8813             LDRH     R3,[R2, #+0]
   \   0000006C   0x1C5B             ADDS     R3,R3,#+1
   \   0000006E   0x8013             STRH     R3,[R2, #+0]
   \   00000070   0xE001             B.N      ??prvTimerCallback1000msec_6
    139          	else HTLvLCnt = 0;
   \                     ??prvTimerCallback1000msec_5: (+1)
   \   00000072   0x2300             MOVS     R3,#+0
   \   00000074   0x8013             STRH     R3,[R2, #+0]
    140            
    141          	if(Flags1.QualityCntFlag) QualityCnt++;
   \                     ??prvTimerCallback1000msec_6: (+1)
   \   00000076   0x....             LDR.N    R2,??DataTable24_21
   \   00000078   0xF3C1 0x0380      UBFX     R3,R1,#+2,#+1
   \   0000007C   0x2B00             CMP      R3,#+0
   \   0000007E   0xD003             BEQ.N    ??prvTimerCallback1000msec_7
   \   00000080   0x8813             LDRH     R3,[R2, #+0]
   \   00000082   0x1C5B             ADDS     R3,R3,#+1
   \   00000084   0x8013             STRH     R3,[R2, #+0]
   \   00000086   0xE001             B.N      ??prvTimerCallback1000msec_8
    142          	else QualityCnt = 0;
   \                     ??prvTimerCallback1000msec_7: (+1)
   \   00000088   0x2300             MOVS     R3,#+0
   \   0000008A   0x8013             STRH     R3,[R2, #+0]
    143            
    144            if(!Flags1.BuzzerFlag && TLv_Beep) {
   \                     ??prvTimerCallback1000msec_8: (+1)
   \   0000008C   0xF3C1 0x2200      UBFX     R2,R1,#+8,#+1
   \   00000090   0x2A00             CMP      R2,#+0
   \   00000092   0xD10D             BNE.N    ??prvTimerCallback1000msec_9
   \   00000094   0x....             LDR.N    R2,??DataTable24_22
   \   00000096   0x8813             LDRH     R3,[R2, #+0]
   \   00000098   0x001C             MOVS     R4,R3
   \   0000009A   0xD009             BEQ.N    ??prvTimerCallback1000msec_9
    145              if(TLv_Beep > 3) TLv_Beep = 3;
   \   0000009C   0x2B04             CMP      R3,#+4
   \   0000009E   0xDB01             BLT.N    ??prvTimerCallback1000msec_10
   \   000000A0   0x2303             MOVS     R3,#+3
   \   000000A2   0x8013             STRH     R3,[R2, #+0]
    146              Flags1.BuzzerFlag = 1;
   \                     ??prvTimerCallback1000msec_10: (+1)
   \   000000A4   0xF441 0x7180      ORR      R1,R1,#0x100
   \   000000A8   0x8001             STRH     R1,[R0, #+0]
    147              TLv_Beep--;
   \   000000AA   0x8811             LDRH     R1,[R2, #+0]
   \   000000AC   0x1E49             SUBS     R1,R1,#+1
   \   000000AE   0x8011             STRH     R1,[R2, #+0]
    148            }
    149            
    150            if(key.kiflag)
   \                     ??prvTimerCallback1000msec_9: (+1)
   \   000000B0   0x....             LDR.N    R1,??DataTable24_23
   \   000000B2   0x784A             LDRB     R2,[R1, #+1]
   \   000000B4   0x2A00             CMP      R2,#+0
   \   000000B6   0xD00A             BEQ.N    ??prvTimerCallback1000msec_11
    151            {
    152              key.keycount++;
   \   000000B8   0x890A             LDRH     R2,[R1, #+8]
   \   000000BA   0x1C52             ADDS     R2,R2,#+1
   \   000000BC   0x810A             STRH     R2,[R1, #+8]
    153              if(key.keycount > 3){
   \   000000BE   0xB292             UXTH     R2,R2
   \   000000C0   0x2A04             CMP      R2,#+4
   \   000000C2   0xDB04             BLT.N    ??prvTimerCallback1000msec_11
    154                keyflag.longflag = 1;
   \   000000C4   0x2201             MOVS     R2,#+1
   \   000000C6   0x....             LDR.N    R3,??DataTable24_24
   \   000000C8   0x719A             STRB     R2,[R3, #+6]
    155                key.keycount = 0;
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0x810A             STRH     R2,[R1, #+8]
    156              }                  
    157            }
    158          
    159            Flags1.DispFlag = 1;
   \                     ??prvTimerCallback1000msec_11: (+1)
   \   000000CE   0x8801             LDRH     R1,[R0, #+0]
   \   000000D0   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000D4   0x8001             STRH     R1,[R0, #+0]
    160          }
   \   000000D6   0xBD10             POP      {R4,PC}          ;; return
    161          
    162          /* 100mSec 간격으로 Callback Function				                    *
    163          ** 각 Sensor의 값을 계산                                        *
    164          ** LED 100msec, 500msec Control                                 *
    165          */

   \                                 In section .text, align 4, keep-with-next
    166          static void prvTimerCallback(xTimerHandle xTimer)
    167          {
   \                     prvTimerCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    168          
    169          	if(TmrChk(TMR_LED) == 0)
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x.... 0x....      BL       TmrChk
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD10C             BNE.N    ??prvTimerCallback_0
    170          	{
    171          		TmrSetT(TMR_LED, 500);
   \   0000000C   0xF44F 0x71FA      MOV      R1,#+500
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x.... 0x....      BL       TmrSetT
    172          		TmrStart(TMR_LED);
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x.... 0x....      BL       TmrStart
    173          		BSP_LED_Toggle(1);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000022   0x.... 0x....      B.W      BSP_LED_Toggle
    174          //    if(!FotaFlag) ReadValue.ObdTemp = Read_max6675();	    //K type
    175          //    ReadValue.ObdPress = Pressure_Process();	//24DPS100-01
    176          	}
    177          }
   \                     ??prvTimerCallback_0: (+1)
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    178          
    179          /* 2mSec 간격으로 Callback Function				                           *
    180          ** 출력 데이터를 FND에 Display                                       *
    181          ** 시간을 짧게 할수록 FND 밝기를 진하게 함.                          *
    182          */

   \                                 In section .text, align 4, keep-with-next
    183          static void prvTimerCallbackFND(xTimerHandle xTimer)
    184          {
    185          
    186          	fnd_callback_fun();
   \                     prvTimerCallbackFND: (+1)
   \   00000000   0x.... 0x....      B.W      fnd_callback_fun
    187          
    188          }
    189          
    190          /* 
    191          ** Task 만들경우 아래 함수도 Flag을 추가 해야한다.				                  *
    192          ** sys_struct.h에Flag, Counter 변수을 추가, Task에 while문에 추가           *
    193          ** Task가 무한 루프에 빠지게 되면 Callback function에서 Watchdog을 시동한다.*
    194          */

   \                                 In section .text, align 4, keep-with-next
    195          static void prvwatchdogCallback(xTimerHandle xTimer)
    196          {
   \                     prvwatchdogCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    197          
    198          	sysinfo_t *s = &_sysinfo 	;
    199          
    200          	if( s->twatchCliFlag  && (s->twatchCliCount++ >= 20) )
   \   00000002   0x....             LDR.N    R4,??DataTable24_5
   \   00000004   0x78E0             LDRB     R0,[R4, #+3]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00B             BEQ.N    ??prvwatchdogCallback_0
   \   0000000A   0x7920             LDRB     R0,[R4, #+4]
   \   0000000C   0x1C41             ADDS     R1,R0,#+1
   \   0000000E   0x7121             STRB     R1,[R4, #+4]
   \   00000010   0x2814             CMP      R0,#+20
   \   00000012   0xDB06             BLT.N    ??prvwatchdogCallback_0
    201          	{
    202          		s->tInfiniteLoop = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x70A0             STRB     R0,[R4, #+2]
    203          		printk("CLI wait 3Sec ......\n");
   \   00000018   0x.... 0x....      ADR.W    R0,?_11
   \   0000001C   0x.... 0x....      BL       printk
   \   00000020   0xE001             B.N      ??prvwatchdogCallback_1
    204          	}
    205          	else					s->twatchCliCount = 0;
   \                     ??prvwatchdogCallback_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x7120             STRB     R0,[R4, #+4]
    206          
    207          	if(s->twatchCanFlag && (s->twatchCanCount++ >= 20) )
   \                     ??prvwatchdogCallback_1: (+1)
   \   00000026   0x79E0             LDRB     R0,[R4, #+7]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD00B             BEQ.N    ??prvwatchdogCallback_2
   \   0000002C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000002E   0x1C41             ADDS     R1,R0,#+1
   \   00000030   0x7221             STRB     R1,[R4, #+8]
   \   00000032   0x2814             CMP      R0,#+20
   \   00000034   0xDB06             BLT.N    ??prvwatchdogCallback_2
    208          	{
    209          		s->tInfiniteLoop = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x70A0             STRB     R0,[R4, #+2]
    210          		printk("CAN OBD wait 3Sec ......\n");
   \   0000003A   0x.... 0x....      ADR.W    R0,?_12
   \   0000003E   0x.... 0x....      BL       printk
   \   00000042   0xE001             B.N      ??prvwatchdogCallback_3
    211          	}
    212          	else					s->twatchCanCount = 0;
   \                     ??prvwatchdogCallback_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x7220             STRB     R0,[R4, #+8]
    213          	if(s->twatchUSBFlag && (s->twatchUSBCount++ >= 20) )
   \                     ??prvwatchdogCallback_3: (+1)
   \   00000048   0x7A60             LDRB     R0,[R4, #+9]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00B             BEQ.N    ??prvwatchdogCallback_4
   \   0000004E   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000050   0x1C41             ADDS     R1,R0,#+1
   \   00000052   0x72A1             STRB     R1,[R4, #+10]
   \   00000054   0x2814             CMP      R0,#+20
   \   00000056   0xDB06             BLT.N    ??prvwatchdogCallback_4
    214          	{
    215          		s->tInfiniteLoop = 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x70A0             STRB     R0,[R4, #+2]
    216          		printk("USB Host wait 3Sec ......\n");
   \   0000005C   0x.... 0x....      ADR.W    R0,?_13
   \   00000060   0x.... 0x....      BL       printk
   \   00000064   0xE001             B.N      ??prvwatchdogCallback_5
    217          	}
    218          	else					s->twatchUSBCount = 0;
   \                     ??prvwatchdogCallback_4: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x72A0             STRB     R0,[R4, #+10]
    219          	if(s->twatchKeyFlag && (s->twatchKeyCount++ >= 20) )
   \                     ??prvwatchdogCallback_5: (+1)
   \   0000006A   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00B             BEQ.N    ??prvwatchdogCallback_6
   \   00000070   0x7B20             LDRB     R0,[R4, #+12]
   \   00000072   0x1C41             ADDS     R1,R0,#+1
   \   00000074   0x7321             STRB     R1,[R4, #+12]
   \   00000076   0x2814             CMP      R0,#+20
   \   00000078   0xDB06             BLT.N    ??prvwatchdogCallback_6
    220          	{
    221          		s->tInfiniteLoop = 1;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x70A0             STRB     R0,[R4, #+2]
    222          		printk("Key wait 3Sec ......\n");
   \   0000007E   0x.... 0x....      ADR.W    R0,?_14
   \   00000082   0x.... 0x....      BL       printk
   \   00000086   0xE001             B.N      ??prvwatchdogCallback_7
    223          	}
    224          	else					s->twatchKeyCount = 0;
   \                     ??prvwatchdogCallback_6: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x7320             STRB     R0,[R4, #+12]
    225          	if(s->twatchObdFlag && (s->twatchObdCount++ >= 20) )
   \                     ??prvwatchdogCallback_7: (+1)
   \   0000008C   0x7B60             LDRB     R0,[R4, #+13]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00B             BEQ.N    ??prvwatchdogCallback_8
   \   00000092   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000094   0x1C41             ADDS     R1,R0,#+1
   \   00000096   0x73A1             STRB     R1,[R4, #+14]
   \   00000098   0x2814             CMP      R0,#+20
   \   0000009A   0xDB06             BLT.N    ??prvwatchdogCallback_8
    226          	{
    227          		s->tInfiniteLoop = 1;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x70A0             STRB     R0,[R4, #+2]
    228          		printk("OBD wait 3Sec ......\n");
   \   000000A0   0x.... 0x....      ADR.W    R0,?_15
   \   000000A4   0x.... 0x....      BL       printk
   \   000000A8   0xE001             B.N      ??prvwatchdogCallback_9
    229          	}
    230          	else					s->twatchObdCount = 0;
   \                     ??prvwatchdogCallback_8: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x73A0             STRB     R0,[R4, #+14]
    231          	if(s->twatchModFlag && (s->twatchModCount++ >= 20) )
   \                     ??prvwatchdogCallback_9: (+1)
   \   000000AE   0x7BE0             LDRB     R0,[R4, #+15]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD00B             BEQ.N    ??prvwatchdogCallback_10
   \   000000B4   0x7C20             LDRB     R0,[R4, #+16]
   \   000000B6   0x1C41             ADDS     R1,R0,#+1
   \   000000B8   0x7421             STRB     R1,[R4, #+16]
   \   000000BA   0x2814             CMP      R0,#+20
   \   000000BC   0xDB06             BLT.N    ??prvwatchdogCallback_10
    232          	{
    233          		s->tInfiniteLoop = 1;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x70A0             STRB     R0,[R4, #+2]
    234          		printk("Modem wait 3Sec ......\n");
   \   000000C2   0x.... 0x....      ADR.W    R0,?_16
   \   000000C6   0x.... 0x....      BL       printk
   \   000000CA   0xE001             B.N      ??prvwatchdogCallback_11
    235          	}
    236          	else					s->twatchModCount = 0;  
   \                     ??prvwatchdogCallback_10: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x7420             STRB     R0,[R4, #+16]
    237          	if(s->twatchGpsFlag && (s->twatchGpsCount++ >= 20) )
   \                     ??prvwatchdogCallback_11: (+1)
   \   000000D0   0x7C60             LDRB     R0,[R4, #+17]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD00B             BEQ.N    ??prvwatchdogCallback_12
   \   000000D6   0x7CA0             LDRB     R0,[R4, #+18]
   \   000000D8   0x1C41             ADDS     R1,R0,#+1
   \   000000DA   0x74A1             STRB     R1,[R4, #+18]
   \   000000DC   0x2814             CMP      R0,#+20
   \   000000DE   0xDB06             BLT.N    ??prvwatchdogCallback_12
    238          	{
    239          		s->tInfiniteLoop = 1;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x70A0             STRB     R0,[R4, #+2]
    240          		printk("GPS wait 3Sec ......\n");
   \   000000E4   0x.... 0x....      ADR.W    R0,?_17
   \   000000E8   0x.... 0x....      BL       printk
   \   000000EC   0xE001             B.N      ??prvwatchdogCallback_13
    241          	}
    242          	else					s->twatchGpsCount = 0;   
   \                     ??prvwatchdogCallback_12: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x74A0             STRB     R0,[R4, #+18]
    243          	/* Reload IWDG counter */
    244          	if( !s->tInfiniteLoop )
   \                     ??prvwatchdogCallback_13: (+1)
   \   000000F2   0x78A0             LDRB     R0,[R4, #+2]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD103             BNE.N    ??prvwatchdogCallback_14
    245          	{
    246          #if WATCHDOG_ENABLE > 0
    247          		IWDG_ReloadCounter();  
   \   000000F8   0xE8BD 0x4010      POP      {R4,LR}
   \   000000FC   0x.... 0x....      B.W      IWDG_ReloadCounter
    248          #endif
    249          	}
    250          }
   \                     ??prvwatchdogCallback_14: (+1)
   \   00000100   0xBD10             POP      {R4,PC}          ;; return
    251          
    252          

   \                                 In section .text, align 2, keep-with-next
    253          void vApplicationIdleHook( void )
    254          {
   \                     vApplicationIdleHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255          volatile size_t xFreeStackSpace;
    256          
    257          	/* This function is called on each cycle of the idle task.  In this case it
    258          	does nothing useful, other than report the amout of FreeRTOS heap that 
    259          	remains unallocated. */
    260          	xFreeStackSpace = xPortGetFreeHeapSize();
   \   00000002   0x.... 0x....      BL       xPortGetFreeHeapSize
   \   00000006   0x9000             STR      R0,[SP, #+0]
    261          
    262          	if( xFreeStackSpace > 100 )
   \   00000008   0x9800             LDR      R0,[SP, #+0]
    263          	{
    264          		/* By now, the kernel has allocated everything it is going to, so
    265          		if there is a lot of heap remaining unallocated then
    266          		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
    267          		reduced accordingly. */
    268          	}
    269          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    270          
    271          

   \                                 In section .text, align 2, keep-with-next
    272          void vApplicationMallocFailedHook( void )
    273          {
   \                     vApplicationMallocFailedHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    274          	/* Called if a call to pvPortMalloc() fails because there is insufficient
    275          	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
    276          	internally by FreeRTOS API functions that create tasks, queues, software 
    277          	timers, and semaphores.  The size of the FreeRTOS heap is set by the
    278          	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
    279          	printd("vApplicationMallocFailedHook....\n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_18
   \   00000006   0x.... 0x....      BL       printd
    280          	for( ;; );
   \                     ??vApplicationMallocFailedHook_0: (+1)
   \   0000000A   0xE7FE             B.N      ??vApplicationMallocFailedHook_0
    281          }
    282          

   \                                 In section .text, align 2, keep-with-next
    283          void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName )
    284          {
   \                     vApplicationStackOverflowHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    285          	( void ) pcTaskName;
    286          	( void ) pxTask;
    287          
    288          	/* Run time stack overflow checking is performed if
    289          	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
    290          	function is called if a stack overflow is detected. */
    291          	printd("StackOverflowHook....%s\n",pcTaskName);
   \   00000002   0x.... 0x....      ADR.W    R0,?_19
   \   00000006   0x.... 0x....      BL       printd
    292          	for( ;; );
   \                     ??vApplicationStackOverflowHook_0: (+1)
   \   0000000A   0xE7FE             B.N      ??vApplicationStackOverflowHook_0
    293          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x43 0x4C          DC8      "CLI"
   \              0x49 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x54 0x4D          DC8      "TMR"
   \              0x52 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x4D 0x4F          DC8      "MOD"
   \              0x44 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x43 0x41          DC8      "CAN"
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x4F 0x42          DC8      "OBD"
   \              0x44 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x47 0x50          DC8      "GPS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x4B 0x45          DC8      "KEY"
   \              0x59 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x6C 0x65          DC8      "led"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x66 0x6E          DC8      "fnd"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x........         DC32     _sysinfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x........         DC32     Task_CLI

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     TmrTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x........         DC32     Task_MOD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     xHandle_can

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     Task_CAN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x........         DC32     Task_OBD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x........         DC32     Task_GPS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x........         DC32     Task_KEY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x........         DC32     xTimer01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x........         DC32     Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \   00000000   0x........         DC32     ReadValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \   00000000   0x........         DC32     Flags1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \   00000000   0x........         DC32     HTLvHCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_20:
   \   00000000   0x........         DC32     HTLvLCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_21:
   \   00000000   0x........         DC32     QualityCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_22:
   \   00000000   0x........         DC32     TLv_Beep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_23:
   \   00000000   0x........         DC32     key

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_24:
   \   00000000   0x........         DC32     keyflag

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x43 0x4C          DC8 "CLI"
   \              0x49 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x54 0x4D          DC8 "TMR"
   \              0x52 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x4D 0x4F          DC8 "MOD"
   \              0x44 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x43 0x41          DC8 "CAN"
   \              0x4E 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x4F 0x42          DC8 "OBD"
   \              0x44 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x47 0x50          DC8 "GPS"
   \              0x53 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x4B 0x45          DC8 "KEY"
   \              0x59 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x6C 0x65          DC8 "led"
   \              0x64 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x66 0x6E          DC8 "fnd"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x74 0x69          DC8 "time"
   \              0x6D 0x65    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x77 0x61          DC8 "watch"
   \              0x74 0x63    
   \              0x68 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x43 0x4C          DC8 "CLI wait 3Sec ......\012"
   \              0x49 0x20    
   \              0x77 0x61    
   \              0x69 0x74    
   \              0x20 0x33    
   \              0x53 0x65    
   \              0x63 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x43 0x41          DC8 "CAN OBD wait 3Sec ......\012"
   \              0x4E 0x20    
   \              0x4F 0x42    
   \              0x44 0x20    
   \              0x77 0x61    
   \              0x69 0x74    
   \              0x20 0x33    
   \              0x53 0x65    
   \              0x63 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x55 0x53          DC8 "USB Host wait 3Sec ......\012"
   \              0x42 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x77    
   \              0x61 0x69    
   \              0x74 0x20    
   \              0x33 0x53    
   \              0x65 0x63    
   \              0x20 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x4B 0x65          DC8 "Key wait 3Sec ......\012"
   \              0x79 0x20    
   \              0x77 0x61    
   \              0x69 0x74    
   \              0x20 0x33    
   \              0x53 0x65    
   \              0x63 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x4F 0x42          DC8 "OBD wait 3Sec ......\012"
   \              0x44 0x20    
   \              0x77 0x61    
   \              0x69 0x74    
   \              0x20 0x33    
   \              0x53 0x65    
   \              0x63 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x4D 0x6F          DC8 "Modem wait 3Sec ......\012"
   \              0x64 0x65    
   \              0x6D 0x20    
   \              0x77 0x61    
   \              0x69 0x74    
   \              0x20 0x33    
   \              0x53 0x65    
   \              0x63 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x47 0x50          DC8 "GPS wait 3Sec ......\012"
   \              0x53 0x20    
   \              0x77 0x61    
   \              0x69 0x74    
   \              0x20 0x33    
   \              0x53 0x65    
   \              0x63 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x76 0x41          DC8 "vApplicationMallocFailedHook....\012"
   \              0x70 0x70    
   \              0x6C 0x69    
   \              0x63 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x4D 0x61    
   \              0x6C 0x6C    
   \              0x6F 0x63    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x48 0x6F    
   \              0x6F 0x6B    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x53 0x74          DC8 "StackOverflowHook....%s\012"
   \              0x61 0x63    
   \              0x6B 0x4F    
   \              0x76 0x65    
   \              0x72 0x66    
   \              0x6C 0x6F    
   \              0x77 0x48    
   \              0x6F 0x6F    
   \              0x6B 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    294          
    295          
    296          
    297          #ifdef  USE_FULL_ASSERT
    298          
    299          /**
    300            * @brief  Reports the name of the source file and the source line number
    301            *   where the assert_param error has occurred.
    302            * @param  file: pointer to the source file name
    303            * @param  line: assert_param error line source number
    304            * @retval None
    305            */
    306          void assert_failed(uint8_t* file, uint32_t line)
    307          {
    308            /* User can add his own implementation to report the file name and line number,
    309               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    310          
    311            /* Infinite loop */
    312            while (1)
    313            {}
    314          }
    315          #endif
    316          
    317          
    318          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_SetPriority
       8   SysTick_Config
         8   -> NVIC_SetPriority
      48   main
        48   -> BSP_Lowlevel_Init
        48   -> BSRAMSemaphore_Init
        48   -> CLI_SetConsolPort
        48   -> CommInit
        48   -> DisplayLogo
        48   -> IWDG_ReloadCounter
        48   -> KeypadInit
        48   -> RCC_GetClocksFreq
        48   -> SysTick_CLKSourceConfig
        48   -> SysTick_Config
        48   -> flashSemaphore_Init
        48   -> framSemaphore_Init
        48   -> nvxSemaphore_init
        48   -> sys_struct_init
        48   -> vTaskDelay
        48   -> vTaskStartScheduler
        48   -> vTaskSuspend
        48   -> xTaskGenericCreate
        48   -> xTaskGetTickCount
        48   -> xTimerCreate
        48   -> xTimerGenericCommand
       8   prvTimerCallback
         0   -> BSP_LED_Toggle
         8   -> TmrChk
         8   -> TmrSetT
         8   -> TmrStart
       8   prvTimerCallback1000msec
         8   -> GPIO_ReadInputDataBit
         8   -> SendSaveFlag
       0   prvTimerCallbackFND
         0   -> fnd_callback_fun
       8   prvwatchdogCallback
         0   -> IWDG_ReloadCounter
         8   -> printk
       8   vApplicationIdleHook
         8   -> xPortGetFreeHeapSize
       8   vApplicationMallocFailedHook
         8   -> printd
       8   vApplicationStackOverflowHook
         8   -> printd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       4  ?_0
       4  ?_1
       4  ?_10
      24  ?_11
      28  ?_12
      28  ?_13
      24  ?_14
      24  ?_15
      24  ?_16
      24  ?_17
      36  ?_18
      28  ?_19
       4  ?_2
       4  ?_3
       4  ?_4
       4  ?_5
       4  ?_6
       4  ?_7
       8  ?_8
       8  ?_9
       4  BSP_BKRtcSem
       4  BSP_BKSramSem
       4  BSP_CanSem
       4  BSP_I2C1Sem
       4  BSP_KeySem
       4  BSP_NANDSem
       4  BSP_SaveSem
      30  NVIC_SetPriority
     548  SD_Fil
     564  SD_Fs
       4  SpiFlashDevSem
      42  SysTick_Config
     548  USB_Fil
     564  USB_Fs
       4  errno
     468  main
      40  prvTimerCallback
     216  prvTimerCallback1000msec
       4  prvTimerCallbackFND
     258  prvwatchdogCallback
      12  vApplicationIdleHook
      12  vApplicationMallocFailedHook
      12  vApplicationStackOverflowHook
      16  xTimer01
          xTimer02
          xTimer03
          xTimer04

 
 2 276 bytes in section .bss
    36 bytes in section .rodata
 1 478 bytes in section .text
 
 1 478 bytes of CODE  memory
    36 bytes of CONST memory
 2 276 bytes of DATA  memory

Errors: none
Warnings: none
