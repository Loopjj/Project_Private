###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:16
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\croutine.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\croutine.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\croutine.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\croutine.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Util\Third_Party\FreeRTOS_v7.6.0\croutine.c
      1          /*
      2              FreeRTOS V7.6.0 - Copyright (C) 2013 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          #include "FreeRTOS.h"
     67          #include "task.h"
     68          #include "croutine.h"
     69          
     70          /*
     71           * Some kernel aware debuggers require data to be viewed to be global, rather
     72           * than file scope.
     73           */
     74          #ifdef portREMOVE_STATIC_QUALIFIER
     75          	#define static
     76          #endif
     77          
     78          
     79          /* Lists for ready and blocked co-routines. --------------------*/

   \                                 In section .bss, align 4
     80          static xList pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
     81          static xList xDelayedCoRoutineList1;									/*< Delayed co-routines. */
     82          static xList xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
     83          static xList * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
     84          static xList * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
     85          static xList xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
   \                     xPendingReadyCoRoutineList:
   \   00000000                      DS8 20
   \   00000014                      DS8 40
   \   0000003C                      DS8 4
   \   00000040                      DS8 4
     86          
     87          /* Other file private variables. --------------------------------*/
     88          corCRCB * pxCurrentCoRoutine = NULL;
   \                     pxCurrentCoRoutine:
   \   00000044                      DS8 4
   \   00000048                      DS8 4
   \   0000004C                      DS8 4
   \   00000050                      DS8 4
   \   00000054                      DS8 4
   \   00000058                      DS8 20
   \   0000006C                      DS8 20
     89          static unsigned portBASE_TYPE uxTopCoRoutineReadyPriority = 0;
     90          static portTickType xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
     91          
     92          /* The initial state of the co-routine when it is created. */
     93          #define corINITIAL_STATE	( 0 )
     94          
     95          /*
     96           * Place the co-routine represented by pxCRCB into the appropriate ready queue
     97           * for the priority.  It is inserted at the end of the list.
     98           *
     99           * This macro accesses the co-routine ready lists and therefore must not be
    100           * used from within an ISR.
    101           */
    102          #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
    103          {																													\
    104          	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
    105          	{																												\
    106          		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
    107          	}																												\
    108          	vListInsertEnd( ( xList * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
    109          }
    110          
    111          /*
    112           * Utility to ready all the lists used by the scheduler.  This is called
    113           * automatically upon the creation of the first co-routine.
    114           */
    115          static void prvInitialiseCoRoutineLists( void );
    116          
    117          /*
    118           * Co-routines that are readied by an interrupt cannot be placed directly into
    119           * the ready lists (there is no mutual exclusion).  Instead they are placed in
    120           * in the pending ready list in order that they can later be moved to the ready
    121           * list by the co-routine scheduler.
    122           */
    123          static void prvCheckPendingReadyList( void );
    124          
    125          /*
    126           * Macro that looks at the list of co-routines that are currently delayed to
    127           * see if any require waking.
    128           *
    129           * Co-routines are stored in the queue in the order of their wake time -
    130           * meaning once one co-routine has been found whose timer has not expired
    131           * we need not look any further down the list.
    132           */
    133          static void prvCheckDelayedList( void );
    134          
    135          /*-----------------------------------------------------------*/
    136          

   \                                 In section .text, align 2, keep-with-next
    137          signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
    138          {
   \                     xCoRoutineCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
    139          signed portBASE_TYPE xReturn;
    140          corCRCB *pxCoRoutine;
    141          
    142          	/* Allocate the memory that will store the co-routine control block. */
    143          	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
   \   0000000A   0x2038             MOVS     R0,#+56
   \   0000000C   0x.... 0x....      BL       pvPortMalloc
   \   00000010   0x0004             MOVS     R4,R0
    144          	if( pxCoRoutine )
   \   00000012   0xD02B             BEQ.N    ??xCoRoutineCreate_0
    145          	{
    146          		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
    147          		be created and the co-routine data structures need initialising. */
    148          		if( pxCurrentCoRoutine == NULL )
   \   00000014   0x....             LDR.N    R5,??DataTable6
   \   00000016   0x6C68             LDR      R0,[R5, #+68]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD102             BNE.N    ??xCoRoutineCreate_1
    149          		{
    150          			pxCurrentCoRoutine = pxCoRoutine;
   \   0000001C   0x646C             STR      R4,[R5, #+68]
    151          			prvInitialiseCoRoutineLists();
   \   0000001E   0x.... 0x....      BL       prvInitialiseCoRoutineLists
    152          		}
    153          
    154          		/* Check the priority is within limits. */
    155          		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
   \                     ??xCoRoutineCreate_1: (+1)
   \   00000022   0x2F02             CMP      R7,#+2
   \   00000024   0xD300             BCC.N    ??xCoRoutineCreate_2
    156          		{
    157          			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
   \   00000026   0x2701             MOVS     R7,#+1
    158          		}
    159          
    160          		/* Fill out the co-routine control block from the function parameters. */
    161          		pxCoRoutine->uxState = corINITIAL_STATE;
   \                     ??xCoRoutineCreate_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x86A0             STRH     R0,[R4, #+52]
    162          		pxCoRoutine->uxPriority = uxPriority;
   \   0000002C   0x62E7             STR      R7,[R4, #+44]
    163          		pxCoRoutine->uxIndex = uxIndex;
   \   0000002E   0xF8C4 0x8030      STR      R8,[R4, #+48]
    164          		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
   \   00000032   0x6026             STR      R6,[R4, #+0]
    165          
    166          		/* Initialise all the other co-routine control block parameters. */
    167          		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
   \   00000034   0x1D20             ADDS     R0,R4,#+4
   \   00000036   0x.... 0x....      BL       vListInitialiseItem
    168          		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
   \   0000003A   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000003E   0x.... 0x....      BL       vListInitialiseItem
    169          
    170          		/* Set the co-routine control block as a link back from the xListItem.
    171          		This is so we can get back to the containing CRCB from a generic item
    172          		in a list. */
    173          		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
   \   00000042   0x6124             STR      R4,[R4, #+16]
    174          		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
   \   00000044   0x6264             STR      R4,[R4, #+36]
    175          
    176          		/* Event lists are always in priority order. */
    177          		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   \   00000046   0xF1C7 0x000C      RSB      R0,R7,#+12
   \   0000004A   0x61A0             STR      R0,[R4, #+24]
    178          
    179          		/* Now the co-routine has been initialised it can be added to the ready
    180          		list at the correct priority. */
    181          		prvAddCoRoutineToReadyQueue( pxCoRoutine );
   \   0000004C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004E   0x6CA9             LDR      R1,[R5, #+72]
   \   00000050   0x4281             CMP      R1,R0
   \   00000052   0xD200             BCS.N    ??xCoRoutineCreate_3
   \   00000054   0x4601             MOV      R1,R0
   \                     ??xCoRoutineCreate_3: (+1)
   \   00000056   0x64A9             STR      R1,[R5, #+72]
   \   00000058   0x1D21             ADDS     R1,R4,#+4
   \   0000005A   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   0000005E   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   00000062   0x3014             ADDS     R0,R0,#+20
   \   00000064   0x.... 0x....      BL       vListInsertEnd
    182          
    183          		xReturn = pdPASS;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE001             B.N      ??xCoRoutineCreate_4
    184          	}
    185          	else
    186          	{
    187          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   \                     ??xCoRoutineCreate_0: (+1)
   \   0000006C   0xF04F 0x30FF      MOV      R0,#-1
    188          	}
    189          
    190          	return xReturn;
   \                     ??xCoRoutineCreate_4: (+1)
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    191          }
    192          /*-----------------------------------------------------------*/
    193          

   \                                 In section .text, align 2, keep-with-next
    194          void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
    195          {
   \                     vCoRoutineAddToDelayedList: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    196          portTickType xTimeToWake;
    197          
    198          	/* Calculate the time to wake - this may overflow but this is
    199          	not a problem. */
    200          	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
   \   00000004   0x....             LDR.N    R5,??DataTable6
   \   00000006   0x6CE9             LDR      R1,[R5, #+76]
   \   00000008   0x1846             ADDS     R6,R0,R1
    201          
    202          	/* We must remove ourselves from the ready list before adding
    203          	ourselves to the blocked list as the same list item is used for
    204          	both lists. */
    205          	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
   \   0000000A   0x6C68             LDR      R0,[R5, #+68]
   \   0000000C   0x1D00             ADDS     R0,R0,#+4
   \   0000000E   0x.... 0x....      BL       uxListRemove
    206          
    207          	/* The list item will be inserted in wake time order. */
    208          	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
   \   00000012   0x6C68             LDR      R0,[R5, #+68]
   \   00000014   0x6046             STR      R6,[R0, #+4]
    209          
    210          	if( xTimeToWake < xCoRoutineTickCount )
   \   00000016   0x6C68             LDR      R0,[R5, #+68]
   \   00000018   0x6CE9             LDR      R1,[R5, #+76]
   \   0000001A   0x428E             CMP      R6,R1
   \   0000001C   0xD204             BCS.N    ??vCoRoutineAddToDelayedList_0
    211          	{
    212          		/* Wake time has overflowed.  Place this item in the
    213          		overflow list. */
    214          		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
   \   0000001E   0x1D01             ADDS     R1,R0,#+4
   \   00000020   0x6C28             LDR      R0,[R5, #+64]
   \   00000022   0x.... 0x....      BL       vListInsert
   \   00000026   0xE003             B.N      ??vCoRoutineAddToDelayedList_1
    215          	}
    216          	else
    217          	{
    218          		/* The wake time has not overflowed, so we can use the
    219          		current block list. */
    220          		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
   \                     ??vCoRoutineAddToDelayedList_0: (+1)
   \   00000028   0x1D01             ADDS     R1,R0,#+4
   \   0000002A   0x6BE8             LDR      R0,[R5, #+60]
   \   0000002C   0x.... 0x....      BL       vListInsert
    221          	}
    222          
    223          	if( pxEventList )
   \                     ??vCoRoutineAddToDelayedList_1: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD007             BEQ.N    ??vCoRoutineAddToDelayedList_2
    224          	{
    225          		/* Also add the co-routine to an event list.  If this is done then the
    226          		function must be called with interrupts disabled. */
    227          		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
   \   00000034   0x6C68             LDR      R0,[R5, #+68]
   \   00000036   0xF100 0x0118      ADD      R1,R0,#+24
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000040   0x.... 0x....      B.W      vListInsert
    228          	}
    229          }
   \                     ??vCoRoutineAddToDelayedList_2: (+1)
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    230          /*-----------------------------------------------------------*/
    231          

   \                                 In section .text, align 2, keep-with-next
    232          static void prvCheckPendingReadyList( void )
    233          {
   \                     prvCheckPendingReadyList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R5,??DataTable6
   \   00000004   0xE01B             B.N      ??prvCheckPendingReadyList_0
    234          	/* Are there any co-routines waiting to get moved to the ready list?  These
    235          	are co-routines that have been readied by an ISR.  The ISR cannot access
    236          	the	ready lists itself. */
    237          	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    238          	{
    239          		corCRCB *pxUnblockedCRCB;
    240          
    241          		/* The pending ready list can be accessed by an ISR. */
    242          		portDISABLE_INTERRUPTS();
   \                     ??prvCheckPendingReadyList_1: (+1)
   \   00000006   0x.... 0x....      BL       ulPortSetInterruptMask
    243          		{
    244          			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
   \   0000000A   0x68E8             LDR      R0,[R5, #+12]
   \   0000000C   0x68C4             LDR      R4,[R0, #+12]
    245          			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
   \   0000000E   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000012   0x.... 0x....      BL       uxListRemove
    246          		}
    247          		portENABLE_INTERRUPTS();
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       vPortClearInterruptMask
    248          
    249          		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
   \   0000001C   0x1D20             ADDS     R0,R4,#+4
   \   0000001E   0x.... 0x....      BL       uxListRemove
    250          		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x6CA9             LDR      R1,[R5, #+72]
   \   00000026   0x4281             CMP      R1,R0
   \   00000028   0xD200             BCS.N    ??prvCheckPendingReadyList_2
   \   0000002A   0x4601             MOV      R1,R0
   \                     ??prvCheckPendingReadyList_2: (+1)
   \   0000002C   0x64A9             STR      R1,[R5, #+72]
   \   0000002E   0x1D21             ADDS     R1,R4,#+4
   \   00000030   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000034   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   00000038   0x3014             ADDS     R0,R0,#+20
   \   0000003A   0x.... 0x....      BL       vListInsertEnd
    251          	}
   \                     ??prvCheckPendingReadyList_0: (+1)
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD1E0             BNE.N    ??prvCheckPendingReadyList_1
    252          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    253          /*-----------------------------------------------------------*/
    254          

   \                                 In section .text, align 2, keep-with-next
    255          static void prvCheckDelayedList( void )
    256          {
   \                     prvCheckDelayedList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    257          corCRCB *pxCRCB;
    258          
    259          	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
   \   00000002   0x.... 0x....      BL       xTaskGetTickCount
   \   00000006   0x....             LDR.N    R4,??DataTable6
   \   00000008   0x6D21             LDR      R1,[R4, #+80]
   \   0000000A   0x1A40             SUBS     R0,R0,R1
   \   0000000C   0x6560             STR      R0,[R4, #+84]
    260          	while( xPassedTicks )
   \                     ??prvCheckDelayedList_0: (+1)
   \   0000000E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000010   0x6D61             LDR      R1,[R4, #+84]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD031             BEQ.N    ??prvCheckDelayedList_1
    261          	{
    262          		xCoRoutineTickCount++;
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x64E0             STR      R0,[R4, #+76]
    263          		xPassedTicks--;
   \   0000001A   0x1E49             SUBS     R1,R1,#+1
   \   0000001C   0x6561             STR      R1,[R4, #+84]
    264          
    265          		/* If the tick count has overflowed we need to swap the ready lists. */
    266          		if( xCoRoutineTickCount == 0 )
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??prvCheckDelayedList_2
    267          		{
    268          			xList * pxTemp;
    269          
    270          			/* Tick count has overflowed so we need to swap the delay lists.  If there are
    271          			any items in pxDelayedCoRoutineList here then there is an error! */
    272          			pxTemp = pxDelayedCoRoutineList;
   \   00000022   0x6BE0             LDR      R0,[R4, #+60]
    273          			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
   \   00000024   0x6C21             LDR      R1,[R4, #+64]
   \   00000026   0x63E1             STR      R1,[R4, #+60]
    274          			pxOverflowDelayedCoRoutineList = pxTemp;
   \   00000028   0x6420             STR      R0,[R4, #+64]
    275          		}
    276          
    277          		/* See if this tick has made a timeout expire. */
    278          		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
   \                     ??prvCheckDelayedList_2: (+1)
   \   0000002A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD0ED             BEQ.N    ??prvCheckDelayedList_0
    279          		{
    280          			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x68C5             LDR      R5,[R0, #+12]
    281          
    282          			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
   \   00000036   0x6CE0             LDR      R0,[R4, #+76]
   \   00000038   0x6869             LDR      R1,[R5, #+4]
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD3E7             BCC.N    ??prvCheckDelayedList_0
    283          			{
    284          				/* Timeout not yet expired. */
    285          				break;
    286          			}
    287          
    288          			portDISABLE_INTERRUPTS();
   \   0000003E   0x.... 0x....      BL       ulPortSetInterruptMask
    289          			{
    290          				/* The event could have occurred just before this critical
    291          				section.  If this is the case then the generic list item will
    292          				have been moved to the pending ready list and the following
    293          				line is still valid.  Also the pvContainer parameter will have
    294          				been set to NULL so the following lines are also valid. */
    295          				uxListRemove( &( pxCRCB->xGenericListItem ) );
   \   00000042   0x1D28             ADDS     R0,R5,#+4
   \   00000044   0x.... 0x....      BL       uxListRemove
    296          
    297          				/* Is the co-routine waiting on an event also? */
    298          				if( pxCRCB->xEventListItem.pvContainer )
   \   00000048   0x6AA8             LDR      R0,[R5, #+40]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD003             BEQ.N    ??prvCheckDelayedList_3
    299          				{
    300          					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
   \   0000004E   0xF105 0x0018      ADD      R0,R5,#+24
   \   00000052   0x.... 0x....      BL       uxListRemove
    301          				}
    302          			}
    303          			portENABLE_INTERRUPTS();
   \                     ??prvCheckDelayedList_3: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       vPortClearInterruptMask
    304          
    305          			prvAddCoRoutineToReadyQueue( pxCRCB );
   \   0000005C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000005E   0x6CA1             LDR      R1,[R4, #+72]
   \   00000060   0x4281             CMP      R1,R0
   \   00000062   0xD200             BCS.N    ??prvCheckDelayedList_4
   \   00000064   0x4601             MOV      R1,R0
   \                     ??prvCheckDelayedList_4: (+1)
   \   00000066   0x64A1             STR      R1,[R4, #+72]
   \   00000068   0x1D29             ADDS     R1,R5,#+4
   \   0000006A   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   0000006E   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000072   0x3014             ADDS     R0,R0,#+20
   \   00000074   0x.... 0x....      BL       vListInsertEnd
   \   00000078   0xE7D7             B.N      ??prvCheckDelayedList_2
    306          		}
    307          	}
    308          
    309          	xLastTickCount = xCoRoutineTickCount;
   \                     ??prvCheckDelayedList_1: (+1)
   \   0000007A   0x6520             STR      R0,[R4, #+80]
    310          }
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    311          /*-----------------------------------------------------------*/
    312          

   \                                 In section .text, align 2, keep-with-next
    313          void vCoRoutineSchedule( void )
    314          {
   \                     vCoRoutineSchedule: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    315          	/* See if any co-routines readied by events need moving to the ready lists. */
    316          	prvCheckPendingReadyList();
   \   00000002   0x.... 0x....      BL       prvCheckPendingReadyList
    317          
    318          	/* See if any delayed co-routines have timed out. */
    319          	prvCheckDelayedList();
   \   00000006   0x.... 0x....      BL       prvCheckDelayedList
   \   0000000A   0x....             LDR.N    R1,??DataTable6
   \   0000000C   0xE001             B.N      ??vCoRoutineSchedule_0
    320          
    321          	/* Find the highest priority queue that contains ready co-routines. */
    322          	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    323          	{
    324          		if( uxTopCoRoutineReadyPriority == 0 )
    325          		{
    326          			/* No more co-routines to check. */
    327          			return;
    328          		}
    329          		--uxTopCoRoutineReadyPriority;
   \                     ??vCoRoutineSchedule_1: (+1)
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x6488             STR      R0,[R1, #+72]
   \                     ??vCoRoutineSchedule_0: (+1)
   \   00000012   0x6C88             LDR      R0,[R1, #+72]
   \   00000014   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000018   0xEB01 0x0282      ADD      R2,R1,R2, LSL #+2
   \   0000001C   0x6953             LDR      R3,[R2, #+20]
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD102             BNE.N    ??vCoRoutineSchedule_2
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F3             BNE.N    ??vCoRoutineSchedule_1
   \   00000026   0xBD01             POP      {R0,PC}
    330          	}
    331          
    332          	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
    333          	 of the	same priority get an equal share of the processor time. */
    334          	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
   \                     ??vCoRoutineSchedule_2: (+1)
   \   00000028   0x6990             LDR      R0,[R2, #+24]
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x6190             STR      R0,[R2, #+24]
   \   0000002E   0xF102 0x031C      ADD      R3,R2,#+28
   \   00000032   0x4298             CMP      R0,R3
   \   00000034   0xD101             BNE.N    ??vCoRoutineSchedule_3
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x6190             STR      R0,[R2, #+24]
   \                     ??vCoRoutineSchedule_3: (+1)
   \   0000003A   0x6990             LDR      R0,[R2, #+24]
   \   0000003C   0x68C0             LDR      R0,[R0, #+12]
   \   0000003E   0x6448             STR      R0,[R1, #+68]
    335          
    336          	/* Call the co-routine. */
    337          	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
   \   00000040   0x6B01             LDR      R1,[R0, #+48]
   \   00000042   0x6802             LDR      R2,[R0, #+0]
   \   00000044   0xE8BD 0x4008      POP      {R3,LR}
   \   00000048   0x4710             BX       R2
    338          
    339          	return;
    340          }
    341          /*-----------------------------------------------------------*/
    342          

   \                                 In section .text, align 2, keep-with-next
    343          static void prvInitialiseCoRoutineLists( void )
    344          {
   \                     prvInitialiseCoRoutineLists: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    345          unsigned portBASE_TYPE uxPriority;
    346          
    347          	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x....             LDR.N    R5,??DataTable6
   \   00000006   0xE007             B.N      ??prvInitialiseCoRoutineLists_0
    348          	{
    349          		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
   \                     ??prvInitialiseCoRoutineLists_1: (+1)
   \   00000008   0xEB04 0x0084      ADD      R0,R4,R4, LSL #+2
   \   0000000C   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   00000010   0x3014             ADDS     R0,R0,#+20
   \   00000012   0x.... 0x....      BL       vListInitialise
    350          	}
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??prvInitialiseCoRoutineLists_0: (+1)
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD3F5             BCC.N    ??prvInitialiseCoRoutineLists_1
    351          
    352          	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
   \   0000001C   0xF105 0x0058      ADD      R0,R5,#+88
   \   00000020   0x.... 0x....      BL       vListInitialise
    353          	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
   \   00000024   0xF105 0x006C      ADD      R0,R5,#+108
   \   00000028   0x.... 0x....      BL       vListInitialise
    354          	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       vListInitialise
    355          
    356          	/* Start with pxDelayedCoRoutineList using list1 and the
    357          	pxOverflowDelayedCoRoutineList using list2. */
    358          	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
   \   00000032   0xF105 0x0058      ADD      R0,R5,#+88
   \   00000036   0x63E8             STR      R0,[R5, #+60]
    359          	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
   \   00000038   0xF105 0x006C      ADD      R0,R5,#+108
   \   0000003C   0x6428             STR      R0,[R5, #+64]
    360          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    361          /*-----------------------------------------------------------*/
    362          

   \                                 In section .text, align 2, keep-with-next
    363          signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
    364          {
   \                     xCoRoutineRemoveFromEventList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    365          corCRCB *pxUnblockedCRCB;
    366          signed portBASE_TYPE xReturn;
    367          
    368          	/* This function is called from within an interrupt.  It can only access
    369          	event lists and the pending ready list.  This function assumes that a
    370          	check has already been made to ensure pxEventList is not empty. */
    371          	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x68C4             LDR      R4,[R0, #+12]
    372          	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
   \   00000006   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000000A   0x.... 0x....      BL       uxListRemove
    373          	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
   \   0000000E   0x....             LDR.N    R5,??DataTable6
   \   00000010   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       vListInsertEnd
    374          
    375          	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
   \   0000001A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000001C   0x6C69             LDR      R1,[R5, #+68]
   \   0000001E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0x4180             SBCS     R0,R0,R0
   \   00000024   0x43C0             MVNS     R0,R0
   \   00000026   0x0FC0             LSRS     R0,R0,#+31
    376          	{
    377          		xReturn = pdTRUE;
    378          	}
    379          	else
    380          	{
    381          		xReturn = pdFALSE;
    382          	}
    383          
    384          	return xReturn;
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    385          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     xPendingReadyCoRoutineList
    386          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   prvCheckDelayedList
        16   -> ulPortSetInterruptMask
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortClearInterruptMask
        16   -> xTaskGetTickCount
      16   prvCheckPendingReadyList
        16   -> ulPortSetInterruptMask
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortClearInterruptMask
      16   prvInitialiseCoRoutineLists
        16   -> vListInitialise
      16   vCoRoutineAddToDelayedList
        16   -> uxListRemove
         0   -> vListInsert
        16   -> vListInsert
       8   vCoRoutineSchedule
         0   -- Indirect call
         8   -> prvCheckDelayedList
         8   -> prvCheckPendingReadyList
      24   xCoRoutineCreate
        24   -> prvInitialiseCoRoutineLists
        24   -> pvPortMalloc
        24   -> vListInitialiseItem
        24   -> vListInsertEnd
      16   xCoRoutineRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
     126  prvCheckDelayedList
      70  prvCheckPendingReadyList
      64  prvInitialiseCoRoutineLists
      70  vCoRoutineAddToDelayedList
      74  vCoRoutineSchedule
     116  xCoRoutineCreate
      42  xCoRoutineRemoveFromEventList
     128  xPendingReadyCoRoutineList
          pxReadyCoRoutineLists
          pxDelayedCoRoutineList
          pxOverflowDelayedCoRoutineList
          pxCurrentCoRoutine
          uxTopCoRoutineReadyPriority
          xCoRoutineTickCount
          xLastTickCount
          xPassedTicks
          xDelayedCoRoutineList1
          xDelayedCoRoutineList2

 
 128 bytes in section .bss
 566 bytes in section .text
 
 566 bytes of CODE memory
 128 bytes of DATA memory

Errors: none
Warnings: none
