###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\usbh_usr.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\usbh_usr.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_usr.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_usr.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\usbh_usr.c
      1          /**
      2            ******************************************************************************
      3            * @file    Audio_playback_and_record/src/usbh_usr.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    28-October-2011
      7            * @brief   This file includes the usb host user callbacks
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usbh_usr.h"
     24          #include "includes.h"
     25          
     26          /** @addtogroup STM32F4-Discovery_Audio_Player_Recorder
     27            * @{
     28            */
     29          
     30          /* External variables --------------------------------------------------------*/
     31          /* Private typedef -----------------------------------------------------------*/
     32          /* Private defines -----------------------------------------------------------*/
     33          /* Private macros ------------------------------------------------------------*/
     34          /* Private variables ---------------------------------------------------------*/
     35          /*  Points to the DEVICE_PROP structure of current device */
     36          /*  The purpose of this register is to speed up the execution */
     37          
     38          

   \                                 In section .data, align 4
     39          USBH_Usr_cb_TypeDef USR_Callbacks =
   \                     USR_Callbacks:
   \   00000000   0x........         DC32 USBH_USR_Init, USBH_USR_DeInit, USBH_USR_DeviceAttached
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 USBH_USR_ResetDevice, USBH_USR_DeviceDisconnected
   \              0x........   
   \   00000014   0x........         DC32 USBH_USR_OverCurrentDetected, USBH_USR_DeviceSpeedDetected
   \              0x........   
   \   0000001C   0x........         DC32 USBH_USR_Device_DescAvailable, USBH_USR_DeviceAddressAssigned
   \              0x........   
   \   00000024   0x........         DC32 USBH_USR_Configuration_DescAvailable, USBH_USR_Manufacturer_String
   \              0x........   
   \   0000002C   0x........         DC32 USBH_USR_Product_String, USBH_USR_SerialNum_String
   \              0x........   
   \   00000034   0x........         DC32 USBH_USR_EnumerationDone, USBH_USR_UserInput
   \              0x........   
   \   0000003C   0x........         DC32 USBH_USR_MSC_Application, USBH_USR_DeviceNotSupported
   \              0x........   
   \   00000044   0x........         DC32 USBH_USR_UnrecoveredError
     40          {
     41            USBH_USR_Init,
     42            USBH_USR_DeInit,
     43            USBH_USR_DeviceAttached,
     44            USBH_USR_ResetDevice,
     45            USBH_USR_DeviceDisconnected,
     46            USBH_USR_OverCurrentDetected,
     47            USBH_USR_DeviceSpeedDetected,
     48            USBH_USR_Device_DescAvailable,
     49            USBH_USR_DeviceAddressAssigned,
     50            USBH_USR_Configuration_DescAvailable,
     51            USBH_USR_Manufacturer_String,
     52            USBH_USR_Product_String,
     53            USBH_USR_SerialNum_String,
     54            USBH_USR_EnumerationDone,
     55            USBH_USR_UserInput,
     56            USBH_USR_MSC_Application,
     57            USBH_USR_DeviceNotSupported,
     58            USBH_USR_UnrecoveredError
     59          };
     60          
     61          extern USB_OTG_CORE_HANDLE          USB_OTG_Core;
     62          
     63          
     64          /* Private function prototypes -----------------------------------------------*/
     65          /* Private functions ---------------------------------------------------------*/
     66          

   \                                 In section .rodata, align 4, keep-with-next
     67          const uint8_t MSG_HOST_INIT[]        = "> Host Library Initialized\r\n";
   \                     MSG_HOST_INIT:
   \   00000000   0x3E 0x20          DC8 "> Host Library Initialized\015\012"
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x4C    
   \              0x69 0x62    
   \              0x72 0x61    
   \              0x72 0x79    
   \              0x20 0x49    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
     68          const uint8_t MSG_DEV_ATTACHED[]     = "> Device Attached \r\n";
   \                     MSG_DEV_ATTACHED:
   \   00000000   0x3E 0x20          DC8 "> Device Attached \015\012"
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x41    
   \              0x74 0x74    
   \              0x61 0x63    
   \              0x68 0x65    
   \              0x64 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
     69          const uint8_t MSG_DEV_DISCONNECTED[] = "> Device Disconnected\r\n";
   \                     MSG_DEV_DISCONNECTED:
   \   00000000   0x3E 0x20          DC8 "> Device Disconnected\015\012"
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
     70          const uint8_t MSG_DEV_ENUMERATED[]   = "> Enumeration completed \r\n";
   \                     MSG_DEV_ENUMERATED:
   \   00000000   0x3E 0x20          DC8 "> Enumeration completed \015\012"
   \              0x45 0x6E    
   \              0x75 0x6D    
   \              0x65 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x63 0x6F    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
     71          const uint8_t MSG_DEV_HIGHSPEED[]    = "> High speed device detected\r\n";
   \                     MSG_DEV_HIGHSPEED:
   \   00000000   0x3E 0x20          DC8 "> High speed device detected\015\012"
   \              0x48 0x69    
   \              0x67 0x68    
   \              0x20 0x73    
   \              0x70 0x65    
   \              0x65 0x64    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x64 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
     72          const uint8_t MSG_DEV_FULLSPEED[]    = "> Full speed device detected\r\n";
   \                     MSG_DEV_FULLSPEED:
   \   00000000   0x3E 0x20          DC8 "> Full speed device detected\015\012"
   \              0x46 0x75    
   \              0x6C 0x6C    
   \              0x20 0x73    
   \              0x70 0x65    
   \              0x65 0x64    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x64 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
     73          const uint8_t MSG_DEV_LOWSPEED[]     = "> Low speed device detected\r\n";
   \                     MSG_DEV_LOWSPEED:
   \   00000000   0x3E 0x20          DC8 "> Low speed device detected\015\012"
   \              0x4C 0x6F    
   \              0x77 0x20    
   \              0x73 0x70    
   \              0x65 0x65    
   \              0x64 0x20    
   \              0x64 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x64    
   \              0x65 0x74    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0D    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
     74          const uint8_t MSG_DEV_ERROR[]        = "> Device fault \r\n";
   \                     MSG_DEV_ERROR:
   \   00000000   0x3E 0x20          DC8 "> Device fault \015\012"
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x66    
   \              0x61 0x75    
   \              0x6C 0x74    
   \              0x20 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     75          

   \                                 In section .text, align 4, keep-with-next
     76          const uint8_t MSG_MSC_CLASS[]        = "> Mass storage device connected\r\n";
   \                     MSG_MSC_CLASS:
   \   00000000   0x3E 0x20          DC8 "> Mass storage device connected\015\012"
   \              0x4D 0x61    
   \              0x73 0x73    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x72 0x61    
   \              0x67 0x65    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0D    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
     77          const uint8_t MSG_HID_CLASS[]        = "> HID device connected\r\n";
   \                     MSG_HID_CLASS:
   \   00000000   0x3E 0x20          DC8 "> HID device connected\015\012"
   \              0x48 0x49    
   \              0x44 0x20    
   \              0x64 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
     78          const uint8_t MSG_DISK_SIZE[]        = "> Size of the disk in MBytes: \r\n";
   \                     MSG_DISK_SIZE:
   \   00000000   0x3E 0x20          DC8 "> Size of the disk in MBytes: \015\012"
   \              0x53 0x69    
   \              0x7A 0x65    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x74 0x68    
   \              0x65 0x20    
   \              0x64 0x69    
   \              0x73 0x6B    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x4D 0x42    
   \              0x79 0x74    
   \              0x65 0x73    
   \              0x3A 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
     79          const uint8_t MSG_LUN[]              = "> LUN Available in the device:\r\n";
   \                     MSG_LUN:
   \   00000000   0x3E 0x20          DC8 "> LUN Available in the device:\015\012"
   \              0x4C 0x55    
   \              0x4E 0x20    
   \              0x41 0x76    
   \              0x61 0x69    
   \              0x6C 0x61    
   \              0x62 0x6C    
   \              0x65 0x20    
   \              0x69 0x6E    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x3A    
   \              0x0D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
     80          const uint8_t MSG_ROOT_CONT[]        = "> Exploring disk flash ...\r\n";
   \                     MSG_ROOT_CONT:
   \   00000000   0x3E 0x20          DC8 "> Exploring disk flash ...\015\012"
   \              0x45 0x78    
   \              0x70 0x6C    
   \              0x6F 0x72    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x64 0x69    
   \              0x73 0x6B    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x2E    
   \              0x2E 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
     81          const uint8_t MSG_WR_PROTECT[]       = "> The disk is write protected\r\n";
   \                     MSG_WR_PROTECT:
   \   00000000   0x3E 0x20          DC8 "> The disk is write protected\015\012"
   \              0x54 0x68    
   \              0x65 0x20    
   \              0x64 0x69    
   \              0x73 0x6B    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x70 0x72    
   \              0x6F 0x74    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
     82          const uint8_t MSG_UNREC_ERROR[]      = "> UNRECOVERED ERROR STATE\r\n";
   \                     MSG_UNREC_ERROR:
   \   00000000   0x3E 0x20          DC8 "> UNRECOVERED ERROR STATE\015\012"
   \              0x55 0x4E    
   \              0x52 0x45    
   \              0x43 0x4F    
   \              0x56 0x45    
   \              0x52 0x45    
   \              0x44 0x20    
   \              0x45 0x52    
   \              0x52 0x4F    
   \              0x52 0x20    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x45 0x0D    
   \              0x0A 0x00    
     83          
     84          
     85          #define __DEBUG_USB_MSG
     86          /**
     87            * @brief  USBH_USR_Init
     88            * @param  None
     89            * @retval None
     90            */
     91          
     92          extern TM_USB_MSCHOST_Result_t 	TM_USB_MSCHOST_INT_Result;

   \                                 In section .bss, align 1
     93          uint8_t Application = USH_USR_FS_INIT;
   \                     Application:
   \   00000000                      DS8 1
     94          
     95          

   \                                 In section .text, align 2, keep-with-next
     96          void USBH_USR_Init(void)
     97          {
   \                     USBH_USR_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     98          #ifdef __DEBUG_USB_MSG
     99          #ifdef USE_USB_OTG_HS 
    100            printd(" USB OTG HS MSC Host\r\n");
    101          #else
    102            printd(" USB OTG FS MSC Host\r\n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_0
   \   00000006   0x.... 0x....      BL       printd
    103          #endif
    104              printd(">USB Host library started.\r\n"); 
   \   0000000A   0x.... 0x....      ADR.W    R0,?_1
   \   0000000E   0x.... 0x....      BL       printd
    105              printd(" USB Host Library v2.1.0\r\n" );
   \   00000012   0x.... 0x....      ADR.W    R0,?_2
   \   00000016   0x.... 0x....      BL       printd
    106          #endif
    107          	/* Device has been initialized, device is not connected yet */
    108          	TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_Disconnected;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x....             LDR.N    R1,??DataTable34
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    109          	/* We have to initialize first */
    110          	Application = USH_USR_FS_INIT;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable34_1
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    111          
    112          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    113          
    114          
    115          /**
    116            * @brief  USBH_USR_DeInit
    117            *         Deint User state and associated variables
    118            * @param  None
    119            * @retval None
    120            */

   \                                 In section .text, align 2, keep-with-next
    121          void USBH_USR_DeInit(void)
    122          {
    123          	Application = USH_USR_FS_INIT;
   \                     USBH_USR_DeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable34_1
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    124          }
   \   00000006   0x4770             BX       LR               ;; return
    125          
    126          /**
    127            * @brief  USBH_USR_DeviceAttached
    128            * @param  None
    129            * @retval None
    130            */

   \                                 In section .text, align 2, keep-with-next
    131          void USBH_USR_DeviceAttached(void)
    132          {  
   \                     USBH_USR_DeviceAttached: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    133          #ifdef __DEBUG_USB_MSG
    134            printd((void *)MSG_DEV_ATTACHED);  
   \   00000002   0x.... 0x....      ADR.W    R0,MSG_DEV_ATTACHED
   \   00000006   0x.... 0x....      BL       printd
    135          #endif  
    136            /* Device has been initialized, device is not connected yet */
    137          	TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_Disconnected;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x....             LDR.N    R1,??DataTable34
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    138          	/* We have to initialize first */
    139          	Application = USH_USR_FS_INIT;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable34_1
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    140          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    141          
    142          /**
    143            * @brief  USBH_USR_UnrecoveredError
    144            * @param  None
    145            * @retval None
    146            */

   \                                 In section .text, align 2, keep-with-next
    147          void USBH_USR_UnrecoveredError (void)
    148          {
   \                     USBH_USR_UnrecoveredError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    149          #ifdef __DEBUG_USB_MSG  
    150            /* Set default screen color*/ 
    151            printd((void *)MSG_UNREC_ERROR); 
   \   00000002   0x.... 0x....      ADR.W    R0,MSG_UNREC_ERROR
   \   00000006   0x.... 0x....      BL       printd
    152          #endif  
    153            /* Device has been initialized, device is not connected yet */
    154          	TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_Disconnected;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x....             LDR.N    R1,??DataTable34
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    155          	/* We have to initialize first */
    156          	Application = USH_USR_FS_INIT;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable34_1
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    157          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    158          
    159          /**
    160            * @brief  USBH_DisconnectEvent
    161            *         Device disconnect event
    162            * @param  None
    163            * @retval Staus
    164            */

   \                                 In section .text, align 2, keep-with-next
    165          void USBH_USR_DeviceDisconnected (void)
    166          {    
   \                     USBH_USR_DeviceDisconnected: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    167          #ifdef __DEBUG_USB_MSG
    168            /* Set default screen color*/
    169            printd((void *)MSG_DEV_DISCONNECTED);
   \   00000002   0x.... 0x....      ADR.W    R0,MSG_DEV_DISCONNECTED
   \   00000006   0x.... 0x....      BL       printd
    170          #endif  
    171            //USB_Detect_Flag = 0;
    172          	/* Device has been initialized, device is not connected yet */
    173          	TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_Disconnected;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x....             LDR.N    R1,??DataTable34
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    174          	/* We have to initialize first */
    175          	Application = USH_USR_FS_INIT;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable34_1
   \   00000014   0x7008             STRB     R0,[R1, #+0]
    176          	printd("DETECT 0");
   \   00000016   0x.... 0x....      ADR.W    R0,?_3
   \   0000001A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000001E   0x.... 0x....      B.W      printd
    177          }
    178          
    179          /**
    180            * @brief  USBH_USR_ResetUSBDevice
    181            * @param  None
    182            * @retval None
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          void USBH_USR_ResetDevice(void)
    185          {
    186            /* callback for USB-Reset */
    187          	Application = USH_USR_FS_INIT;
   \                     USBH_USR_ResetDevice: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable34_1
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    188          }
   \   00000006   0x4770             BX       LR               ;; return
    189          
    190          
    191          /**
    192            * @brief  USBH_USR_DeviceSpeedDetected
    193            *         Displays the message on LCD for device speed
    194            * @param  Device speed:
    195            * @retval None
    196            */

   \                                 In section .text, align 2, keep-with-next
    197          void USBH_USR_DeviceSpeedDetected(uint8_t DeviceSpeed)
    198          {
    199          #ifdef __DEBUG_USB_MSG  
    200            if(DeviceSpeed == HPRT0_PRTSPD_HIGH_SPEED)
   \                     USBH_USR_DeviceSpeedDetected: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xD103             BNE.N    ??USBH_USR_DeviceSpeedDetected_0
    201            {
    202              printd((void *)MSG_DEV_HIGHSPEED);
   \   00000004   0x.... 0x....      ADR.W    R0,MSG_DEV_HIGHSPEED
   \   00000008   0x.... 0x....      B.W      printd
    203            }  
    204            else if(DeviceSpeed == HPRT0_PRTSPD_FULL_SPEED)
   \                     ??USBH_USR_DeviceSpeedDetected_0: (+1)
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD103             BNE.N    ??USBH_USR_DeviceSpeedDetected_1
    205            {
    206              printd((void *)MSG_DEV_FULLSPEED);
   \   00000010   0x.... 0x....      ADR.W    R0,MSG_DEV_FULLSPEED
   \   00000014   0x.... 0x....      B.W      printd
    207            }
    208            else if(DeviceSpeed == HPRT0_PRTSPD_LOW_SPEED)
   \                     ??USBH_USR_DeviceSpeedDetected_1: (+1)
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD103             BNE.N    ??USBH_USR_DeviceSpeedDetected_2
    209            {
    210              printd((void *)MSG_DEV_LOWSPEED);
   \   0000001C   0x.... 0x....      ADR.W    R0,MSG_DEV_LOWSPEED
   \   00000020   0x.... 0x....      B.W      printd
    211            }
    212            else
    213            {
    214              printd((void *)MSG_DEV_ERROR);
   \                     ??USBH_USR_DeviceSpeedDetected_2: (+1)
   \   00000024   0x.... 0x....      ADR.W    R0,MSG_DEV_ERROR
   \   00000028   0x.... 0x....      B.W      printd
    215            }
    216          #endif  
    217          }
    218          
    219          /**
    220            * @brief  USBH_USR_Device_DescAvailable
    221            * @param  device descriptor
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          void USBH_USR_Device_DescAvailable(void *DeviceDesc)
    225          {
   \                     USBH_USR_Device_DescAvailable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    226            /* callback for device descriptor */
    227          #ifdef __DEBUG_USB_MSG  
    228            USBH_DevDesc_TypeDef *hs;
    229            hs = DeviceDesc;  
    230            
    231            
    232            printd("VID : %04Xh\r\n" , (uint32_t)(*hs).idVendor); 
   \   00000004   0x8921             LDRH     R1,[R4, #+8]
   \   00000006   0x.... 0x....      ADR.W    R0,?_4
   \   0000000A   0x.... 0x....      BL       printd
    233            printd("PID : %04Xh\r\n" , (uint32_t)(*hs).idProduct); 
   \   0000000E   0x8961             LDRH     R1,[R4, #+10]
   \   00000010   0x.... 0x....      ADR.W    R0,?_5
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      printd
    234          #endif  
    235          }
    236          
    237          /**
    238            * @brief  USBH_USR_DeviceAddressAssigned
    239            *         USB device is successfully assigned the Address
    240            * @param  None
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void USBH_USR_DeviceAddressAssigned(void)
    244          {
    245            /* callback for device successfully assigned the Address */
    246          }
   \                     USBH_USR_DeviceAddressAssigned: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    247          
    248          /**
    249            * @brief  USBH_USR_Conf_Desc
    250            * @param  Configuration descriptor
    251            * @retval None
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          void USBH_USR_Configuration_DescAvailable(USBH_CfgDesc_TypeDef * cfgDesc,
    254              USBH_InterfaceDesc_TypeDef *itfDesc,
    255              USBH_EpDesc_TypeDef *epDesc)
    256          {
    257            /* callback for configuration descriptor */
    258          #ifdef __DEBUG_USB_MSG  
    259            USBH_InterfaceDesc_TypeDef *id;
    260            
    261            id = itfDesc;  
    262            
    263            if((*id).bInterfaceClass  == 0x08)
   \                     USBH_USR_Configuration_DescAvailable: (+1)
   \   00000000   0x7948             LDRB     R0,[R1, #+5]
   \   00000002   0x2808             CMP      R0,#+8
   \   00000004   0xD103             BNE.N    ??USBH_USR_Configuration_DescAvailable_0
    264            {
    265              printd((void *)MSG_MSC_CLASS);
   \   00000006   0x.... 0x....      ADR.W    R0,MSG_MSC_CLASS
   \   0000000A   0x.... 0x....      B.W      printd
    266            }
    267            else if((*id).bInterfaceClass  == 0x03)
   \                     ??USBH_USR_Configuration_DescAvailable_0: (+1)
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD103             BNE.N    ??USBH_USR_Configuration_DescAvailable_1
    268            {
    269              printd((void *)MSG_HID_CLASS);
   \   00000012   0x.... 0x....      ADR.W    R0,MSG_HID_CLASS
   \   00000016   0x.... 0x....      B.W      printd
    270            }    
    271          #endif  
    272          }
   \                     ??USBH_USR_Configuration_DescAvailable_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    273          
    274          /**
    275            * @brief  USBH_USR_Manufacturer_String
    276            * @param  Manufacturer String
    277            * @retval None
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          void USBH_USR_Manufacturer_String(void *ManufacturerString)
    280          {
    281          #ifdef __DEBUG_USB_MSG  
    282            /* callback for  Manufacturer String */
    283            printd("Manufacturer : %s\r\n", (char *)ManufacturerString);
   \                     USBH_USR_Manufacturer_String: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x.... 0x....      ADR.W    R0,?_6
   \   00000006   0x.... 0x....      B.W      printd
    284          #endif  
    285          }
    286          
    287          /**
    288            * @brief  USBH_USR_Product_String
    289            * @param  Product String
    290            * @retval None
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void USBH_USR_Product_String(void *ProductString)
    293          {
    294          #ifdef __DEBUG_USB_MSG
    295            /* callback for Product String */
    296            printd("Product : %s\r\n", (char *)ProductString);  
   \                     USBH_USR_Product_String: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x.... 0x....      ADR.W    R0,?_7
   \   00000006   0x.... 0x....      B.W      printd
    297          #endif  
    298          }
    299          
    300          /**
    301            * @brief  USBH_USR_SerialNum_String
    302            * @param  SerialNum_String
    303            * @retval None
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          void USBH_USR_SerialNum_String(void *SerialNumString)
    306          {
    307          #ifdef __DEBUG_USB_MSG  
    308            /* callback for SerialNum_String */
    309            printd( "Serial Number : %s\r\n", (char *)SerialNumString);    
   \                     USBH_USR_SerialNum_String: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x.... 0x....      ADR.W    R0,?_8
   \   00000006   0x.... 0x....      B.W      printd
    310          #endif  
    311          }
    312          
    313          /**
    314            * @brief  EnumerationDone 
    315            *         User response request is displayed to ask application jump to class
    316            * @param  None
    317            * @retval None
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          void USBH_USR_EnumerationDone(void)
    320          {
    321          #ifdef __DEBUG_USB_MSG  
    322            printd((void *)MSG_DEV_ENUMERATED);
   \                     USBH_USR_EnumerationDone: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,MSG_DEV_ENUMERATED
   \   00000004   0x.... 0x....      B.W      printd
    323          #endif  
    324          } 
    325          
    326          /**
    327            * @brief  USBH_USR_DeviceNotSupported
    328            *         Device is not supported
    329            * @param  None
    330            * @retval None
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          void USBH_USR_DeviceNotSupported(void)
    333          {
   \                     USBH_USR_DeviceNotSupported: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    334          #ifdef __DEBUG_USB_MSG  
    335            printd ("> Device not supported.\r\n"); 
   \   00000002   0x.... 0x....      ADR.W    R0,?_9
   \   00000006   0x.... 0x....      BL       printd
    336          #endif  
    337            TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_DeviceNotSupported;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x....             LDR.N    R1,??DataTable34
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    338          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    339          
    340          
    341          /**
    342            * @brief  USBH_USR_UserInput
    343            *         User Action for application state entry
    344            * @param  None
    345            * @retval USBH_USR_Status : User response for key button
    346            */

   \                                 In section .text, align 2, keep-with-next
    347          USBH_USR_Status USBH_USR_UserInput(void)
    348          {
    349            /* callback for Key botton: set by software in this case */
    350            return USBH_USR_RESP_OK;
   \                     USBH_USR_UserInput: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /**
    354            * @brief  USBH_USR_OverCurrentDetected
    355            *         Over Current Detected on VBUS
    356            * @param  None
    357            * @retval None
    358            */

   \                                 In section .text, align 2, keep-with-next
    359          void USBH_USR_OverCurrentDetected (void)
    360          {
    361          	/* Error */
    362          	TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_Error;
   \                     USBH_USR_OverCurrentDetected: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable34
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    363          }
   \   00000006   0x4770             BX       LR               ;; return
    364          
    365          /**
    366            * @brief  USBH_USR_MSC_Application
    367            * @param  None
    368            * @retval Staus
    369            */
    370          //extern static BYTE check_fs (FATFS *fs,WORD sect);

   \                                 In section .text, align 2, keep-with-next
    371          int USBH_USR_MSC_Application(void)
    372          {
   \                     USBH_USR_MSC_Application: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    373          	/* Device is connected */
    374          	if (Application == USH_USR_FS_INIT) 
   \   00000002   0x....             LDR.N    R0,??DataTable34_1
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD10D             BNE.N    ??USBH_USR_MSC_Application_0
    375          	{
    376          		Application = USH_USR_FS_LOOP;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    377          		/* Device is connected */
    378          		TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_Connected;
   \   0000000E   0x....             LDR.N    R0,??DataTable34
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    379          		if (USBH_MSC_Param.MSWriteProtect == DISK_WRITE_PROTECTED)
   \   00000012   0x....             LDR.N    R1,??DataTable34_2
   \   00000014   0x7B09             LDRB     R1,[R1, #+12]
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD105             BNE.N    ??USBH_USR_MSC_Application_0
    380          		{
    381          			/* Device is write protected */
    382          			TM_USB_MSCHOST_INT_Result = TM_USB_MSCHOST_Result_WriteProtected;
   \   0000001A   0x2104             MOVS     R1,#+4
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
    383          			printk("Write protected......\n");
   \   0000001E   0x.... 0x....      ADR.W    R0,?_10
   \   00000022   0x.... 0x....      BL       printk
    384          		}
    385          	}
    386          	return 0;
   \                     ??USBH_USR_MSC_Application_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    387          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x........         DC32     TM_USB_MSCHOST_INT_Result

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x........         DC32     Application

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x........         DC32     USBH_MSC_Param

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x20 0x55          DC8 " USB OTG FS MSC Host\015\012"
   \              0x53 0x42    
   \              0x20 0x4F    
   \              0x54 0x47    
   \              0x20 0x46    
   \              0x53 0x20    
   \              0x4D 0x53    
   \              0x43 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x3E 0x55          DC8 ">USB Host library started.\015\012"
   \              0x53 0x42    
   \              0x20 0x48    
   \              0x6F 0x73    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x62 0x72    
   \              0x61 0x72    
   \              0x79 0x20    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x65    
   \              0x64 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x20 0x55          DC8 " USB Host Library v2.1.0\015\012"
   \              0x53 0x42    
   \              0x20 0x48    
   \              0x6F 0x73    
   \              0x74 0x20    
   \              0x4C 0x69    
   \              0x62 0x72    
   \              0x61 0x72    
   \              0x79 0x20    
   \              0x76 0x32    
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x44 0x45          DC8 "DETECT 0"
   \              0x54 0x45    
   \              0x43 0x54    
   \              0x20 0x30    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x56 0x49          DC8 "VID : %04Xh\015\012"
   \              0x44 0x20    
   \              0x3A 0x20    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x68 0x0D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x50 0x49          DC8 "PID : %04Xh\015\012"
   \              0x44 0x20    
   \              0x3A 0x20    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x68 0x0D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x4D 0x61          DC8 "Manufacturer : %s\015\012"
   \              0x6E 0x75    
   \              0x66 0x61    
   \              0x63 0x74    
   \              0x75 0x72    
   \              0x65 0x72    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x73 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x50 0x72          DC8 "Product : %s\015\012"
   \              0x6F 0x64    
   \              0x75 0x63    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x53 0x65          DC8 "Serial Number : %s\015\012"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x4E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x3E 0x20          DC8 "> Device not supported.\015\012"
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x73    
   \              0x75 0x70    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x57 0x72          DC8 "Write protected......\012"
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x70 0x72    
   \              0x6F 0x74    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0
    388          
    389          
    390          #if 0
    391          	char fname[20] = {0,};
    392          	sprintf(fname,"1:usbmkh.txt");
    393          	switch (USBH_USR_ApplicationState)
    394          	{
    395          	case USH_USR_FS_INIT:
    396          		if (f_mount( &USB_Fs, "1:", 1 ) != FR_OK ) 
    397          		{
    398          		  /* efs initialisation fails*/
    399          			printk("USB Mount Fail.....\n");
    400          			return(-1);
    401          		}
    402          			/* Flash Disk is write protected */
    403          		if (USBH_MSC_Param.MSWriteProtect == DISK_WRITE_PROTECTED)
    404          		{ 
    405          			return(-1);
    406          		}
    407          		USBH_USR_ApplicationState = USH_USR_APP;
    408          		printk("USB Mount OK.....\n");
    409          		printk("USB step.....[%d]\n",USBH_USR_ApplicationState);
    410          		break;
    411              case USH_USR_APP:
    412          		f_unlink(fname);
    413          		if(f_open(&USB_Fil,fname,FA_READ | FA_WRITE | FA_CREATE_ALWAYS) == FR_OK)
    414          		{
    415          			f_printf(&USB_Fil,"First string in my file\n");
    416          			f_close(&USB_Fil);
    417          			printk("USB fine write.....\n");
    418          		}
    419          		USBH_USR_ApplicationState = USH_USR_IDLE;
    420          		printk("USB step.....[%d]\n",USBH_USR_ApplicationState);
    421          		break;
    422              case USH_USR_IDLE:
    423          		break;
    424              default:
    425          		break;
    426            }
    427          
    428            return(0);
    429          }
    430          #endif
    431          
    432          
    433          #if 0
    434          
    435          
    436          void ProgramUpdateMsg(void)
    437          {
    438            if(ProgramUpdateMsgNo > 0 && ProgramUpdateMsgNo < 6) {  
    439              lcd_clear();
    440              switch(ProgramUpdateMsgNo) {
    441                case 1:
    442                      LCD_printf(0,0,0," Incorrect File ");
    443                      LCD_printf(0,2,0,"Can Not Download");  
    444                      break;
    445                case 2:
    446                      LCD_printf(0,0,0,"Found New SW Ver");
    447                      LCD_printf(0,2,0,"  System Reset  ");   
    448                      break;
    449                case 3:
    450                      LCD_printf(0,0,0,"NAND Update Fail");
    451                      LCD_printf(0,2,0,"Can not download");  
    452                      break;
    453                case 4:
    454                      LCD_printf(0,0,0,"  Same SW Ver   ");
    455                      LCD_printf(0,2,0," Updated Already");   
    456                      break;
    457                case 5:
    458                      LCD_printf(0,0,0,"Previous SW Ver ");
    459                      LCD_printf(0,2,0,"Can Not Download");   
    460                      break;
    461              }
    462              delay_ms(1000);  
    463            }
    464          }
    465                    
    466          void BootUpdateMsg(void)
    467          {
    468            if(BootUpdateMsgNo > 0 && BootUpdateMsgNo < 6) {
    469              lcd_clear();
    470              switch(BootUpdateMsgNo) {
    471                case 1:
    472                      LCD_printf(0,0,0,"Boot Loader File");
    473                      LCD_printf(0,2,0,"Update...       ");  
    474                      break;
    475                case 2:
    476                      LCD_printf(0,0,0,"Boot Loader File");
    477                      LCD_printf(0,2,0,"Update Fail!     ");  
    478                      LCD_printf(0,4,0,"Try Again!!     ");  
    479                      break;
    480                case 3:
    481                      LCD_printf(0,0,0,"Boot Loader File");
    482                      LCD_printf(0,2,0,"NAND Update Fail");
    483                      LCD_printf(0,4,0,"Can Not Download");  
    484                      break;
    485                case 4:
    486                      LCD_printf(0,0,0,"Boot Loader File");
    487                      LCD_printf(0,2,0," Updated Already");   
    488                      break;
    489                case 5:
    490                      LCD_printf(0,0,0,"Boot Loader File");
    491                      LCD_printf(0,2,0," Updated Already");   
    492                  break;
    493              }  
    494              delay_ms(1000);
    495            }
    496          }
    497          
    498          void ProgramFileUpdate(void)
    499          {
    500            FIL tfile; 	
    501            u32 val0, val1, jump = 0, startCode;
    502          	u16 bytesRead;
    503          	u32 i, j, n, checksum = 0, read_checksum = 0, nand_addr, nand_checksum = 0;
    504          	u8 buff[4], error = 0;
    505          
    506            IWDG_ReloadCounter(); 
    507            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
    508              lcd_clear();
    509              LCD_printf(0,2,0,"Not connected");
    510              return;
    511            }
    512            DownFileLength = 0;
    513            nand_addr = NAND_PROGRAM_ADDR;
    514            memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
    515            if (f_open(&tfile, DOWNLOAD_FILENAME, FA_READ) == FR_OK) {
    516              if(!(tfile.fsize%4) && tfile.fsize < USER_PROGRAM_SIZE) {
    517                n = tfile.fsize/4;
    518                for(i = 0; i < n; i++) {
    519                  IWDG_ReloadCounter(); 
    520                  if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) return;
    521                  if(f_read (&tfile, buff, 4, (void *)&bytesRead) == FR_OK) {
    522                    if(bytesRead != 4) { 
    523                      error = 1;
    524                      break;
    525                    }
    526                    if(i == 0) {
    527                      memcpy((u8*)&startCode, buff, 4);
    528                      if ((startCode & 0x2FFE0000 ) != 0x20000000) {
    529                        error = 1;
    530                        break;
    531                      }
    532                    }
    533                    if(i == n-1)
    534                      memcpy((u8*)&read_checksum, buff, 4);
    535                    else {
    536                      for(j = 0; j < bytesRead; j++)
    537                        checksum += buff[j];
    538                    }
    539                    memcpy(&IDE_DnBuff[DownFileLength%NAND_PAGE_SIZE],buff,4);
    540                    DownFileLength +=4;
    541                    if(DownFileLength%NAND_PAGE_SIZE == 0) {
    542                      IWDG_ReloadCounter();
    543                      Nand_Write_Buffer(IDE_DnBuff, nand_addr, NAND_PAGE_SIZE); 
    544                      nand_addr += NAND_PAGE_SIZE;
    545                      memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
    546                    }
    547                  }
    548                  else {
    549                    error = 1;
    550                    break;
    551                  }
    552                }
    553                IWDG_ReloadCounter();
    554                if(DownFileLength%NAND_PAGE_SIZE != 0 && DownFileLength > NAND_PAGE_SIZE) {
    555                  Nand_Write_Buffer(IDE_DnBuff, nand_addr, NAND_PAGE_SIZE); 
    556                  memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
    557                }
    558              }
    559              else
    560                error = 1;
    561              f_close (&tfile);
    562            }
    563            if(checksum != read_checksum || error) {
    564              if(HCD_IsDeviceConnected(&USB_OTG_Core) == 1)
    565                ProgramUpdateMsgNo = 1;
    566              return;
    567            }
    568            jump = FRAMByteRead(offsetof(st_FRAM_Data,UpdateCheck)); 
    569            val0 = ((u32)finfo.fdate*0x10000) + (u32)finfo.ftime;
    570          
    571            if(jump) {
    572              FRAMMultiWrite((u8 *)&val0, offsetof(st_FRAM_Data,FW_Date), 4);  
    573              FRAMByteWrite(0,offsetof(st_FRAM_Data,UpdateCheck));
    574            }
    575            else {
    576              IWDG_ReloadCounter();
    577              FRAMMultiRead((u8 *)&val1, offsetof(st_FRAM_Data,FW_Date), 4);  
    578              if(val0 > val1 && DownFileLength > 4) { //1.4.0.0
    579                n = (DownFileLength-4)/NAND_PAGE_SIZE;
    580                nand_addr = NAND_PROGRAM_ADDR;
    581                checksum = 0;
    582                nand_checksum = 0;
    583                for(i = 0; i < n; i++) {
    584                  IWDG_ReloadCounter();
    585                  Nand_Read_Buffer(IDE_DnBuff, nand_addr, NAND_PAGE_SIZE); 
    586                  for(j = 0; j < NAND_PAGE_SIZE; j++)
    587                      checksum += IDE_DnBuff[j];
    588                  nand_addr += NAND_PAGE_SIZE;
    589                }
    590                n = (DownFileLength-4)%NAND_PAGE_SIZE;
    591                IWDG_ReloadCounter();
    592                Nand_Read_Buffer(IDE_DnBuff, nand_addr, n); 
    593                for(i = 0; i < n; i++)
    594                    checksum += IDE_DnBuff[i];
    595                nand_addr += n;
    596                Nand_Read_Buffer((u8*)&nand_checksum, nand_addr, 4); 
    597                if(checksum == nand_checksum && nand_checksum == read_checksum) {
    598          //        IT_Configuration(DISABLE);
    599                  IWDG_ReloadCounter();
    600                  FRAMMultiWrite((u8 *)&val0, offsetof(st_FRAM_Data,FW_File_Date), 4);  
    601                  FRAMMultiWrite((u8 *)&DownFileLength, offsetof(st_FRAM_Data,FW_Size), 4);  
    602                  FRAMByteWrite(10,offsetof(st_FRAM_Data,UpdateCheck));   
    603          #ifdef __DATE_UPDATE_ENABLE        
    604                  Fram.VuIdentification.vuSoftInstallationDate = 0; 		
    605                  FramWriteData((u8*)&Fram.VuIdentification.vuSoftInstallationDate,4);
    606          #endif        
    607                  Fram.PowerInterruption.powerFlag = 0;
    608                  FramWrite(offsetof(st_FRAM_Data,PowerInterruption),sizeof(Fram.PowerInterruption)); 
    609                  ProgramUpdateMsgNo = 2;
    610                  ProgramResetFlag = 1;
    611          //        NVIC_SystemReset();
    612                }
    613                else {
    614                  ProgramUpdateMsgNo = 3;
    615                }
    616              }
    617              else if(val0 == val1) {
    618                ProgramUpdateMsgNo = 4;
    619              }
    620              else {
    621                ProgramUpdateMsgNo = 5;
    622              }
    623            }  
    624          }
    625          
    626          void BootFileUpdate(void)
    627          {
    628            FIL tfile; 	
    629            u32 startCode;
    630          	u16 bytesRead;
    631          	u32 i, j, n, checksum = 0, read_checksum = 0, nand_addr, nand_checksum = 0, boot_checksum = 0;
    632          	u8 buff[4], error = 0;
    633            __IO uint32_t address;
    634          
    635            IWDG_ReloadCounter(); 
    636            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
    637              lcd_clear();
    638              LCD_printf(0,2,0,"Not connected");
    639              return;
    640            }
    641            DownFileLength = 0;
    642            nand_addr = NAND_BOOT_PROGRAM_ADDR;
    643            memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
    644            if (f_open(&tfile, BOOTLOADER_FILENAME, FA_READ) == FR_OK) {
    645              if(!(tfile.fsize%4) && tfile.fsize < BOOTLOADER_SIZE) {
    646                n = tfile.fsize/4;
    647                for(i = 0; i < n; i++) {
    648                  IWDG_ReloadCounter(); 
    649                  if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) return;
    650                  if(f_read (&tfile, buff, 4, (void *)&bytesRead) == FR_OK) {
    651                    if(bytesRead != 4) { 
    652                      error = 1;
    653                      break;
    654                    }
    655                    if(i == 0) {
    656                      memcpy((u8*)&startCode, buff, 4);
    657                      if ((startCode & 0x2FFE0000 ) != 0x20000000) {
    658                        error = 1;
    659                        break;
    660                      }
    661                    }
    662                    if(i == n-1) 
    663                      memcpy((u8*)&read_checksum, buff, 4);
    664                    else {
    665                      for(j = 0; j < bytesRead; j++)
    666                        checksum += buff[j];
    667                    }
    668                    memcpy(&IDE_DnBuff[DownFileLength%NAND_PAGE_SIZE],buff,4);
    669                    DownFileLength +=4;
    670                    if(DownFileLength%NAND_PAGE_SIZE == 0) {
    671                      IWDG_ReloadCounter();
    672                      Nand_Write_Buffer(IDE_DnBuff, nand_addr, NAND_PAGE_SIZE); 
    673                      nand_addr += NAND_PAGE_SIZE;
    674                      memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
    675                    }
    676                  }
    677                  else {
    678                    error = 1;
    679                    break;
    680                  }
    681                }
    682                IWDG_ReloadCounter();
    683                if(DownFileLength%NAND_PAGE_SIZE != 0 && DownFileLength > NAND_PAGE_SIZE) {
    684                  Nand_Write_Buffer(IDE_DnBuff, nand_addr, NAND_PAGE_SIZE); 
    685                  memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
    686                }
    687              }
    688              else
    689                error = 1;
    690              f_close (&tfile);
    691            }
    692            if(checksum == read_checksum && DownFileLength > 4 && !error) {
    693              IWDG_ReloadCounter();
    694              address = BOOTLOADER_ADDRESS+DownFileLength-4;
    695              boot_checksum = 0;
    696              for(i = 0; i < 4; i++)
    697                buff[i] = (*(uint8_t*)(address++));
    698              memcpy((u8*)&boot_checksum, buff, 4);
    699              if(read_checksum != boot_checksum) {
    700                IWDG_ReloadCounter(); 
    701                n = (DownFileLength-4)/NAND_PAGE_SIZE;
    702                nand_addr = NAND_BOOT_PROGRAM_ADDR;
    703                checksum = 0;
    704                nand_checksum = 0;
    705                for(i = 0; i < n; i++) {
    706                  IWDG_ReloadCounter();
    707                  Nand_Read_Buffer(IDE_DnBuff, nand_addr, NAND_PAGE_SIZE); 
    708                  for(j = 0; j < NAND_PAGE_SIZE; j++)
    709                      checksum += IDE_DnBuff[j];
    710                  nand_addr += NAND_PAGE_SIZE;
    711                }
    712                IWDG_ReloadCounter();
    713                n = (DownFileLength-4)%NAND_PAGE_SIZE;
    714                Nand_Read_Buffer(IDE_DnBuff, nand_addr, n); 
    715                for(i = 0; i < n; i++)
    716                    checksum += IDE_DnBuff[i];
    717                nand_addr += n;
    718                Nand_Read_Buffer((u8*)&nand_checksum, nand_addr, 4); 
    719                if(checksum == nand_checksum && nand_checksum == read_checksum) {
    720                  IWDG_ReloadCounter();
    721                  BootUpdateMsgNo = 1;
    722                  if(BOOT_DOWNLOAD() == 0) {
    723          //          IT_Configuration(DISABLE);
    724                    Fram.PowerInterruption.powerFlag = 0;
    725                    FramWrite(offsetof(st_FRAM_Data,PowerInterruption),sizeof(Fram.PowerInterruption)); 
    726                    ProgramResetFlag = 1;
    727          //          NVIC_SystemReset();
    728                  }
    729                  else {
    730                    BootUpdateMsgNo = 2;
    731                  }
    732                }
    733                else {
    734                  BootUpdateMsgNo = 3;
    735                }
    736              }
    737              else {
    738                BootUpdateMsgNo = 4;
    739              }
    740            }
    741            else {
    742              BootUpdateMsgNo = 5;
    743            }
    744          }
    745          
    746          
    747          /**
    748            * @brief  USBH_USR_MSC_Application
    749            * @param  None
    750            * @retval Staus
    751            */
    752          //extern static BYTE check_fs (FATFS *fs,WORD sect);
    753          int USBH_USR_MSC_Application(void)
    754          {
    755          
    756            switch (USBH_USR_ApplicationState)
    757            {
    758              case USH_USR_FS_INIT:
    759          
    760                /* Initialises the File System*/
    761                IWDG_ReloadCounter();
    762                if (f_mount( &fatfs, "", 0 ) != FR_OK ) 
    763                {
    764                  /* efs initialisation fails*/
    765                  return(-1);
    766                }
    767            
    768                /* Flash Disk is write protected */
    769                if (USBH_MSC_Param.MSWriteProtect == DISK_WRITE_PROTECTED)
    770                { 
    771                  return(-1);
    772                }
    773                USB_Detect_Flag = 1;
    774                if(USB_DL_Flag) {
    775                  USBH_USR_ApplicationState = USH_USR_APP;
    776                  break;
    777                }
    778                ProgramResetFlag = 0;
    779                ProgramUpdateMsgNo = 0;
    780                BootUpdateMsgNo = 0;
    781                //- Upgrade File Detected -//
    782                if(USB_Detect_Flag) {
    783                  IWDG_ReloadCounter();
    784                  if(f_stat(DOWNLOAD_FILENAME,&finfo) == FR_OK) {
    785                    ProgramFileUpdate();
    786                  } 
    787                }
    788                if(USB_Detect_Flag) {
    789                  IWDG_ReloadCounter();
    790                  if(f_stat(BOOTLOADER_FILENAME,&finfo) == FR_OK) {
    791                    BootFileUpdate();
    792                  } 
    793                }
    794                ProgramUpdateMsg();      
    795                BootUpdateMsg();
    796                if(ProgramResetFlag)
    797                  NVIC_SystemReset();
    798                /* Go to menu */ 
    799          //      if(ProgramUpdateMsgNo == 0 && BootUpdateMsgNo == 0) {  // USB Connect ..
    800          //        LCD_printf(0,2,0," USB Connected! ");
    801          //        delay_ms(500);
    802          //      }
    803                USBH_USR_ApplicationState = USH_USR_IDLE;
    804                break;
    805          
    806              case USH_USR_APP:
    807                if(USB_Detect_Flag) {
    808          //        IT_Configuration(DISABLE);
    809                  BUZZER_OFF();
    810                  COMMAND_ExecuteApplication();  
    811          //        IT_Configuration(ENABLE);
    812                } 
    813                USB_DL_Flag = 0;
    814                USBH_USR_ApplicationState = USH_USR_IDLE;
    815                break;
    816          
    817              case USH_USR_IDLE:
    818                if(USB_DL_Flag && USB_Detect_Flag) {
    819                  USBH_USR_ApplicationState = USH_USR_APP;
    820                }
    821          
    822                break;
    823          
    824              default:
    825                break;
    826            }
    827            return(0);
    828          }
    829          
    830          /**
    831            * @brief  Test_USB Func
    832            * @param  None
    833            * @retval None
    834            */
    835          u16 Test_USB(void)
    836          {
    837            UINT bytesWritten, bytesRead;  
    838            FIL tfile;  
    839            u8 usbWrite_err_cnt = 0, usbRead_err_cnt = 0;  
    840            u8 wbuff[20] = {0,}, rbuff[20] = {0,} ,i;
    841            char fname[20] = {0,};
    842          
    843            sprintf(fname,"TestDTG.txt");
    844            IWDG_ReloadCounter();
    845          
    846            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
    847              lcd_clear();
    848              LCD_printf(0,2,0,"Not connected");
    849              return 0xffff;
    850            }
    851          
    852            f_unlink(fname);
    853            IWDG_ReloadCounter(); 
    854            if(f_open(&tfile, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
    855              USB_Error_Flag = 1;
    856              usbWrite_err_cnt = 0xff;
    857              return 0xffff;
    858            }
    859            IWDG_ReloadCounter(); 
    860            for(i = 0; i < 10; i++) {
    861              sprintf((char*)wbuff,"USB TEST %d",i);
    862              if(f_write (&tfile, wbuff, 10, &bytesWritten) != FR_OK) {
    863                usbWrite_err_cnt++;
    864              }    
    865            }
    866            if(f_close (&tfile) != FR_OK) {
    867              USB_Error_Flag = 1;
    868              return 0xffff;
    869            }
    870            IWDG_ReloadCounter(); 
    871            
    872            if (f_open(&tfile, fname, FA_READ) != FR_OK)
    873            {
    874              USB_Error_Flag = 1;
    875              usbRead_err_cnt = 0xff;
    876              return 0xffff;
    877            }
    878            IWDG_ReloadCounter(); 
    879            for(i = 0; i < 10; i++) {
    880              sprintf((char*)wbuff,"USB TEST %d",i);
    881              if(f_read (&tfile, rbuff, 10, (void *)&bytesRead) != FR_OK) {
    882                 usbRead_err_cnt++;
    883              }
    884              else if(!IsSameMem(wbuff,rbuff,16)) usbRead_err_cnt++;
    885            }
    886            if(f_close (&tfile) != FR_OK) {
    887              USB_Error_Flag = 1;
    888              return 0xffff;
    889            }
    890            return (((usbWrite_err_cnt<<8)&0xff00)|usbRead_err_cnt);
    891          }
    892          
    893          /**
    894            * @brief  Up Calibration Data Func
    895            * @param  None
    896            * @retval None
    897            */
    898          
    899          union Chk_Sum{
    900            u16 w;
    901            u8 b[2];
    902          };
    903          union W_Data{
    904            u16 w;
    905            u8 b[2];
    906          };
    907          u16 UploadCalData(void)
    908          {
    909            UINT bytesRead;
    910            FIL tfile;
    911            u16 chksum = 0, i;
    912            u8 slot;  
    913            u8 rbuff[sizeof(st_VuCalibrationRecord)+6+86+2] = {0,};
    914            char fname[20] = {0,};
    915            union Chk_Sum rChksum;
    916            union W_Data V_dataTmp, Work_dataTmp;
    917            u8 can_baud, elec_leakage;
    918          
    919            sprintf(fname,"DTG-S1.PRM");
    920            IWDG_ReloadCounter();
    921          
    922            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
    923              lcd_clear();
    924              LCD_printf(0,2,0,"Not connected");
    925              return 1;
    926            }
    927            IWDG_ReloadCounter();
    928            
    929            if (f_open(&tfile, fname, FA_READ) != FR_OK)
    930            {
    931              USB_Error_Flag = 1;//File Open Error
    932              return 1;
    933            }
    934            IWDG_ReloadCounter();
    935            
    936            if(f_read (&tfile, (u8*)&rbuff, sizeof(st_VuCalibrationRecord)+6+86+2, (void*)&bytesRead) != FR_OK) {
    937              USB_Error_Flag = 1;//File Read Error
    938              return 1;
    939            }
    940            if(f_close (&tfile) != FR_OK) {
    941              USB_Error_Flag = 1;//File Close Error
    942              return 1;
    943            }
    944            IWDG_ReloadCounter();
    945            
    946            for(i = 0; i < sizeof(st_VuCalibrationRecord); i++)
    947              chksum += rbuff[i];
    948            for(i = 0; i < 2; i++) {
    949              V_dataTmp.b[i] = rbuff[sizeof(st_VuCalibrationRecord)+i];
    950              chksum += rbuff[sizeof(st_VuCalibrationRecord)+i];
    951            }
    952            for(i = 0; i < 2; i++) {
    953              Work_dataTmp.b[i] = rbuff[sizeof(st_VuCalibrationRecord)+i+2];
    954              chksum += rbuff[sizeof(st_VuCalibrationRecord)+i+2];
    955            }
    956            elec_leakage = rbuff[sizeof(st_VuCalibrationRecord)+4];
    957            chksum += rbuff[sizeof(st_VuCalibrationRecord)+4];
    958            can_baud = rbuff[sizeof(st_VuCalibrationRecord)+5];
    959            chksum += rbuff[sizeof(st_VuCalibrationRecord)+5];
    960            for(i = 0; i < 86; i++)
    961              chksum += rbuff[sizeof(st_VuCalibrationRecord)+i+6];
    962            for(i = 0; i < 2; i++)
    963              rChksum.b[i] = rbuff[sizeof(st_VuCalibrationRecord)+i+92];
    964            
    965            IWDG_ReloadCounter();
    966            
    967            if(rChksum.w == chksum) {
    968              if(CardType[0] == WORKSHOP_CARD) slot = 0;
    969              else if(CardType[1] == WORKSHOP_CARD) slot = 1; 
    970              else slot = 0xff;
    971              if(slot < 2) {
    972                memcpy((u8*)&TmpCalibData, rbuff, sizeof(st_VuCalibrationRecord));
    973                if(RTC_LVal+(RTC_LVal%(3600*24)) > TmpCalibData.nextCalibrationDate) {
    974                  lcd_clear();
    975                  LCD_printf(0,0,0,"Next Calibration");
    976                  LCD_printf(0,2,0,"  Date Error!   ");
    977                  delay_ms(1000);
    978                  return 1;
    979                }
    980                TmpCalibData.oldTimeValue = CalibrationRecord.oldTimeValue;
    981                TmpCalibData.newTimeValue = CalibrationRecord.newTimeValue;
    982                memcpy((u8*)&TmpCalibData.oldOdometerValue, (u8*)&CalibrationRecord.oldOdometerValue, 3);
    983                if(!IsSameMem((u8*)&CalibrationRecord.vehicleIdNumber, (u8*)&TmpCalibData.vehicleIdNumber, sizeof(st_VuCalibrationRecord)-95)) {
    984                  if(IsSameMem((u8*)&TmpCalibData.vehicleRegistration, (u8*)&CalibrationRecord.vehicleRegistration, sizeof(st_VehicleRegistration))) 
    985                    TmpCalibData.calibrationPurpose = 4;
    986                  else
    987                    TmpCalibData.calibrationPurpose = 3;
    988                  memcpy((u8*)&CalibrationRecord, (u8*)&TmpCalibData, sizeof(st_VuCalibrationRecord)-12);
    989          				memcpy((u8*)&CalibrationRecord.workshopName, (u8*)&WorkshopIdentification[slot].WorkshopCardHolderId.workshopName, sizeof(st_NameField));
    990          				memcpy((u8*)&CalibrationRecord.workshopAddress, (u8*)&WorkshopIdentification[slot].WorkshopCardHolderId.workshopAddress, sizeof(st_NameField));
    991                  memcpy((u8*)&CalibrationRecord.workshopCardNumber, (u8*)&VuCardIWRecord[slot].FullCardNumber, sizeof(st_fullCardNumber));
    992                  CalibrationRecord.workshopCardExpiryDate = VuCardIWRecord[slot].cardExpiryDate;
    993                  ODOValToBuff(CalibrationRecord.oldOdometerValue,(u32)Fram.TTrip);
    994                  Fram.TTrip = (double)ODOBuffToVal(CalibrationRecord.newOdometerValue);
    995                  CalibrationRecord.oldTimeValue = RTC_LVal;
    996                  CalibrationRecord.newTimeValue = CalibrationRecord.oldTimeValue;
    997                  CardCalibrationRecord.oldTimeValue = SwapEndian32(RTC_LVal);
    998                  CardCalibrationRecord.newTimeValue = CardCalibrationRecord.oldTimeValue;
    999                  CalibrationRecord.nextCalibrationDate = TmpCalibData.nextCalibrationDate;// RTC_LVal+(2*24*365*3600);
   1000                  CardCalibrationRecord.nextCalibrationDate = SwapEndian32(CalibrationRecord.nextCalibrationDate);
   1001                  
   1002                  memcpy((u8*)&CardCalibrationRecord.vehicleIdentificationNumber, (u8*)&CalibrationRecord.vehicleIdNumber, 17);
   1003                  memcpy((u8*)&CardCalibrationRecord.vehicleRegistration, (u8*)&CalibrationRecord.vehicleRegistration, sizeof(st_VehicleRegistration));
   1004                  memcpy((u8*)&CardCalibrationRecord.tyreSize, (u8*)&CalibrationRecord.tyreSize, 15);
   1005                  MemCopyChangeEndian((u8*)&CardCalibrationRecord.wVehicleCharacteristicConstant, (u8*)&CalibrationRecord.wVehicleCharacteristicConstant, 2);
   1006                  MemCopyChangeEndian((u8*)&CardCalibrationRecord.kConstantOfRecordingEquipment, (u8*)&CalibrationRecord.kConstantOfRecordingEquipment, 2);
   1007                  MemCopyChangeEndian((u8*)&CardCalibrationRecord.lTyreCircumference, (u8*)&CalibrationRecord.lTyreCircumference, 2);
   1008                  MemCopyChangeEndian((u8*)&CardCalibrationRecord.oldOdometerValue, (u8*)&CalibrationRecord.oldOdometerValue, 3);
   1009                  MemCopyChangeEndian((u8*)&CardCalibrationRecord.newOdometerValue, (u8*)&CalibrationRecord.newOdometerValue, 3);
   1010                  CardCalibrationRecord.authorisedSpeed = CalibrationRecord.authorisedSpeed;
   1011                  
   1012                  Nand_Write_Calibration(CalibrationRecord);
   1013                  Write_Calibration_Data();
   1014                  Write_WorkshopDownload(1);
   1015                  CalibToFram();
   1016                }
   1017                else {
   1018                  if(Fram.V_Factor == V_dataTmp.w && Fram.WorkNumber == Work_dataTmp.w && Fram.CAN_BaudrateFlag == can_baud && Fram.ElectricLeakageFlag == elec_leakage) {
   1019                    lcd_clear();
   1020                    LCD_printf(0,2,0," Same Parameter!");
   1021                    delay_ms(1000);
   1022                    return 1;
   1023                  }
   1024                }
   1025                Fram.V_Factor = V_dataTmp.w;
   1026                FramWrite(offsetof(st_FRAM_Data,V_Factor),sizeof(Fram.V_Factor));
   1027                Fram.WorkNumber = Work_dataTmp.w;
   1028                FramWrite(offsetof(st_FRAM_Data,WorkNumber),sizeof(Fram.WorkNumber));
   1029                Fram.CAN_BaudrateFlag = can_baud;
   1030                FramWrite(offsetof(st_FRAM_Data,CAN_BaudrateFlag),sizeof(Fram.CAN_BaudrateFlag));
   1031                CAN_Configuration();
   1032                Fram.ElectricLeakageFlag = elec_leakage;
   1033                FramWrite(offsetof(st_FRAM_Data,ElectricLeakageFlag),sizeof(Fram.ElectricLeakageFlag));  
   1034              }
   1035            }
   1036            else {
   1037              lcd_clear();
   1038              LCD_printf(0,2,0," Incorrect File ");
   1039              delay_ms(1000);
   1040              USB_Error_Flag = 1;//Chksum Error
   1041              return 1;
   1042            }
   1043            
   1044            return 0;
   1045          }
   1046          
   1047          /**
   1048            * @brief  Down Calibration Data Func
   1049            * @param  None
   1050            * @retval None
   1051            */
   1052          __packed typedef struct {
   1053            u8  calibrationPurpose;
   1054            st_NameField workshopName;
   1055            st_NameField workshopAddress;
   1056            st_fullCardNumber workshopCardNumber;
   1057            long workshopCardExpiryDate;
   1058            u8  vehicleIdNumber[17];
   1059            st_VehicleRegistration vehicleRegistration;
   1060            u16 wVehicleCharacteristicConstant;
   1061            u16 kConstantOfRecordingEquipment;
   1062            u16 lTyreCircumference;
   1063            u8  tyreSize[15];
   1064            u8  authorisedSpeed;
   1065            u8  oldOdometerValue[3];
   1066            u8  newOdometerValue[3];
   1067            long oldTimeValue;
   1068            long newTimeValue;
   1069            long nextCalibrationDate;
   1070            // Add Parameger
   1071            u16 V_Factor;
   1072            u16 WorkShopNumber;
   1073            u8  ElectricLeakageFlag;
   1074            u8  CAN_BaudrateFlag;  
   1075            // Add Information
   1076            u8  ManuFactureName[35];
   1077            u8  vuPartNumber[16];
   1078            u8  vuSerialNumber[8];
   1079            long  vuManufacturingDate;
   1080            u8  NCMNumber;
   1081            u8  NCMPartNumber[16];
   1082            u8  NCMExPiredDate[6];
   1083          }st_USBCalibrationRecord;
   1084          
   1085          u16 DownloadCalData(void)
   1086          {
   1087            UINT bytesRead;
   1088            FIL tfile;
   1089            u16 chksum = 0, i;
   1090            u8 *ptr;
   1091            st_USBCalibrationRecord USBCalibrationRecord;
   1092            char fname[50] = {0,};
   1093            u8 ch, year_ch, mon_ch, day_ch[2];
   1094          
   1095            BuzzerOff();  
   1096          	year_ch = YEAR-14+'A';
   1097          	mon_ch = MONTH-1+'A';
   1098          	day_ch[0] = (DAY/10)+'0';
   1099          	day_ch[1] = (DAY%10)+'0';
   1100            
   1101            IWDG_ReloadCounter(); 
   1102            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1103              lcd_clear();
   1104              LCD_printf(0,2,0,"Not connected");
   1105              return 1;
   1106            }
   1107            
   1108            memset(fname,0,50);
   1109            sprintf(fname, "S1_CAL20%02d%02d%02d%02d%02d%02d%c", RTC_Val.tm_year, RTC_Val.tm_mon, RTC_Val.tm_mday, RTC_Val.tm_hour, RTC_Val.tm_min, RTC_Val.tm_sec,'_');
   1110            for(i=21;i<34;i++) {
   1111              ch = Fram.VRN[i-21+1];
   1112              if((ch<'0' || ch>'9') && (ch<'a' || ch>'z') && (ch<'A' || ch>'Z'))
   1113                fname[i] =  '_';
   1114              else
   1115                fname[i] =  ch;
   1116            }
   1117            fname[34] = '_';
   1118            fname[35] = year_ch;
   1119            fname[36] = mon_ch;
   1120            fname[37] = day_ch[0];
   1121            fname[38] = day_ch[1];
   1122          
   1123            fname[39] = '.';
   1124            fname[40] = 'C';
   1125            fname[41] = 'A';
   1126            fname[42] = 'L';
   1127          
   1128            // Remove file if exist on flash disk 
   1129          
   1130            f_unlink(fname);
   1131          
   1132            IWDG_ReloadCounter();
   1133            
   1134            // Calibration Record Copy
   1135            memcpy((u8*)&USBCalibrationRecord, (u8*)&CalibrationRecord, sizeof(st_VuCalibrationRecord));
   1136            // Add Parameter
   1137            USBCalibrationRecord.V_Factor = Fram.V_Factor;
   1138            USBCalibrationRecord.WorkShopNumber = Fram.WorkNumber;
   1139            USBCalibrationRecord.ElectricLeakageFlag = Fram.ElectricLeakageFlag;
   1140            USBCalibrationRecord.CAN_BaudrateFlag = Fram.CAN_BaudrateFlag;           
   1141            // Add Information
   1142            memcpy((u8*)USBCalibrationRecord.ManuFactureName, (u8*)Fram.VuIdentification.vuManufacturerName.Name, 35);
   1143            memcpy((u8*)USBCalibrationRecord.vuPartNumber, (u8*)Fram.VuIdentification.vuPartNumber, 16);
   1144            memcpy((u8*)USBCalibrationRecord.vuSerialNumber, (u8*)Fram.VuIdentification.vuSerialNumber, 8);
   1145            USBCalibrationRecord.vuManufacturingDate = Fram.VuIdentification.vuManufacturingDate;
   1146            USBCalibrationRecord.NCMNumber = Fram.NCMNumber;
   1147            memcpy((u8*)USBCalibrationRecord.NCMPartNumber, (u8*)NCMActivationData.PartNumber, 16);;
   1148            memcpy((u8*)USBCalibrationRecord.NCMExPiredDate, (u8*)NCMStatus.ExPiredDate, 6);
   1149          
   1150            ptr = (u8*)&USBCalibrationRecord;
   1151            
   1152            for(i = 0; i < sizeof(st_USBCalibrationRecord); i++)
   1153              chksum += *(ptr+i);
   1154            
   1155            if (f_open(&tfile, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
   1156            {
   1157              USB_Error_Flag = 1;//File Open Error
   1158              return 1;
   1159            }
   1160            IWDG_ReloadCounter();
   1161            
   1162            if(f_write(&tfile, (u8*)&USBCalibrationRecord, sizeof(st_USBCalibrationRecord), (void*)&bytesRead) != FR_OK) {
   1163              USB_Error_Flag = 1;//File Read Error
   1164              return 1;
   1165            }
   1166            if(f_write(&tfile, (u8*)&chksum, sizeof(u16), (void*)&bytesRead) != FR_OK) {
   1167              USB_Error_Flag = 1;//File Read Error
   1168              return 1;
   1169            }
   1170            
   1171            if(f_close (&tfile) != FR_OK) {
   1172              USB_Error_Flag = 1;//File Close Error
   1173              return 1;
   1174            }
   1175            IWDG_ReloadCounter();
   1176            
   1177            return 0;
   1178          }
   1179          
   1180          #if 1
   1181            /**
   1182            * @brief  File Name
   1183            * @param  None
   1184            * @retval None
   1185            */
   1186          void FileName(char *filename, char *ext) 
   1187          {
   1188            int i;
   1189            
   1190            memset(filename,0,32);
   1191            sprintf(filename, "%02d%02d%02d%02d%02d%02d%c", RTC_Val.tm_year, RTC_Val.tm_mon, RTC_Val.tm_mday, RTC_Val.tm_hour, RTC_Val.tm_min, RTC_Val.tm_sec,'-');
   1192            for(i=13;i<26;i++) {
   1193              if((Fram.VRN[(i-13)+1]<'0' || Fram.VRN[(i-13)+1]>'9') && (Fram.VRN[(i-13)+1]<'a' || Fram.VRN[(i-13)+1]>'z') && (Fram.VRN[(i-13)+1]<'A' || Fram.VRN[(i-13)+1]>'Z'))
   1194                filename[i] =  '_';
   1195              else
   1196                filename[i] =  Fram.VRN[(i-13)+1];
   1197            }
   1198            filename[26] = ext[0];
   1199            filename[27] = ext[1];
   1200            filename[28] = ext[2];
   1201            filename[29] = ext[3];
   1202          }
   1203          #else 
   1204            /**
   1205            * @brief  File Name
   1206            * @param  None
   1207            * @retval None
   1208            */
   1209          void FileName(char *filename, char *ext) 
   1210          {
   1211            int i;
   1212            
   1213            memset(filename,0,20);
   1214            
   1215            for(i=0;i<13;i++) {
   1216              if((Fram.VRN[i+1]<'0' || Fram.VRN[i+1]>'9') && (Fram.VRN[i+1]<'a' || Fram.VRN[i+1]>'z') && (Fram.VRN[i+1]<'A' || Fram.VRN[i+1]>'Z'))
   1217                filename[i] =  '_';
   1218              else
   1219                filename[i] =  Fram.VRN[i+1];
   1220            }
   1221            filename[13] = ext[0];
   1222            filename[14] = ext[1];
   1223            filename[15] = ext[2];
   1224            filename[16] = ext[3];
   1225          }
   1226          #endif
   1227          
   1228          /**
   1229            * @brief  USB User Func
   1230            * @param  None
   1231            * @retval None
   1232            */
   1233          void DownloadDrvData(u8 count)
   1234          {  
   1235            UINT bytesWritten;  
   1236            char fname[50]; 
   1237            u8 buff[NAND_PAGE_SIZE];
   1238            u16 i, n, size;
   1239            u32 start_addr = 0, end_addr = 0;
   1240            long start_date;
   1241            u8 ch;
   1242            u8 year_ch, mon_ch, day_ch[2];
   1243          
   1244            BuzzerOff();  
   1245            if(count == 0) return;
   1246          	year_ch = YEAR-14+'A';
   1247          	mon_ch = MONTH-1+'A';
   1248          	day_ch[0] = (DAY/10)+'0';
   1249          	day_ch[1] = (DAY%10)+'0';
   1250            
   1251            lcd_clear();   
   1252          
   1253            LCD_printf(0,0,0,"DOWNLOAD TRAJECT");
   1254          
   1255            IWDG_ReloadCounter(); 
   1256            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1257              lcd_clear();
   1258              LCD_printf(0,2,0,"Not connected");
   1259              return;
   1260            }
   1261          
   1262            start_addr = Fram.VuDailyActRecord.Nand_SecDataAddr;
   1263            if(count < 8) {
   1264              start_date = (RTC_LVal/(3600*24) - (count-1))*3600*24;
   1265              for(i = 0; i < count; i++)  {
   1266                Nand_Read_DailyData(i,(u8*)&TmpDayAct);
   1267                if(TmpDayAct.recordDate >= start_date) {
   1268                  start_addr = TmpDayAct.Nand_SecDataAddr;
   1269                }
   1270                else break;
   1271              }
   1272            }
   1273            else {
   1274              if(Fram.NandSaveAddr < NAND_SIZE_DATA) start_addr = 0;
   1275              else 
   1276                start_addr = (Fram.NandSaveAddr + NAND_BLOCK_SIZE)%NAND_SIZE_DATA;
   1277            }
   1278            
   1279            end_addr = Fram.NandSaveAddr - Fram.NandSaveAddr%NAND_PAGE_SIZE;
   1280          
   1281            if(start_addr >= end_addr) return;
   1282          
   1283            memset(fname,0,50);
   1284            sprintf(fname, "S1_T20%02d%02d%02d%02d%02d%02d%c", RTC_Val.tm_year, RTC_Val.tm_mon, RTC_Val.tm_mday, RTC_Val.tm_hour, RTC_Val.tm_min, RTC_Val.tm_sec,'_');
   1285            for(i=19;i<32;i++) {
   1286              ch = Fram.VRN[i-19+1];
   1287              if((ch<'0' || ch>'9') && (ch<'a' || ch>'z') && (ch<'A' || ch>'Z'))
   1288                fname[i] =  '_';
   1289              else
   1290                fname[i] =  ch;
   1291            }
   1292            fname[32] = '_';
   1293            fname[33] = year_ch;
   1294            fname[34] = mon_ch;
   1295            fname[35] = day_ch[0];
   1296            fname[36] = day_ch[1];
   1297            
   1298            fname[37] = '.';
   1299            fname[38] = 'D';
   1300            fname[39] = 'T';
   1301            fname[40] = 'G';
   1302          
   1303            // Remove file if exist on flash disk 
   1304          
   1305            f_unlink(fname);
   1306            
   1307            IWDG_ReloadCounter(); 
   1308            // Open the file to write on it 
   1309            if(f_open(&file, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
   1310              lcd_clear();
   1311              LCD_printf(0,2,0,"Create file fail");
   1312              delay_ms(2000);
   1313              return;
   1314            }
   1315          
   1316          //- drive data save -//
   1317            draw_rectangle(40,140,3);
   1318              
   1319            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1320            if(f_write (&file, (u8*)&Fram.NationCode, 32, &bytesWritten) != FR_OK) {
   1321              USB_Error_Flag = 1;
   1322              return;    
   1323            }    
   1324              
   1325            IWDG_ReloadCounter();  
   1326          
   1327            size = NAND_PAGE_SIZE - start_addr%NAND_PAGE_SIZE;
   1328            
   1329            if(end_addr > start_addr + size) {
   1330              Nand_Read_Buffer(buff, start_addr%NAND_SIZE_DATA, size);  
   1331              if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1332              if(f_write (&file, buff, size, &bytesWritten) != FR_OK) {
   1333                USB_Error_Flag = 1;
   1334                return;
   1335              }    
   1336              start_addr += size;
   1337            }
   1338            
   1339            n = (end_addr-start_addr)/NAND_PAGE_SIZE;
   1340            
   1341            delay_ms(1);
   1342            for(int i = 0; i < n; i++) {    
   1343              IWDG_ReloadCounter();  
   1344              Nand_Read_Buffer(buff, (start_addr+i*NAND_PAGE_SIZE)%NAND_SIZE_DATA, NAND_PAGE_SIZE); 
   1345              if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1346              delay_ms(1);
   1347              if(f_write (&file, buff, NAND_PAGE_SIZE, &bytesWritten) != FR_OK) {
   1348                USB_Error_Flag = 1;
   1349                return;
   1350              }        
   1351              if(i%10 == 0) {
   1352                draw_fill_box(40, (i*100/n)+40, 3);      
   1353              }    
   1354              if(IDE_Download_Cancel() == KEY_CANCEL){f_close (&file);  return;} 
   1355            }
   1356            
   1357            IWDG_ReloadCounter();    
   1358            delay_ms(1);
   1359            n = Fram.NandSaveAddr%NAND_PAGE_SIZE;
   1360            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1361            if(f_write (&file, Nand_Save_Buff, n, &bytesWritten) != FR_OK) {
   1362              USB_Error_Flag = 1;
   1363              return;
   1364            }      
   1365            draw_fill_box(40, 140, 3);   
   1366            
   1367            if(f_close (&file) != FR_OK) {
   1368              USB_Error_Flag = 1;
   1369              return;
   1370            }  
   1371          }
   1372          
   1373          /**
   1374            * @brief  USB User Func
   1375            * @param  None
   1376            * @retval None
   1377            */
   1378          void DownloadVehicleData(void)
   1379          {  
   1380            UINT bytesWritten;  
   1381            char fname[50]; 
   1382            u8 buff[NAND_PAGE_SIZE];
   1383            u8 hbuff[2];
   1384            int n, size, i;
   1385            u8 ch;
   1386            u8 year_ch, mon_ch, day_ch[2];
   1387            u8 slot;
   1388            long first_downdate;
   1389          
   1390            BuzzerOff();  
   1391          	year_ch = YEAR-14+'A';
   1392          	mon_ch = MONTH-1+'A';
   1393          	day_ch[0] = (DAY/10)+'0';
   1394          	day_ch[1] = (DAY%10)+'0';
   1395            
   1396            lcd_clear();     
   1397            LCD_printf(0,0,0,"DOWNLOAD VEHICLE");
   1398            
   1399            IWDG_ReloadCounter(); 
   1400            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1401              lcd_clear();
   1402              LCD_printf(0,2,0,"Not connected");
   1403              return;
   1404            }
   1405            
   1406            memset(fname,0,50);
   1407            sprintf(fname, "S1_V20%02d%02d%02d%02d%02d%02d%c", RTC_Val.tm_year, RTC_Val.tm_mon, RTC_Val.tm_mday, RTC_Val.tm_hour, RTC_Val.tm_min, RTC_Val.tm_sec,'_');
   1408            for(i=19;i<32;i++) {
   1409              ch = Fram.VRN[i-19+1];
   1410              if((ch<'0' || ch>'9') && (ch<'a' || ch>'z') && (ch<'A' || ch>'Z'))
   1411                fname[i] =  '_';
   1412              else
   1413                fname[i] =  ch;
   1414            }
   1415            fname[32] = '_';
   1416            fname[33] = year_ch;
   1417            fname[34] = mon_ch;
   1418            fname[35] = day_ch[0];
   1419            fname[36] = day_ch[1];
   1420          
   1421            fname[37] = '.';
   1422            fname[38] = 'D';
   1423            fname[39] = 'D';
   1424            fname[40] = 'D';
   1425          
   1426            // Remove file if exist on flash disk 
   1427          
   1428            f_unlink(fname);
   1429            
   1430            IWDG_ReloadCounter(); 
   1431            // Open the file to write on it 
   1432            if(f_open(&file, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
   1433              lcd_clear();
   1434              LCD_printf(0,2,0,"Create file fail");
   1435              delay_ms(2000);
   1436              return;
   1437            }
   1438          
   1439          //- drive data save -//
   1440            draw_rectangle(40,140,3);
   1441            
   1442            IDE_DnDate = RTC_LVal;
   1443            
   1444            IWDG_ReloadCounter();    
   1445            MakeOverviewData(1);
   1446            hbuff[0] = 0x76;  hbuff[1] = 1;
   1447            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1448            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1449            if(f_write (&file, IDE_DnBuff, IDE_DnDataNum, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;}    
   1450            
   1451            if(IDE_Download_Cancel() == KEY_CANCEL){f_close (&file);  return;} 
   1452            draw_fill_box(40, 45, 3);   
   1453          
   1454            IWDG_ReloadCounter();    
   1455            MakeEventFaultData(1);
   1456            hbuff[0] = 0x76;  hbuff[1] = 3;
   1457            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1458            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1459            if(f_write (&file, IDE_DnBuff, IDE_DnDataNum, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;}    
   1460          
   1461            if(IDE_Download_Cancel() == KEY_CANCEL){f_close (&file);  return;} 
   1462            draw_fill_box(40, 50, 3);   
   1463          
   1464          #if 1  
   1465            IWDG_ReloadCounter();    
   1466            MakeDetailedSpeedData(1);
   1467            if(IDE_Download_Cancel() == KEY_CANCEL || IDE_Down_Cancel_Flag){f_close (&file);  return;}  
   1468            hbuff[0] = 0x76;  hbuff[1] = 4;
   1469            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1470            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1471          //  draw_fill_box(40, 70, 3);   
   1472            n = IDE_DnDataNum/NAND_PAGE_SIZE;
   1473            for(int i = 0; i <= n; i++) {    
   1474              IWDG_ReloadCounter();  
   1475              if(i < n) size = NAND_PAGE_SIZE;
   1476              else size = IDE_DnDataNum%NAND_PAGE_SIZE;
   1477              if(size > 0) {
   1478                Nand_Read_Buffer(buff, NAND_DETAILED_DATA_ADDR+i*NAND_PAGE_SIZE, size);  
   1479                if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1480                if(f_write (&file, buff, size, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;}    
   1481              }
   1482              if(i%10 == 0) {
   1483                draw_fill_box(70, 100+i*10/n, 3);      
   1484              }    
   1485            } 
   1486          #endif  
   1487            IWDG_ReloadCounter();    
   1488            draw_fill_box(40, 110, 3);   
   1489            
   1490            
   1491            IWDG_ReloadCounter();    
   1492            MakeTechnicalData(1);
   1493            if(IDE_Download_Cancel() == KEY_CANCEL){f_close (&file);  return;} 
   1494            hbuff[0] = 0x76;  hbuff[1] = 5;
   1495            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1496            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1497            if(f_write (&file, IDE_DnBuff, IDE_DnDataNum, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;}    
   1498           
   1499            n = CalcDayCount(RTC_LVal,Fram.FirstDailyDataDate);
   1500            if(n > 364) n = 364;
   1501            first_downdate = Fram.FirstDailyDataDate-(Fram.FirstDailyDataDate%(3600*24));
   1502            for(i = n; i >= 0 ; i--) {
   1503              IWDG_ReloadCounter();    
   1504              IDE_DnDate = RTC_LVal-3600*24*i;
   1505              if(IDE_DnDate >= first_downdate) {
   1506                MakeActivityData(1);
   1507                if(IDE_Download_Cancel() == KEY_CANCEL){f_close (&file);  return;} 
   1508                if(!IDE_DataNotAvailable) {
   1509                  hbuff[0] = 0x76;  hbuff[1] = 2;
   1510                  if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1511                  if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1512                  if(f_write (&file, IDE_DnBuff, IDE_DnDataNum, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;}    
   1513                }
   1514              }
   1515              if((n-i)%5 == 0) {
   1516                draw_fill_box(70, 110+(n-i)*20/n, 3);      
   1517              }    
   1518              disp_printf(32, 4, 0, "DAYS: %03d/%03d",n-i+1,n+1);
   1519            }
   1520            draw_fill_box(40, 130, 3);   
   1521          
   1522            hbuff[0] = 0x76;  hbuff[1] = 0x81;
   1523            if(flag.ncmfind)      
   1524              Request_NCM_Key_Authentication(1);
   1525            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1526            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1527            if(f_write (&file, NCM_RX_BUFFER, NCM_CertiLen, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;} 
   1528          
   1529            draw_fill_box(40, 135, 3);   
   1530          
   1531            hbuff[0] = 0x76;  hbuff[1] = 0x82;
   1532            if(flag.ncmfind)      
   1533              Request_NCM_Key_Authentication(0);
   1534            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1535            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1536            if(f_write (&file, NCM_RX_BUFFER, NCM_CertiLen, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;} 
   1537          
   1538            draw_fill_box(40, 140, 3);   
   1539            if(OperationMode == COMPANY) {
   1540              slot = SearchDownloadCard();
   1541              if(slot < 2)    
   1542                PutCompanyActivity(slot, 2);
   1543            }    
   1544            if(f_close (&file) != FR_OK) {
   1545              USB_Error_Flag = 1;
   1546              return;
   1547            }
   1548          }
   1549          
   1550          /**
   1551            * @brief  USB User Func
   1552            * @param  None
   1553            * @retval None
   1554            */
   1555          void DownloadCardData(void)
   1556          {  
   1557            char fname[50]; 
   1558            int i;
   1559            u8 ch;
   1560            u8 year_ch, mon_ch, day_ch[2];
   1561          
   1562            BuzzerOff();  
   1563          	year_ch = YEAR-14+'A';
   1564          	mon_ch = MONTH-1+'A';
   1565          	day_ch[0] = (DAY/10)+'0';
   1566          	day_ch[1] = (DAY%10)+'0';
   1567          
   1568            lcd_clear();       
   1569            LCD_printf(0,0,0,"DOWNLOAD CARD");
   1570            IWDG_ReloadCounter(); 
   1571            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1572              lcd_clear();
   1573              LCD_printf(0,2,0,"Not connected");
   1574              return;
   1575            }
   1576            if(flag.slot1 && (VuCardIWRecord[0].FullCardNumber.cardType == DRIVER_CARD || VuCardIWRecord[0].FullCardNumber.cardType == WORKSHOP_CARD)) {  
   1577              memset(fname,0,50);
   1578              sprintf(fname, "S1_C20%02d%02d%02d%02d%02d%02d%c", RTC_Val.tm_year, RTC_Val.tm_mon, RTC_Val.tm_mday, RTC_Val.tm_hour, RTC_Val.tm_min, RTC_Val.tm_sec,'_');
   1579              for(i=19;i<35;i++) {
   1580                ch = VuCardIWRecord[0].FullCardNumber.cardNumber[i-19];
   1581                if((ch<'0' || ch>'9') && (ch<'a' || ch>'z') && (ch<'A' || ch>'Z'))
   1582                  fname[i] =  '_';
   1583                else
   1584                  fname[i] =  ch;
   1585              }
   1586              fname[35] = '_';
   1587              fname[36] = year_ch;
   1588              fname[37] = mon_ch;
   1589              fname[38] = day_ch[0];
   1590              fname[39] = day_ch[1];
   1591          
   1592              fname[40] = '.';
   1593              fname[41] = 'D';
   1594              fname[42] = 'D';
   1595              fname[43] = 'D';
   1596          
   1597              // Remove file if exist on flash disk 
   1598            
   1599              f_unlink(fname);
   1600              
   1601              IWDG_ReloadCounter(); 
   1602              // Open the file to write on it 
   1603              if(f_open(&file, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
   1604                lcd_clear();
   1605                LCD_printf(0,2,0,"Create file fail");
   1606                delay_ms(2000);
   1607                return;
   1608              }
   1609            //- drive data save -//
   1610              draw_rectangle(40,140,3);
   1611            
   1612              MakeDownloadCardData(VuCardIWRecord[0].FullCardNumber.cardType-1, 1);
   1613              if(USB_Error_Flag) return;
   1614             
   1615              draw_fill_box(40, 140, 3);   
   1616               
   1617              if(f_close (&file) != FR_OK) {
   1618                USB_Error_Flag = 1;
   1619                return;
   1620              }
   1621            }  
   1622            else {
   1623              LCD_printf(0,2,0,"Not Driver Card!");
   1624              delay_ms(2000);
   1625            }
   1626          }
   1627          
   1628          /**
   1629            * @brief  USB User Func
   1630            * @param  None
   1631            * @retval None
   1632            */
   1633          void DownloadNCMData(u8 count)
   1634          {  
   1635            char fname[50]; 
   1636            int i;
   1637            u8 ch;
   1638            UINT bytesWritten;  
   1639            u8 hbuff[2];
   1640            u8 year_ch, mon_ch, day_ch[2];
   1641          
   1642            BuzzerOff();  
   1643          	year_ch = YEAR-14+'A';
   1644          	mon_ch = MONTH-1+'A';
   1645          	day_ch[0] = (DAY/10)+'0';
   1646          	day_ch[1] = (DAY%10)+'0';
   1647          
   1648            if(!flag.ncmfind || count == 0) return;
   1649            NCM_All_Data_Flag = 0;
   1650            NCM_Down_EndDate = RTC_LVal;
   1651            if(count < 8) {
   1652              NCM_Down_StartDate = (RTC_LVal-RTC_LVal%(3600*24)) - ((count-1)*3600*24);
   1653            }
   1654            else {
   1655              NCM_Down_StartDate = NCM_ActivationTime;
   1656              NCM_All_Data_Flag = 1;
   1657            }
   1658          
   1659            lcd_clear();       
   1660            LCD_printf(0,0,0,"DOWNLOAD NCM");
   1661            IWDG_ReloadCounter(); 
   1662            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1663              lcd_clear();
   1664              LCD_printf(0,2,0,"Not connected");
   1665              return;
   1666            }
   1667          
   1668            memset(fname,0,50);
   1669            sprintf(fname, "S1_N20%02d%02d%02d%02d%02d%02d%c", RTC_Val.tm_year, RTC_Val.tm_mon, RTC_Val.tm_mday, RTC_Val.tm_hour, RTC_Val.tm_min, RTC_Val.tm_sec,'_');
   1670            for(i=19;i<35;i++) {
   1671              ch = NCMActivationData.PartNumber[i-19];
   1672              if((ch<'0' || ch>'9') && (ch<'a' || ch>'z') && (ch<'A' || ch>'Z'))
   1673                fname[i] =  '_';
   1674              else
   1675                fname[i] =  ch;
   1676            }
   1677            fname[35] = '_';
   1678            fname[36] = year_ch;
   1679            fname[37] = mon_ch;
   1680            fname[38] = day_ch[0];
   1681            fname[39] = day_ch[1];
   1682          
   1683            fname[40] = '.';
   1684            fname[41] = 'N';
   1685            fname[42] = 'K';
   1686            fname[43] = 'M';
   1687          
   1688            // Remove file if exist on flash disk 
   1689          
   1690            f_unlink(fname);
   1691            
   1692            IWDG_ReloadCounter(); 
   1693            // Open the file to write on it 
   1694            if(f_open(&file, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
   1695              lcd_clear();
   1696              LCD_printf(0,2,0,"Create file fail");
   1697              delay_ms(2000);
   1698              return;
   1699            }
   1700            draw_rectangle(40,140,3);
   1701          
   1702            hbuff[0] = 0x76;  hbuff[1] = 0x81;
   1703            if(flag.ncmfind)      
   1704              Request_NCM_Key_Authentication(1);
   1705            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1706            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1707            if(f_write (&file, NCM_RX_BUFFER, NCM_CertiLen, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;} 
   1708          
   1709            hbuff[0] = 0x76;  hbuff[1] = 0x82;
   1710            if(flag.ncmfind)      
   1711              Request_NCM_Key_Authentication(0);
   1712            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1713            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1714            if(f_write (&file, NCM_RX_BUFFER, NCM_CertiLen, &bytesWritten) != FR_OK) {USB_Error_Flag = 1; return;} 
   1715          
   1716            hbuff[0] = 0x76;  hbuff[1] = 0x84;
   1717            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {USB_Error_Flag = 1; return;}
   1718            if(f_write (&file, hbuff, 2, &bytesWritten) != FR_OK) {USB_Error_Flag = 1;  return;}
   1719            MakeNCMInfoData(1);
   1720            if(USB_Error_Flag) return;
   1721            MakeNCMArchiveData(1);
   1722            if(USB_Error_Flag) return;
   1723            
   1724            draw_fill_box(40, 140, 3);   
   1725             
   1726            if(f_close (&file) != FR_OK) {
   1727              USB_Error_Flag = 1;
   1728              return;
   1729            }
   1730          }
   1731          /**
   1732            * @brief  USB User Func
   1733            * @param  None
   1734            * @retval None
   1735            */
   1736          void COMMAND_ExecuteApplication(void)
   1737          {    
   1738            if(DL_DrvDataCount == 0) DL_DrvDataCount = 1;
   1739            
   1740            if(USB_DL_Flag == 1) {
   1741              if(USB_NCMFlag)
   1742                DownloadNCMData(DL_DrvDataCount);
   1743              else 
   1744                DownloadDrvData(DL_DrvDataCount);
   1745            }
   1746            else if(USB_DL_Flag == 2)
   1747              DownloadVehicleData();
   1748            else if(USB_DL_Flag == 3)
   1749              DownloadCardData();
   1750            else if(USB_DL_Flag == 5)
   1751              DownloadCalData();
   1752            USB_Error_Flag = 0;   
   1753            lcd_clear();    
   1754          }
   1755          
   1756          /**
   1757            * @brief  USBH_USR_DeInit
   1758            *         Deint User state and associated variables
   1759            * @param  None
   1760            * @retval None
   1761            */
   1762          void USBH_USR_DeInit(void)
   1763          {
   1764          }
   1765          
   1766          /**
   1767            * @}
   1768            */
   1769          void COMMAND_ProgramFlashMemory_boot(void)
   1770          {
   1771            u32 cpu_sr;
   1772            
   1773            __IO uint32_t programcounter = 0x00;
   1774            uint8_t readflag = TRUE;
   1775            u32 fsize;
   1776            u32 readsize = 0;
   1777            u32 rcnt;
   1778            uint32_t TmpProgramCounter = 0x00, TmpReadSize = 0x00 , RamAddress = 0x00;
   1779            uint32_t LastPGAddress;
   1780          
   1781            fsize = DownFileLength;
   1782            /* RAM Address Initialization */
   1783            memset(IDE_DnBuff, 0, NAND_PAGE_SIZE);
   1784            RamAddress = (uint32_t) & IDE_DnBuff;
   1785            
   1786            /* Erase address init */
   1787            LastPGAddress = ((uint32_t)0x08000000);
   1788            
   1789            /* While file still contain data */
   1790            IWDG_ReloadCounter();
   1791            while (readflag == TRUE)
   1792            {
   1793              rcnt = fsize - readsize;
   1794              if(rcnt > NAND_PAGE_SIZE) {
   1795                IWDG_ReloadCounter();
   1796                Nand_Read_Buffer(IDE_DnBuff, NAND_BOOT_PROGRAM_ADDR+readsize, NAND_PAGE_SIZE); 
   1797                TmpReadSize = NAND_PAGE_SIZE;
   1798                readsize += TmpReadSize;
   1799              }
   1800              else {
   1801                IWDG_ReloadCounter();
   1802                Nand_Read_Buffer(IDE_DnBuff, NAND_BOOT_PROGRAM_ADDR+readsize, rcnt); 
   1803                TmpReadSize = rcnt;
   1804                readsize += TmpReadSize;
   1805                readflag = FALSE;
   1806              }
   1807          		OS_ENTER_CRITICAL();
   1808              /* Program flash memory */
   1809              for (programcounter = TmpReadSize; programcounter != 0; programcounter -= 4)
   1810              {
   1811                TmpProgramCounter = programcounter;
   1812                /* Write word into flash memory */
   1813                if (FLASH_If_ProgramWord((LastPGAddress - TmpProgramCounter + TmpReadSize), \
   1814                  *(__IO uint32_t *)(RamAddress - programcounter + TmpReadSize)) != FLASH_COMPLETE)
   1815                {
   1816                  /* Toggle Red LED in infinite loop: Flash programming error */
   1817          				OS_EXIT_CRITICAL();
   1818                  return;
   1819                }
   1820              }
   1821          		OS_EXIT_CRITICAL();
   1822              /* Update last programmed address value */
   1823              LastPGAddress = LastPGAddress + TmpReadSize;
   1824            }
   1825          }
   1826          
   1827          /**
   1828            * @brief  IAP write memory
   1829            * @param  None
   1830            * @retval None
   1831            */
   1832          int BOOT_DOWNLOAD(void)
   1833          {
   1834            IWDG_ReloadCounter();
   1835          //  LCD_printf(0,4,0,"Flash Erase...  ");
   1836            FLASH_Unlock();
   1837            IWDG_ReloadCounter();
   1838            if (FLASH_If_EraseSectors_boot(0) != 0x00)
   1839            {
   1840          //    LCD_printf(0,4,0,"Erase Error!    ");
   1841              FLASH_Lock();
   1842              IWDG_ReloadCounter();
   1843              return -1;
   1844            }
   1845          //  LCD_printf(0,4,0,"Erase Done      ");
   1846          //  LCD_printf(0,4,0,"Flash Program...");
   1847            IWDG_ReloadCounter();
   1848            COMMAND_ProgramFlashMemory_boot();
   1849          //  LCD_printf(0,4,0,"Done            ");
   1850            return 0;
   1851          }
   1852          
   1853          void CopyNand2USB(void)
   1854          {
   1855            UINT bytesWritten;  
   1856            FIL tfile;
   1857          	u32 i, n;
   1858            char fname[20] = {0,};
   1859               
   1860            sprintf(fname,"nandbak.bin");
   1861            IWDG_ReloadCounter();
   1862          
   1863            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1864              printd("Not connected\n");
   1865              return;
   1866            }
   1867          
   1868            f_unlink(fname);
   1869            IWDG_ReloadCounter(); 
   1870            if(f_open(&tfile, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
   1871          		printd("File Create Error\n");
   1872              return;
   1873            }
   1874            IWDG_ReloadCounter(); 
   1875          	n = NAND_SIZE/NAND_PAGE_SIZE;
   1876          	printd("\n");
   1877            for(i = 0; i < n; i++) {
   1878          		Nand_Read_Buffer(IDE_DnBuff, i*NAND_PAGE_SIZE, NAND_PAGE_SIZE);
   1879              if(f_write (&tfile, IDE_DnBuff, NAND_PAGE_SIZE, &bytesWritten) != FR_OK) {
   1880          		  printd("File Write Error\n");
   1881                return;
   1882              }
   1883          		
   1884          		if(n % 64 == 0){
   1885          			printd("%d\r",i/64);
   1886          		}
   1887              
   1888          	  IWDG_ReloadCounter(); 
   1889            }
   1890          	printd("\n");
   1891            f_write (&tfile, Nand_Save_Buff, NAND_PAGE_SIZE, &bytesWritten);
   1892            if(f_close (&tfile) != FR_OK) {
   1893          		printd("File Close Error\n");
   1894          		return ;
   1895            }
   1896            IWDG_ReloadCounter();    	
   1897          }
   1898          
   1899          void CopyUSB2Nand(void)
   1900          {
   1901            UINT bytesWritten;  
   1902            FIL tfile;
   1903          	u32 i, n;
   1904            char fname[20] = {0,};
   1905          
   1906            sprintf(fname,"nandbak.bin");
   1907            IWDG_ReloadCounter();
   1908          
   1909            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1910              printd("Not connected\n");
   1911              return;
   1912            }
   1913          
   1914            IWDG_ReloadCounter(); 
   1915            if(f_open(&tfile, fname, FA_READ) != FR_OK)  {
   1916          		printd("File Create Error\n");
   1917              return;
   1918            }
   1919            IWDG_ReloadCounter(); 
   1920          	n = NAND_SIZE/NAND_PAGE_SIZE;
   1921          	printd("\n");
   1922            for(i = 0; i < n; i++) {
   1923              if(f_read (&tfile, IDE_DnBuff, NAND_PAGE_SIZE, &bytesWritten) != FR_OK) {
   1924          		  printd("File Write Error\n");
   1925                return;
   1926              }    
   1927          		Nand_Write_Buffer(IDE_DnBuff, i*NAND_PAGE_SIZE, NAND_PAGE_SIZE);   
   1928          	  IWDG_ReloadCounter();
   1929          		
   1930          		if(n % 64 == 0){
   1931          			printd("%d\r",i/64);
   1932          		}		
   1933            }
   1934          	printd("\n");
   1935            f_read (&tfile, Nand_Save_Buff, NAND_PAGE_SIZE, &bytesWritten);
   1936            if(f_close (&tfile) != FR_OK) {
   1937          		printd("File Close Error\n");
   1938          		return ;
   1939            }
   1940            IWDG_ReloadCounter();      
   1941          }
   1942          
   1943          void CopyFram2USB(void)
   1944          {
   1945            UINT bytesWritten;  
   1946            FIL tfile;
   1947          	u32 i, n;
   1948            char fname[20] = {0,};
   1949          
   1950            sprintf(fname,"frambak.bin");
   1951            IWDG_ReloadCounter();
   1952          
   1953            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1954              printd("Not connected\n");
   1955              return;
   1956            }
   1957          
   1958            f_unlink(fname);
   1959            IWDG_ReloadCounter(); 
   1960            if(f_open(&tfile, fname, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)  {
   1961          		printd("File Create Error\n");
   1962              return;
   1963            }
   1964            IWDG_ReloadCounter(); 
   1965          	n = 8192/32;
   1966          	printd("\n");
   1967            for(i = 0; i < n; i++) {                                           
   1968              if(f_write (&tfile, (u8*)((u8*)&Fram+i*32), 32, &bytesWritten) != FR_OK) {
   1969          		  printd("File Write Error\n");
   1970                return;
   1971              }    
   1972          	  IWDG_ReloadCounter(); 
   1973          		
   1974          		printd("%d\r",i);
   1975            }
   1976          	printd("\n");                                                             
   1977            if(f_close (&tfile) != FR_OK) {
   1978          		printd("File Close Error\n");
   1979          		return ;
   1980            }
   1981            IWDG_ReloadCounter(); 
   1982          }
   1983          
   1984          void CopyUSB2Fram(void)
   1985          {
   1986            UINT bytesWritten;  
   1987            FIL tfile;
   1988          	u32 i, n;
   1989            char fname[20] = {0,};
   1990          
   1991            sprintf(fname,"frambak.bin");
   1992            IWDG_ReloadCounter();
   1993          
   1994            if(HCD_IsDeviceConnected(&USB_OTG_Core) != 1) {
   1995              printd("Not connected\n");
   1996              return;
   1997            }
   1998          
   1999            IWDG_ReloadCounter(); 
   2000            if(f_open(&tfile, fname, FA_READ) != FR_OK)  {
   2001          		printd("File Create Error\n");
   2002              return;
   2003            }
   2004            IWDG_ReloadCounter(); 
   2005          	n = 8192/32;
   2006          	printd("\n");
   2007            for(i = 0; i < n; i++) {                                           
   2008              if(f_read (&tfile, (u8*)((u8*)&Fram+i*32), 32, &bytesWritten) != FR_OK) {
   2009          		  printd("File Write Error\n");
   2010                return;
   2011              }    
   2012          	  IWDG_ReloadCounter(); 
   2013          		printd("%d\r",i);
   2014            }
   2015          	printd("\n");                                                             
   2016                      
   2017          	FramWrite(0,sizeof(st_FRAM_Data));
   2018            if(f_close (&tfile) != FR_OK) {
   2019          		printd("File Close Error\n");
   2020          		return ;
   2021            }
   2022            IWDG_ReloadCounter(); 
   2023          }
   2024          
   2025          
   2026          #endif
   2027          
   2028          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBH_USR_Configuration_DescAvailable
         0   -> printd
       0   USBH_USR_DeInit
       0   USBH_USR_DeviceAddressAssigned
       8   USBH_USR_DeviceAttached
         8   -> printd
       8   USBH_USR_DeviceDisconnected
         0   -> printd
         8   -> printd
       8   USBH_USR_DeviceNotSupported
         8   -> printd
       0   USBH_USR_DeviceSpeedDetected
         0   -> printd
       8   USBH_USR_Device_DescAvailable
         0   -> printd
         8   -> printd
       0   USBH_USR_EnumerationDone
         0   -> printd
       8   USBH_USR_Init
         8   -> printd
       8   USBH_USR_MSC_Application
         8   -> printk
       0   USBH_USR_Manufacturer_String
         0   -> printd
       0   USBH_USR_OverCurrentDetected
       0   USBH_USR_Product_String
         0   -> printd
       0   USBH_USR_ResetDevice
       0   USBH_USR_SerialNum_String
         0   -> printd
       8   USBH_USR_UnrecoveredError
         8   -> printd
       0   USBH_USR_UserInput


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
      24  ?_0
      32  ?_1
      24  ?_10
      28  ?_2
      12  ?_3
      16  ?_4
      16  ?_5
      20  ?_6
      16  ?_7
      24  ?_8
      28  ?_9
       1  Application
      24  MSG_DEV_ATTACHED
      24  MSG_DEV_DISCONNECTED
      28  MSG_DEV_ENUMERATED
      20  MSG_DEV_ERROR
      32  MSG_DEV_FULLSPEED
      32  MSG_DEV_HIGHSPEED
      32  MSG_DEV_LOWSPEED
      36  MSG_DISK_SIZE
      28  MSG_HID_CLASS
      32  MSG_HOST_INIT
      36  MSG_LUN
      36  MSG_MSC_CLASS
      32  MSG_ROOT_CONT
      28  MSG_UNREC_ERROR
      32  MSG_WR_PROTECT
      28  USBH_USR_Configuration_DescAvailable
       8  USBH_USR_DeInit
       2  USBH_USR_DeviceAddressAssigned
      24  USBH_USR_DeviceAttached
      34  USBH_USR_DeviceDisconnected
      18  USBH_USR_DeviceNotSupported
      44  USBH_USR_DeviceSpeedDetected
      28  USBH_USR_Device_DescAvailable
       8  USBH_USR_EnumerationDone
      40  USBH_USR_Init
      42  USBH_USR_MSC_Application
      10  USBH_USR_Manufacturer_String
       8  USBH_USR_OverCurrentDetected
      10  USBH_USR_Product_String
       8  USBH_USR_ResetDevice
      10  USBH_USR_SerialNum_String
      24  USBH_USR_UnrecoveredError
       4  USBH_USR_UserInput
      72  USR_Callbacks

 
   1 byte  in section .bss
  72 bytes in section .data
 168 bytes in section .rodata
 886 bytes in section .text
 
 886 bytes of CODE  memory
 168 bytes of CONST memory
  73 bytes of DATA  memory

Errors: none
Warnings: none
