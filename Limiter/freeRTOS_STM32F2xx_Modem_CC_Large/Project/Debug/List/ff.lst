###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:17
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\ff.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\ff.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\ff.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\ff.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.11                 (C)ChaN, 2015
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a free software that opened under license policy of
      5          / following conditions.
      6          /
      7          / Copyright (C) 2015, ChaN, all right reserved.
      8          /
      9          / 1. Redistributions of source code must retain the above copyright notice,
     10          /    this condition and the following disclaimer.
     11          /
     12          / This software is provided by the copyright holder and contributors "AS IS"
     13          / and any warranties related to this software are DISCLAIMED.
     14          / The copyright owner or contributors be NOT LIABLE for any damages caused
     15          / by use of this software.
     16          /----------------------------------------------------------------------------*/
     17          
     18          
     19          #include "ff.h"			/* Declarations of FatFs API */
     20          #include "diskio.h"		/* Declarations of disk I/O functions */
     21          
     22          
     23          /*--------------------------------------------------------------------------
     24          
     25             Module Private Definitions
     26          
     27          ---------------------------------------------------------------------------*/
     28          
     29          #if _FATFS != 32020	/* Revision ID */
     30          #error Wrong include file (ff.h).
     31          #endif
     32          
     33          
     34          /* Reentrancy related */
     35          #if _FS_REENTRANT
     36          #if _USE_LFN == 1
     37          #error Static LFN work area cannot be used at thread-safe configuration
     38          #endif
     39          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
     40          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
     41          #else
     42          #define	ENTER_FF(fs)
     43          #define LEAVE_FF(fs, res)	return res
     44          #endif
     45          
     46          #define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
     47          
     48          
     49          /* Definitions of sector size */
     50          #if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
     51          #error Wrong sector size configuration
     52          #endif
     53          #if _MAX_SS == _MIN_SS
     54          #define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
     55          #else
     56          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
     57          #endif
     58          
     59          
     60          /* Timestamp feature */
     61          #if _FS_NORTC == 1
     62          #if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
     63          #error Invalid _FS_NORTC settings
     64          #endif
     65          #define GET_FATTIME()	((DWORD)(_NORTC_YEAR - 1980) << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
     66          #else
     67          #define GET_FATTIME()	get_fattime()
     68          #endif
     69          
     70          
     71          /* File access control feature */
     72          #if _FS_LOCK
     73          #if _FS_READONLY
     74          #error _FS_LOCK must be 0 at read-only configuration
     75          #endif
     76          typedef struct {
     77          	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
     78          	DWORD clu;		/* Object ID 2, directory (0:root) */
     79          	WORD idx;		/* Object ID 3, directory index */
     80          	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
     81          } FILESEM;
     82          #endif
     83          
     84          
     85          
     86          /* DBCS code ranges and SBCS extend character conversion table */
     87          
     88          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
     89          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
     90          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
     91          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
     92          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
     93          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
     94          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
     95          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
     96          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
     97          
     98          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
     99          #define _DF1S	0x81
    100          #define _DF1E	0xFE
    101          #define _DS1S	0x40
    102          #define _DS1E	0x7E
    103          #define _DS2S	0x80
    104          #define _DS2E	0xFE
    105          
    106          #elif _CODE_PAGE == 949	/* Korean */
    107          #define _DF1S	0x81
    108          #define _DF1E	0xFE
    109          #define _DS1S	0x41
    110          #define _DS1E	0x5A
    111          #define _DS2S	0x61
    112          #define _DS2E	0x7A
    113          #define _DS3S	0x81
    114          #define _DS3E	0xFE
    115          
    116          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    117          #define _DF1S	0x81
    118          #define _DF1E	0xFE
    119          #define _DS1S	0x40
    120          #define _DS1E	0x7E
    121          #define _DS2S	0xA1
    122          #define _DS2E	0xFE
    123          
    124          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    125          #define _DF1S	0
    126          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    127          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    128          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    129          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    130          
    131          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    132          #define _DF1S	0
    133          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    134          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    135          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    136          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    137          
    138          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    139          #define _DF1S	0
    140          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    141          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    142          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    143          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    144          
    145          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    146          #define _DF1S	0
    147          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    148          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    149          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    150          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    151          
    152          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    153          #define _DF1S	0
    154          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    155          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    156          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    157          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    158          
    159          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    160          #define _DF1S	0
    161          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    162          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    163          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    164          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    165          
    166          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    167          #define _DF1S	0
    168          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    169          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    170          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    171          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    172          
    173          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    174          #define _DF1S	0
    175          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    176          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    177          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    178          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    179          
    180          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    181          #define _DF1S	0
    182          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    183          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    184          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    185          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    186          
    187          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    188          #define _DF1S	0
    189          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    190          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    191          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    192          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    193          
    194          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    195          #define _DF1S	0
    196          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    197          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    198          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    199          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    200          
    201          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    202          #define _DF1S	0
    203          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    204          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    205          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    206          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    207          
    208          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    209          #define _DF1S	0
    210          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    211          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    212          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    213          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    214          
    215          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    216          #define _DF1S	0
    217          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    218          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    219          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    220          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    221          
    222          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    223          #define _DF1S	0
    224          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    225          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    226          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    227          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    228          
    229          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    230          #define _DF1S	0
    231          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    232          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    233          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    234          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    235          
    236          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    237          #define _DF1S	0
    238          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    239          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    240          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    241          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    242          
    243          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    244          #define _DF1S	0
    245          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    246          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    247          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    248          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    249          
    250          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    251          #define _DF1S	0
    252          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    253          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    254          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    255          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    256          
    257          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    258          #define _DF1S	0
    259          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    260          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    261          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    262          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    263          
    264          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    265          #define _DF1S	0
    266          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    267          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    268          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    269          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    270          
    271          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    272          #if _USE_LFN
    273          #error Cannot use LFN feature without valid code page.
    274          #endif
    275          #define _DF1S	0
    276          
    277          #else
    278          #error Unknown code page
    279          
    280          #endif
    281          
    282          
    283          /* Character code support macros */
    284          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    285          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    286          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    287          
    288          #if _DF1S		/* Code page is DBCS */
    289          
    290          #ifdef _DF2S	/* Two 1st byte areas */
    291          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    292          #else			/* One 1st byte area */
    293          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    294          #endif
    295          
    296          #ifdef _DS3S	/* Three 2nd byte areas */
    297          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    298          #else			/* Two 2nd byte areas */
    299          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    300          #endif
    301          
    302          #else			/* Code page is SBCS */
    303          
    304          #define IsDBCS1(c)	0
    305          #define IsDBCS2(c)	0
    306          
    307          #endif /* _DF1S */
    308          
    309          
    310          /* Name status flags */
    311          #define NSFLAG		11		/* Index of name status byte in fn[] */
    312          #define NS_LOSS		0x01	/* Out of 8.3 format */
    313          #define NS_LFN		0x02	/* Force to create LFN entry */
    314          #define NS_LAST		0x04	/* Last segment */
    315          #define NS_BODY		0x08	/* Lower case flag (body) */
    316          #define NS_EXT		0x10	/* Lower case flag (ext) */
    317          #define NS_DOT		0x20	/* Dot entry */
    318          
    319          
    320          /* FAT sub-type boundaries (Differ from specs but correct for real DOS/Windows) */
    321          #define MIN_FAT16	4086U	/* Minimum number of clusters as FAT16 */
    322          #define	MIN_FAT32	65526U	/* Minimum number of clusters as FAT32 */
    323          
    324          
    325          /* FatFs refers the members in the FAT structures as byte array instead of
    326          / structure member because the structure is not binary compatible between
    327          / different platforms */
    328          
    329          #define BS_jmpBoot			0		/* x86 jump instruction (3) */
    330          #define BS_OEMName			3		/* OEM name (8) */
    331          #define BPB_BytsPerSec		11		/* Sector size [byte] (2) */
    332          #define BPB_SecPerClus		13		/* Cluster size [sector] (1) */
    333          #define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (2) */
    334          #define BPB_NumFATs			16		/* Number of FAT copies (1) */
    335          #define BPB_RootEntCnt		17		/* Number of root directory entries for FAT12/16 (2) */
    336          #define BPB_TotSec16		19		/* Volume size [sector] (2) */
    337          #define BPB_Media			21		/* Media descriptor (1) */
    338          #define BPB_FATSz16			22		/* FAT size [sector] (2) */
    339          #define BPB_SecPerTrk		24		/* Track size [sector] (2) */
    340          #define BPB_NumHeads		26		/* Number of heads (2) */
    341          #define BPB_HiddSec			28		/* Number of special hidden sectors (4) */
    342          #define BPB_TotSec32		32		/* Volume size [sector] (4) */
    343          #define BS_DrvNum			36		/* Physical drive number (2) */
    344          #define BS_BootSig			38		/* Extended boot signature (1) */
    345          #define BS_VolID			39		/* Volume serial number (4) */
    346          #define BS_VolLab			43		/* Volume label (8) */
    347          #define BS_FilSysType		54		/* File system type (1) */
    348          #define BPB_FATSz32			36		/* FAT size [sector] (4) */
    349          #define BPB_ExtFlags		40		/* Extended flags (2) */
    350          #define BPB_FSVer			42		/* File system version (2) */
    351          #define BPB_RootClus		44		/* Root directory first cluster (4) */
    352          #define BPB_FSInfo			48		/* Offset of FSINFO sector (2) */
    353          #define BPB_BkBootSec		50		/* Offset of backup boot sector (2) */
    354          #define BS_DrvNum32			64		/* Physical drive number (2) */
    355          #define BS_BootSig32		66		/* Extended boot signature (1) */
    356          #define BS_VolID32			67		/* Volume serial number (4) */
    357          #define BS_VolLab32			71		/* Volume label (8) */
    358          #define BS_FilSysType32		82		/* File system type (1) */
    359          #define	FSI_LeadSig			0		/* FSI: Leading signature (4) */
    360          #define	FSI_StrucSig		484		/* FSI: Structure signature (4) */
    361          #define	FSI_Free_Count		488		/* FSI: Number of free clusters (4) */
    362          #define	FSI_Nxt_Free		492		/* FSI: Last allocated cluster (4) */
    363          #define MBR_Table			446		/* MBR: Partition table offset (2) */
    364          #define	SZ_PTE				16		/* MBR: Size of a partition table entry */
    365          #define BS_55AA				510		/* Signature word (2) */
    366          
    367          #define	DIR_Name			0		/* Short file name (11) */
    368          #define	DIR_Attr			11		/* Attribute (1) */
    369          #define	DIR_NTres			12		/* Lower case flag (1) */
    370          #define DIR_CrtTimeTenth	13		/* Created time sub-second (1) */
    371          #define	DIR_CrtTime			14		/* Created time (2) */
    372          #define	DIR_CrtDate			16		/* Created date (2) */
    373          #define DIR_LstAccDate		18		/* Last accessed date (2) */
    374          #define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (2) */
    375          #define	DIR_WrtTime			22		/* Modified time (2) */
    376          #define	DIR_WrtDate			24		/* Modified date (2) */
    377          #define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (2) */
    378          #define	DIR_FileSize		28		/* File size (4) */
    379          #define	LDIR_Ord			0		/* LFN entry order and LLE flag (1) */
    380          #define	LDIR_Attr			11		/* LFN attribute (1) */
    381          #define	LDIR_Type			12		/* LFN type (1) */
    382          #define	LDIR_Chksum			13		/* Sum of corresponding SFN entry */
    383          #define	LDIR_FstClusLO		26		/* Must be zero (0) */
    384          #define	SZ_DIRE				32		/* Size of a directory entry */
    385          #define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
    386          #define	DDEM				0xE5	/* Deleted directory entry mark at DIR_Name[0] */
    387          #define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
    388          
    389          
    390          
    391          
    392          /*------------------------------------------------------------*/
    393          /* Module private work area                                   */
    394          /*------------------------------------------------------------*/
    395          /* Remark: Uninitialized variables with static duration are
    396          /  guaranteed zero/null at start-up. If not, either the linker
    397          /  or start-up routine being used is out of ANSI-C standard.
    398          */
    399          
    400          #if _VOLUMES < 1 || _VOLUMES > 9
    401          #error Wrong _VOLUMES setting
    402          #endif

   \                                 In section .bss, align 4
    403          static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
    404          static WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 8
    405          
    406          #if _FS_RPATH && _VOLUMES >= 2

   \                                 In section .bss, align 1
    407          static BYTE CurrVol;			/* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
    408          #endif
    409          
    410          #if _FS_LOCK
    411          static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
    412          #endif
    413          
    414          #if _USE_LFN == 0			/* Non LFN feature */
    415          #define	DEFINE_NAMEBUF		BYTE sfn[12]
    416          #define INIT_BUF(dobj)		(dobj).fn = sfn
    417          #define	FREE_BUF()
    418          #else
    419          #if _MAX_LFN < 12 || _MAX_LFN > 255
    420          #error Wrong _MAX_LFN setting
    421          #endif
    422          #if _USE_LFN == 1			/* LFN feature with static working buffer */
    423          static WCHAR LfnBuf[_MAX_LFN + 1];
    424          #define	DEFINE_NAMEBUF		BYTE sfn[12]
    425          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    426          #define	FREE_BUF()
    427          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    428          #define	DEFINE_NAMEBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN + 1]
    429          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    430          #define	FREE_BUF()
    431          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    432          #define	DEFINE_NAMEBUF		BYTE sfn[12]; WCHAR *lfn
    433          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); (dobj).lfn = lfn; (dobj).fn = sfn; }
    434          #define	FREE_BUF()			ff_memfree(lfn)
    435          #else
    436          #error Wrong _USE_LFN setting
    437          #endif
    438          #endif
    439          
    440          #ifdef _EXCVT

   \                                 In section .text, align 4, keep-with-next
    441          static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended characters */
   \                     ExCvt:
   \   00000000   0x80 0x81          DC8 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140
   \              0x82 0x83    
   \              0x84 0x85    
   \              0x86 0x87    
   \              0x88 0x89    
   \              0x8A 0x8B    
   \              0x8C         
   \   0000000D   0x8D 0x8E          DC8 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153
   \              0x8F 0x90    
   \              0x91 0x92    
   \              0x93 0x94    
   \              0x95 0x96    
   \              0x97 0x98    
   \              0x99         
   \   0000001A   0xAD 0x9B          DC8 173, 155, 140, 157, 174, 159, 160, 33, 162, 163, 164, 165, 166, 167
   \              0x8C 0x9D    
   \              0xAE 0x9F    
   \              0xA0 0x21    
   \              0xA2 0xA3    
   \              0xA4 0xA5    
   \              0xA6 0xA7    
   \   00000028   0xA8 0xA9          DC8 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180
   \              0xAA 0xAB    
   \              0xAC 0xAD    
   \              0xAE 0xAF    
   \              0xB0 0xB1    
   \              0xB2 0xB3    
   \              0xB4         
   \   00000035   0xB5 0xB6          DC8 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193
   \              0xB7 0xB8    
   \              0xB9 0xBA    
   \              0xBB 0xBC    
   \              0xBD 0xBE    
   \              0xBF 0xC0    
   \              0xC1         
   \   00000042   0xC2 0xC3          DC8 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206
   \              0xC4 0xC5    
   \              0xC6 0xC7    
   \              0xC8 0xC9    
   \              0xCA 0xCB    
   \              0xCC 0xCD    
   \              0xCE         
   \   0000004F   0xCF 0xD0          DC8 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219
   \              0xD1 0xD2    
   \              0xD3 0xD4    
   \              0xD5 0xD6    
   \              0xD7 0xD8    
   \              0xD9 0xDA    
   \              0xDB         
   \   0000005C   0xDC 0xDD          DC8 220, 221, 222, 223, 192, 193, 194, 195, 196, 197, 198, 199, 200
   \              0xDE 0xDF    
   \              0xC0 0xC1    
   \              0xC2 0xC3    
   \              0xC4 0xC5    
   \              0xC6 0xC7    
   \              0xC8         
   \   00000069   0xC9 0xCA          DC8 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213
   \              0xCB 0xCC    
   \              0xCD 0xCE    
   \              0xCF 0xD0    
   \              0xD1 0xD2    
   \              0xD3 0xD4    
   \              0xD5         
   \   00000076   0xD6 0xF7          DC8 214, 247, 216, 217, 218, 219, 220, 221, 222, 159
   \              0xD8 0xD9    
   \              0xDA 0xDB    
   \              0xDC 0xDD    
   \              0xDE 0x9F    
    442          #endif
    443          
    444          
    445          
    446          
    447          
    448          
    449          /*--------------------------------------------------------------------------
    450          
    451             Module Private Functions
    452          
    453          ---------------------------------------------------------------------------*/
    454          
    455          
    456          /*-----------------------------------------------------------------------*/
    457          /* String functions                                                      */
    458          /*-----------------------------------------------------------------------*/
    459          
    460          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    461          static
    462          void mem_cpy (void* dst, const void* src, UINT cnt) {
    463          	BYTE *d = (BYTE*)dst;
    464          	const BYTE *s = (const BYTE*)src;
   \                     mem_cpy: (+1)
   \   00000000   0xE003             B.N      ??mem_cpy_0
    465          
    466          #if _WORD_ACCESS == 1
    467          	while (cnt >= sizeof (int)) {
    468          		*(int*)d = *(int*)s;
    469          		d += sizeof (int); s += sizeof (int);
    470          		cnt -= sizeof (int);
    471          	}
    472          #endif
    473          	while (cnt--)
    474          		*d++ = *s++;
   \                     ??mem_cpy_1: (+1)
   \   00000002   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000006   0xF800 0x3B01      STRB     R3,[R0], #+1
   \                     ??mem_cpy_0: (+1)
   \   0000000A   0x4613             MOV      R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F7             BNE.N    ??mem_cpy_1
    475          }
   \   00000012   0x4770             BX       LR               ;; return
    476          
    477          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    478          static
    479          void mem_set (void* dst, int val, UINT cnt) {
    480          	BYTE *d = (BYTE*)dst;
   \                     mem_set: (+1)
   \   00000000   0xE001             B.N      ??mem_set_0
    481          
    482          	while (cnt--)
    483          		*d++ = (BYTE)val;
   \                     ??mem_set_1: (+1)
   \   00000002   0xF800 0x1B01      STRB     R1,[R0], #+1
   \                     ??mem_set_0: (+1)
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x1E5A             SUBS     R2,R3,#+1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD1F9             BNE.N    ??mem_set_1
    484          }
   \   0000000E   0x4770             BX       LR               ;; return
    485          
    486          /* Compare memory to memory */

   \                                 In section .text, align 2, keep-with-next
    487          static
    488          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
    489          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    490          	int r = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    491          
    492          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0: (+1)
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x1E62             SUBS     R2,R4,#+1
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD005             BEQ.N    ??mem_cmp_1
   \   0000000C   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   00000010   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   00000014   0x1B1B             SUBS     R3,R3,R4
   \   00000016   0xD0F5             BEQ.N    ??mem_cmp_0
    493          	return r;
   \                     ??mem_cmp_1: (+1)
   \   00000018   0x4618             MOV      R0,R3
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    494          }
    495          
    496          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    497          static
    498          int chk_chr (const char* str, int chr) {
   \                     chk_chr: (+1)
   \   00000000   0xE000             B.N      ??chk_chr_0
    499          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1: (+1)
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??chk_chr_0: (+1)
   \   00000004   0x7803             LDRB     R3,[R0, #+0]
   \   00000006   0x001A             MOVS     R2,R3
   \   00000008   0xD001             BEQ.N    ??chk_chr_2
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD1F9             BNE.N    ??chk_chr_1
    500          	return *str;
   \                     ??chk_chr_2: (+1)
   \   0000000E   0x4610             MOV      R0,R2
   \   00000010   0x4770             BX       LR               ;; return
    501          }
    502          
    503          
    504          
    505          
    506          /*-----------------------------------------------------------------------*/
    507          /* Request/Release grant to access the volume                            */
    508          /*-----------------------------------------------------------------------*/
    509          #if _FS_REENTRANT
    510          static
    511          int lock_fs (
    512          	FATFS* fs		/* File system object */
    513          )
    514          {
    515          	return ff_req_grant(fs->sobj);
    516          }
    517          
    518          
    519          static
    520          void unlock_fs (
    521          	FATFS* fs,		/* File system object */
    522          	FRESULT res		/* Result code to be returned */
    523          )
    524          {
    525          	if (fs &&
    526          		res != FR_NOT_ENABLED &&
    527          		res != FR_INVALID_DRIVE &&
    528          		res != FR_INVALID_OBJECT &&
    529          		res != FR_TIMEOUT) {
    530          		ff_rel_grant(fs->sobj);
    531          	}
    532          }
    533          #endif
    534          
    535          
    536          
    537          
    538          /*-----------------------------------------------------------------------*/
    539          /* File lock control functions                                           */
    540          /*-----------------------------------------------------------------------*/
    541          #if _FS_LOCK
    542          
    543          static
    544          FRESULT chk_lock (	/* Check if the file can be accessed */
    545          	DIR* dp,		/* Directory object pointing the file to be checked */
    546          	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
    547          )
    548          {
    549          	UINT i, be;
    550          
    551          	/* Search file semaphore table */
    552          	for (i = be = 0; i < _FS_LOCK; i++) {
    553          		if (Files[i].fs) {	/* Existing entry */
    554          			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
    555          				Files[i].clu == dp->sclust &&
    556          				Files[i].idx == dp->index) break;
    557          		} else {			/* Blank entry */
    558          			be = 1;
    559          		}
    560          	}
    561          	if (i == _FS_LOCK)	/* The object is not opened */
    562          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
    563          
    564          	/* The object has been opened. Reject any open against writing file and all write mode open */
    565          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    566          }
    567          
    568          
    569          static
    570          int enq_lock (void)	/* Check if an entry is available for a new object */
    571          {
    572          	UINT i;
    573          
    574          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    575          	return (i == _FS_LOCK) ? 0 : 1;
    576          }
    577          
    578          
    579          static
    580          UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
    581          	DIR* dp,	/* Directory object pointing the file to register or increment */
    582          	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    583          )
    584          {
    585          	UINT i;
    586          
    587          
    588          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
    589          		if (Files[i].fs == dp->fs &&
    590          			Files[i].clu == dp->sclust &&
    591          			Files[i].idx == dp->index) break;
    592          	}
    593          
    594          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    595          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    596          		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
    597          		Files[i].fs = dp->fs;
    598          		Files[i].clu = dp->sclust;
    599          		Files[i].idx = dp->index;
    600          		Files[i].ctr = 0;
    601          	}
    602          
    603          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    604          
    605          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    606          
    607          	return i + 1;
    608          }
    609          
    610          
    611          static
    612          FRESULT dec_lock (	/* Decrement object open counter */
    613          	UINT i			/* Semaphore index (1..) */
    614          )
    615          {
    616          	WORD n;
    617          	FRESULT res;
    618          
    619          
    620          	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
    621          		n = Files[i].ctr;
    622          		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
    623          		if (n) n--;					/* Decrement read mode open count */
    624          		Files[i].ctr = n;
    625          		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
    626          		res = FR_OK;
    627          	} else {
    628          		res = FR_INT_ERR;			/* Invalid index nunber */
    629          	}
    630          	return res;
    631          }
    632          
    633          
    634          static
    635          void clear_lock (	/* Clear lock entries of the volume */
    636          	FATFS *fs
    637          )
    638          {
    639          	UINT i;
    640          
    641          	for (i = 0; i < _FS_LOCK; i++) {
    642          		if (Files[i].fs == fs) Files[i].fs = 0;
    643          	}
    644          }
    645          #endif
    646          
    647          
    648          
    649          
    650          /*-----------------------------------------------------------------------*/
    651          /* Move/Flush disk access window in the file system object               */
    652          /*-----------------------------------------------------------------------*/
    653          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    654          static
    655          FRESULT sync_window (
    656          	FATFS* fs		/* File system object */
    657          )
    658          {
   \                     sync_window: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    659          	DWORD wsect;
    660          	UINT nf;
    661          	FRESULT res = FR_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    662          
    663          
    664          	if (fs->wflag) {	/* Write back the sector if it is dirty */
   \   00000006   0x7928             LDRB     R0,[R5, #+4]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD020             BEQ.N    ??sync_window_0
    665          		wsect = fs->winsect;	/* Current sector number */
   \   0000000C   0x6B2E             LDR      R6,[R5, #+48]
    666          		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x4632             MOV      R2,R6
   \   00000012   0xF105 0x0134      ADD      R1,R5,#+52
   \   00000016   0x7868             LDRB     R0,[R5, #+1]
   \   00000018   0x.... 0x....      BL       disk_write
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??sync_window_1
    667          			res = FR_DISK_ERR;
   \   00000020   0x2401             MOVS     R4,#+1
   \   00000022   0xE014             B.N      ??sync_window_0
    668          		} else {
    669          			fs->wflag = 0;
   \                     ??sync_window_1: (+1)
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x7128             STRB     R0,[R5, #+4]
    670          			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
   \   00000028   0x6A68             LDR      R0,[R5, #+36]
   \   0000002A   0x1A30             SUBS     R0,R6,R0
   \   0000002C   0x69E9             LDR      R1,[R5, #+28]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD20D             BCS.N    ??sync_window_0
    671          				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   \   00000032   0x78EF             LDRB     R7,[R5, #+3]
   \   00000034   0xE009             B.N      ??sync_window_2
    672          					wsect += fs->fsize;
   \                     ??sync_window_3: (+1)
   \   00000036   0x69E8             LDR      R0,[R5, #+28]
   \   00000038   0x1986             ADDS     R6,R0,R6
    673          					disk_write(fs->drv, fs->win, wsect, 1);
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0xF105 0x0134      ADD      R1,R5,#+52
   \   00000042   0x7868             LDRB     R0,[R5, #+1]
   \   00000044   0x.... 0x....      BL       disk_write
    674          				}
   \   00000048   0x1E7F             SUBS     R7,R7,#+1
   \                     ??sync_window_2: (+1)
   \   0000004A   0x2F02             CMP      R7,#+2
   \   0000004C   0xD2F3             BCS.N    ??sync_window_3
    675          			}
    676          		}
    677          	}
    678          	return res;
   \                     ??sync_window_0: (+1)
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    679          }
    680          #endif
    681          
    682          

   \                                 In section .text, align 2, keep-with-next
    683          static
    684          FRESULT move_window (
    685          	FATFS* fs,		/* File system object */
    686          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    687          )
    688          {
   \                     move_window: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    689          	FRESULT res = FR_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    690          
    691          
    692          	if (sector != fs->winsect) {	/* Window offset changed? */
   \   00000008   0x6B20             LDR      R0,[R4, #+48]
   \   0000000A   0x4285             CMP      R5,R0
   \   0000000C   0xD011             BEQ.N    ??move_window_0
    693          #if !_FS_READONLY
    694          		res = sync_window(fs);		/* Write-back changes */
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       sync_window
   \   00000014   0x0006             MOVS     R6,R0
    695          #endif
    696          		if (res == FR_OK) {			/* Fill sector window with new data */
   \   00000016   0xD10C             BNE.N    ??move_window_0
    697          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x462A             MOV      R2,R5
   \   0000001C   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x.... 0x....      BL       disk_read
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??move_window_1
    698          				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
   \   0000002A   0xF04F 0x35FF      MOV      R5,#-1
    699          				res = FR_DISK_ERR;
   \   0000002E   0x2601             MOVS     R6,#+1
    700          			}
    701          			fs->winsect = sector;
   \                     ??move_window_1: (+1)
   \   00000030   0x6325             STR      R5,[R4, #+48]
    702          		}
    703          	}
    704          	return res;
   \                     ??move_window_0: (+1)
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    705          }
    706          
    707          
    708          
    709          
    710          /*-----------------------------------------------------------------------*/
    711          /* Synchronize file system and strage device                             */
    712          /*-----------------------------------------------------------------------*/
    713          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    714          static
    715          FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
    716          	FATFS* fs		/* File system object */
    717          )
    718          {
   \                     sync_fs: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    719          	FRESULT res;
    720          
    721          
    722          	res = sync_window(fs);
   \   00000004   0x.... 0x....      BL       sync_window
   \   00000008   0x0005             MOVS     R5,R0
    723          	if (res == FR_OK) {
   \   0000000A   0xD14C             BNE.N    ??sync_fs_0
    724          		/* Update FSINFO sector if needed */
    725          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD141             BNE.N    ??sync_fs_1
   \   00000012   0x7960             LDRB     R0,[R4, #+5]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD13E             BNE.N    ??sync_fs_1
    726          			/* Create FSINFO structure */
    727          			mem_set(fs->win, 0, SS(fs));
   \   00000018   0xF104 0x0634      ADD      R6,R4,#+52
   \   0000001C   0xF44F 0x7200      MOV      R2,#+512
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       mem_set
    728          			ST_WORD(fs->win + BS_55AA, 0xAA55);
   \   00000028   0xF44F 0x7006      MOV      R0,#+536
   \   0000002C   0x4420             ADD      R0,R4,R0
   \   0000002E   0x2155             MOVS     R1,#+85
   \   00000030   0x7681             STRB     R1,[R0, #+26]
   \   00000032   0x21AA             MOVS     R1,#+170
   \   00000034   0x76C1             STRB     R1,[R0, #+27]
    729          			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
   \   00000036   0x2152             MOVS     R1,#+82
   \   00000038   0x7031             STRB     R1,[R6, #+0]
   \   0000003A   0x7071             STRB     R1,[R6, #+1]
   \   0000003C   0x2161             MOVS     R1,#+97
   \   0000003E   0x70B1             STRB     R1,[R6, #+2]
   \   00000040   0x2141             MOVS     R1,#+65
   \   00000042   0x70F1             STRB     R1,[R6, #+3]
    730          			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
   \   00000044   0x2172             MOVS     R1,#+114
   \   00000046   0x7001             STRB     R1,[R0, #+0]
   \   00000048   0x7041             STRB     R1,[R0, #+1]
   \   0000004A   0x2141             MOVS     R1,#+65
   \   0000004C   0x7081             STRB     R1,[R0, #+2]
   \   0000004E   0x2161             MOVS     R1,#+97
   \   00000050   0x70C1             STRB     R1,[R0, #+3]
    731          			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
   \   00000052   0x6921             LDR      R1,[R4, #+16]
   \   00000054   0x7101             STRB     R1,[R0, #+4]
   \   00000056   0x6921             LDR      R1,[R4, #+16]
   \   00000058   0xB289             UXTH     R1,R1
   \   0000005A   0x0A09             LSRS     R1,R1,#+8
   \   0000005C   0x7141             STRB     R1,[R0, #+5]
   \   0000005E   0x6921             LDR      R1,[R4, #+16]
   \   00000060   0x0C09             LSRS     R1,R1,#+16
   \   00000062   0x7181             STRB     R1,[R0, #+6]
   \   00000064   0x6921             LDR      R1,[R4, #+16]
   \   00000066   0x0E09             LSRS     R1,R1,#+24
   \   00000068   0x71C1             STRB     R1,[R0, #+7]
    732          			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
   \   0000006A   0x68E1             LDR      R1,[R4, #+12]
   \   0000006C   0x7201             STRB     R1,[R0, #+8]
   \   0000006E   0x68E1             LDR      R1,[R4, #+12]
   \   00000070   0xB289             UXTH     R1,R1
   \   00000072   0x0A09             LSRS     R1,R1,#+8
   \   00000074   0x7241             STRB     R1,[R0, #+9]
   \   00000076   0x68E1             LDR      R1,[R4, #+12]
   \   00000078   0x0C09             LSRS     R1,R1,#+16
   \   0000007A   0x7281             STRB     R1,[R0, #+10]
   \   0000007C   0x68E1             LDR      R1,[R4, #+12]
   \   0000007E   0x0E09             LSRS     R1,R1,#+24
   \   00000080   0x72C1             STRB     R1,[R0, #+11]
    733          			/* Write it into the FSINFO sector */
    734          			fs->winsect = fs->volbase + 1;
   \   00000082   0x6A20             LDR      R0,[R4, #+32]
   \   00000084   0x1C42             ADDS     R2,R0,#+1
   \   00000086   0x6322             STR      R2,[R4, #+48]
    735          			disk_write(fs->drv, fs->win, fs->winsect, 1);
   \   00000088   0x2301             MOVS     R3,#+1
   \   0000008A   0x4631             MOV      R1,R6
   \   0000008C   0x7860             LDRB     R0,[R4, #+1]
   \   0000008E   0x.... 0x....      BL       disk_write
    736          			fs->fsi_flag = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x7160             STRB     R0,[R4, #+5]
    737          		}
    738          		/* Make sure that no pending write process in the physical drive */
    739          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_fs_1: (+1)
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0x4611             MOV      R1,R2
   \   0000009A   0x7860             LDRB     R0,[R4, #+1]
   \   0000009C   0x.... 0x....      BL       disk_ioctl
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD000             BEQ.N    ??sync_fs_0
    740          			res = FR_DISK_ERR;
   \   000000A4   0x2501             MOVS     R5,#+1
    741          	}
    742          
    743          	return res;
   \                     ??sync_fs_0: (+1)
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
    744          }
    745          #endif
    746          
    747          
    748          
    749          
    750          /*-----------------------------------------------------------------------*/
    751          /* Get sector# from cluster#                                             */
    752          /*-----------------------------------------------------------------------*/
    753          /* Hidden API for hacks and disk tools */
    754          

   \                                 In section .text, align 2, keep-with-next
    755          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    756          	FATFS* fs,		/* File system object */
    757          	DWORD clst		/* Cluster# to be converted */
    758          )
    759          {
    760          	clst -= 2;
   \                     clust2sect: (+1)
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    761          	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
   \   00000002   0x6982             LDR      R2,[R0, #+24]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC.N    ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    762          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0: (+1)
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x6AC0             LDR      R0,[R0, #+44]
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000016   0x4770             BX       LR               ;; return
    763          }
    764          
    765          
    766          
    767          
    768          /*-----------------------------------------------------------------------*/
    769          /* FAT access - Read value of a FAT entry                                */
    770          /*-----------------------------------------------------------------------*/
    771          /* Hidden API for hacks and disk tools */
    772          

   \                                 In section .text, align 2, keep-with-next
    773          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
    774          	FATFS* fs,	/* File system object */
    775          	DWORD clst	/* FAT index number (cluster number) to get the value */
    776          )
    777          {
   \                     get_fat: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    778          	UINT wc, bc;
    779          	BYTE *p;
    780          	DWORD val;
    781          
    782          
    783          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xD35F             BCC.N    ??get_fat_0
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD25C             BCS.N    ??get_fat_0
    784          		val = 1;	/* Internal error */
    785          
    786          	} else {
    787          		val = 0xFFFFFFFF;	/* Default value falls on disk error */
   \   00000012   0xF04F 0x36FF      MOV      R6,#-1
    788          
    789          		switch (fs->fs_type) {
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??get_fat_1
   \   0000001C   0xD356             BCC.N    ??get_fat_0
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD03A             BEQ.N    ??get_fat_2
   \   00000022   0xD327             BCC.N    ??get_fat_3
   \   00000024   0xE052             B.N      ??get_fat_0
    790          		case FS_FAT12 :
    791          			bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_1: (+1)
   \   00000026   0xEB05 0x0755      ADD      R7,R5,R5, LSR #+1
    792          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   \   0000002A   0x6A60             LDR      R0,[R4, #+36]
   \   0000002C   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       move_window
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD149             BNE.N    ??get_fat_4
    793          			wc = fs->win[bc++ % SS(fs)];
   \   0000003A   0xF3C7 0x0008      UBFX     R0,R7,#+0,#+9
   \   0000003E   0x4420             ADD      R0,R4,R0
   \   00000040   0xF890 0x8034      LDRB     R8,[R0, #+52]
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
    794          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   \   00000046   0x6A60             LDR      R0,[R4, #+36]
   \   00000048   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       move_window
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD13B             BNE.N    ??get_fat_4
    795          			wc |= fs->win[bc % SS(fs)] << 8;
   \   00000056   0xF3C7 0x0008      UBFX     R0,R7,#+0,#+9
   \   0000005A   0x4420             ADD      R0,R4,R0
   \   0000005C   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000060   0xEA48 0x2800      ORR      R8,R8,R0, LSL #+8
    796          			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
   \   00000064   0x07E8             LSLS     R0,R5,#+31
   \   00000066   0xD502             BPL.N    ??get_fat_5
   \   00000068   0xEA4F 0x1618      LSR      R6,R8,#+4
   \   0000006C   0xE02F             B.N      ??get_fat_4
   \                     ??get_fat_5: (+1)
   \   0000006E   0xF3C8 0x060B      UBFX     R6,R8,#+0,#+12
   \   00000072   0xE02C             B.N      ??get_fat_4
    797          			break;
    798          
    799          		case FS_FAT16 :
    800          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   \                     ??get_fat_3: (+1)
   \   00000074   0x6A60             LDR      R0,[R4, #+36]
   \   00000076   0xEB00 0x2115      ADD      R1,R0,R5, LSR #+8
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       move_window
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD124             BNE.N    ??get_fat_4
    801          			p = &fs->win[clst * 2 % SS(fs)];
   \   00000084   0x0068             LSLS     R0,R5,#+1
   \   00000086   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   0000008A   0x4420             ADD      R0,R4,R0
   \   0000008C   0x3034             ADDS     R0,R0,#+52
    802          			val = LD_WORD(p);
   \   0000008E   0x7841             LDRB     R1,[R0, #+1]
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xEA40 0x2601      ORR      R6,R0,R1, LSL #+8
    803          			break;
   \   00000096   0xE01A             B.N      ??get_fat_4
    804          
    805          		case FS_FAT32 :
    806          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   \                     ??get_fat_2: (+1)
   \   00000098   0x6A60             LDR      R0,[R4, #+36]
   \   0000009A   0xEB00 0x11D5      ADD      R1,R0,R5, LSR #+7
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       move_window
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD112             BNE.N    ??get_fat_4
    807          			p = &fs->win[clst * 4 % SS(fs)];
   \   000000A8   0x00A8             LSLS     R0,R5,#+2
   \   000000AA   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   000000AE   0x4420             ADD      R0,R4,R0
   \   000000B0   0x3034             ADDS     R0,R0,#+52
    808          			val = LD_DWORD(p) & 0x0FFFFFFF;
   \   000000B2   0x78C1             LDRB     R1,[R0, #+3]
   \   000000B4   0x7882             LDRB     R2,[R0, #+2]
   \   000000B6   0x0412             LSLS     R2,R2,#+16
   \   000000B8   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   000000BC   0x7842             LDRB     R2,[R0, #+1]
   \   000000BE   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x4308             ORRS     R0,R0,R1
   \   000000C6   0xF020 0x4670      BIC      R6,R0,#0xF0000000
    809          			break;
   \   000000CA   0xE000             B.N      ??get_fat_4
    810          
    811          		default:
    812          			val = 1;	/* Internal error */
   \                     ??get_fat_0: (+1)
   \   000000CC   0x2601             MOVS     R6,#+1
    813          		}
    814          	}
    815          
    816          	return val;
   \                     ??get_fat_4: (+1)
   \   000000CE   0x4630             MOV      R0,R6
   \   000000D0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    817          }
    818          
    819          
    820          
    821          
    822          /*-----------------------------------------------------------------------*/
    823          /* FAT access - Change value of a FAT entry                              */
    824          /*-----------------------------------------------------------------------*/
    825          /* Hidden API for hacks and disk tools */
    826          
    827          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    828          FRESULT put_fat (
    829          	FATFS* fs,	/* File system object */
    830          	DWORD clst,	/* FAT index number (cluster number) to be changed */
    831          	DWORD val	/* New value to be set to the entry */
    832          )
    833          {
   \                     put_fat: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    834          	UINT bc;
    835          	BYTE *p;
    836          	FRESULT res;
    837          
    838          
    839          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2E02             CMP      R6,#+2
   \   0000000A   0xD374             BCC.N    ??put_fat_0
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD271             BCS.N    ??put_fat_0
    840          		res = FR_INT_ERR;
    841          
    842          	} else {
    843          		switch (fs->fs_type) {
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD004             BEQ.N    ??put_fat_1
   \   00000018   0xD36D             BCC.N    ??put_fat_0
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD04D             BEQ.N    ??put_fat_2
   \   0000001E   0xD338             BCC.N    ??put_fat_3
   \   00000020   0xE069             B.N      ??put_fat_0
    844          		case FS_FAT12 :
    845          			bc = (UINT)clst; bc += bc / 2;
   \                     ??put_fat_1: (+1)
   \   00000022   0xEB06 0x0756      ADD      R7,R6,R6, LSR #+1
    846          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000026   0x6A60             LDR      R0,[R4, #+36]
   \   00000028   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       move_window
    847          			if (res != FR_OK) break;
   \   00000032   0x0001             MOVS     R1,R0
   \   00000034   0xD160             BNE.N    ??put_fat_4
    848          			p = &fs->win[bc++ % SS(fs)];
   \   00000036   0xF3C7 0x0008      UBFX     R0,R7,#+0,#+9
   \   0000003A   0x4420             ADD      R0,R4,R0
   \   0000003C   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000040   0x1C7F             ADDS     R7,R7,#+1
    849          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000042   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000046   0xD005             BEQ.N    ??put_fat_5
   \   00000048   0x7808             LDRB     R0,[R1, #+0]
   \   0000004A   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000004E   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \   00000052   0xE000             B.N      ??put_fat_6
   \                     ??put_fat_5: (+1)
   \   00000054   0x4628             MOV      R0,R5
   \                     ??put_fat_6: (+1)
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    850          			fs->wflag = 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x7120             STRB     R0,[R4, #+4]
    851          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000005C   0x6A60             LDR      R0,[R4, #+36]
   \   0000005E   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       move_window
    852          			if (res != FR_OK) break;
   \   00000068   0x0001             MOVS     R1,R0
   \   0000006A   0xD145             BNE.N    ??put_fat_4
    853          			p = &fs->win[bc % SS(fs)];
   \   0000006C   0xF3C7 0x0108      UBFX     R1,R7,#+0,#+9
   \   00000070   0x4421             ADD      R1,R4,R1
   \   00000072   0x3134             ADDS     R1,R1,#+52
    854          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD001             BEQ.N    ??put_fat_7
   \   00000078   0x092A             LSRS     R2,R5,#+4
   \   0000007A   0xE006             B.N      ??put_fat_8
   \                     ??put_fat_7: (+1)
   \   0000007C   0x780A             LDRB     R2,[R1, #+0]
   \   0000007E   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   00000082   0x0A2B             LSRS     R3,R5,#+8
   \   00000084   0xF003 0x030F      AND      R3,R3,#0xF
   \   00000088   0x431A             ORRS     R2,R3,R2
   \                     ??put_fat_8: (+1)
   \   0000008A   0x700A             STRB     R2,[R1, #+0]
    855          			fs->wflag = 1;
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x7121             STRB     R1,[R4, #+4]
    856          			break;
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}
    857          
    858          		case FS_FAT16 :
    859          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_3: (+1)
   \   00000092   0x6A60             LDR      R0,[R4, #+36]
   \   00000094   0xEB00 0x2116      ADD      R1,R0,R6, LSR #+8
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       move_window
    860          			if (res != FR_OK) break;
   \   0000009E   0x0001             MOVS     R1,R0
   \   000000A0   0xD12A             BNE.N    ??put_fat_4
    861          			p = &fs->win[clst * 2 % SS(fs)];
   \   000000A2   0x0071             LSLS     R1,R6,#+1
   \   000000A4   0xF3C1 0x0108      UBFX     R1,R1,#+0,#+9
   \   000000A8   0x4421             ADD      R1,R4,R1
   \   000000AA   0x3134             ADDS     R1,R1,#+52
    862          			ST_WORD(p, (WORD)val);
   \   000000AC   0x700D             STRB     R5,[R1, #+0]
   \   000000AE   0xB2AD             UXTH     R5,R5
   \   000000B0   0x0A2A             LSRS     R2,R5,#+8
   \   000000B2   0x704A             STRB     R2,[R1, #+1]
    863          			fs->wflag = 1;
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x7121             STRB     R1,[R4, #+4]
    864          			break;
   \   000000B8   0xBDF2             POP      {R1,R4-R7,PC}
    865          
    866          		case FS_FAT32 :
    867          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_2: (+1)
   \   000000BA   0x6A60             LDR      R0,[R4, #+36]
   \   000000BC   0xEB00 0x11D6      ADD      R1,R0,R6, LSR #+7
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       move_window
    868          			if (res != FR_OK) break;
   \   000000C6   0x0001             MOVS     R1,R0
   \   000000C8   0xD116             BNE.N    ??put_fat_4
    869          			p = &fs->win[clst * 4 % SS(fs)];
   \   000000CA   0x00B1             LSLS     R1,R6,#+2
   \   000000CC   0xF3C1 0x0108      UBFX     R1,R1,#+0,#+9
   \   000000D0   0x4421             ADD      R1,R4,R1
   \   000000D2   0x3134             ADDS     R1,R1,#+52
    870          			val |= LD_DWORD(p) & 0xF0000000;
   \   000000D4   0x78CA             LDRB     R2,[R1, #+3]
   \   000000D6   0x0612             LSLS     R2,R2,#+24
   \   000000D8   0xF002 0x4270      AND      R2,R2,#0xF0000000
   \   000000DC   0x4315             ORRS     R5,R2,R5
    871          			ST_DWORD(p, val);
   \   000000DE   0x700D             STRB     R5,[R1, #+0]
   \   000000E0   0x462A             MOV      R2,R5
   \   000000E2   0xB292             UXTH     R2,R2
   \   000000E4   0x0A12             LSRS     R2,R2,#+8
   \   000000E6   0x704A             STRB     R2,[R1, #+1]
   \   000000E8   0x0C2A             LSRS     R2,R5,#+16
   \   000000EA   0x708A             STRB     R2,[R1, #+2]
   \   000000EC   0x0E2A             LSRS     R2,R5,#+24
   \   000000EE   0x70CA             STRB     R2,[R1, #+3]
    872          			fs->wflag = 1;
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x7121             STRB     R1,[R4, #+4]
    873          			break;
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}
    874          
    875          		default :
    876          			res = FR_INT_ERR;
   \                     ??put_fat_0: (+1)
   \   000000F6   0x2002             MOVS     R0,#+2
    877          		}
    878          	}
    879          
    880          	return res;
   \                     ??put_fat_4: (+1)
   \   000000F8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    881          }
    882          #endif /* !_FS_READONLY */
    883          
    884          
    885          
    886          
    887          /*-----------------------------------------------------------------------*/
    888          /* FAT handling - Remove a cluster chain                                 */
    889          /*-----------------------------------------------------------------------*/
    890          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    891          static
    892          FRESULT remove_chain (
    893          	FATFS* fs,			/* File system object */
    894          	DWORD clst			/* Cluster# to remove a chain from */
    895          )
    896          {
   \                     remove_chain: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
    897          	FRESULT res;
    898          	DWORD nxt;
    899          #if _USE_TRIM
    900          	DWORD scl = clst, ecl = clst, rt[2];
    901          #endif
    902          
    903          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2F02             CMP      R7,#+2
   \   00000008   0xD31A             BCC.N    ??remove_chain_0
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0x4287             CMP      R7,R0
   \   0000000E   0xD217             BCS.N    ??remove_chain_0
    904          		res = FR_INT_ERR;
    905          
    906          	} else {
    907          		res = FR_OK;
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0xE00A             B.N      ??remove_chain_1
    908          		while (clst < fs->n_fatent) {			/* Not a last link? */
    909          			nxt = get_fat(fs, clst);			/* Get cluster status */
    910          			if (nxt == 0) break;				/* Empty cluster? */
    911          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    912          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    913          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    914          			if (res != FR_OK) break;
    915          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
   \                     ??remove_chain_2: (+1)
   \   00000014   0x6920             LDR      R0,[R4, #+16]
   \   00000016   0xF110 0x0F01      CMN      R0,#+1
   \   0000001A   0xD005             BEQ.N    ??remove_chain_3
    916          				fs->free_clust++;
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x6120             STR      R0,[R4, #+16]
    917          				fs->fsi_flag |= 1;
   \   00000020   0x7960             LDRB     R0,[R4, #+5]
   \   00000022   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000026   0x7160             STRB     R0,[R4, #+5]
    918          			}
    919          #if _USE_TRIM
    920          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
    921          				ecl = nxt;
    922          			} else {				/* End of contiguous clusters */ 
    923          				rt[0] = clust2sect(fs, scl);					/* Start sector */
    924          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    925          				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
    926          				scl = ecl = nxt;
    927          			}
    928          #endif
    929          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_3: (+1)
   \   00000028   0x4637             MOV      R7,R6
   \                     ??remove_chain_1: (+1)
   \   0000002A   0x69A0             LDR      R0,[R4, #+24]
   \   0000002C   0x4287             CMP      R7,R0
   \   0000002E   0xD215             BCS.N    ??remove_chain_4
   \   00000030   0x4639             MOV      R1,R7
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       get_fat
   \   00000038   0x0006             MOVS     R6,R0
   \   0000003A   0xD00F             BEQ.N    ??remove_chain_4
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD101             BNE.N    ??remove_chain_5
   \                     ??remove_chain_0: (+1)
   \   00000040   0x2502             MOVS     R5,#+2
   \   00000042   0xE00B             B.N      ??remove_chain_4
   \                     ??remove_chain_5: (+1)
   \   00000044   0xF116 0x0F01      CMN      R6,#+1
   \   00000048   0xD101             BNE.N    ??remove_chain_6
   \   0000004A   0x2501             MOVS     R5,#+1
   \   0000004C   0xE006             B.N      ??remove_chain_4
   \                     ??remove_chain_6: (+1)
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x4639             MOV      R1,R7
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       put_fat
   \   00000058   0x0005             MOVS     R5,R0
   \   0000005A   0xD0DB             BEQ.N    ??remove_chain_2
    930          		}
    931          	}
    932          
    933          	return res;
   \                     ??remove_chain_4: (+1)
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    934          }
    935          #endif
    936          
    937          
    938          
    939          
    940          /*-----------------------------------------------------------------------*/
    941          /* FAT handling - Stretch or Create a cluster chain                      */
    942          /*-----------------------------------------------------------------------*/
    943          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    944          static
    945          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    946          	FATFS* fs,			/* File system object */
    947          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    948          )
    949          {
   \                     create_chain: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    950          	DWORD cs, ncl, scl;
    951          	FRESULT res;
    952          
    953          
    954          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0xD107             BNE.N    ??create_chain_0
    955          		scl = fs->last_clust;			/* Get suggested start point */
   \   00000008   0x68E7             LDR      R7,[R4, #+12]
    956          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD002             BEQ.N    ??create_chain_1
   \   0000000E   0x69A0             LDR      R0,[R4, #+24]
   \   00000010   0x4287             CMP      R7,R0
   \   00000012   0xD30E             BCC.N    ??create_chain_2
   \                     ??create_chain_1: (+1)
   \   00000014   0x2701             MOVS     R7,#+1
   \   00000016   0xE00C             B.N      ??create_chain_2
    957          	}
    958          	else {					/* Stretch the current chain */
    959          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0: (+1)
   \   00000018   0x.... 0x....      BL       get_fat
    960          		if (cs < 2) return 1;			/* Invalid value */
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD201             BCS.N    ??create_chain_3
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}
    961          		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
   \                     ??create_chain_3: (+1)
   \   00000024   0xF110 0x0F01      CMN      R0,#+1
   \   00000028   0xD03E             BEQ.N    ??create_chain_4
    962          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \   0000002A   0x69A1             LDR      R1,[R4, #+24]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD33B             BCC.N    ??create_chain_4
    963          		scl = clst;
   \   00000030   0x4637             MOV      R7,R6
    964          	}
    965          
    966          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2: (+1)
   \   00000032   0x463D             MOV      R5,R7
    967          	for (;;) {
    968          		ncl++;							/* Next cluster */
   \                     ??create_chain_5: (+1)
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    969          		if (ncl >= fs->n_fatent) {		/* Check wrap around */
   \   00000036   0x69A0             LDR      R0,[R4, #+24]
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD302             BCC.N    ??create_chain_6
    970          			ncl = 2;
   \   0000003C   0x2502             MOVS     R5,#+2
    971          			if (ncl > scl) return 0;	/* No free cluster */
   \   0000003E   0x2F02             CMP      R7,#+2
   \   00000040   0xD329             BCC.N    ??create_chain_7
    972          		}
    973          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_6: (+1)
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       get_fat
    974          		if (cs == 0) break;				/* Found a free cluster */
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD11C             BNE.N    ??create_chain_8
    975          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    976          			return cs;
    977          		if (ncl == scl) return 0;		/* No free cluster */
    978          	}
    979          
    980          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   0000004E   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       put_fat
    981          	if (res == FR_OK && clst != 0) {
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD106             BNE.N    ??create_chain_9
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xD004             BEQ.N    ??create_chain_9
    982          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00000062   0x462A             MOV      R2,R5
   \   00000064   0x4631             MOV      R1,R6
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       put_fat
    983          	}
    984          	if (res == FR_OK) {
   \                     ??create_chain_9: (+1)
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD114             BNE.N    ??create_chain_10
    985          		fs->last_clust = ncl;			/* Update FSINFO */
   \   00000070   0x60E5             STR      R5,[R4, #+12]
    986          		if (fs->free_clust != 0xFFFFFFFF) {
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0xF110 0x0F01      CMN      R0,#+1
   \   00000078   0xD015             BEQ.N    ??create_chain_11
    987          			fs->free_clust--;
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x6120             STR      R0,[R4, #+16]
    988          			fs->fsi_flag |= 1;
   \   0000007E   0x7960             LDRB     R0,[R4, #+5]
   \   00000080   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000084   0x7160             STRB     R0,[R4, #+5]
   \   00000086   0xE00E             B.N      ??create_chain_11
    989          		}
    990          	} else {
   \                     ??create_chain_8: (+1)
   \   00000088   0xF110 0x0F01      CMN      R0,#+1
   \   0000008C   0xD00C             BEQ.N    ??create_chain_4
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD00A             BEQ.N    ??create_chain_4
   \   00000092   0x42BD             CMP      R5,R7
   \   00000094   0xD1CE             BNE.N    ??create_chain_5
   \                     ??create_chain_7: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xBDF2             POP      {R1,R4-R7,PC}
    991          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10: (+1)
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0xD102             BNE.N    ??create_chain_12
   \   0000009E   0xF04F 0x35FF      MOV      R5,#-1
   \   000000A2   0xE000             B.N      ??create_chain_11
   \                     ??create_chain_12: (+1)
   \   000000A4   0x2501             MOVS     R5,#+1
    992          	}
    993          
    994          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_11: (+1)
   \   000000A6   0x4628             MOV      R0,R5
   \                     ??create_chain_4: (+1)
   \   000000A8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    995          }
    996          #endif /* !_FS_READONLY */
    997          
    998          
    999          
   1000          
   1001          /*-----------------------------------------------------------------------*/
   1002          /* FAT handling - Convert offset into cluster with link map table        */
   1003          /*-----------------------------------------------------------------------*/
   1004          
   1005          #if _USE_FASTSEEK
   1006          static
   1007          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1008          	FIL* fp,		/* Pointer to the file object */
   1009          	DWORD ofs		/* File offset to be converted to cluster# */
   1010          )
   1011          {
   1012          	DWORD cl, ncl, *tbl;
   1013          
   1014          
   1015          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1016          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   1017          	for (;;) {
   1018          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1019          		if (!ncl) return 0;		/* End of table? (error) */
   1020          		if (cl < ncl) break;	/* In this fragment? */
   1021          		cl -= ncl; tbl++;		/* Next fragment */
   1022          	}
   1023          	return cl + *tbl;	/* Return the cluster number */
   1024          }
   1025          #endif	/* _USE_FASTSEEK */
   1026          
   1027          
   1028          
   1029          
   1030          /*-----------------------------------------------------------------------*/
   1031          /* Directory handling - Set directory index                              */
   1032          /*-----------------------------------------------------------------------*/
   1033          

   \                                 In section .text, align 2, keep-with-next
   1034          static
   1035          FRESULT dir_sdi (
   1036          	DIR* dp,		/* Pointer to directory object */
   1037          	UINT idx		/* Index of directory table */
   1038          )
   1039          {
   \                     dir_sdi: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1040          	DWORD clst, sect;
   1041          	UINT ic;
   1042          
   1043          
   1044          	dp->index = (WORD)idx;	/* Current index */
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1045          	clst = dp->sclust;		/* Table start cluster (0:root) */
   \   00000008   0x68A6             LDR      R6,[R4, #+8]
   1046          	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2E01             CMP      R6,#+1
   \   0000000C   0xD003             BEQ.N    ??dir_sdi_0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6981             LDR      R1,[R0, #+24]
   \   00000012   0x428E             CMP      R6,R1
   \   00000014   0xD301             BCC.N    ??dir_sdi_1
   1047          		return FR_INT_ERR;
   \                     ??dir_sdi_0: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}
   1048          	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_1: (+1)
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD103             BNE.N    ??dir_sdi_2
   \   0000001E   0x7801             LDRB     R1,[R0, #+0]
   \   00000020   0x2903             CMP      R1,#+3
   \   00000022   0xD100             BNE.N    ??dir_sdi_2
   1049          		clst = dp->fs->dirbase;
   \   00000024   0x6A86             LDR      R6,[R0, #+40]
   1050          
   1051          	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
   \                     ??dir_sdi_2: (+1)
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD106             BNE.N    ??dir_sdi_3
   1052          		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
   \   0000002A   0x8901             LDRH     R1,[R0, #+8]
   \   0000002C   0x428D             CMP      R5,R1
   \   0000002E   0xD301             BCC.N    ??dir_sdi_4
   1053          			return FR_INT_ERR;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
   1054          		sect = dp->fs->dirbase;
   \                     ??dir_sdi_4: (+1)
   \   00000034   0x6A80             LDR      R0,[R0, #+40]
   \   00000036   0xE019             B.N      ??dir_sdi_5
   1055          	}
   1056          	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
   1057          		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_3: (+1)
   \   00000038   0x7880             LDRB     R0,[R0, #+2]
   \   0000003A   0x0107             LSLS     R7,R0,#+4
   \   0000003C   0xE000             B.N      ??dir_sdi_6
   1058          		while (idx >= ic) {	/* Follow cluster chain */
   1059          			clst = get_fat(dp->fs, clst);				/* Get next cluster */
   1060          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1061          			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
   1062          				return FR_INT_ERR;
   1063          			idx -= ic;
   \                     ??dir_sdi_7: (+1)
   \   0000003E   0x1BED             SUBS     R5,R5,R7
   \                     ??dir_sdi_6: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x42BD             CMP      R5,R7
   \   00000044   0x4631             MOV      R1,R6
   \   00000046   0xD30F             BCC.N    ??dir_sdi_8
   \   00000048   0x.... 0x....      BL       get_fat
   \   0000004C   0x4606             MOV      R6,R0
   \   0000004E   0xF116 0x0F01      CMN      R6,#+1
   \   00000052   0xD101             BNE.N    ??dir_sdi_9
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??dir_sdi_9: (+1)
   \   00000058   0x2E02             CMP      R6,#+2
   \   0000005A   0xD303             BCC.N    ??dir_sdi_10
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6980             LDR      R0,[R0, #+24]
   \   00000060   0x4286             CMP      R6,R0
   \   00000062   0xD3EC             BCC.N    ??dir_sdi_7
   \                     ??dir_sdi_10: (+1)
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}
   1064          		}
   1065          		sect = clust2sect(dp->fs, clst);
   \                     ??dir_sdi_8: (+1)
   \   00000068   0x.... 0x....      BL       clust2sect
   1066          	}
   1067          	dp->clust = clst;	/* Current cluster# */
   \                     ??dir_sdi_5: (+1)
   \   0000006C   0x60E6             STR      R6,[R4, #+12]
   1068          	if (!sect) return FR_INT_ERR;
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD101             BNE.N    ??dir_sdi_11
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}
   1069          	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
   \                     ??dir_sdi_11: (+1)
   \   00000076   0xEB00 0x1015      ADD      R0,R0,R5, LSR #+4
   \   0000007A   0x6120             STR      R0,[R4, #+16]
   1070          	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x0169             LSLS     R1,R5,#+5
   \   00000080   0xF401 0x71F0      AND      R1,R1,#0x1E0
   \   00000084   0x4408             ADD      R0,R0,R1
   \   00000086   0x3034             ADDS     R0,R0,#+52
   \   00000088   0x6160             STR      R0,[R4, #+20]
   1071          
   1072          	return FR_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1073          }
   1074          
   1075          
   1076          
   1077          
   1078          /*-----------------------------------------------------------------------*/
   1079          /* Directory handling - Move directory table index next                  */
   1080          /*-----------------------------------------------------------------------*/
   1081          

   \                                 In section .text, align 2, keep-with-next
   1082          static
   1083          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
   1084          	DIR* dp,		/* Pointer to the directory object */
   1085          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1086          )
   1087          {
   \                     dir_next: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   1088          	DWORD clst;
   1089          	UINT i;
   1090          #if !_FS_READONLY
   1091          	UINT c;
   1092          #endif
   1093          
   1094          
   1095          	i = dp->index + 1;
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x1C45             ADDS     R5,R0,#+1
   1096          	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
   \   0000000A   0x0428             LSLS     R0,R5,#+16
   \   0000000C   0xD022             BEQ.N    ??dir_next_0
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01F             BEQ.N    ??dir_next_0
   1097          		return FR_NO_FILE;
   1098          
   1099          	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
   \   00000014   0xF015 0x0F0F      TST      R5,#0xF
   \   00000018   0xD15B             BNE.N    ??dir_next_1
   1100          		dp->sect++;					/* Next sector */
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x6120             STR      R0,[R4, #+16]
   1101          
   1102          		if (!dp->clust) {		/* Static table */
   \   0000001E   0x68E1             LDR      R1,[R4, #+12]
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD103             BNE.N    ??dir_next_2
   1103          			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
   \   00000026   0x8900             LDRH     R0,[R0, #+8]
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD352             BCC.N    ??dir_next_1
   \   0000002C   0xE012             B.N      ??dir_next_0
   1104          				return FR_NO_FILE;
   1105          		}
   1106          		else {					/* Dynamic table */
   1107          			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_2: (+1)
   \   0000002E   0x7882             LDRB     R2,[R0, #+2]
   \   00000030   0x1E52             SUBS     R2,R2,#+1
   \   00000032   0xEA12 0x1F15      TST      R2,R5, LSR #+4
   \   00000036   0xD14C             BNE.N    ??dir_next_1
   1108          				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
   \   00000038   0x.... 0x....      BL       get_fat
   \   0000003C   0x4606             MOV      R6,R0
   1109          				if (clst <= 1) return FR_INT_ERR;
   \   0000003E   0x2E02             CMP      R6,#+2
   \   00000040   0xD313             BCC.N    ??dir_next_3
   1110          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \   00000042   0xF116 0x0F01      CMN      R6,#+1
   \   00000046   0xD039             BEQ.N    ??dir_next_4
   1111          				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6981             LDR      R1,[R0, #+24]
   \   0000004C   0x428E             CMP      R6,R1
   \   0000004E   0xD33A             BCC.N    ??dir_next_5
   1112          #if !_FS_READONLY
   1113          					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
   \   00000050   0x2F00             CMP      R7,#+0
   \   00000052   0xD101             BNE.N    ??dir_next_6
   \                     ??dir_next_0: (+1)
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}
   1114          					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
   \                     ??dir_next_6: (+1)
   \   00000058   0x68E1             LDR      R1,[R4, #+12]
   \   0000005A   0x.... 0x....      BL       create_chain
   \   0000005E   0x0006             MOVS     R6,R0
   1115          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000060   0xD101             BNE.N    ??dir_next_7
   \   00000062   0x2007             MOVS     R0,#+7
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}
   1116          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_7: (+1)
   \   00000066   0x2E01             CMP      R6,#+1
   \   00000068   0xD101             BNE.N    ??dir_next_8
   \                     ??dir_next_3: (+1)
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}
   1117          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_8: (+1)
   \   0000006E   0xF116 0x0F01      CMN      R6,#+1
   \   00000072   0xD023             BEQ.N    ??dir_next_4
   1118          					/* Clean-up stretched table */
   1119          					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x.... 0x....      BL       sync_window
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD11E             BNE.N    ??dir_next_4
   1120          					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
   \   0000007E   0xF44F 0x7200      MOV      R2,#+512
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x3034             ADDS     R0,R0,#+52
   \   00000088   0x.... 0x....      BL       mem_set
   1121          					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
   \   0000008C   0x4631             MOV      R1,R6
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       clust2sect
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6308             STR      R0,[R1, #+48]
   1122          					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   00000098   0x2700             MOVS     R7,#+0
   \   0000009A   0xE004             B.N      ??dir_next_9
   1123          						dp->fs->wflag = 1;
   1124          						if (sync_window(dp->fs)) return FR_DISK_ERR;
   1125          						dp->fs->winsect++;
   \                     ??dir_next_10: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6B01             LDR      R1,[R0, #+48]
   \   000000A0   0x1C49             ADDS     R1,R1,#+1
   \   000000A2   0x6301             STR      R1,[R0, #+48]
   \   000000A4   0x1C7F             ADDS     R7,R7,#+1
   \                     ??dir_next_9: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x7881             LDRB     R1,[R0, #+2]
   \   000000AA   0x428F             CMP      R7,R1
   \   000000AC   0xD208             BCS.N    ??dir_next_11
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0x7101             STRB     R1,[R0, #+4]
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x.... 0x....      BL       sync_window
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD0EF             BEQ.N    ??dir_next_10
   \                     ??dir_next_4: (+1)
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xBDF2             POP      {R1,R4-R7,PC}
   1126          					}
   1127          					dp->fs->winsect -= c;						/* Rewind window offset */
   \                     ??dir_next_11: (+1)
   \   000000C0   0x6B01             LDR      R1,[R0, #+48]
   \   000000C2   0x1BC9             SUBS     R1,R1,R7
   \   000000C4   0x6301             STR      R1,[R0, #+48]
   1128          #else
   1129          					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
   1130          					return FR_NO_FILE;							/* Report EOT */
   1131          #endif
   1132          				}
   1133          				dp->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_5: (+1)
   \   000000C6   0x60E6             STR      R6,[R4, #+12]
   1134          				dp->sect = clust2sect(dp->fs, clst);
   \   000000C8   0x4631             MOV      R1,R6
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       clust2sect
   \   000000D0   0x6120             STR      R0,[R4, #+16]
   1135          			}
   1136          		}
   1137          	}
   1138          
   1139          	dp->index = (WORD)i;	/* Current index */
   \                     ??dir_next_1: (+1)
   \   000000D2   0x80E5             STRH     R5,[R4, #+6]
   1140          	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x0169             LSLS     R1,R5,#+5
   \   000000D8   0xF401 0x71F0      AND      R1,R1,#0x1E0
   \   000000DC   0x4408             ADD      R0,R0,R1
   \   000000DE   0x3034             ADDS     R0,R0,#+52
   \   000000E0   0x6160             STR      R0,[R4, #+20]
   1141          
   1142          	return FR_OK;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1143          }
   1144          
   1145          
   1146          
   1147          
   1148          /*-----------------------------------------------------------------------*/
   1149          /* Directory handling - Reserve directory entry                          */
   1150          /*-----------------------------------------------------------------------*/
   1151          
   1152          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1153          static
   1154          FRESULT dir_alloc (
   1155          	DIR* dp,	/* Pointer to the directory object */
   1156          	UINT nent	/* Number of contiguous entries to allocate (1-21) */
   1157          )
   1158          {
   \                     dir_alloc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1159          	FRESULT res;
   1160          	UINT n;
   1161          
   1162          
   1163          	res = dir_sdi(dp, 0);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       dir_sdi
   1164          	if (res == FR_OK) {
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0xD117             BNE.N    ??dir_alloc_0
   1165          		n = 0;
   \   00000010   0x2600             MOVS     R6,#+0
   1166          		do {
   1167          			res = move_window(dp->fs, dp->sect);
   \                     ??dir_alloc_1: (+1)
   \   00000012   0x6921             LDR      R1,[R4, #+16]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       move_window
   1168          			if (res != FR_OK) break;
   \   0000001A   0x0001             MOVS     R1,R0
   \   0000001C   0xD110             BNE.N    ??dir_alloc_0
   1169          			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
   \   0000001E   0x6961             LDR      R1,[R4, #+20]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x29E5             CMP      R1,#+229
   \   00000024   0xD001             BEQ.N    ??dir_alloc_2
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD103             BNE.N    ??dir_alloc_3
   1170          				if (++n == nent) break;	/* A block of contiguous free entries is found */
   \                     ??dir_alloc_2: (+1)
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0x42AE             CMP      R6,R5
   \   0000002E   0xD101             BNE.N    ??dir_alloc_4
   \   00000030   0xE006             B.N      ??dir_alloc_0
   1171          			} else {
   1172          				n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_alloc_3: (+1)
   \   00000032   0x2600             MOVS     R6,#+0
   1173          			}
   1174          			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
   \                     ??dir_alloc_4: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       dir_next
   1175          		} while (res == FR_OK);
   \   0000003C   0x0001             MOVS     R1,R0
   \   0000003E   0xD0E8             BEQ.N    ??dir_alloc_1
   1176          	}
   1177          	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
   \                     ??dir_alloc_0: (+1)
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD100             BNE.N    ??dir_alloc_5
   \   00000044   0x2007             MOVS     R0,#+7
   1178          	return res;
   \                     ??dir_alloc_5: (+1)
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
   1179          }
   1180          #endif
   1181          
   1182          
   1183          
   1184          
   1185          /*-----------------------------------------------------------------------*/
   1186          /* Directory handling - Load/Store start cluster number                  */
   1187          /*-----------------------------------------------------------------------*/
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          static
   1190          DWORD ld_clust (
   1191          	FATFS* fs,	/* Pointer to the fs object */
   1192          	BYTE* dir	/* Pointer to the directory entry */
   1193          )
   1194          {
   1195          	DWORD cl;
   1196          
   1197          	cl = LD_WORD(dir + DIR_FstClusLO);
   \                     ld_clust: (+1)
   \   00000000   0x7ECA             LDRB     R2,[R1, #+27]
   \   00000002   0x7E8B             LDRB     R3,[R1, #+26]
   \   00000004   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   1198          	if (fs->fs_type == FS_FAT32)
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD105             BNE.N    ??ld_clust_0
   1199          		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
   \   0000000E   0x7D48             LDRB     R0,[R1, #+21]
   \   00000010   0x7D09             LDRB     R1,[R1, #+20]
   \   00000012   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000016   0xEA42 0x4200      ORR      R2,R2,R0, LSL #+16
   1200          
   1201          	return cl;
   \                     ??ld_clust_0: (+1)
   \   0000001A   0x4610             MOV      R0,R2
   \   0000001C   0x4770             BX       LR               ;; return
   1202          }
   1203          
   1204          
   1205          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1206          static
   1207          void st_clust (
   1208          	BYTE* dir,	/* Pointer to the directory entry */
   1209          	DWORD cl	/* Value to be set */
   1210          )
   1211          {
   1212          	ST_WORD(dir + DIR_FstClusLO, cl);
   \                     st_clust: (+1)
   \   00000000   0x7681             STRB     R1,[R0, #+26]
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0x76C2             STRB     R2,[R0, #+27]
   1213          	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
   \   0000000A   0x0C09             LSRS     R1,R1,#+16
   \   0000000C   0x7501             STRB     R1,[R0, #+20]
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0x7541             STRB     R1,[R0, #+21]
   1214          }
   \   00000012   0x4770             BX       LR               ;; return
   1215          #endif
   1216          
   1217          
   1218          
   1219          
   1220          /*-----------------------------------------------------------------------*/
   1221          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1222          /*-----------------------------------------------------------------------*/
   1223          #if _USE_LFN
   1224          static
   1225          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
   1226          
   1227          
   1228          static
   1229          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1230          	WCHAR* lfnbuf,		/* Pointer to the LFN to be compared */
   1231          	BYTE* dir			/* Pointer to the directory entry containing a part of LFN */
   1232          )
   1233          {
   1234          	UINT i, s;
   1235          	WCHAR wc, uc;
   1236          
   1237          
   1238          	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
   1239          	s = 0; wc = 1;
   1240          	do {
   1241          		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
   1242          		if (wc) {	/* Last character has not been processed */
   1243          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   1244          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1245          				return 0;				/* Not matched */
   1246          		} else {
   1247          			if (uc != 0xFFFF) return 0;	/* Check filler */
   1248          		}
   1249          	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
   1250          
   1251          	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
   1252          		return 0;
   1253          
   1254          	return 1;						/* The part of LFN matched */
   1255          }
   1256          
   1257          
   1258          
   1259          static
   1260          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1261          	WCHAR* lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1262          	BYTE* dir			/* Pointer to the directory entry */
   1263          )
   1264          {
   1265          	UINT i, s;
   1266          	WCHAR wc, uc;
   1267          
   1268          
   1269          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1270          
   1271          	s = 0; wc = 1;
   1272          	do {
   1273          		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character from the entry */
   1274          		if (wc) {	/* Last character has not been processed */
   1275          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   1276          			lfnbuf[i++] = wc = uc;			/* Store it */
   1277          		} else {
   1278          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1279          		}
   1280          	} while (++s < 13);						/* Read all character in the entry */
   1281          
   1282          	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
   1283          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   1284          		lfnbuf[i] = 0;
   1285          	}
   1286          
   1287          	return 1;
   1288          }
   1289          
   1290          
   1291          #if !_FS_READONLY
   1292          static
   1293          void fit_lfn (
   1294          	const WCHAR* lfnbuf,	/* Pointer to the LFN buffer */
   1295          	BYTE* dir,				/* Pointer to the directory entry */
   1296          	BYTE ord,				/* LFN order (1-20) */
   1297          	BYTE sum				/* SFN sum */
   1298          )
   1299          {
   1300          	UINT i, s;
   1301          	WCHAR wc;
   1302          
   1303          
   1304          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   1305          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1306          	dir[LDIR_Type] = 0;
   1307          	ST_WORD(dir + LDIR_FstClusLO, 0);
   1308          
   1309          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   1310          	s = wc = 0;
   1311          	do {
   1312          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
   1313          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   1314          		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
   1315          	} while (++s < 13);
   1316          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
   1317          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1318          }
   1319          
   1320          #endif
   1321          #endif
   1322          
   1323          
   1324          
   1325          
   1326          /*-----------------------------------------------------------------------*/
   1327          /* Create numbered name                                                  */
   1328          /*-----------------------------------------------------------------------*/
   1329          #if _USE_LFN
   1330          static
   1331          void gen_numname (
   1332          	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
   1333          	const BYTE* src,	/* Pointer to SFN */
   1334          	const WCHAR* lfn,	/* Pointer to LFN */
   1335          	UINT seq			/* Sequence number */
   1336          )
   1337          {
   1338          	BYTE ns[8], c;
   1339          	UINT i, j;
   1340          	WCHAR wc;
   1341          	DWORD sr;
   1342          
   1343          
   1344          	mem_cpy(dst, src, 11);
   1345          
   1346          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   1347          		sr = seq;
   1348          		while (*lfn) {	/* Create a CRC */
   1349          			wc = *lfn++;
   1350          			for (i = 0; i < 16; i++) {
   1351          				sr = (sr << 1) + (wc & 1);
   1352          				wc >>= 1;
   1353          				if (sr & 0x10000) sr ^= 0x11021;
   1354          			}
   1355          		}
   1356          		seq = (UINT)sr;
   1357          	}
   1358          
   1359          	/* itoa (hexdecimal) */
   1360          	i = 7;
   1361          	do {
   1362          		c = (seq % 16) + '0';
   1363          		if (c > '9') c += 7;
   1364          		ns[i--] = c;
   1365          		seq /= 16;
   1366          	} while (seq);
   1367          	ns[i] = '~';
   1368          
   1369          	/* Append the number */
   1370          	for (j = 0; j < i && dst[j] != ' '; j++) {
   1371          		if (IsDBCS1(dst[j])) {
   1372          			if (j == i - 1) break;
   1373          			j++;
   1374          		}
   1375          	}
   1376          	do {
   1377          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   1378          	} while (j < 8);
   1379          }
   1380          #endif
   1381          
   1382          
   1383          
   1384          
   1385          /*-----------------------------------------------------------------------*/
   1386          /* Calculate sum of an SFN                                               */
   1387          /*-----------------------------------------------------------------------*/
   1388          #if _USE_LFN
   1389          static
   1390          BYTE sum_sfn (
   1391          	const BYTE* dir		/* Pointer to the SFN entry */
   1392          )
   1393          {
   1394          	BYTE sum = 0;
   1395          	UINT n = 11;
   1396          
   1397          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1398          	return sum;
   1399          }
   1400          #endif
   1401          
   1402          
   1403          
   1404          
   1405          /*-----------------------------------------------------------------------*/
   1406          /* Directory handling - Find an object in the directory                  */
   1407          /*-----------------------------------------------------------------------*/
   1408          

   \                                 In section .text, align 2, keep-with-next
   1409          static
   1410          FRESULT dir_find (
   1411          	DIR* dp			/* Pointer to the directory object linked to the file name */
   1412          )
   1413          {
   \                     dir_find: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1414          	FRESULT res;
   1415          	BYTE c, *dir;
   1416          #if _USE_LFN
   1417          	BYTE a, ord, sum;
   1418          #endif
   1419          
   1420          	res = dir_sdi(dp, 0);			/* Rewind directory object */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       dir_sdi
   \   0000000A   0x0005             MOVS     R5,R0
   1421          	if (res != FR_OK) return res;
   \   0000000C   0xD11A             BNE.N    ??dir_find_0
   1422          
   1423          #if _USE_LFN
   1424          	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1425          #endif
   1426          	do {
   1427          		res = move_window(dp->fs, dp->sect);
   \                     ??dir_find_1: (+1)
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       move_window
   \   00000016   0x0005             MOVS     R5,R0
   1428          		if (res != FR_OK) break;
   \   00000018   0xD114             BNE.N    ??dir_find_0
   1429          		dir = dp->dir;					/* Ptr to the directory entry of current index */
   \   0000001A   0x6960             LDR      R0,[R4, #+20]
   1430          		c = dir[DIR_Name];
   1431          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD101             BNE.N    ??dir_find_2
   \   00000022   0x2504             MOVS     R5,#+4
   \   00000024   0xE00E             B.N      ??dir_find_0
   1432          #if _USE_LFN	/* LFN configuration */
   1433          		a = dir[DIR_Attr] & AM_MASK;
   1434          		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   1435          			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1436          		} else {
   1437          			if (a == AM_LFN) {			/* An LFN entry is found */
   1438          				if (dp->lfn) {
   1439          					if (c & LLEF) {		/* Is it start of LFN sequence? */
   1440          						sum = dir[LDIR_Chksum];
   1441          						c &= ~LLEF; ord = c;	/* LFN start order */
   1442          						dp->lfn_idx = dp->index;	/* Start index of LFN */
   1443          					}
   1444          					/* Check validity of the LFN entry and compare it with given name */
   1445          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   1446          				}
   1447          			} else {					/* An SFN entry is found */
   1448          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1449          				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
   1450          				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1451          			}
   1452          		}
   1453          #else		/* Non LFN configuration */
   1454          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
   \                     ??dir_find_2: (+1)
   \   00000026   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000028   0x0709             LSLS     R1,R1,#+28
   \   0000002A   0xD405             BMI.N    ??dir_find_3
   \   0000002C   0x220B             MOVS     R2,#+11
   \   0000002E   0x69A1             LDR      R1,[R4, #+24]
   \   00000030   0x.... 0x....      BL       mem_cmp
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ.N    ??dir_find_0
   1455          			break;
   1456          #endif
   1457          		res = dir_next(dp, 0);		/* Next entry */
   \                     ??dir_find_3: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       dir_next
   \   00000040   0x0005             MOVS     R5,R0
   1458          	} while (res == FR_OK);
   \   00000042   0xD0E4             BEQ.N    ??dir_find_1
   1459          
   1460          	return res;
   \                     ??dir_find_0: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1461          }
   1462          
   1463          
   1464          
   1465          
   1466          /*-----------------------------------------------------------------------*/
   1467          /* Read an object from the directory                                     */
   1468          /*-----------------------------------------------------------------------*/
   1469          #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1470          static
   1471          FRESULT dir_read (
   1472          	DIR* dp,		/* Pointer to the directory object */
   1473          	int vol			/* Filtered by 0:file/directory or 1:volume label */
   1474          )
   1475          {
   \                     dir_read: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1476          	FRESULT res;
   1477          	BYTE a, c, *dir;
   1478          #if _USE_LFN
   1479          	BYTE ord = 0xFF, sum = 0xFF;
   1480          #endif
   1481          
   1482          	res = FR_NO_FILE;
   \   00000006   0x2004             MOVS     R0,#+4
   1483          	while (dp->sect) {
   \                     ??dir_read_0: (+1)
   \   00000008   0x6921             LDR      R1,[R4, #+16]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD021             BEQ.N    ??dir_read_1
   1484          		res = move_window(dp->fs, dp->sect);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       move_window
   1485          		if (res != FR_OK) break;
   \   00000014   0x0001             MOVS     R1,R0
   \   00000016   0xD11C             BNE.N    ??dir_read_1
   1486          		dir = dp->dir;					/* Ptr to the directory entry of current index */
   \   00000018   0x6961             LDR      R1,[R4, #+20]
   1487          		c = dir[DIR_Name];
   \   0000001A   0x780A             LDRB     R2,[R1, #+0]
   1488          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD101             BNE.N    ??dir_read_2
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xE016             B.N      ??dir_read_1
   1489          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_2: (+1)
   \   00000024   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000026   0xF001 0x013F      AND      R1,R1,#0x3F
   1490          #if _USE_LFN	/* LFN configuration */
   1491          		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   1492          			ord = 0xFF;
   1493          		} else {
   1494          			if (a == AM_LFN) {			/* An LFN entry is found */
   1495          				if (c & LLEF) {			/* Is it start of LFN sequence? */
   1496          					sum = dir[LDIR_Chksum];
   1497          					c &= ~LLEF; ord = c;
   1498          					dp->lfn_idx = dp->index;
   1499          				}
   1500          				/* Check LFN validity and capture it */
   1501          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   1502          			} else {					/* An SFN entry is found */
   1503          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1504          					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1505          				break;
   1506          			}
   1507          		}
   1508          #else		/* Non LFN configuration */
   1509          		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
   \   0000002A   0x2AE5             CMP      R2,#+229
   \   0000002C   0xD00B             BEQ.N    ??dir_read_3
   \   0000002E   0x290F             CMP      R1,#+15
   \   00000030   0xD009             BEQ.N    ??dir_read_3
   \   00000032   0xF06F 0x0220      MVN      R2,#+32
   \   00000036   0x4011             ANDS     R1,R2,R1
   \   00000038   0x2908             CMP      R1,#+8
   \   0000003A   0xD101             BNE.N    ??dir_read_4
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xE000             B.N      ??dir_read_5
   \                     ??dir_read_4: (+1)
   \   00000040   0x2100             MOVS     R1,#+0
   \                     ??dir_read_5: (+1)
   \   00000042   0x42A9             CMP      R1,R5
   \   00000044   0xD005             BEQ.N    ??dir_read_1
   1510          			break;
   1511          #endif
   1512          		res = dir_next(dp, 0);				/* Next entry */
   \                     ??dir_read_3: (+1)
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   1513          		if (res != FR_OK) break;
   \   0000004E   0x0001             MOVS     R1,R0
   \   00000050   0xD0DA             BEQ.N    ??dir_read_0
   1514          	}
   1515          
   1516          	if (res != FR_OK) dp->sect = 0;
   \                     ??dir_read_1: (+1)
   \   00000052   0x0001             MOVS     R1,R0
   \   00000054   0xD001             BEQ.N    ??dir_read_6
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6121             STR      R1,[R4, #+16]
   1517          
   1518          	return res;
   \                     ??dir_read_6: (+1)
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1519          }
   1520          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   1521          
   1522          
   1523          
   1524          
   1525          /*-----------------------------------------------------------------------*/
   1526          /* Register an object to the directory                                   */
   1527          /*-----------------------------------------------------------------------*/
   1528          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1529          static
   1530          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1531          	DIR* dp				/* Target directory with object name to be created */
   1532          )
   1533          {
   \                     dir_register: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1534          	FRESULT res;
   1535          #if _USE_LFN	/* LFN configuration */
   1536          	UINT n, nent;
   1537          	BYTE sn[12], *fn, sum;
   1538          	WCHAR *lfn;
   1539          
   1540          
   1541          	fn = dp->fn; lfn = dp->lfn;
   1542          	mem_cpy(sn, fn, 12);
   1543          
   1544          	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
   1545          		return FR_INVALID_NAME;
   1546          
   1547          	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   1548          		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
   1549          		for (n = 1; n < 100; n++) {
   1550          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   1551          			res = dir_find(dp);				/* Check if the name collides with existing SFN */
   1552          			if (res != FR_OK) break;
   1553          		}
   1554          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   1555          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   1556          		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
   1557          	}
   1558          
   1559          	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
   1560          		for (n = 0; lfn[n]; n++) ;
   1561          		nent = (n + 25) / 13;
   1562          	} else {						/* Otherwise allocate an entry for an SFN  */
   1563          		nent = 1;
   1564          	}
   1565          	res = dir_alloc(dp, nent);		/* Allocate entries */
   1566          
   1567          	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
   1568          		res = dir_sdi(dp, dp->index - nent);
   1569          		if (res == FR_OK) {
   1570          			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
   1571          			do {					/* Store LFN entries in bottom first */
   1572          				res = move_window(dp->fs, dp->sect);
   1573          				if (res != FR_OK) break;
   1574          				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
   1575          				dp->fs->wflag = 1;
   1576          				res = dir_next(dp, 0);	/* Next entry */
   1577          			} while (res == FR_OK && --nent);
   1578          		}
   1579          	}
   1580          #else	/* Non LFN configuration */
   1581          	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x.... 0x....      BL       dir_alloc
   \   0000000A   0x0005             MOVS     R5,R0
   1582          #endif
   1583          
   1584          	if (res == FR_OK) {				/* Set SFN entry */
   \   0000000C   0xD112             BNE.N    ??dir_register_0
   1585          		res = move_window(dp->fs, dp->sect);
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       move_window
   \   00000016   0x0005             MOVS     R5,R0
   1586          		if (res == FR_OK) {
   \   00000018   0xD10C             BNE.N    ??dir_register_0
   1587          			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
   \   0000001A   0x2220             MOVS     R2,#+32
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0x.... 0x....      BL       mem_set
   1588          			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
   \   00000024   0x220B             MOVS     R2,#+11
   \   00000026   0x69A1             LDR      R1,[R4, #+24]
   \   00000028   0x6960             LDR      R0,[R4, #+20]
   \   0000002A   0x.... 0x....      BL       mem_cpy
   1589          #if _USE_LFN
   1590          			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   1591          #endif
   1592          			dp->fs->wflag = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x7108             STRB     R0,[R1, #+4]
   1593          		}
   1594          	}
   1595          
   1596          	return res;
   \                     ??dir_register_0: (+1)
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1597          }
   1598          #endif /* !_FS_READONLY */
   1599          
   1600          
   1601          
   1602          
   1603          /*-----------------------------------------------------------------------*/
   1604          /* Remove an object from the directory                                   */
   1605          /*-----------------------------------------------------------------------*/
   1606          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1607          static
   1608          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1609          	DIR* dp				/* Directory object pointing the entry to be removed */
   1610          )
   1611          {
   \                     dir_remove: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1612          	FRESULT res;
   1613          #if _USE_LFN	/* LFN configuration */
   1614          	UINT i;
   1615          
   1616          	i = dp->index;	/* SFN index */
   1617          	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
   1618          	if (res == FR_OK) {
   1619          		do {
   1620          			res = move_window(dp->fs, dp->sect);
   1621          			if (res != FR_OK) break;
   1622          			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
   1623          			*dp->dir = DDEM;
   1624          			dp->fs->wflag = 1;
   1625          			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   1626          			res = dir_next(dp, 0);		/* Next entry */
   1627          		} while (res == FR_OK);
   1628          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   1629          	}
   1630          
   1631          #else			/* Non LFN configuration */
   1632          	res = dir_sdi(dp, dp->index);
   \   00000004   0x88E1             LDRH     R1,[R4, #+6]
   \   00000006   0x.... 0x....      BL       dir_sdi
   \   0000000A   0x0005             MOVS     R5,R0
   1633          	if (res == FR_OK) {
   \   0000000C   0xD110             BNE.N    ??dir_remove_0
   1634          		res = move_window(dp->fs, dp->sect);
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       move_window
   \   00000016   0x0005             MOVS     R5,R0
   1635          		if (res == FR_OK) {
   \   00000018   0xD10A             BNE.N    ??dir_remove_0
   1636          			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
   \   0000001A   0x2220             MOVS     R2,#+32
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0x.... 0x....      BL       mem_set
   1637          			*dp->dir = DDEM;
   \   00000024   0x20E5             MOVS     R0,#+229
   \   00000026   0x6961             LDR      R1,[R4, #+20]
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   1638          			dp->fs->wflag = 1;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x7108             STRB     R0,[R1, #+4]
   1639          		}
   1640          	}
   1641          #endif
   1642          
   1643          	return res;
   \                     ??dir_remove_0: (+1)
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1644          }
   1645          #endif /* !_FS_READONLY */
   1646          
   1647          
   1648          
   1649          
   1650          /*-----------------------------------------------------------------------*/
   1651          /* Get file information from directory entry                             */
   1652          /*-----------------------------------------------------------------------*/
   1653          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1654          static
   1655          void get_fileinfo (		/* No return code */
   1656          	DIR* dp,			/* Pointer to the directory object */
   1657          	FILINFO* fno	 	/* Pointer to the file information to be filled */
   1658          )
   1659          {
   \                     get_fileinfo: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1660          	UINT i;
   1661          	TCHAR *p, c;
   1662          	BYTE *dir;
   1663          #if _USE_LFN
   1664          	WCHAR w, *lfn;
   1665          #endif
   1666          
   1667          	p = fno->fname;
   \   00000002   0xF101 0x0209      ADD      R2,R1,#+9
   1668          	if (dp->sect) {		/* Get SFN */
   \   00000006   0x6903             LDR      R3,[R0, #+16]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD02A             BEQ.N    ??get_fileinfo_0
   1669          		dir = dp->dir;
   \   0000000C   0x6940             LDR      R0,[R0, #+20]
   1670          		i = 0;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0xE00E             B.N      ??get_fileinfo_1
   1671          		while (i < 11) {		/* Copy name body and extension */
   1672          			c = (TCHAR)dir[i++];
   \                     ??get_fileinfo_2: (+1)
   \   00000012   0x5CC4             LDRB     R4,[R0, R3]
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   1673          			if (c == ' ') continue;				/* Skip padding spaces */
   \   00000016   0x4625             MOV      R5,R4
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD009             BEQ.N    ??get_fileinfo_1
   1674          			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
   \   0000001C   0x2D05             CMP      R5,#+5
   \   0000001E   0xD100             BNE.N    ??get_fileinfo_3
   \   00000020   0x24E5             MOVS     R4,#+229
   1675          			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
   \                     ??get_fileinfo_3: (+1)
   \   00000022   0x2B09             CMP      R3,#+9
   \   00000024   0xD102             BNE.N    ??get_fileinfo_4
   \   00000026   0x252E             MOVS     R5,#+46
   \   00000028   0xF802 0x5B01      STRB     R5,[R2], #+1
   1676          #if _USE_LFN
   1677          			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
   1678          				c += 0x20;			/* To lower */
   1679          #if _LFN_UNICODE
   1680          			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
   1681          				c = c << 8 | dir[i++];
   1682          			c = ff_convert(c, 1);	/* OEM -> Unicode */
   1683          			if (!c) c = '?';
   1684          #endif
   1685          #endif
   1686          			*p++ = c;
   \                     ??get_fileinfo_4: (+1)
   \   0000002C   0xF802 0x4B01      STRB     R4,[R2], #+1
   1687          		}
   \                     ??get_fileinfo_1: (+1)
   \   00000030   0x2B0B             CMP      R3,#+11
   \   00000032   0xD3EE             BCC.N    ??get_fileinfo_2
   1688          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \   00000034   0x7AC3             LDRB     R3,[R0, #+11]
   \   00000036   0x720B             STRB     R3,[R1, #+8]
   1689          		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
   \   00000038   0x7FC3             LDRB     R3,[R0, #+31]
   \   0000003A   0x7F84             LDRB     R4,[R0, #+30]
   \   0000003C   0x0424             LSLS     R4,R4,#+16
   \   0000003E   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   00000042   0x7F44             LDRB     R4,[R0, #+29]
   \   00000044   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000048   0x7F04             LDRB     R4,[R0, #+28]
   \   0000004A   0x4323             ORRS     R3,R4,R3
   \   0000004C   0x600B             STR      R3,[R1, #+0]
   1690          		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
   \   0000004E   0x7E43             LDRB     R3,[R0, #+25]
   \   00000050   0x7E04             LDRB     R4,[R0, #+24]
   \   00000052   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   00000056   0x808B             STRH     R3,[R1, #+4]
   1691          		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
   \   00000058   0x7DC3             LDRB     R3,[R0, #+23]
   \   0000005A   0x7D80             LDRB     R0,[R0, #+22]
   \   0000005C   0xEA40 0x2003      ORR      R0,R0,R3, LSL #+8
   \   00000060   0x80C8             STRH     R0,[R1, #+6]
   1692          	}
   1693          	*p = 0;		/* Terminate SFN string by a \0 */
   \                     ??get_fileinfo_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7010             STRB     R0,[R2, #+0]
   1694          
   1695          #if _USE_LFN
   1696          	if (fno->lfname) {
   1697          		i = 0; p = fno->lfname;
   1698          		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
   1699          			lfn = dp->lfn;
   1700          			while ((w = *lfn++) != 0) {		/* Get an LFN character */
   1701          #if !_LFN_UNICODE
   1702          				w = ff_convert(w, 0);		/* Unicode -> OEM */
   1703          				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
   1704          				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1705          					p[i++] = (TCHAR)(w >> 8);
   1706          #endif
   1707          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
   1708          				p[i++] = (TCHAR)w;
   1709          			}
   1710          		}
   1711          		p[i] = 0;	/* Terminate LFN string by a \0 */
   1712          	}
   1713          #endif
   1714          }
   \   00000066   0xBC30             POP      {R4,R5}
   \   00000068   0x4770             BX       LR               ;; return
   1715          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
   1716          
   1717          
   1718          
   1719          
   1720          /*-----------------------------------------------------------------------*/
   1721          /* Pattern matching                                                      */
   1722          /*-----------------------------------------------------------------------*/
   1723          #if _USE_FIND && _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1724          static
   1725          WCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
   1726          	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
   1727          )
   1728          {
   1729          	WCHAR chr;
   1730          
   1731          #if !_LFN_UNICODE
   1732          	chr = (BYTE)*(*ptr)++;					/* Get a byte */
   \                     get_achar: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6002             STR      R2,[R0, #+0]
   \   00000006   0x7808             LDRB     R0,[R1, #+0]
   1733          	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
   \   00000008   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   0000000C   0x291A             CMP      R1,#+26
   \   0000000E   0xD201             BCS.N    ??get_achar_0
   \   00000010   0x3820             SUBS     R0,R0,#+32
   \   00000012   0xB280             UXTH     R0,R0
   1734          	if (IsDBCS1(chr) && IsDBCS2(**ptr))		/* Get DBC 2nd byte if needed */
   1735          		chr = chr << 8 | (BYTE)*(*ptr)++;
   1736          #ifdef _EXCVT
   1737          	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
   \                     ??get_achar_0: (+1)
   \   00000014   0x2880             CMP      R0,#+128
   \   00000016   0xDB04             BLT.N    ??get_achar_1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000001C   0x4408             ADD      R0,R1,R0
   \   0000001E   0xF810 0x0C80      LDRB     R0,[R0, #-128]
   1738          #endif
   1739          #else
   1740          	chr = ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
   1741          #endif
   1742          	return chr;
   \                     ??get_achar_1: (+1)
   \   00000022   0x4770             BX       LR               ;; return
   1743          }
   1744          
   1745          

   \                                 In section .text, align 2, keep-with-next
   1746          static
   1747          int pattern_matching (	/* Return value: 0:mismatched, 1:matched */
   1748          	const TCHAR* pat,	/* Matching pattern */
   1749          	const TCHAR* nam,	/* String to be tested */
   1750          	int skip,			/* Number of pre-skip chars (number of ?s) */
   1751          	int inf				/* Infinite search (* specified) */
   1752          )
   1753          {
   \                     pattern_matching: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461D             MOV      R5,R3
   1754          	const TCHAR *pp, *np;
   1755          	WCHAR pc, nc;
   1756          	int nm, nx;
   1757          
   1758          
   1759          	while (skip--) {				/* Pre-skip name chars */
   \                     ??pattern_matching_0: (+1)
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x1E46             SUBS     R6,R0,#+1
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??pattern_matching_1
   1760          		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
   \   00000012   0xA802             ADD      R0,SP,#+8
   \   00000014   0x.... 0x....      BL       get_achar
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F6             BNE.N    ??pattern_matching_0
   \   0000001C   0xE02E             B.N      ??pattern_matching_2
   1761          	}
   1762          	if (!*pat && inf) return 1;		/* (short circuit) */
   \                     ??pattern_matching_1: (+1)
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE.N    ??pattern_matching_3
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD137             BNE.N    ??pattern_matching_4
   1763          
   1764          	do {
   1765          		pp = pat; np = nam;			/* Top of pattern and name to match */
   \                     ??pattern_matching_3: (+1)
   \   00000028   0x9400             STR      R4,[SP, #+0]
   \   0000002A   0x9802             LDR      R0,[SP, #+8]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   1766          		for (;;) {
   1767          			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
   \                     ??pattern_matching_5: (+1)
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x283F             CMP      R0,#+63
   \   00000034   0xD001             BEQ.N    ??pattern_matching_6
   \   00000036   0x282A             CMP      R0,#+42
   \   00000038   0xD122             BNE.N    ??pattern_matching_7
   1768          				nm = nx = 0;
   \                     ??pattern_matching_6: (+1)
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x461A             MOV      R2,R3
   1769          				do {				/* Analyze the wildcard chars */
   1770          					if (*pp++ == '?') nm++; else nx = 1;
   \                     ??pattern_matching_8: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x283F             CMP      R0,#+63
   \   0000004A   0xD101             BNE.N    ??pattern_matching_9
   \   0000004C   0x1C52             ADDS     R2,R2,#+1
   \   0000004E   0xE000             B.N      ??pattern_matching_10
   \                     ??pattern_matching_9: (+1)
   \   00000050   0x2301             MOVS     R3,#+1
   1771          				} while (*pp == '?' || *pp == '*');
   \                     ??pattern_matching_10: (+1)
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x283F             CMP      R0,#+63
   \   00000058   0xD0F1             BEQ.N    ??pattern_matching_8
   \   0000005A   0x282A             CMP      R0,#+42
   \   0000005C   0xD0EF             BEQ.N    ??pattern_matching_8
   1772          				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
   \   0000005E   0x9901             LDR      R1,[SP, #+4]
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0xF7FF 0xFFCD      BL       pattern_matching
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD116             BNE.N    ??pattern_matching_4
   1773          				nc = *np; break;	/* Branch mismatched */
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x7806             LDRB     R6,[R0, #+0]
   1774          			}
   1775          			pc = get_achar(&pp);	/* Get a pattern char */
   1776          			nc = get_achar(&np);	/* Get a name char */
   1777          			if (pc != nc) break;	/* Branch mismatched? */
   1778          			if (!pc) return 1;		/* Branch matched? (matched at end of both strings) */
   1779          		}
   1780          		get_achar(&nam);			/* nam++ */
   \                     ??pattern_matching_11: (+1)
   \   0000006E   0xA802             ADD      R0,SP,#+8
   \   00000070   0x.... 0x....      BL       get_achar
   1781          	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD001             BEQ.N    ??pattern_matching_2
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD1D5             BNE.N    ??pattern_matching_3
   1782          
   1783          	return 0;
   \                     ??pattern_matching_2: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??pattern_matching_7: (+1)
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x.... 0x....      BL       get_achar
   \   00000086   0x4607             MOV      R7,R0
   \   00000088   0xA801             ADD      R0,SP,#+4
   \   0000008A   0x.... 0x....      BL       get_achar
   \   0000008E   0x4606             MOV      R6,R0
   \   00000090   0x42B7             CMP      R7,R6
   \   00000092   0xD1EC             BNE.N    ??pattern_matching_11
   \   00000094   0x2F00             CMP      R7,#+0
   \   00000096   0xD1CA             BNE.N    ??pattern_matching_5
   \                     ??pattern_matching_4: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xBDFE             POP      {R1-R7,PC}
   1784          }
   1785          #endif /* _USE_FIND && _FS_MINIMIZE <= 1 */
   1786          
   1787          
   1788          
   1789          
   1790          /*-----------------------------------------------------------------------*/
   1791          /* Pick a segment and create the object name in directory form           */
   1792          /*-----------------------------------------------------------------------*/
   1793          

   \                                 In section .text, align 2, keep-with-next
   1794          static
   1795          FRESULT create_name (
   1796          	DIR* dp,			/* Pointer to the directory object */
   1797          	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
   1798          )
   1799          {
   \                     create_name: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x460C             MOV      R4,R1
   1800          #if _USE_LFN	/* LFN configuration */
   1801          	BYTE b, cf;
   1802          	WCHAR w, *lfn;
   1803          	UINT i, ni, si, di;
   1804          	const TCHAR *p;
   1805          
   1806          	/* Create LFN in Unicode */
   1807          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1808          	lfn = dp->lfn;
   1809          	si = di = 0;
   1810          	for (;;) {
   1811          		w = p[si++];					/* Get a character */
   1812          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1813          		if (di >= _MAX_LFN)				/* Reject too long name */
   1814          			return FR_INVALID_NAME;
   1815          #if !_LFN_UNICODE
   1816          		w &= 0xFF;
   1817          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1818          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1819          			w = (w << 8) + b;			/* Create a DBC */
   1820          			if (!IsDBCS2(b))
   1821          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1822          		}
   1823          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1824          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1825          #endif
   1826          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
   1827          			return FR_INVALID_NAME;
   1828          		lfn[di++] = w;					/* Store the Unicode character */
   1829          	}
   1830          	*path = &p[si];						/* Return pointer to the next segment */
   1831          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1832          #if _FS_RPATH
   1833          	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
   1834          		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
   1835          		lfn[di] = 0;
   1836          		for (i = 0; i < 11; i++)
   1837          			dp->fn[i] = (i < di) ? '.' : ' ';
   1838          		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   1839          		return FR_OK;
   1840          	}
   1841          #endif
   1842          	while (di) {						/* Strip trailing spaces and dots */
   1843          		w = lfn[di - 1];
   1844          		if (w != ' ' && w != '.') break;
   1845          		di--;
   1846          	}
   1847          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   1848          
   1849          	lfn[di] = 0;						/* LFN is created */
   1850          
   1851          	/* Create SFN in directory form */
   1852          	mem_set(dp->fn, ' ', 11);
   1853          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   1854          	if (si) cf |= NS_LOSS | NS_LFN;
   1855          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   1856          
   1857          	b = i = 0; ni = 8;
   1858          	for (;;) {
   1859          		w = lfn[si++];					/* Get an LFN character */
   1860          		if (!w) break;					/* Break on end of the LFN */
   1861          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1862          			cf |= NS_LOSS | NS_LFN; continue;
   1863          		}
   1864          
   1865          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1866          			if (ni == 11) {				/* Long extension */
   1867          				cf |= NS_LOSS | NS_LFN; break;
   1868          			}
   1869          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1870          			if (si > di) break;			/* No extension */
   1871          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1872          			b <<= 2; continue;
   1873          		}
   1874          
   1875          		if (w >= 0x80) {				/* Non ASCII character */
   1876          #ifdef _EXCVT
   1877          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1878          			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
   1879          #else
   1880          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1881          #endif
   1882          			cf |= NS_LFN;				/* Force create LFN entry */
   1883          		}
   1884          
   1885          		if (_DF1S && w >= 0x100) {		/* DBC (always false at SBCS cfg) */
   1886          			if (i >= ni - 1) {
   1887          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1888          			}
   1889          			dp->fn[i++] = (BYTE)(w >> 8);
   1890          		} else {						/* SBC */
   1891          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
   1892          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1893          			} else {
   1894          				if (IsUpper(w)) {		/* ASCII large capital */
   1895          					b |= 2;
   1896          				} else {
   1897          					if (IsLower(w)) {	/* ASCII small capital */
   1898          						b |= 1; w -= 0x20;
   1899          					}
   1900          				}
   1901          			}
   1902          		}
   1903          		dp->fn[i++] = (BYTE)w;
   1904          	}
   1905          
   1906          	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
   1907          
   1908          	if (ni == 8) b <<= 2;
   1909          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   1910          		cf |= NS_LFN;
   1911          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
   1912          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   1913          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   1914          	}
   1915          
   1916          	dp->fn[NSFLAG] = cf;	/* SFN is created */
   1917          
   1918          	return FR_OK;
   1919          
   1920          
   1921          #else	/* Non-LFN configuration */
   1922          	BYTE b, c, d, *sfn;
   1923          	UINT ni, si, i;
   1924          	const char *p;
   1925          
   1926          	/* Create file name in directory form */
   1927          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000006   0x6825             LDR      R5,[R4, #+0]
   \   00000008   0xE000             B.N      ??create_name_0
   \                     ??create_name_1: (+1)
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_0: (+1)
   \   0000000C   0x7829             LDRB     R1,[R5, #+0]
   \   0000000E   0x292F             CMP      R1,#+47
   \   00000010   0xD0FB             BEQ.N    ??create_name_1
   \   00000012   0x295C             CMP      R1,#+92
   \   00000014   0xD0F9             BEQ.N    ??create_name_1
   1928          	sfn = dp->fn;
   \   00000016   0x6986             LDR      R6,[R0, #+24]
   1929          	mem_set(sfn, ' ', 11);
   \   00000018   0x220B             MOVS     R2,#+11
   \   0000001A   0x2120             MOVS     R1,#+32
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       mem_set
   1930          	si = i = b = 0; ni = 8;
   \   00000022   0x2700             MOVS     R7,#+0
   \   00000024   0x46B8             MOV      R8,R7
   \   00000026   0x46B9             MOV      R9,R7
   \   00000028   0xF04F 0x0A08      MOV      R10,#+8
   1931          #if _FS_RPATH
   1932          	if (p[si] == '.') { /* Is this a dot entry? */
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x282E             CMP      R0,#+46
   \   00000030   0xD12F             BNE.N    ??create_name_2
   \   00000032   0xE003             B.N      ??create_name_3
   1933          		for (;;) {
   1934          			c = (BYTE)p[si++];
   1935          			if (c != '.' || si >= 3) break;
   1936          			sfn[i++] = c;
   \                     ??create_name_4: (+1)
   \   00000034   0xF806 0xB008      STRB     R11,[R6, R8]
   \   00000038   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??create_name_3: (+1)
   \   0000003C   0xF815 0xB009      LDRB     R11,[R5, R9]
   \   00000040   0xF109 0x0901      ADD      R9,R9,#+1
   \   00000044   0xF1BB 0x0F2E      CMP      R11,#+46
   \   00000048   0xD102             BNE.N    ??create_name_5
   \   0000004A   0xF1B9 0x0F03      CMP      R9,#+3
   \   0000004E   0xD3F1             BCC.N    ??create_name_4
   1937          		}
   1938          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   \                     ??create_name_5: (+1)
   \   00000050   0xF1BB 0x0F2F      CMP      R11,#+47
   \   00000054   0xD005             BEQ.N    ??create_name_6
   \   00000056   0xF1BB 0x0F5C      CMP      R11,#+92
   \   0000005A   0xD002             BEQ.N    ??create_name_6
   \   0000005C   0xF1BB 0x0F21      CMP      R11,#+33
   \   00000060   0xDA60             BGE.N    ??create_name_7
   1939          		*path = &p[si];									/* Return pointer to the next segment */
   \                     ??create_name_6: (+1)
   \   00000062   0xEB05 0x0009      ADD      R0,R5,R9
   \   00000066   0x6020             STR      R0,[R4, #+0]
   1940          		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   \   00000068   0xF1BB 0x0F21      CMP      R11,#+33
   \   0000006C   0xDA01             BGE.N    ??create_name_8
   \   0000006E   0x2024             MOVS     R0,#+36
   \   00000070   0xE000             B.N      ??create_name_9
   \                     ??create_name_8: (+1)
   \   00000072   0x2020             MOVS     R0,#+32
   \                     ??create_name_9: (+1)
   \   00000074   0x72F0             STRB     R0,[R6, #+11]
   1941          		return FR_OK;
   \   00000076   0x4638             MOV      R0,R7
   \   00000078   0xE06F             B.N      ??create_name_10
   1942          	}
   1943          #endif
   1944          	for (;;) {
   1945          		c = (BYTE)p[si++];
   1946          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1947          		if (c == '.' || i >= ni) {
   1948          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   \                     ??create_name_11: (+1)
   \   0000007A   0xF1BA 0x0F08      CMP      R10,#+8
   \   0000007E   0xD151             BNE.N    ??create_name_7
   \   00000080   0xF1BB 0x0F2E      CMP      R11,#+46
   \   00000084   0xD14E             BNE.N    ??create_name_7
   1949          			i = 8; ni = 11;
   \   00000086   0xF04F 0x0808      MOV      R8,#+8
   \   0000008A   0xF04F 0x0A0B      MOV      R10,#+11
   1950          			b <<= 2; continue;
   \   0000008E   0x00BF             LSLS     R7,R7,#+2
   \   00000090   0xB2FF             UXTB     R7,R7
   1951          		}
   \                     ??create_name_2: (+1)
   \   00000092   0xF815 0xB009      LDRB     R11,[R5, R9]
   \   00000096   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000009A   0xF1BB 0x0F21      CMP      R11,#+33
   \   0000009E   0xDB05             BLT.N    ??create_name_12
   \   000000A0   0xF1BB 0x0F2F      CMP      R11,#+47
   \   000000A4   0xD002             BEQ.N    ??create_name_12
   \   000000A6   0xF1BB 0x0F5C      CMP      R11,#+92
   \   000000AA   0xD108             BNE.N    ??create_name_13
   1952          		if (c >= 0x80) {				/* Extended character? */
   1953          			b |= 3;						/* Eliminate NT flag */
   1954          #ifdef _EXCVT
   1955          			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
   1956          #else
   1957          #if !_DF1S
   1958          			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
   1959          #endif
   1960          #endif
   1961          		}
   1962          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1963          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1964          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1965          				return FR_INVALID_NAME;
   1966          			sfn[i++] = c;
   1967          			sfn[i++] = d;
   1968          		} else {						/* SBC */
   1969          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1970          				return FR_INVALID_NAME;
   1971          			if (IsUpper(c)) {			/* ASCII large capital? */
   1972          				b |= 2;
   1973          			} else {
   1974          				if (IsLower(c)) {		/* ASCII small capital? */
   1975          					b |= 1; c -= 0x20;
   1976          				}
   1977          			}
   1978          			sfn[i++] = c;
   1979          		}
   1980          	}
   1981          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_12: (+1)
   \   000000AC   0xEB05 0x0009      ADD      R0,R5,R9
   \   000000B0   0x6020             STR      R0,[R4, #+0]
   1982          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   000000B2   0xF1BB 0x0F21      CMP      R11,#+33
   \   000000B6   0xDA30             BGE.N    ??create_name_14
   \   000000B8   0xF04F 0x0B04      MOV      R11,#+4
   \   000000BC   0xE02F             B.N      ??create_name_15
   \                     ??create_name_13: (+1)
   \   000000BE   0xF1BB 0x0F2E      CMP      R11,#+46
   \   000000C2   0xD0DA             BEQ.N    ??create_name_11
   \   000000C4   0x45D0             CMP      R8,R10
   \   000000C6   0xD2D8             BCS.N    ??create_name_11
   \   000000C8   0xF1BB 0x0F80      CMP      R11,#+128
   \   000000CC   0xDB06             BLT.N    ??create_name_16
   \   000000CE   0xF047 0x0703      ORR      R7,R7,#0x3
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000000D6   0x4458             ADD      R0,R0,R11
   \   000000D8   0xF810 0xBC80      LDRB     R11,[R0, #-128]
   \                     ??create_name_16: (+1)
   \   000000DC   0x4659             MOV      R1,R11
   \   000000DE   0x.... 0x....      ADR.W    R0,?_0
   \   000000E2   0x.... 0x....      BL       chk_chr
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD11C             BNE.N    ??create_name_7
   \   000000EA   0xF1AB 0x0041      SUB      R0,R11,#+65
   \   000000EE   0x281A             CMP      R0,#+26
   \   000000F0   0xD203             BCS.N    ??create_name_17
   \   000000F2   0xF047 0x0702      ORR      R7,R7,#0x2
   \   000000F6   0xB2FF             UXTB     R7,R7
   \   000000F8   0xE00A             B.N      ??create_name_18
   \                     ??create_name_17: (+1)
   \   000000FA   0xF1AB 0x0061      SUB      R0,R11,#+97
   \   000000FE   0x281A             CMP      R0,#+26
   \   00000100   0xD206             BCS.N    ??create_name_18
   \   00000102   0xF047 0x0701      ORR      R7,R7,#0x1
   \   00000106   0xB2FF             UXTB     R7,R7
   \   00000108   0xF1AB 0x0B20      SUB      R11,R11,#+32
   \   0000010C   0xFA5F 0xFB8B      UXTB     R11,R11
   \                     ??create_name_18: (+1)
   \   00000110   0xF806 0xB008      STRB     R11,[R6, R8]
   \   00000114   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000118   0xE7BB             B.N      ??create_name_2
   \                     ??create_name_14: (+1)
   \   0000011A   0xF04F 0x0B00      MOV      R11,#+0
   1983          
   1984          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   \                     ??create_name_15: (+1)
   \   0000011E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000122   0xD101             BNE.N    ??create_name_19
   \                     ??create_name_7: (+1)
   \   00000124   0x2006             MOVS     R0,#+6
   \   00000126   0xE018             B.N      ??create_name_10
   1985          	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
   \                     ??create_name_19: (+1)
   \   00000128   0x7830             LDRB     R0,[R6, #+0]
   \   0000012A   0x28E5             CMP      R0,#+229
   \   0000012C   0xD101             BNE.N    ??create_name_20
   \   0000012E   0x2005             MOVS     R0,#+5
   \   00000130   0x7030             STRB     R0,[R6, #+0]
   1986          
   1987          	if (ni == 8) b <<= 2;
   \                     ??create_name_20: (+1)
   \   00000132   0xF1BA 0x0F08      CMP      R10,#+8
   \   00000136   0xD101             BNE.N    ??create_name_21
   \   00000138   0x00BF             LSLS     R7,R7,#+2
   \   0000013A   0xB2FF             UXTB     R7,R7
   1988          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   \                     ??create_name_21: (+1)
   \   0000013C   0xF007 0x0003      AND      R0,R7,#0x3
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD101             BNE.N    ??create_name_22
   \   00000144   0xF04B 0x0B10      ORR      R11,R11,#0x10
   1989          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   \                     ??create_name_22: (+1)
   \   00000148   0xF007 0x000C      AND      R0,R7,#0xC
   \   0000014C   0x2804             CMP      R0,#+4
   \   0000014E   0xD101             BNE.N    ??create_name_23
   \   00000150   0xF04B 0x0B08      ORR      R11,R11,#0x8
   1990          
   1991          	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
   \                     ??create_name_23: (+1)
   \   00000154   0xF886 0xB00B      STRB     R11,[R6, #+11]
   1992          
   1993          	return FR_OK;
   \   00000158   0x2000             MOVS     R0,#+0
   \                     ??create_name_10: (+1)
   \   0000015A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1994          #endif
   1995          }
   1996          
   1997          
   1998          
   1999          
   2000          /*-----------------------------------------------------------------------*/
   2001          /* Follow a file path                                                    */
   2002          /*-----------------------------------------------------------------------*/
   2003          

   \                                 In section .text, align 2, keep-with-next
   2004          static
   2005          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   2006          	DIR* dp,			/* Directory object to return last directory and found object */
   2007          	const TCHAR* path	/* Full-path string to find a file or directory */
   2008          )
   2009          {
   \                     follow_path: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2010          	FRESULT res;
   2011          	BYTE *dir, ns;
   2012          
   2013          
   2014          #if _FS_RPATH
   2015          	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD001             BEQ.N    ??follow_path_0
   \   0000000C   0x285C             CMP      R0,#+92
   \   0000000E   0xD105             BNE.N    ??follow_path_1
   2016          		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
   \                     ??follow_path_0: (+1)
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x60A0             STR      R0,[R4, #+8]
   \   0000001A   0xE002             B.N      ??follow_path_2
   2017          	} else {								/* No heading separator */
   2018          		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
   \                     ??follow_path_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0x60A0             STR      R0,[R4, #+8]
   2019          	}
   2020          #else
   2021          	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
   2022          		path++;
   2023          	dp->sclust = 0;							/* Always start from the root directory */
   2024          #endif
   2025          
   2026          	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
   \                     ??follow_path_2: (+1)
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2820             CMP      R0,#+32
   \   00000028   0xD20A             BCS.N    ??follow_path_3
   2027          		res = dir_sdi(dp, 0);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       dir_sdi
   2028          		dp->dir = 0;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6161             STR      R1,[R4, #+20]
   \   00000036   0xBD16             POP      {R1,R2,R4,PC}
   2029          	} else {								/* Follow path */
   2030          		for (;;) {
   2031          			res = create_name(dp, &path);	/* Get a segment name of the path */
   2032          			if (res != FR_OK) break;
   2033          			res = dir_find(dp);				/* Find an object with the sagment name */
   2034          			ns = dp->fn[NSFLAG];
   2035          			if (res != FR_OK) {				/* Failed to find the object */
   2036          				if (res == FR_NO_FILE) {	/* Object is not found */
   2037          					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
   2038          						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
   2039          						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
   2040          						res = FR_OK;					/* Ended at the root directroy. Function completed. */
   2041          					} else {							/* Could not find the object */
   2042          						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
   2043          					}
   2044          				}
   2045          				break;
   2046          			}
   2047          			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   2048          			dir = dp->dir;						/* Follow the sub-directory */
   2049          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
   2050          				res = FR_NO_PATH; break;
   2051          			}
   2052          			dp->sclust = ld_clust(dp->fs, dir);
   \                     ??follow_path_4: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       ld_clust
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   \                     ??follow_path_3: (+1)
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       create_name
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD11D             BNE.N    ??follow_path_5
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       dir_find
   \   00000052   0x69A1             LDR      R1,[R4, #+24]
   \   00000054   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00F             BEQ.N    ??follow_path_6
   \   0000005A   0x2804             CMP      R0,#+4
   \   0000005C   0xD114             BNE.N    ??follow_path_5
   \   0000005E   0xF001 0x0204      AND      R2,R1,#0x4
   \   00000062   0x0689             LSLS     R1,R1,#+26
   \   00000064   0xD505             BPL.N    ??follow_path_7
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x60A0             STR      R0,[R4, #+8]
   \   0000006A   0x6160             STR      R0,[R4, #+20]
   \   0000006C   0x2A00             CMP      R2,#+0
   \   0000006E   0xD0E7             BEQ.N    ??follow_path_3
   \   00000070   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??follow_path_7: (+1)
   \   00000072   0x2A00             CMP      R2,#+0
   \   00000074   0xD108             BNE.N    ??follow_path_5
   \   00000076   0x2005             MOVS     R0,#+5
   \   00000078   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??follow_path_6: (+1)
   \   0000007A   0x0749             LSLS     R1,R1,#+29
   \   0000007C   0xD404             BMI.N    ??follow_path_5
   \   0000007E   0x6961             LDR      R1,[R4, #+20]
   \   00000080   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000082   0x06C0             LSLS     R0,R0,#+27
   \   00000084   0xD4D8             BMI.N    ??follow_path_4
   \   00000086   0x2005             MOVS     R0,#+5
   2053          		}
   2054          	}
   2055          
   2056          	return res;
   \                     ??follow_path_5: (+1)
   \   00000088   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2057          }
   2058          
   2059          
   2060          
   2061          
   2062          /*-----------------------------------------------------------------------*/
   2063          /* Get logical drive number from path name                               */
   2064          /*-----------------------------------------------------------------------*/
   2065          

   \                                 In section .text, align 2, keep-with-next
   2066          static
   2067          int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
   2068          	const TCHAR** path	/* Pointer to pointer to the path name */
   2069          )
   2070          {
   \                     get_ldnumber: (+1)
   \   00000000   0xB410             PUSH     {R4}
   2071          	const TCHAR *tp, *tt;
   2072          	UINT i;
   2073          	int vol = -1;
   \   00000002   0xF04F 0x31FF      MOV      R1,#-1
   2074          #if _STR_VOLUME_ID		/* Find string drive id */
   2075          	static const char* const str[] = {_VOLUME_STRS};
   2076          	const char *sp;
   2077          	char c;
   2078          	TCHAR tc;
   2079          #endif
   2080          
   2081          
   2082          	if (*path) {	/* If the pointer is not a null */
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD01A             BEQ.N    ??get_ldnumber_0
   2083          		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
   \   0000000C   0xE000             B.N      ??get_ldnumber_1
   \                     ??get_ldnumber_2: (+1)
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \                     ??get_ldnumber_1: (+1)
   \   00000010   0x7813             LDRB     R3,[R2, #+0]
   \   00000012   0x461C             MOV      R4,R3
   \   00000014   0x2B21             CMP      R3,#+33
   \   00000016   0xD301             BCC.N    ??get_ldnumber_3
   \   00000018   0x2C3A             CMP      R4,#+58
   \   0000001A   0xD1F8             BNE.N    ??get_ldnumber_2
   2084          		if (*tt == ':') {	/* If a ':' is exist in the path name */
   \                     ??get_ldnumber_3: (+1)
   \   0000001C   0x2C3A             CMP      R4,#+58
   \   0000001E   0xD10D             BNE.N    ??get_ldnumber_4
   2085          			tp = *path;
   \   00000020   0x6803             LDR      R3,[R0, #+0]
   2086          			i = *tp++ - '0'; 
   \   00000022   0xF813 0x4B01      LDRB     R4,[R3], #+1
   \   00000026   0x3C30             SUBS     R4,R4,#+48
   2087          			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
   \   00000028   0x2C0A             CMP      R4,#+10
   \   0000002A   0xD20A             BCS.N    ??get_ldnumber_0
   \   0000002C   0x4293             CMP      R3,R2
   \   0000002E   0xD108             BNE.N    ??get_ldnumber_0
   2088          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   \   00000030   0x2C02             CMP      R4,#+2
   \   00000032   0xD206             BCS.N    ??get_ldnumber_0
   2089          					vol = (int)i;
   \   00000034   0x4621             MOV      R1,R4
   2090          					*path = ++tt;
   \   00000036   0x1C52             ADDS     R2,R2,#+1
   \   00000038   0x6002             STR      R2,[R0, #+0]
   \   0000003A   0xE002             B.N      ??get_ldnumber_0
   2091          				}
   2092          			}
   2093          #if _STR_VOLUME_ID
   2094          			 else {	/* No numeric drive number, find string drive id */
   2095          				i = 0; tt++;
   2096          				do {
   2097          					sp = str[i]; tp = *path;
   2098          					do {	/* Compare a string drive id with path name */
   2099          						c = *sp++; tc = *tp++;
   2100          						if (IsLower(tc)) tc -= 0x20;
   2101          					} while (c && (TCHAR)c == tc);
   2102          				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
   2103          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2104          					vol = (int)i;
   2105          					*path = tt;
   2106          				}
   2107          			}
   2108          #endif
   2109          			return vol;
   2110          		}
   2111          #if _FS_RPATH && _VOLUMES >= 2
   2112          		vol = CurrVol;	/* Current drive */
   \                     ??get_ldnumber_4: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000040   0x7801             LDRB     R1,[R0, #+0]
   2113          #else
   2114          		vol = 0;		/* Drive 0 */
   2115          #endif
   2116          	}
   2117          	return vol;
   \                     ??get_ldnumber_0: (+1)
   \   00000042   0x4608             MOV      R0,R1
   \   00000044   0xBC10             POP      {R4}
   \   00000046   0x4770             BX       LR               ;; return
   2118          }
   2119          
   2120          
   2121          
   2122          
   2123          /*-----------------------------------------------------------------------*/
   2124          /* Load a sector and check if it is an FAT boot sector                   */
   2125          /*-----------------------------------------------------------------------*/
   2126          

   \                                 In section .text, align 2, keep-with-next
   2127          static
   2128          BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
   2129          	FATFS* fs,	/* File system object */
   2130          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2131          )
   2132          {
   \                     check_fs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2133          	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
   \   00000004   0x1D20             ADDS     R0,R4,#+4
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x7002             STRB     R2,[R0, #+0]
   \   0000000A   0xF04F 0x32FF      MOV      R2,#-1
   \   0000000E   0x62C2             STR      R2,[R0, #+44]
   2134          	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       move_window
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??check_fs_0
   2135          		return 3;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xBD10             POP      {R4,PC}
   2136          
   2137          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0: (+1)
   \   0000001E   0xF204 0x2032      ADDW     R0,R4,#+562
   \   00000022   0x7841             LDRB     R1,[R0, #+1]
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000002A   0xF64A 0x2155      MOVW     R1,#+43605
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD001             BEQ.N    ??check_fs_1
   2138          		return 2;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xBD10             POP      {R4,PC}
   2139          
   2140          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
   \                     ??check_fs_1: (+1)
   \   00000036   0xF104 0x006A      ADD      R0,R4,#+106
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x544146
   \   0000003E   0x7882             LDRB     R2,[R0, #+2]
   \   00000040   0x7843             LDRB     R3,[R0, #+1]
   \   00000042   0x021B             LSLS     R3,R3,#+8
   \   00000044   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   00000048   0x7803             LDRB     R3,[R0, #+0]
   \   0000004A   0x431A             ORRS     R2,R3,R2
   \   0000004C   0x428A             CMP      R2,R1
   \   0000004E   0xD101             BNE.N    ??check_fs_2
   2141          		return 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD10             POP      {R4,PC}
   2142          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_2: (+1)
   \   00000054   0x7F82             LDRB     R2,[R0, #+30]
   \   00000056   0x7F43             LDRB     R3,[R0, #+29]
   \   00000058   0x021B             LSLS     R3,R3,#+8
   \   0000005A   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   0000005E   0x7F00             LDRB     R0,[R0, #+28]
   \   00000060   0x4310             ORRS     R0,R0,R2
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD101             BNE.N    ??check_fs_3
   2143          		return 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD10             POP      {R4,PC}
   2144          
   2145          	return 1;
   \                     ??check_fs_3: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
   2146          }
   2147          
   2148          
   2149          
   2150          
   2151          /*-----------------------------------------------------------------------*/
   2152          /* Find logical drive and check if the volume is mounted                 */
   2153          /*-----------------------------------------------------------------------*/
   2154          

   \                                 In section .text, align 2, keep-with-next
   2155          static
   2156          FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
   2157          	FATFS** rfs,		/* Pointer to pointer to the found file system object */
   2158          	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
   2159          	BYTE wmode			/* !=0: Check write protection for write access */
   2160          )
   2161          {
   \                     find_volume: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4614             MOV      R4,R2
   2162          	BYTE fmt, *pt;
   2163          	int vol;
   2164          	DSTATUS stat;
   2165          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
   2166          	WORD nrsv;
   2167          	FATFS *fs;
   2168          	UINT i;
   2169          
   2170          
   2171          	/* Get logical drive number from the path name */
   2172          	*rfs = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2173          	vol = get_ldnumber(path);
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x.... 0x....      BL       get_ldnumber
   \   00000014   0x0007             MOVS     R7,R0
   2174          	if (vol < 0) return FR_INVALID_DRIVE;
   \   00000016   0xD501             BPL.N    ??find_volume_0
   \   00000018   0x200B             MOVS     R0,#+11
   \   0000001A   0xE167             B.N      ??find_volume_1
   2175          
   2176          	/* Check if the file system object is valid or not */
   2177          	fs = FatFs[vol];					/* Get pointer to the file system object */
   \                     ??find_volume_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable10_3
   \   00000020   0xEB05 0x0087      ADD      R0,R5,R7, LSL #+2
   \   00000024   0x6846             LDR      R6,[R0, #+4]
   2178          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD101             BNE.N    ??find_volume_2
   \   0000002A   0x200C             MOVS     R0,#+12
   \   0000002C   0xE15E             B.N      ??find_volume_1
   2179          
   2180          	ENTER_FF(fs);						/* Lock the volume */
   2181          	*rfs = fs;							/* Return pointer to the file system object */
   \                     ??find_volume_2: (+1)
   \   0000002E   0xF8C8 0x6000      STR      R6,[R8, #+0]
   2182          
   2183          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   00000032   0x7830             LDRB     R0,[R6, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00B             BEQ.N    ??find_volume_3
   2184          		stat = disk_status(fs->drv);
   \   00000038   0x7870             LDRB     R0,[R6, #+1]
   \   0000003A   0x.... 0x....      BL       disk_status
   2185          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   \   0000003E   0x4601             MOV      R1,R0
   \   00000040   0x07C9             LSLS     R1,R1,#+31
   \   00000042   0xD405             BMI.N    ??find_volume_3
   2186          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD001             BEQ.N    ??find_volume_4
   \   00000048   0x0740             LSLS     R0,R0,#+29
   \   0000004A   0xD410             BMI.N    ??find_volume_5
   2187          				return FR_WRITE_PROTECTED;
   2188          			return FR_OK;				/* The file system object is valid */
   \                     ??find_volume_4: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE14D             B.N      ??find_volume_1
   2189          		}
   2190          	}
   2191          
   2192          	/* The file system object is not valid. */
   2193          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2194          
   2195          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??find_volume_3: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x7030             STRB     R0,[R6, #+0]
   2196          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   00000054   0x7077             STRB     R7,[R6, #+1]
   2197          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   00000056   0x7870             LDRB     R0,[R6, #+1]
   \   00000058   0x.... 0x....      BL       disk_initialize
   2198          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x07C9             LSLS     R1,R1,#+31
   \   00000060   0xD501             BPL.N    ??find_volume_6
   2199          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0xE142             B.N      ??find_volume_1
   2200          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??find_volume_6: (+1)
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD003             BEQ.N    ??find_volume_7
   \   0000006A   0x0740             LSLS     R0,R0,#+29
   \   0000006C   0xD501             BPL.N    ??find_volume_7
   2201          		return FR_WRITE_PROTECTED;
   \                     ??find_volume_5: (+1)
   \   0000006E   0x200A             MOVS     R0,#+10
   \   00000070   0xE13C             B.N      ??find_volume_1
   2202          #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
   2203          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2204          		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
   2205          #endif
   2206          	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
   2207          	bsect = 0;
   \                     ??find_volume_7: (+1)
   \   00000072   0x2700             MOVS     R7,#+0
   2208          	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       check_fs
   \   0000007C   0x4604             MOV      R4,R0
   2209          	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
   \   0000007E   0x2C01             CMP      R4,#+1
   \   00000080   0xD12E             BNE.N    ??find_volume_8
   2210          		for (i = 0; i < 4; i++) {			/* Get partition offset */
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0xE004             B.N      ??find_volume_9
   2211          			pt = fs->win + MBR_Table + i * SZ_PTE;
   2212          			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
   \                     ??find_volume_10: (+1)
   \   00000086   0x4639             MOV      R1,R7
   \                     ??find_volume_11: (+1)
   \   00000088   0x466A             MOV      R2,SP
   \   0000008A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \                     ??find_volume_9: (+1)
   \   00000090   0x2804             CMP      R0,#+4
   \   00000092   0xD212             BCS.N    ??find_volume_12
   \   00000094   0xEB06 0x1100      ADD      R1,R6,R0, LSL #+4
   \   00000098   0xF44F 0x72F9      MOV      R2,#+498
   \   0000009C   0x4411             ADD      R1,R1,R2
   \   0000009E   0x790A             LDRB     R2,[R1, #+4]
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0xD0F0             BEQ.N    ??find_volume_10
   \   000000A4   0x7ACA             LDRB     R2,[R1, #+11]
   \   000000A6   0x7A8B             LDRB     R3,[R1, #+10]
   \   000000A8   0x041B             LSLS     R3,R3,#+16
   \   000000AA   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   000000AE   0x7A4B             LDRB     R3,[R1, #+9]
   \   000000B0   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   000000B4   0x7A09             LDRB     R1,[R1, #+8]
   \   000000B6   0x4311             ORRS     R1,R1,R2
   \   000000B8   0xE7E6             B.N      ??find_volume_11
   2213          		}
   2214          		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
   \                     ??find_volume_12: (+1)
   \   000000BA   0x46B8             MOV      R8,R7
   2215          		if (i) i--;
   2216          		do {								/* Find an FAT volume */
   2217          			bsect = br[i];
   \                     ??find_volume_13: (+1)
   \   000000BC   0x4668             MOV      R0,SP
   \   000000BE   0xF850 0x7028      LDR      R7,[R0, R8, LSL #+2]
   2218          			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
   \   000000C2   0x2F00             CMP      R7,#+0
   \   000000C4   0xD004             BEQ.N    ??find_volume_14
   \   000000C6   0x4639             MOV      R1,R7
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       check_fs
   \   000000CE   0xE000             B.N      ??find_volume_15
   \                     ??find_volume_14: (+1)
   \   000000D0   0x2002             MOVS     R0,#+2
   \                     ??find_volume_15: (+1)
   \   000000D2   0x0004             MOVS     R4,R0
   2219          		} while (!LD2PT(vol) && fmt && ++i < 4);
   \   000000D4   0xD004             BEQ.N    ??find_volume_8
   \   000000D6   0xF108 0x0801      ADD      R8,R8,#+1
   \   000000DA   0xF1B8 0x0F04      CMP      R8,#+4
   \   000000DE   0xD3ED             BCC.N    ??find_volume_13
   2220          	}
   2221          	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   \                     ??find_volume_8: (+1)
   \   000000E0   0x2C03             CMP      R4,#+3
   \   000000E2   0xD101             BNE.N    ??find_volume_16
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0xE101             B.N      ??find_volume_1
   2222          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??find_volume_16: (+1)
   \   000000E8   0x2C00             CMP      R4,#+0
   \   000000EA   0xF040 0x809D      BNE.W    ??find_volume_17
   2223          
   2224          	/* An FAT volume is found. Following code initializes the file system object */
   2225          
   2226          	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \   000000EE   0xF106 0x0834      ADD      R8,R6,#+52
   \   000000F2   0xF898 0x000C      LDRB     R0,[R8, #+12]
   \   000000F6   0xF898 0x100B      LDRB     R1,[R8, #+11]
   \   000000FA   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000000FE   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000102   0xF040 0x8091      BNE.W    ??find_volume_17
   2227          		return FR_NO_FILESYSTEM;
   2228          
   2229          	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
   \   00000106   0xF898 0x0017      LDRB     R0,[R8, #+23]
   \   0000010A   0xF898 0x1016      LDRB     R1,[R8, #+22]
   \   0000010E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   2230          	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
   \   00000112   0xD10B             BNE.N    ??find_volume_18
   \   00000114   0xF106 0x0154      ADD      R1,R6,#+84
   \   00000118   0x79C8             LDRB     R0,[R1, #+7]
   \   0000011A   0x798A             LDRB     R2,[R1, #+6]
   \   0000011C   0x0412             LSLS     R2,R2,#+16
   \   0000011E   0xEA42 0x6000      ORR      R0,R2,R0, LSL #+24
   \   00000122   0x794A             LDRB     R2,[R1, #+5]
   \   00000124   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   00000128   0x7909             LDRB     R1,[R1, #+4]
   \   0000012A   0x4308             ORRS     R0,R1,R0
   2231          	fs->fsize = fasize;
   \                     ??find_volume_18: (+1)
   \   0000012C   0x61F0             STR      R0,[R6, #+28]
   2232          
   2233          	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
   \   0000012E   0xF898 0x1010      LDRB     R1,[R8, #+16]
   \   00000132   0x70F1             STRB     R1,[R6, #+3]
   2234          	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
   \   00000134   0x460A             MOV      R2,R1
   \   00000136   0x2A01             CMP      R2,#+1
   \   00000138   0xD001             BEQ.N    ??find_volume_19
   \   0000013A   0x2A02             CMP      R2,#+2
   \   0000013C   0xD174             BNE.N    ??find_volume_17
   2235          		return FR_NO_FILESYSTEM;
   2236          	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
   \                     ??find_volume_19: (+1)
   \   0000013E   0x4348             MULS     R0,R1,R0
   2237          
   2238          	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
   \   00000140   0xF898 0x100D      LDRB     R1,[R8, #+13]
   \   00000144   0x70B1             STRB     R1,[R6, #+2]
   2239          	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
   \   00000146   0x000A             MOVS     R2,R1
   \   00000148   0xD06E             BEQ.N    ??find_volume_17
   \   0000014A   0x1E4A             SUBS     R2,R1,#+1
   \   0000014C   0x4211             TST      R1,R2
   \   0000014E   0xD16B             BNE.N    ??find_volume_17
   2240          		return FR_NO_FILESYSTEM;
   2241          
   2242          	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
   \   00000150   0xF898 0x1012      LDRB     R1,[R8, #+18]
   \   00000154   0xF898 0x2011      LDRB     R2,[R8, #+17]
   \   00000158   0xEA42 0x2201      ORR      R2,R2,R1, LSL #+8
   \   0000015C   0x8132             STRH     R2,[R6, #+8]
   2243          	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
   \   0000015E   0x210F             MOVS     R1,#+15
   \   00000160   0x420A             TST      R2,R1
   \   00000162   0xD161             BNE.N    ??find_volume_17
   2244          		return FR_NO_FILESYSTEM;
   2245          
   2246          	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
   \   00000164   0xF898 0x1014      LDRB     R1,[R8, #+20]
   \   00000168   0xF898 0x3013      LDRB     R3,[R8, #+19]
   \   0000016C   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   2247          	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
   \   00000170   0xD10B             BNE.N    ??find_volume_20
   \   00000172   0xF106 0x0154      ADD      R1,R6,#+84
   \   00000176   0x78CB             LDRB     R3,[R1, #+3]
   \   00000178   0x788C             LDRB     R4,[R1, #+2]
   \   0000017A   0x0424             LSLS     R4,R4,#+16
   \   0000017C   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   00000180   0x784C             LDRB     R4,[R1, #+1]
   \   00000182   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000186   0x7809             LDRB     R1,[R1, #+0]
   \   00000188   0x430B             ORRS     R3,R1,R3
   2248          
   2249          	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
   \                     ??find_volume_20: (+1)
   \   0000018A   0xF898 0x100F      LDRB     R1,[R8, #+15]
   \   0000018E   0xF898 0x400E      LDRB     R4,[R8, #+14]
   \   00000192   0xEA54 0x2101      ORRS     R1,R4,R1, LSL #+8
   2250          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
   \   00000196   0xD047             BEQ.N    ??find_volume_17
   2251          
   2252          	/* Determine the FAT sub type */
   2253          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
   \   00000198   0x1844             ADDS     R4,R0,R1
   \   0000019A   0xEB04 0x1212      ADD      R2,R4,R2, LSR #+4
   2254          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   0000019E   0x4293             CMP      R3,R2
   \   000001A0   0xD342             BCC.N    ??find_volume_17
   2255          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \   000001A2   0x1A9B             SUBS     R3,R3,R2
   \   000001A4   0x78B4             LDRB     R4,[R6, #+2]
   \   000001A6   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   2256          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   000001AA   0x2B00             CMP      R3,#+0
   \   000001AC   0xD03C             BEQ.N    ??find_volume_17
   2257          	fmt = FS_FAT12;
   \   000001AE   0x2401             MOVS     R4,#+1
   2258          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   000001B0   0xF640 0x7CF6      MOVW     R12,#+4086
   \   000001B4   0x4563             CMP      R3,R12
   \   000001B6   0xD300             BCC.N    ??find_volume_21
   \   000001B8   0x2402             MOVS     R4,#+2
   2259          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??find_volume_21: (+1)
   \   000001BA   0xF64F 0x7CF6      MOVW     R12,#+65526
   \   000001BE   0x4563             CMP      R3,R12
   \   000001C0   0xD300             BCC.N    ??find_volume_22
   \   000001C2   0x2403             MOVS     R4,#+3
   2260          
   2261          	/* Boundaries and Limits */
   2262          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??find_volume_22: (+1)
   \   000001C4   0x1C9B             ADDS     R3,R3,#+2
   \   000001C6   0x61B3             STR      R3,[R6, #+24]
   2263          	fs->volbase = bsect;								/* Volume start sector */
   \   000001C8   0x6237             STR      R7,[R6, #+32]
   2264          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   000001CA   0x19C9             ADDS     R1,R1,R7
   \   000001CC   0x6271             STR      R1,[R6, #+36]
   2265          	fs->database = bsect + sysect;						/* Data start sector */
   \   000001CE   0x19D1             ADDS     R1,R2,R7
   \   000001D0   0x62F1             STR      R1,[R6, #+44]
   2266          	if (fmt == FS_FAT32) {
   \   000001D2   0x8931             LDRH     R1,[R6, #+8]
   \   000001D4   0x2C03             CMP      R4,#+3
   \   000001D6   0xD111             BNE.N    ??find_volume_23
   2267          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   000001D8   0x2900             CMP      R1,#+0
   \   000001DA   0xD125             BNE.N    ??find_volume_17
   2268          		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
   \   000001DC   0xF106 0x0154      ADD      R1,R6,#+84
   \   000001E0   0x7BC8             LDRB     R0,[R1, #+15]
   \   000001E2   0x7B8A             LDRB     R2,[R1, #+14]
   \   000001E4   0x0412             LSLS     R2,R2,#+16
   \   000001E6   0xEA42 0x6000      ORR      R0,R2,R0, LSL #+24
   \   000001EA   0x7B4A             LDRB     R2,[R1, #+13]
   \   000001EC   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   000001F0   0x7B09             LDRB     R1,[R1, #+12]
   \   000001F2   0x4308             ORRS     R0,R1,R0
   \   000001F4   0x62B0             STR      R0,[R6, #+40]
   2269          		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
   \   000001F6   0x69B0             LDR      R0,[R6, #+24]
   \   000001F8   0x0080             LSLS     R0,R0,#+2
   \   000001FA   0xE00F             B.N      ??find_volume_24
   2270          	} else {
   2271          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??find_volume_23: (+1)
   \   000001FC   0x2900             CMP      R1,#+0
   \   000001FE   0xD013             BEQ.N    ??find_volume_17
   2272          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \   00000200   0x6A71             LDR      R1,[R6, #+36]
   \   00000202   0x1840             ADDS     R0,R0,R1
   \   00000204   0x62B0             STR      R0,[R6, #+40]
   2273          		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
   2274          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   00000206   0x69B0             LDR      R0,[R6, #+24]
   \   00000208   0x2C02             CMP      R4,#+2
   \   0000020A   0xD101             BNE.N    ??find_volume_25
   \   0000020C   0x0040             LSLS     R0,R0,#+1
   \   0000020E   0xE005             B.N      ??find_volume_24
   \                     ??find_volume_25: (+1)
   \   00000210   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000214   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000218   0xEB00 0x0051      ADD      R0,R0,R1, LSR #+1
   2275          	}
   2276          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
   \                     ??find_volume_24: (+1)
   \   0000021C   0x69F1             LDR      R1,[R6, #+28]
   \   0000021E   0xF200 0x10FF      ADDW     R0,R0,#+511
   \   00000222   0xEBB1 0x2F50      CMP      R1,R0, LSR #+9
   \   00000226   0xD201             BCS.N    ??find_volume_26
   2277          		return FR_NO_FILESYSTEM;
   \                     ??find_volume_17: (+1)
   \   00000228   0x200D             MOVS     R0,#+13
   \   0000022A   0xE05F             B.N      ??find_volume_1
   2278          
   2279          #if !_FS_READONLY
   2280          	/* Initialize cluster allocation information */
   2281          	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
   \                     ??find_volume_26: (+1)
   \   0000022C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000230   0x6130             STR      R0,[R6, #+16]
   \   00000232   0x60F0             STR      R0,[R6, #+12]
   2282          
   2283          	/* Get fsinfo if available */
   2284          	fs->fsi_flag = 0x80;
   \   00000234   0x2080             MOVS     R0,#+128
   \   00000236   0x7170             STRB     R0,[R6, #+5]
   2285          #if (_FS_NOFSINFO & 3) != 3
   2286          	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
   2287          		&& LD_WORD(fs->win + BPB_FSInfo) == 1
   2288          		&& move_window(fs, bsect + 1) == FR_OK)
   \   00000238   0x2C03             CMP      R4,#+3
   \   0000023A   0xD150             BNE.N    ??find_volume_27
   \   0000023C   0xF106 0x0154      ADD      R1,R6,#+84
   \   00000240   0x7C48             LDRB     R0,[R1, #+17]
   \   00000242   0x7C09             LDRB     R1,[R1, #+16]
   \   00000244   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000248   0x2801             CMP      R0,#+1
   \   0000024A   0xD148             BNE.N    ??find_volume_27
   \   0000024C   0x1C79             ADDS     R1,R7,#+1
   \   0000024E   0x4630             MOV      R0,R6
   \   00000250   0x.... 0x....      BL       move_window
   \   00000254   0x2800             CMP      R0,#+0
   \   00000256   0xD142             BNE.N    ??find_volume_27
   2289          	{
   2290          		fs->fsi_flag = 0;
   \   00000258   0x2000             MOVS     R0,#+0
   \   0000025A   0x7170             STRB     R0,[R6, #+5]
   2291          		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
   2292          			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
   2293          			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
   \   0000025C   0xF44F 0x7006      MOV      R0,#+536
   \   00000260   0x4430             ADD      R0,R6,R0
   \   00000262   0x7EC1             LDRB     R1,[R0, #+27]
   \   00000264   0x7E82             LDRB     R2,[R0, #+26]
   \   00000266   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   0000026A   0xF64A 0x2255      MOVW     R2,#+43605
   \   0000026E   0x4291             CMP      R1,R2
   \   00000270   0xD135             BNE.N    ??find_volume_27
   \   00000272   0xF898 0x1003      LDRB     R1,[R8, #+3]
   \   00000276   0xF898 0x2002      LDRB     R2,[R8, #+2]
   \   0000027A   0x0412             LSLS     R2,R2,#+16
   \   0000027C   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000280   0xF898 0x2001      LDRB     R2,[R8, #+1]
   \   00000284   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000288   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   0000028C   0x4311             ORRS     R1,R2,R1
   \   0000028E   0x.... 0x....      LDR.W    R2,??DataTable10_4  ;; 0x41615252
   \   00000292   0x4291             CMP      R1,R2
   \   00000294   0xD123             BNE.N    ??find_volume_27
   \   00000296   0x78C1             LDRB     R1,[R0, #+3]
   \   00000298   0x7882             LDRB     R2,[R0, #+2]
   \   0000029A   0x0412             LSLS     R2,R2,#+16
   \   0000029C   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   000002A0   0x7842             LDRB     R2,[R0, #+1]
   \   000002A2   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000002A6   0x7802             LDRB     R2,[R0, #+0]
   \   000002A8   0x4311             ORRS     R1,R2,R1
   \   000002AA   0x.... 0x....      LDR.W    R2,??DataTable10_5  ;; 0x61417272
   \   000002AE   0x4291             CMP      R1,R2
   \   000002B0   0xD115             BNE.N    ??find_volume_27
   2294          		{
   2295          #if (_FS_NOFSINFO & 1) == 0
   2296          			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
   \   000002B2   0x79C1             LDRB     R1,[R0, #+7]
   \   000002B4   0x7982             LDRB     R2,[R0, #+6]
   \   000002B6   0x0412             LSLS     R2,R2,#+16
   \   000002B8   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   000002BC   0x7942             LDRB     R2,[R0, #+5]
   \   000002BE   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000002C2   0x7902             LDRB     R2,[R0, #+4]
   \   000002C4   0x4311             ORRS     R1,R2,R1
   \   000002C6   0x6131             STR      R1,[R6, #+16]
   2297          #endif
   2298          #if (_FS_NOFSINFO & 2) == 0
   2299          			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
   \   000002C8   0x7AC1             LDRB     R1,[R0, #+11]
   \   000002CA   0x7A82             LDRB     R2,[R0, #+10]
   \   000002CC   0x0412             LSLS     R2,R2,#+16
   \   000002CE   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   000002D2   0x7A42             LDRB     R2,[R0, #+9]
   \   000002D4   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000002D8   0x7A00             LDRB     R0,[R0, #+8]
   \   000002DA   0x4308             ORRS     R0,R0,R1
   \   000002DC   0x60F0             STR      R0,[R6, #+12]
   2300          #endif
   2301          		}
   2302          	}
   2303          #endif
   2304          #endif
   2305          	fs->fs_type = fmt;	/* FAT sub-type */
   \                     ??find_volume_27: (+1)
   \   000002DE   0x7034             STRB     R4,[R6, #+0]
   2306          	fs->id = ++Fsid;	/* File system mount ID */
   \   000002E0   0x8828             LDRH     R0,[R5, #+0]
   \   000002E2   0x1C40             ADDS     R0,R0,#+1
   \   000002E4   0x8028             STRH     R0,[R5, #+0]
   \   000002E6   0x80F0             STRH     R0,[R6, #+6]
   2307          #if _FS_RPATH
   2308          	fs->cdir = 0;		/* Set current directory to root */
   \   000002E8   0x2000             MOVS     R0,#+0
   \   000002EA   0x6170             STR      R0,[R6, #+20]
   2309          #endif
   2310          #if _FS_LOCK			/* Clear file lock semaphores */
   2311          	clear_lock(fs);
   2312          #endif
   2313          
   2314          	return FR_OK;
   \                     ??find_volume_1: (+1)
   \   000002EC   0xB004             ADD      SP,SP,#+16
   \   000002EE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2315          }
   2316          
   2317          
   2318          
   2319          
   2320          /*-----------------------------------------------------------------------*/
   2321          /* Check if the file/directory object is valid or not                    */
   2322          /*-----------------------------------------------------------------------*/
   2323          

   \                                 In section .text, align 2, keep-with-next
   2324          static
   2325          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2326          	void* obj		/* Pointer to the object FIL/DIR to check validity */
   2327          )
   2328          {
   \                     validate: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2329          	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
   2330          
   2331          
   2332          	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD009             BEQ.N    ??validate_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD006             BEQ.N    ??validate_0
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD003             BEQ.N    ??validate_0
   \   00000012   0x88CA             LDRH     R2,[R1, #+6]
   \   00000014   0x8880             LDRH     R0,[R0, #+4]
   \   00000016   0x4282             CMP      R2,R0
   \   00000018   0xD001             BEQ.N    ??validate_1
   2333          		return FR_INVALID_OBJECT;
   \                     ??validate_0: (+1)
   \   0000001A   0x2009             MOVS     R0,#+9
   \   0000001C   0xBD02             POP      {R1,PC}
   2334          
   2335          	ENTER_FF(fil->fs);		/* Lock file system */
   2336          
   2337          	if (disk_status(fil->fs->drv) & STA_NOINIT)
   \                     ??validate_1: (+1)
   \   0000001E   0x7848             LDRB     R0,[R1, #+1]
   \   00000020   0x.... 0x....      BL       disk_status
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD501             BPL.N    ??validate_2
   2338          		return FR_NOT_READY;
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0xBD02             POP      {R1,PC}
   2339          
   2340          	return FR_OK;
   \                     ??validate_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
   2341          }
   2342          
   2343          
   2344          
   2345          
   2346          /*--------------------------------------------------------------------------
   2347          
   2348             Public Functions
   2349          
   2350          --------------------------------------------------------------------------*/
   2351          
   2352          
   2353          extern void printk(const char *fmt, ...);
   2354          /*-----------------------------------------------------------------------*/
   2355          /* Mount/Unmount a Logical Drive                                         */
   2356          /*-----------------------------------------------------------------------*/
   2357          

   \                                 In section .text, align 2, keep-with-next
   2358          FRESULT f_mount (
   2359          	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
   2360          	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
   2361          	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
   2362          )
   2363          {
   \                     f_mount: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4614             MOV      R4,R2
   2364          	FATFS *cfs;
   2365          	int vol;
   2366          	FRESULT res;
   2367          	const TCHAR *rp = path;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2368          
   2369          
   2370          	vol = get_ldnumber(&rp);
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       get_ldnumber
   2371          	if (vol < 0) return FR_INVALID_DRIVE;
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD501             BPL.N    ??f_mount_0
   \   00000014   0x200B             MOVS     R0,#+11
   \   00000016   0xE01C             B.N      ??f_mount_1
   2372          	cfs = FatFs[vol];					/* Pointer to fs object */
   \                     ??f_mount_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   0000001C   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000020   0x6841             LDR      R1,[R0, #+4]
   2373          
   2374          	if (cfs) {
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD001             BEQ.N    ??f_mount_2
   2375          #if _FS_LOCK
   2376          		clear_lock(cfs);
   2377          #endif
   2378          #if _FS_REENTRANT						/* Discard sync object of the current volume */
   2379          		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
   2380          #endif
   2381          		cfs->fs_type = 0;				/* Clear old fs object */
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x700A             STRB     R2,[R1, #+0]
   2382          	}
   2383          
   2384          	if (fs) {
   \                     ??f_mount_2: (+1)
   \   0000002A   0x9902             LDR      R1,[SP, #+8]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD002             BEQ.N    ??f_mount_3
   2385          		fs->fs_type = 0;				/* Clear new fs object */
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x9A02             LDR      R2,[SP, #+8]
   \   00000034   0x7011             STRB     R1,[R2, #+0]
   2386          #if _FS_REENTRANT						/* Create sync object for the new volume */
   2387          		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
   2388          #endif
   2389          	}
   2390          	FatFs[vol] = fs;					/* Register new fs object */
   \                     ??f_mount_3: (+1)
   \   00000036   0x9902             LDR      R1,[SP, #+8]
   \   00000038   0x6041             STR      R1,[R0, #+4]
   2391          	//printk(" 00 path = %s[%d]\n", path,opt);
   2392          	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
   \   0000003A   0x9802             LDR      R0,[SP, #+8]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??f_mount_4
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xD001             BEQ.N    ??f_mount_5
   \                     ??f_mount_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE004             B.N      ??f_mount_1
   2393          	//printk(" 11 path = %s[%d]\n", path,opt);
   2394          	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
   2395          	LEAVE_FF(fs, res);
   \                     ??f_mount_5: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0xA903             ADD      R1,SP,#+12
   \   0000004C   0xA802             ADD      R0,SP,#+8
   \   0000004E   0x.... 0x....      BL       find_volume
   \                     ??f_mount_1: (+1)
   \   00000052   0xB004             ADD      SP,SP,#+16
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
   2396          	//intk("path = %s\n", path);
   2397          }
   2398          
   2399          
   2400          
   2401          
   2402          /*-----------------------------------------------------------------------*/
   2403          /* Open or Create a File                                                 */
   2404          /*-----------------------------------------------------------------------*/
   2405          

   \                                 In section .text, align 2, keep-with-next
   2406          FRESULT f_open (
   2407          	FIL* fp,			/* Pointer to the blank file object */
   2408          	const TCHAR* path,	/* Pointer to the file name */
   2409          	BYTE mode			/* Access mode and file open mode flags */
   2410          )
   2411          {
   \                     f_open: (+1)
   \   00000000   0xE92D 0x43F2      PUSH     {R1,R4-R9,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4615             MOV      R5,R2
   2412          	FRESULT res;
   2413          	DIR dj;
   2414          	BYTE *dir;
   2415          	DEFINE_NAMEBUF;
   2416          #if !_FS_READONLY
   2417          	DWORD dw, cl;
   2418          #endif
   2419          
   2420          
   2421          	if (!fp) return FR_INVALID_OBJECT;
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??f_open_0
   \   0000000E   0x2009             MOVS     R0,#+9
   \   00000010   0xE09C             B.N      ??f_open_1
   2422          	fp->fs = 0;			/* Clear file object */
   \                     ??f_open_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6020             STR      R0,[R4, #+0]
   2423          
   2424          	/* Get logical drive number */
   2425          #if !_FS_READONLY
   2426          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00000016   0xF005 0x051F      AND      R5,R5,#0x1F
   2427          	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
   \   0000001A   0xF005 0x02FE      AND      R2,R5,#0xFE
   \   0000001E   0xA90C             ADD      R1,SP,#+48
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       find_volume
   \   00000026   0x0006             MOVS     R6,R0
   2428          #else
   2429          	mode &= FA_READ;
   2430          	res = find_volume(&dj.fs, &path, 0);
   2431          #endif
   2432          	if (res == FR_OK) {
   \   00000028   0xF040 0x808F      BNE.W    ??f_open_2
   2433          		INIT_BUF(dj);
   \   0000002C   0xA808             ADD      R0,SP,#+32
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   2434          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000030   0x990C             LDR      R1,[SP, #+48]
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x.... 0x....      BL       follow_path
   \   00000038   0x0006             MOVS     R6,R0
   2435          		dir = dj.dir;
   \   0000003A   0x9F05             LDR      R7,[SP, #+20]
   2436          #if !_FS_READONLY	/* R/W configuration */
   2437          		if (res == FR_OK) {
   \   0000003C   0xD102             BNE.N    ??f_open_3
   2438          			if (!dir)	/* Default directory itself */
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD100             BNE.N    ??f_open_3
   2439          				res = FR_INVALID_NAME;
   \   00000042   0x2606             MOVS     R6,#+6
   2440          #if _FS_LOCK
   2441          			else
   2442          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2443          #endif
   2444          		}
   2445          		/* Create or Open a file */
   2446          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_3: (+1)
   \   00000044   0x201C             MOVS     R0,#+28
   \   00000046   0x4205             TST      R5,R0
   \   00000048   0xD04D             BEQ.N    ??f_open_4
   2447          			if (res != FR_OK) {					/* No file, create new */
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0xD009             BEQ.N    ??f_open_5
   2448          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   0000004E   0x2E04             CMP      R6,#+4
   \   00000050   0xD103             BNE.N    ??f_open_6
   2449          #if _FS_LOCK
   2450          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2451          #else
   2452          					res = dir_register(&dj);
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       dir_register
   \   00000058   0x4606             MOV      R6,R0
   2453          #endif
   2454          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_6: (+1)
   \   0000005A   0xF045 0x0508      ORR      R5,R5,#0x8
   2455          				dir = dj.dir;					/* New entry */
   \   0000005E   0x9F05             LDR      R7,[SP, #+20]
   \   00000060   0xE008             B.N      ??f_open_7
   2456          			}
   2457          			else {								/* Any object is already existing */
   2458          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_5: (+1)
   \   00000062   0x7AF8             LDRB     R0,[R7, #+11]
   \   00000064   0x2111             MOVS     R1,#+17
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0xD001             BEQ.N    ??f_open_8
   2459          					res = FR_DENIED;
   \   0000006A   0x2607             MOVS     R6,#+7
   \   0000006C   0xE002             B.N      ??f_open_7
   2460          				} else {
   2461          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_8: (+1)
   \   0000006E   0x0768             LSLS     R0,R5,#+29
   \   00000070   0xD500             BPL.N    ??f_open_7
   2462          						res = FR_EXIST;
   \   00000072   0x2608             MOVS     R6,#+8
   2463          				}
   2464          			}
   2465          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_7: (+1)
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xD142             BNE.N    ??f_open_9
   \   00000078   0x0728             LSLS     R0,R5,#+28
   \   0000007A   0xD540             BPL.N    ??f_open_9
   2466          				dw = GET_FATTIME();				/* Created time */
   \   0000007C   0x.... 0x....      BL       get_fattime
   \   00000080   0x4680             MOV      R8,R0
   2467          				ST_DWORD(dir + DIR_CrtTime, dw);
   \   00000082   0xF887 0x800E      STRB     R8,[R7, #+14]
   \   00000086   0xB280             UXTH     R0,R0
   \   00000088   0x0A00             LSRS     R0,R0,#+8
   \   0000008A   0x73F8             STRB     R0,[R7, #+15]
   \   0000008C   0xEA4F 0x4018      LSR      R0,R8,#+16
   \   00000090   0x7438             STRB     R0,[R7, #+16]
   \   00000092   0xEA4F 0x6018      LSR      R0,R8,#+24
   \   00000096   0x7478             STRB     R0,[R7, #+17]
   2468          				dir[DIR_Attr] = 0;				/* Reset attribute */
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x72F8             STRB     R0,[R7, #+11]
   2469          				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
   \   0000009C   0x7738             STRB     R0,[R7, #+28]
   \   0000009E   0x7778             STRB     R0,[R7, #+29]
   \   000000A0   0x77B8             STRB     R0,[R7, #+30]
   \   000000A2   0x77F8             STRB     R0,[R7, #+31]
   2470          				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x.... 0x....      BL       ld_clust
   \   000000AC   0x4681             MOV      R9,R0
   2471          				st_clust(dir, 0);				/* cluster = 0 */
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x4638             MOV      R0,R7
   \   000000B2   0x.... 0x....      BL       st_clust
   2472          				dj.fs->wflag = 1;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x9900             LDR      R1,[SP, #+0]
   \   000000BA   0x7108             STRB     R0,[R1, #+4]
   2473          				if (cl) {						/* Remove the cluster chain if exist */
   \   000000BC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000C0   0xD01D             BEQ.N    ??f_open_9
   2474          					dw = dj.fs->winsect;
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \   000000C4   0xF8D0 0x8030      LDR      R8,[R0, #+48]
   2475          					res = remove_chain(dj.fs, cl);
   \   000000C8   0x4649             MOV      R1,R9
   \   000000CA   0x.... 0x....      BL       remove_chain
   \   000000CE   0x0006             MOVS     R6,R0
   2476          					if (res == FR_OK) {
   \   000000D0   0xD115             BNE.N    ??f_open_9
   2477          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   000000D2   0xF1A9 0x0001      SUB      R0,R9,#+1
   \   000000D6   0x9900             LDR      R1,[SP, #+0]
   \   000000D8   0x60C8             STR      R0,[R1, #+12]
   2478          						res = move_window(dj.fs, dw);
   \   000000DA   0x4641             MOV      R1,R8
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   \   000000DE   0x.... 0x....      BL       move_window
   \   000000E2   0x4606             MOV      R6,R0
   \   000000E4   0xE00B             B.N      ??f_open_9
   2479          					}
   2480          				}
   2481          			}
   2482          		}
   2483          		else {	/* Open an existing file */
   2484          			if (res == FR_OK) {					/* Follow succeeded */
   \                     ??f_open_4: (+1)
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0xD109             BNE.N    ??f_open_9
   2485          				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
   \   000000EA   0x7AF8             LDRB     R0,[R7, #+11]
   \   000000EC   0x06C1             LSLS     R1,R0,#+27
   \   000000EE   0xD501             BPL.N    ??f_open_10
   2486          					res = FR_NO_FILE;
   \   000000F0   0x2604             MOVS     R6,#+4
   \   000000F2   0xE004             B.N      ??f_open_9
   2487          				} else {
   2488          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_10: (+1)
   \   000000F4   0x07A9             LSLS     R1,R5,#+30
   \   000000F6   0xD502             BPL.N    ??f_open_9
   \   000000F8   0x07C0             LSLS     R0,R0,#+31
   \   000000FA   0xD500             BPL.N    ??f_open_9
   2489          						res = FR_DENIED;
   \   000000FC   0x2607             MOVS     R6,#+7
   2490          				}
   2491          			}
   2492          		}
   2493          		if (res == FR_OK) {
   \                     ??f_open_9: (+1)
   \   000000FE   0x0030             MOVS     R0,R6
   \   00000100   0xD107             BNE.N    ??f_open_11
   2494          			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
   \   00000102   0x0728             LSLS     R0,R5,#+28
   \   00000104   0xD501             BPL.N    ??f_open_12
   2495          				mode |= FA__WRITTEN;
   \   00000106   0xF045 0x0520      ORR      R5,R5,#0x20
   2496          			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
   \                     ??f_open_12: (+1)
   \   0000010A   0x9800             LDR      R0,[SP, #+0]
   \   0000010C   0x6B00             LDR      R0,[R0, #+48]
   \   0000010E   0x61E0             STR      R0,[R4, #+28]
   2497          			fp->dir_ptr = dir;
   \   00000110   0x6227             STR      R7,[R4, #+32]
   2498          #if _FS_LOCK
   2499          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2500          			if (!fp->lockid) res = FR_INT_ERR;
   2501          #endif
   2502          		}
   2503          
   2504          #else				/* R/O configuration */
   2505          		if (res == FR_OK) {					/* Follow succeeded */
   2506          			dir = dj.dir;
   2507          			if (!dir) {						/* Current directory itself */
   2508          				res = FR_INVALID_NAME;
   2509          			} else {
   2510          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2511          					res = FR_NO_FILE;
   2512          			}
   2513          		}
   2514          #endif
   2515          		FREE_BUF();
   2516          
   2517          		if (res == FR_OK) {
   \                     ??f_open_11: (+1)
   \   00000112   0x0030             MOVS     R0,R6
   \   00000114   0xD119             BNE.N    ??f_open_2
   2518          			fp->flag = mode;					/* File access mode */
   \   00000116   0x71A5             STRB     R5,[R4, #+6]
   2519          			fp->err = 0;						/* Clear error flag */
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x71E0             STRB     R0,[R4, #+7]
   2520          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   0000011C   0x4639             MOV      R1,R7
   \   0000011E   0x9800             LDR      R0,[SP, #+0]
   \   00000120   0x.... 0x....      BL       ld_clust
   \   00000124   0x6120             STR      R0,[R4, #+16]
   2521          			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
   \   00000126   0x7FF8             LDRB     R0,[R7, #+31]
   \   00000128   0x7FB9             LDRB     R1,[R7, #+30]
   \   0000012A   0x0409             LSLS     R1,R1,#+16
   \   0000012C   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000130   0x7F79             LDRB     R1,[R7, #+29]
   \   00000132   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000136   0x7F39             LDRB     R1,[R7, #+28]
   \   00000138   0x4308             ORRS     R0,R1,R0
   \   0000013A   0x60E0             STR      R0,[R4, #+12]
   2522          			fp->fptr = 0;						/* File pointer */
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x60A0             STR      R0,[R4, #+8]
   2523          			fp->dsect = 0;
   \   00000140   0x61A0             STR      R0,[R4, #+24]
   2524          #if _USE_FASTSEEK
   2525          			fp->cltbl = 0;						/* Normal seek mode */
   2526          #endif
   2527          			fp->fs = dj.fs;	 					/* Validate file object */
   \   00000142   0x9800             LDR      R0,[SP, #+0]
   \   00000144   0x6020             STR      R0,[R4, #+0]
   2528          			fp->id = fp->fs->id;
   \   00000146   0x88C0             LDRH     R0,[R0, #+6]
   \   00000148   0x80A0             STRH     R0,[R4, #+4]
   2529          		}
   2530          	}
   2531          
   2532          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2: (+1)
   \   0000014A   0x4630             MOV      R0,R6
   \                     ??f_open_1: (+1)
   \   0000014C   0xB00D             ADD      SP,SP,#+52
   \   0000014E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2533          }
   2534          
   2535          
   2536          
   2537          
   2538          /*-----------------------------------------------------------------------*/
   2539          /* Read File                                                             */
   2540          /*-----------------------------------------------------------------------*/
   2541          

   \                                 In section .text, align 2, keep-with-next
   2542          FRESULT f_read (
   2543          	FIL* fp, 		/* Pointer to the file object */
   2544          	void* buff,		/* Pointer to data buffer */
   2545          	UINT btr,		/* Number of bytes to read */
   2546          	UINT* br		/* Pointer to number of bytes read */
   2547          )
   2548          {
   \                     f_read: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461E             MOV      R6,R3
   2549          	FRESULT res;
   2550          	DWORD clst, sect, remain;
   2551          	UINT rcnt, cc;
   2552          	BYTE csect, *rbuff = (BYTE*)buff;
   \   0000000A   0x460C             MOV      R4,R1
   2553          
   2554          
   2555          	*br = 0;	/* Clear read byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6030             STR      R0,[R6, #+0]
   2556          
   2557          	res = validate(fp);							/* Check validity */
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       validate
   2558          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xF040 0x809B      BNE.W    ??f_read_0
   2559          	if (fp->err)								/* Check error */
   \   0000001C   0x79E8             LDRB     R0,[R5, #+7]
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0xF040 0x8097      BNE.W    ??f_read_0
   2560          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   2561          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \   00000024   0x79A8             LDRB     R0,[R5, #+6]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD401             BMI.N    ??f_read_1
   2562          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE091             B.N      ??f_read_0
   2563          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_1: (+1)
   \   0000002E   0x68E8             LDR      R0,[R5, #+12]
   \   00000030   0x68A9             LDR      R1,[R5, #+8]
   \   00000032   0x1A40             SUBS     R0,R0,R1
   2564          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   00000034   0x42B8             CMP      R0,R7
   \   00000036   0xD81C             BHI.N    ??f_read_2
   \   00000038   0x4607             MOV      R7,R0
   \   0000003A   0xE01A             B.N      ??f_read_2
   2565          
   2566          	for ( ;  btr;								/* Repeat until all data read */
   2567          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2568          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2569          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2570          			if (!csect) {						/* On the cluster boundary? */
   2571          				if (fp->fptr == 0) {			/* On the top of the file? */
   2572          					clst = fp->sclust;			/* Follow from the origin */
   2573          				} else {						/* Middle or end of the file */
   2574          #if _USE_FASTSEEK
   2575          					if (fp->cltbl)
   2576          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2577          					else
   2578          #endif
   2579          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   2580          				}
   2581          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2582          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2583          				fp->clust = clst;				/* Update current cluster */
   2584          			}
   2585          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2586          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2587          			sect += csect;
   2588          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   2589          			if (cc) {							/* Read maximum contiguous sectors directly */
   2590          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2591          					cc = fp->fs->csize - csect;
   2592          				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
   2593          					ABORT(fp->fs, FR_DISK_ERR);
   2594          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2595          #if _FS_TINY
   2596          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2597          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2598          #else
   2599          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2600          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2601          #endif
   2602          #endif
   2603          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   2604          				continue;
   2605          			}
   2606          #if !_FS_TINY
   2607          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2608          #if !_FS_READONLY
   2609          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2610          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2611          						ABORT(fp->fs, FR_DISK_ERR);
   2612          					fp->flag &= ~FA__DIRTY;
   2613          				}
   2614          #endif
   2615          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2616          					ABORT(fp->fs, FR_DISK_ERR);
   2617          			}
   2618          #endif
   2619          			fp->dsect = sect;
   \                     ??f_read_3: (+1)
   \   0000003C   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2620          		}
   2621          		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_4: (+1)
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   00000046   0xF5C0 0x7100      RSB      R1,R0,#+512
   2622          		if (rcnt > btr) rcnt = btr;
   \   0000004A   0x46B8             MOV      R8,R7
   \   0000004C   0x428F             CMP      R7,R1
   \   0000004E   0xD900             BLS.N    ??f_read_5
   \   00000050   0x4688             MOV      R8,R1
   2623          #if _FS_TINY
   2624          		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
   2625          			ABORT(fp->fs, FR_DISK_ERR);
   2626          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2627          #else
   2628          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_5: (+1)
   \   00000052   0x4642             MOV      R2,R8
   \   00000054   0x4428             ADD      R0,R5,R0
   \   00000056   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_6: (+1)
   \   00000060   0x4444             ADD      R4,R4,R8
   \   00000062   0x68A8             LDR      R0,[R5, #+8]
   \   00000064   0x4440             ADD      R0,R8,R0
   \   00000066   0x60A8             STR      R0,[R5, #+8]
   \   00000068   0x6830             LDR      R0,[R6, #+0]
   \   0000006A   0x4440             ADD      R0,R8,R0
   \   0000006C   0x6030             STR      R0,[R6, #+0]
   \   0000006E   0xEBA7 0x0708      SUB      R7,R7,R8
   \                     ??f_read_2: (+1)
   \   00000072   0x2F00             CMP      R7,#+0
   \   00000074   0xD06C             BEQ.N    ??f_read_7
   \   00000076   0x68A9             LDR      R1,[R5, #+8]
   \   00000078   0x05C8             LSLS     R0,R1,#+23
   \   0000007A   0xD1E1             BNE.N    ??f_read_4
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   \   0000007E   0x7883             LDRB     R3,[R0, #+2]
   \   00000080   0x1E5B             SUBS     R3,R3,#+1
   \   00000082   0xEA03 0x2851      AND      R8,R3,R1, LSR #+9
   \   00000086   0xFA5F 0xF888      UXTB     R8,R8
   \   0000008A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000008E   0xD10C             BNE.N    ??f_read_8
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0xD101             BNE.N    ??f_read_9
   \   00000094   0x6928             LDR      R0,[R5, #+16]
   \   00000096   0xE002             B.N      ??f_read_10
   \                     ??f_read_9: (+1)
   \   00000098   0x6969             LDR      R1,[R5, #+20]
   \   0000009A   0x.... 0x....      BL       get_fat
   \                     ??f_read_10: (+1)
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD30B             BCC.N    ??f_read_11
   \   000000A2   0xF110 0x0F01      CMN      R0,#+1
   \   000000A6   0xD050             BEQ.N    ??f_read_12
   \   000000A8   0x6168             STR      R0,[R5, #+20]
   \                     ??f_read_8: (+1)
   \   000000AA   0x6969             LDR      R1,[R5, #+20]
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x.... 0x....      BL       clust2sect
   \   000000B2   0x4681             MOV      R9,R0
   \   000000B4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B8   0xD102             BNE.N    ??f_read_13
   \                     ??f_read_11: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0x71E8             STRB     R0,[R5, #+7]
   \   000000BE   0xE048             B.N      ??f_read_0
   \                     ??f_read_13: (+1)
   \   000000C0   0x44C1             ADD      R9,R8,R9
   \   000000C2   0xEA5F 0x2A57      LSRS     R10,R7,#+9
   \   000000C6   0xD022             BEQ.N    ??f_read_14
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x7881             LDRB     R1,[R0, #+2]
   \   000000CC   0xEB0A 0x0208      ADD      R2,R10,R8
   \   000000D0   0x4291             CMP      R1,R2
   \   000000D2   0xD201             BCS.N    ??f_read_15
   \   000000D4   0xEBA1 0x0A08      SUB      R10,R1,R8
   \                     ??f_read_15: (+1)
   \   000000D8   0x4653             MOV      R3,R10
   \   000000DA   0x464A             MOV      R2,R9
   \   000000DC   0x4621             MOV      R1,R4
   \   000000DE   0x7840             LDRB     R0,[R0, #+1]
   \   000000E0   0x.... 0x....      BL       disk_read
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD130             BNE.N    ??f_read_12
   \   000000E8   0x79A8             LDRB     R0,[R5, #+6]
   \   000000EA   0x0640             LSLS     R0,R0,#+25
   \   000000EC   0xD50C             BPL.N    ??f_read_16
   \   000000EE   0x69A8             LDR      R0,[R5, #+24]
   \   000000F0   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000F4   0x4550             CMP      R0,R10
   \   000000F6   0xD207             BCS.N    ??f_read_16
   \   000000F8   0xF44F 0x7200      MOV      R2,#+512
   \   000000FC   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000100   0xEB04 0x2040      ADD      R0,R4,R0, LSL #+9
   \   00000104   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_16: (+1)
   \   00000108   0xEA4F 0x284A      LSL      R8,R10,#+9
   \   0000010C   0xE7A8             B.N      ??f_read_6
   \                     ??f_read_14: (+1)
   \   0000010E   0x69AA             LDR      R2,[R5, #+24]
   \   00000110   0x454A             CMP      R2,R9
   \   00000112   0xD093             BEQ.N    ??f_read_3
   \   00000114   0x79A8             LDRB     R0,[R5, #+6]
   \   00000116   0x0640             LSLS     R0,R0,#+25
   \   00000118   0xD50C             BPL.N    ??f_read_17
   \   0000011A   0x2301             MOVS     R3,#+1
   \   0000011C   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000120   0x6828             LDR      R0,[R5, #+0]
   \   00000122   0x7840             LDRB     R0,[R0, #+1]
   \   00000124   0x.... 0x....      BL       disk_write
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD10E             BNE.N    ??f_read_12
   \   0000012C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000012E   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000132   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_read_17: (+1)
   \   00000134   0x2301             MOVS     R3,#+1
   \   00000136   0x464A             MOV      R2,R9
   \   00000138   0xF105 0x0124      ADD      R1,R5,#+36
   \   0000013C   0x6828             LDR      R0,[R5, #+0]
   \   0000013E   0x7840             LDRB     R0,[R0, #+1]
   \   00000140   0x.... 0x....      BL       disk_read
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xF43F 0xAF79      BEQ.W    ??f_read_3
   \                     ??f_read_12: (+1)
   \   0000014A   0x2001             MOVS     R0,#+1
   \   0000014C   0x71E8             STRB     R0,[R5, #+7]
   \   0000014E   0xE000             B.N      ??f_read_0
   2629          #endif
   2630          	}
   2631          
   2632          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_7: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \                     ??f_read_0: (+1)
   \   00000152   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2633          }
   2634          
   2635          
   2636          
   2637          
   2638          #if !_FS_READONLY
   2639          /*-----------------------------------------------------------------------*/
   2640          /* Write File                                                            */
   2641          /*-----------------------------------------------------------------------*/
   2642          

   \                                 In section .text, align 2, keep-with-next
   2643          FRESULT f_write (
   2644          	FIL* fp,			/* Pointer to the file object */
   2645          	const void *buff,	/* Pointer to the data to be written */
   2646          	UINT btw,			/* Number of bytes to write */
   2647          	UINT* bw			/* Pointer to number of bytes written */
   2648          )
   2649          {
   \                     f_write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461E             MOV      R6,R3
   2650          	FRESULT res;
   2651          	DWORD clst, sect;
   2652          	UINT wcnt, cc;
   2653          	const BYTE *wbuff = (const BYTE*)buff;
   \   0000000A   0x460C             MOV      R4,R1
   2654          	BYTE csect;
   2655          
   2656          
   2657          	*bw = 0;	/* Clear write byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6030             STR      R0,[R6, #+0]
   2658          
   2659          	res = validate(fp);						/* Check validity */
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       validate
   2660          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xF040 0x80BD      BNE.W    ??f_write_0
   2661          	if (fp->err)							/* Check error */
   \   0000001C   0x79E8             LDRB     R0,[R5, #+7]
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0xF040 0x80B9      BNE.W    ??f_write_0
   2662          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   2663          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \   00000024   0x79A8             LDRB     R0,[R5, #+6]
   \   00000026   0x0780             LSLS     R0,R0,#+30
   \   00000028   0xD401             BMI.N    ??f_write_1
   2664          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE0B3             B.N      ??f_write_0
   2665          	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_1: (+1)
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x1839             ADDS     R1,R7,R0
   \   00000032   0x4281             CMP      R1,R0
   \   00000034   0xD21F             BCS.N    ??f_write_2
   \   00000036   0x2700             MOVS     R7,#+0
   \   00000038   0xE01D             B.N      ??f_write_2
   2666          
   2667          	for ( ;  btw;							/* Repeat until all data written */
   2668          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2669          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2670          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2671          			if (!csect) {					/* On the cluster boundary? */
   2672          				if (fp->fptr == 0) {		/* On the top of the file? */
   2673          					clst = fp->sclust;		/* Follow from the origin */
   2674          					if (clst == 0)			/* When no cluster is allocated, */
   2675          						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2676          				} else {					/* Middle or end of the file */
   2677          #if _USE_FASTSEEK
   2678          					if (fp->cltbl)
   2679          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2680          					else
   2681          #endif
   2682          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2683          				}
   2684          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2685          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2686          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2687          				fp->clust = clst;			/* Update current cluster */
   2688          				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
   2689          			}
   2690          #if _FS_TINY
   2691          			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
   2692          				ABORT(fp->fs, FR_DISK_ERR);
   2693          #else
   2694          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2695          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2696          					ABORT(fp->fs, FR_DISK_ERR);
   2697          				fp->flag &= ~FA__DIRTY;
   2698          			}
   2699          #endif
   2700          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2701          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2702          			sect += csect;
   2703          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2704          			if (cc) {						/* Write maximum contiguous sectors directly */
   2705          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2706          					cc = fp->fs->csize - csect;
   2707          				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
   2708          					ABORT(fp->fs, FR_DISK_ERR);
   2709          #if _FS_MINIMIZE <= 2
   2710          #if _FS_TINY
   2711          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2712          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2713          					fp->fs->wflag = 0;
   2714          				}
   2715          #else
   2716          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2717          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2718          					fp->flag &= ~FA__DIRTY;
   2719          				}
   2720          #endif
   2721          #endif
   2722          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2723          				continue;
   2724          			}
   2725          #if _FS_TINY
   2726          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2727          				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
   2728          				fp->fs->winsect = sect;
   2729          			}
   2730          #else
   2731          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2732          				if (fp->fptr < fp->fsize &&
   2733          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2734          						ABORT(fp->fs, FR_DISK_ERR);
   2735          			}
   2736          #endif
   2737          			fp->dsect = sect;
   \                     ??f_write_3: (+1)
   \   0000003A   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2738          		}
   2739          		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   \                     ??f_write_4: (+1)
   \   0000003E   0x68A8             LDR      R0,[R5, #+8]
   \   00000040   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   00000044   0xF5C0 0x7100      RSB      R1,R0,#+512
   2740          		if (wcnt > btw) wcnt = btw;
   \   00000048   0x46B8             MOV      R8,R7
   \   0000004A   0x428F             CMP      R7,R1
   \   0000004C   0xD900             BLS.N    ??f_write_5
   \   0000004E   0x4688             MOV      R8,R1
   2741          #if _FS_TINY
   2742          		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
   2743          			ABORT(fp->fs, FR_DISK_ERR);
   2744          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2745          		fp->fs->wflag = 1;
   2746          #else
   2747          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_5: (+1)
   \   00000050   0x4642             MOV      R2,R8
   \   00000052   0x4621             MOV      R1,R4
   \   00000054   0x4428             ADD      R0,R5,R0
   \   00000056   0x3024             ADDS     R0,R0,#+36
   \   00000058   0x.... 0x....      BL       mem_cpy
   2748          		fp->flag |= FA__DIRTY;
   \   0000005C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000005E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000062   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_6: (+1)
   \   00000064   0x4444             ADD      R4,R4,R8
   \   00000066   0x68A8             LDR      R0,[R5, #+8]
   \   00000068   0x4440             ADD      R0,R8,R0
   \   0000006A   0x60A8             STR      R0,[R5, #+8]
   \   0000006C   0x6830             LDR      R0,[R6, #+0]
   \   0000006E   0x4440             ADD      R0,R8,R0
   \   00000070   0x6030             STR      R0,[R6, #+0]
   \   00000072   0xEBA7 0x0708      SUB      R7,R7,R8
   \                     ??f_write_2: (+1)
   \   00000076   0x2F00             CMP      R7,#+0
   \   00000078   0xF000 0x8082      BEQ.W    ??f_write_7
   \   0000007C   0x68A9             LDR      R1,[R5, #+8]
   \   0000007E   0x05C8             LSLS     R0,R1,#+23
   \   00000080   0xD1DD             BNE.N    ??f_write_4
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x7883             LDRB     R3,[R0, #+2]
   \   00000086   0x1E5B             SUBS     R3,R3,#+1
   \   00000088   0xEA03 0x2851      AND      R8,R3,R1, LSR #+9
   \   0000008C   0xFA5F 0xF888      UXTB     R8,R8
   \   00000090   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000094   0xD119             BNE.N    ??f_write_8
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD107             BNE.N    ??f_write_9
   \   0000009A   0x6929             LDR      R1,[R5, #+16]
   \   0000009C   0x2900             CMP      R1,#+0
   \   0000009E   0xD108             BNE.N    ??f_write_10
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x.... 0x....      BL       create_chain
   \   000000A6   0x4601             MOV      R1,R0
   \   000000A8   0xE003             B.N      ??f_write_10
   \                     ??f_write_9: (+1)
   \   000000AA   0x6969             LDR      R1,[R5, #+20]
   \   000000AC   0x.... 0x....      BL       create_chain
   \   000000B0   0x4601             MOV      R1,R0
   \                     ??f_write_10: (+1)
   \   000000B2   0x2900             CMP      R1,#+0
   \   000000B4   0xD064             BEQ.N    ??f_write_7
   \   000000B6   0x2901             CMP      R1,#+1
   \   000000B8   0xD020             BEQ.N    ??f_write_11
   \   000000BA   0xF111 0x0F01      CMN      R1,#+1
   \   000000BE   0xD05C             BEQ.N    ??f_write_12
   \   000000C0   0x6169             STR      R1,[R5, #+20]
   \   000000C2   0x6928             LDR      R0,[R5, #+16]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD100             BNE.N    ??f_write_8
   \   000000C8   0x6129             STR      R1,[R5, #+16]
   \                     ??f_write_8: (+1)
   \   000000CA   0x79A8             LDRB     R0,[R5, #+6]
   \   000000CC   0x0640             LSLS     R0,R0,#+25
   \   000000CE   0xD50D             BPL.N    ??f_write_13
   \   000000D0   0x2301             MOVS     R3,#+1
   \   000000D2   0x69AA             LDR      R2,[R5, #+24]
   \   000000D4   0xF105 0x0124      ADD      R1,R5,#+36
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x7840             LDRB     R0,[R0, #+1]
   \   000000DC   0x.... 0x....      BL       disk_write
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD14A             BNE.N    ??f_write_12
   \   000000E4   0x79A8             LDRB     R0,[R5, #+6]
   \   000000E6   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   000000EA   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_13: (+1)
   \   000000EC   0x6969             LDR      R1,[R5, #+20]
   \   000000EE   0x6828             LDR      R0,[R5, #+0]
   \   000000F0   0x.... 0x....      BL       clust2sect
   \   000000F4   0x4681             MOV      R9,R0
   \   000000F6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000FA   0xD102             BNE.N    ??f_write_14
   \                     ??f_write_11: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0x71E8             STRB     R0,[R5, #+7]
   \   00000100   0xE049             B.N      ??f_write_0
   \                     ??f_write_14: (+1)
   \   00000102   0x44C1             ADD      R9,R8,R9
   \   00000104   0xEA5F 0x2A57      LSRS     R10,R7,#+9
   \   00000108   0xD023             BEQ.N    ??f_write_15
   \   0000010A   0x6828             LDR      R0,[R5, #+0]
   \   0000010C   0x7881             LDRB     R1,[R0, #+2]
   \   0000010E   0xEB0A 0x0208      ADD      R2,R10,R8
   \   00000112   0x4291             CMP      R1,R2
   \   00000114   0xD201             BCS.N    ??f_write_16
   \   00000116   0xEBA1 0x0A08      SUB      R10,R1,R8
   \                     ??f_write_16: (+1)
   \   0000011A   0x4653             MOV      R3,R10
   \   0000011C   0x464A             MOV      R2,R9
   \   0000011E   0x4621             MOV      R1,R4
   \   00000120   0x7840             LDRB     R0,[R0, #+1]
   \   00000122   0x.... 0x....      BL       disk_write
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD127             BNE.N    ??f_write_12
   \   0000012A   0x69A8             LDR      R0,[R5, #+24]
   \   0000012C   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000130   0x4550             CMP      R0,R10
   \   00000132   0xD20B             BCS.N    ??f_write_17
   \   00000134   0xF44F 0x7200      MOV      R2,#+512
   \   00000138   0xEB14 0x2140      ADDS     R1,R4,R0, LSL #+9
   \   0000013C   0xF105 0x0024      ADD      R0,R5,#+36
   \   00000140   0x.... 0x....      BL       mem_cpy
   \   00000144   0x79A8             LDRB     R0,[R5, #+6]
   \   00000146   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   0000014A   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_17: (+1)
   \   0000014C   0xEA4F 0x284A      LSL      R8,R10,#+9
   \   00000150   0xE788             B.N      ??f_write_6
   \                     ??f_write_15: (+1)
   \   00000152   0x69A8             LDR      R0,[R5, #+24]
   \   00000154   0x4548             CMP      R0,R9
   \   00000156   0xF43F 0xAF70      BEQ.W    ??f_write_3
   \   0000015A   0x68A8             LDR      R0,[R5, #+8]
   \   0000015C   0x68E9             LDR      R1,[R5, #+12]
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xF4BF 0xAF6B      BCS.W    ??f_write_3
   \   00000164   0x2301             MOVS     R3,#+1
   \   00000166   0x464A             MOV      R2,R9
   \   00000168   0xF105 0x0124      ADD      R1,R5,#+36
   \   0000016C   0x6828             LDR      R0,[R5, #+0]
   \   0000016E   0x7840             LDRB     R0,[R0, #+1]
   \   00000170   0x.... 0x....      BL       disk_read
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xF43F 0xAF60      BEQ.W    ??f_write_3
   \                     ??f_write_12: (+1)
   \   0000017A   0x2001             MOVS     R0,#+1
   \   0000017C   0x71E8             STRB     R0,[R5, #+7]
   \   0000017E   0xE00A             B.N      ??f_write_0
   2749          #endif
   2750          	}
   2751          
   2752          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_7: (+1)
   \   00000180   0x68E8             LDR      R0,[R5, #+12]
   \   00000182   0x68A9             LDR      R1,[R5, #+8]
   \   00000184   0x4288             CMP      R0,R1
   \   00000186   0xD200             BCS.N    ??f_write_18
   \   00000188   0x4608             MOV      R0,R1
   \                     ??f_write_18: (+1)
   \   0000018A   0x60E8             STR      R0,[R5, #+12]
   2753          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \   0000018C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000018E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000192   0x71A8             STRB     R0,[R5, #+6]
   2754          
   2755          	LEAVE_FF(fp->fs, FR_OK);
   \   00000194   0x2000             MOVS     R0,#+0
   \                     ??f_write_0: (+1)
   \   00000196   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2756          }
   2757          
   2758          
   2759          
   2760          
   2761          /*-----------------------------------------------------------------------*/
   2762          /* Synchronize the File                                                  */
   2763          /*-----------------------------------------------------------------------*/
   2764          

   \                                 In section .text, align 2, keep-with-next
   2765          FRESULT f_sync (
   2766          	FIL* fp		/* Pointer to the file object */
   2767          )
   2768          {
   \                     f_sync: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2769          	FRESULT res;
   2770          	DWORD tm;
   2771          	BYTE *dir;
   2772          
   2773          
   2774          	res = validate(fp);					/* Check validity of the object */
   \   00000004   0x.... 0x....      BL       validate
   2775          	if (res == FR_OK) {
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD149             BNE.N    ??f_sync_0
   2776          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   0000000C   0x79A1             LDRB     R1,[R4, #+6]
   \   0000000E   0x068A             LSLS     R2,R1,#+26
   \   00000010   0xD546             BPL.N    ??f_sync_0
   2777          			/* Write-back dirty buffer */
   2778          #if !_FS_TINY
   2779          			if (fp->flag & FA__DIRTY) {
   \   00000012   0x0648             LSLS     R0,R1,#+25
   \   00000014   0xD50F             BPL.N    ??f_sync_1
   2780          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x69A2             LDR      R2,[R4, #+24]
   \   0000001A   0xF104 0x0124      ADD      R1,R4,#+36
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x7840             LDRB     R0,[R0, #+1]
   \   00000022   0x.... 0x....      BL       disk_write
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??f_sync_2
   2781          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}
   2782          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2: (+1)
   \   0000002E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000030   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000034   0x71A0             STRB     R0,[R4, #+6]
   2783          			}
   2784          #endif
   2785          			/* Update the directory entry */
   2786          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1: (+1)
   \   00000036   0x69E1             LDR      R1,[R4, #+28]
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       move_window
   2787          			if (res == FR_OK) {
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0xD12E             BNE.N    ??f_sync_0
   2788          				dir = fp->dir_ptr;
   \   00000042   0x6A25             LDR      R5,[R4, #+32]
   2789          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   00000044   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000046   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000004A   0x72E8             STRB     R0,[R5, #+11]
   2790          				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x7728             STRB     R0,[R5, #+28]
   \   00000050   0x68E0             LDR      R0,[R4, #+12]
   \   00000052   0xB280             UXTH     R0,R0
   \   00000054   0x0A00             LSRS     R0,R0,#+8
   \   00000056   0x7768             STRB     R0,[R5, #+29]
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x0C00             LSRS     R0,R0,#+16
   \   0000005C   0x77A8             STRB     R0,[R5, #+30]
   \   0000005E   0x68E0             LDR      R0,[R4, #+12]
   \   00000060   0x0E00             LSRS     R0,R0,#+24
   \   00000062   0x77E8             STRB     R0,[R5, #+31]
   2791          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   00000064   0x6921             LDR      R1,[R4, #+16]
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       st_clust
   2792          				tm = GET_FATTIME();							/* Update updated time */
   \   0000006C   0x.... 0x....      BL       get_fattime
   2793          				ST_DWORD(dir + DIR_WrtTime, tm);
   \   00000070   0x75A8             STRB     R0,[R5, #+22]
   \   00000072   0x4601             MOV      R1,R0
   \   00000074   0xB289             UXTH     R1,R1
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0x75E9             STRB     R1,[R5, #+23]
   \   0000007A   0x0C01             LSRS     R1,R0,#+16
   \   0000007C   0x7629             STRB     R1,[R5, #+24]
   \   0000007E   0x0E00             LSRS     R0,R0,#+24
   \   00000080   0x7668             STRB     R0,[R5, #+25]
   2794          				ST_WORD(dir + DIR_LstAccDate, 0);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x74A8             STRB     R0,[R5, #+18]
   \   00000086   0x74E8             STRB     R0,[R5, #+19]
   2795          				fp->flag &= ~FA__WRITTEN;
   \   00000088   0x79A0             LDRB     R0,[R4, #+6]
   \   0000008A   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   0000008E   0x71A0             STRB     R0,[R4, #+6]
   2796          				fp->fs->wflag = 1;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x7108             STRB     R0,[R1, #+4]
   2797          				res = sync_fs(fp->fs);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000009C   0x.... 0x....      B.W      sync_fs
   2798          			}
   2799          		}
   2800          	}
   2801          
   2802          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0: (+1)
   \   000000A0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2803          }
   2804          
   2805          #endif /* !_FS_READONLY */
   2806          
   2807          
   2808          
   2809          
   2810          /*-----------------------------------------------------------------------*/
   2811          /* Close File                                                            */
   2812          /*-----------------------------------------------------------------------*/
   2813          

   \                                 In section .text, align 2, keep-with-next
   2814          FRESULT f_close (
   2815          	FIL *fp		/* Pointer to the file object to be closed */
   2816          )
   2817          {
   \                     f_close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2818          	FRESULT res;
   2819          
   2820          
   2821          #if !_FS_READONLY
   2822          	res = f_sync(fp);					/* Flush cached data */
   \   00000004   0x.... 0x....      BL       f_sync
   2823          	if (res == FR_OK)
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD106             BNE.N    ??f_close_0
   2824          #endif
   2825          	{
   2826          		res = validate(fp);				/* Lock volume */
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       validate
   2827          		if (res == FR_OK) {
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD101             BNE.N    ??f_close_0
   2828          #if _FS_REENTRANT
   2829          			FATFS *fs = fp->fs;
   2830          #endif
   2831          #if _FS_LOCK
   2832          			res = dec_lock(fp->lockid);	/* Decrement file open counter */
   2833          			if (res == FR_OK)
   2834          #endif
   2835          				fp->fs = 0;				/* Invalidate file object */
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6021             STR      R1,[R4, #+0]
   2836          #if _FS_REENTRANT
   2837          			unlock_fs(fs, FR_OK);		/* Unlock volume */
   2838          #endif
   2839          		}
   2840          	}
   2841          	return res;
   \                     ??f_close_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   2842          }
   2843          
   2844          
   2845          
   2846          
   2847          /*-----------------------------------------------------------------------*/
   2848          /* Change Current Directory or Current Drive, Get Current Directory      */
   2849          /*-----------------------------------------------------------------------*/
   2850          
   2851          #if _FS_RPATH >= 1
   2852          #if _VOLUMES >= 2

   \                                 In section .text, align 2, keep-with-next
   2853          FRESULT f_chdrive (
   2854          	const TCHAR* path		/* Drive number */
   2855          )
   2856          {
   \                     f_chdrive: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   2857          	int vol;
   2858          
   2859          
   2860          	vol = get_ldnumber(&path);
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x.... 0x....      BL       get_ldnumber
   2861          	if (vol < 0) return FR_INVALID_DRIVE;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD501             BPL.N    ??f_chdrive_0
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xBD02             POP      {R1,PC}
   2862          
   2863          	CurrVol = (BYTE)vol;
   \                     ??f_chdrive_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable10_1
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   2864          
   2865          	return FR_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
   2866          }
   2867          #endif
   2868          
   2869          

   \                                 In section .text, align 2, keep-with-next
   2870          FRESULT f_chdir (
   2871          	const TCHAR* path	/* Pointer to the directory path */
   2872          )
   2873          {
   \                     f_chdir: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   2874          	FRESULT res;
   2875          	DIR dj;
   2876          	DEFINE_NAMEBUF;
   2877          
   2878          
   2879          	/* Get logical drive number */
   2880          	res = find_volume(&dj.fs, &path, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xA90B             ADD      R1,SP,#+44
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       find_volume
   \   0000000E   0x0004             MOVS     R4,R0
   2881          	if (res == FR_OK) {
   \   00000010   0xD11B             BNE.N    ??f_chdir_0
   2882          		INIT_BUF(dj);
   \   00000012   0xA808             ADD      R0,SP,#+32
   \   00000014   0x9006             STR      R0,[SP, #+24]
   2883          		res = follow_path(&dj, path);		/* Follow the path */
   \   00000016   0x990B             LDR      R1,[SP, #+44]
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x.... 0x....      BL       follow_path
   \   0000001E   0x0004             MOVS     R4,R0
   2884          		FREE_BUF();
   2885          		if (res == FR_OK) {					/* Follow completed */
   \   00000020   0xD110             BNE.N    ??f_chdir_1
   2886          			if (!dj.dir) {
   \   00000022   0x9905             LDR      R1,[SP, #+20]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD103             BNE.N    ??f_chdir_2
   2887          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   00000028   0x9802             LDR      R0,[SP, #+8]
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0x6148             STR      R0,[R1, #+20]
   \   0000002E   0xE009             B.N      ??f_chdir_1
   2888          			} else {
   2889          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_2: (+1)
   \   00000030   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000032   0x06C0             LSLS     R0,R0,#+27
   \   00000034   0xD505             BPL.N    ??f_chdir_3
   2890          					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x.... 0x....      BL       ld_clust
   \   0000003C   0x9900             LDR      R1,[SP, #+0]
   \   0000003E   0x6148             STR      R0,[R1, #+20]
   \   00000040   0xE000             B.N      ??f_chdir_1
   2891          				else
   2892          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_3: (+1)
   \   00000042   0x2405             MOVS     R4,#+5
   2893          			}
   2894          		}
   2895          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_1: (+1)
   \   00000044   0x2C04             CMP      R4,#+4
   \   00000046   0xD100             BNE.N    ??f_chdir_0
   \   00000048   0x2405             MOVS     R4,#+5
   2896          	}
   2897          
   2898          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0xB00C             ADD      SP,SP,#+48
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   2899          }
   2900          
   2901          
   2902          #if _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   2903          FRESULT f_getcwd (
   2904          	TCHAR* buff,	/* Pointer to the directory path */
   2905          	UINT len		/* Size of path */
   2906          )
   2907          {
   \                     f_getcwd: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x460C             MOV      R4,R1
   2908          	FRESULT res;
   2909          	DIR dj;
   2910          	UINT i, n;
   2911          	DWORD ccl;
   2912          	TCHAR *tp;
   2913          	FILINFO fno;
   2914          	DEFINE_NAMEBUF;
   2915          
   2916          
   2917          	*buff = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9912             LDR      R1,[SP, #+72]
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
   2918          	/* Get logical drive number */
   2919          	res = find_volume(&dj.fs, (const TCHAR**)&buff, 0);	/* Get current volume */
   \   0000000C   0x4602             MOV      R2,R0
   \   0000000E   0xA912             ADD      R1,SP,#+72
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       find_volume
   \   00000016   0x0005             MOVS     R5,R0
   2920          	if (res == FR_OK) {
   \   00000018   0xD16C             BNE.N    ??f_getcwd_0
   2921          		INIT_BUF(dj);
   \   0000001A   0xA808             ADD      R0,SP,#+32
   \   0000001C   0x9006             STR      R0,[SP, #+24]
   2922          		i = len;			/* Bottom of buffer (directory stack base) */
   \   0000001E   0x4626             MOV      R6,R4
   2923          		dj.sclust = dj.fs->cdir;			/* Start to follow upper directory from current directory */
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x6940             LDR      R0,[R0, #+20]
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0xE00B             B.N      ??f_getcwd_1
   2924          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
   2925          			res = dir_sdi(&dj, 1);			/* Get parent directory */
   2926          			if (res != FR_OK) break;
   2927          			res = dir_read(&dj, 0);
   2928          			if (res != FR_OK) break;
   2929          			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent directory */
   2930          			res = dir_sdi(&dj, 0);
   2931          			if (res != FR_OK) break;
   2932          			do {							/* Find the entry links to the child directory */
   2933          				res = dir_read(&dj, 0);
   2934          				if (res != FR_OK) break;
   2935          				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
   2936          				res = dir_next(&dj, 0);	
   2937          			} while (res == FR_OK);
   2938          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2939          			if (res != FR_OK) break;
   2940          #if _USE_LFN
   2941          			fno.lfname = buff;
   2942          			fno.lfsize = i;
   2943          #endif
   2944          			get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
   2945          			tp = fno.fname;
   2946          #if _USE_LFN
   2947          			if (*buff) tp = buff;
   2948          #endif
   2949          			for (n = 0; tp[n]; n++) ;
   2950          			if (i < n + 3) {
   2951          				res = FR_NOT_ENOUGH_CORE; break;
   2952          			}
   2953          			while (n) buff[--i] = tp[--n];
   \                     ??f_getcwd_2: (+1)
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0xA90B             ADD      R1,SP,#+44
   \   0000002C   0x4401             ADD      R1,R1,R0
   \   0000002E   0x7A49             LDRB     R1,[R1, #+9]
   \   00000030   0x9A12             LDR      R2,[SP, #+72]
   \   00000032   0x5591             STRB     R1,[R2, R6]
   \                     ??f_getcwd_3: (+1)
   \   00000034   0x1E76             SUBS     R6,R6,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F6             BNE.N    ??f_getcwd_2
   2954          			buff[--i] = '/';
   \   0000003A   0x202F             MOVS     R0,#+47
   \   0000003C   0x9912             LDR      R1,[SP, #+72]
   \   0000003E   0x5588             STRB     R0,[R1, R6]
   \                     ??f_getcwd_1: (+1)
   \   00000040   0x9F02             LDR      R7,[SP, #+8]
   \   00000042   0x2F00             CMP      R7,#+0
   \   00000044   0xD03D             BEQ.N    ??f_getcwd_4
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x.... 0x....      BL       dir_sdi
   \   0000004E   0x0005             MOVS     R5,R0
   \   00000050   0xD137             BNE.N    ??f_getcwd_4
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       dir_read
   \   0000005A   0x0005             MOVS     R5,R0
   \   0000005C   0xD131             BNE.N    ??f_getcwd_4
   \   0000005E   0x9905             LDR      R1,[SP, #+20]
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x.... 0x....      BL       ld_clust
   \   00000066   0x9002             STR      R0,[SP, #+8]
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x.... 0x....      BL       dir_sdi
   \   00000070   0x0005             MOVS     R5,R0
   \   00000072   0xD126             BNE.N    ??f_getcwd_4
   \                     ??f_getcwd_5: (+1)
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x.... 0x....      BL       dir_read
   \   0000007C   0x0005             MOVS     R5,R0
   \   0000007E   0xD10B             BNE.N    ??f_getcwd_6
   \   00000080   0x9905             LDR      R1,[SP, #+20]
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x.... 0x....      BL       ld_clust
   \   00000088   0x4287             CMP      R7,R0
   \   0000008A   0xD005             BEQ.N    ??f_getcwd_6
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x.... 0x....      BL       dir_next
   \   00000094   0x0005             MOVS     R5,R0
   \   00000096   0xD0ED             BEQ.N    ??f_getcwd_5
   \                     ??f_getcwd_6: (+1)
   \   00000098   0x2D04             CMP      R5,#+4
   \   0000009A   0xD100             BNE.N    ??f_getcwd_7
   \   0000009C   0x2502             MOVS     R5,#+2
   \                     ??f_getcwd_7: (+1)
   \   0000009E   0x2D00             CMP      R5,#+0
   \   000000A0   0xD10F             BNE.N    ??f_getcwd_4
   \   000000A2   0xA90B             ADD      R1,SP,#+44
   \   000000A4   0x4668             MOV      R0,SP
   \   000000A6   0x.... 0x....      BL       get_fileinfo
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xE000             B.N      ??f_getcwd_8
   \                     ??f_getcwd_9: (+1)
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_getcwd_8: (+1)
   \   000000B0   0xA90B             ADD      R1,SP,#+44
   \   000000B2   0x4401             ADD      R1,R1,R0
   \   000000B4   0x7A49             LDRB     R1,[R1, #+9]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD1F9             BNE.N    ??f_getcwd_9
   \   000000BA   0x1CC1             ADDS     R1,R0,#+3
   \   000000BC   0x428E             CMP      R6,R1
   \   000000BE   0xD2B9             BCS.N    ??f_getcwd_3
   \   000000C0   0x2511             MOVS     R5,#+17
   2955          		}
   2956          		tp = buff;
   \                     ??f_getcwd_4: (+1)
   \   000000C2   0x9812             LDR      R0,[SP, #+72]
   2957          		if (res == FR_OK) {
   \   000000C4   0x0029             MOVS     R1,R5
   \   000000C6   0xD113             BNE.N    ??f_getcwd_10
   2958          #if _VOLUMES >= 2
   2959          			*tp++ = '0' + CurrVol;			/* Put drive number */
   \   000000C8   0x....             LDR.N    R1,??DataTable10_1
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0x3130             ADDS     R1,R1,#+48
   \   000000CE   0x7001             STRB     R1,[R0, #+0]
   2960          			*tp++ = ':';
   \   000000D0   0x213A             MOVS     R1,#+58
   \   000000D2   0x7041             STRB     R1,[R0, #+1]
   \   000000D4   0x1C80             ADDS     R0,R0,#+2
   2961          #endif
   2962          			if (i == len) {					/* Root-directory */
   \   000000D6   0x42A6             CMP      R6,R4
   \   000000D8   0xD103             BNE.N    ??f_getcwd_11
   2963          				*tp++ = '/';
   \   000000DA   0x212F             MOVS     R1,#+47
   \   000000DC   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   000000E0   0xE006             B.N      ??f_getcwd_10
   2964          			} else {						/* Sub-directroy */
   2965          				do		/* Add stacked path str */
   2966          					*tp++ = buff[i++];
   \                     ??f_getcwd_11: (+1)
   \   000000E2   0x9912             LDR      R1,[SP, #+72]
   \   000000E4   0x5D89             LDRB     R1,[R1, R6]
   \   000000E6   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   000000EA   0x1C76             ADDS     R6,R6,#+1
   2967          				while (i < len);
   \   000000EC   0x42A6             CMP      R6,R4
   \   000000EE   0xD3F8             BCC.N    ??f_getcwd_11
   2968          			}
   2969          		}
   2970          		*tp = 0;
   \                     ??f_getcwd_10: (+1)
   \   000000F0   0x2100             MOVS     R1,#+0
   \   000000F2   0x7001             STRB     R1,[R0, #+0]
   2971          		FREE_BUF();
   2972          	}
   2973          
   2974          	LEAVE_FF(dj.fs, res);
   \                     ??f_getcwd_0: (+1)
   \   000000F4   0x4628             MOV      R0,R5
   \   000000F6   0xB013             ADD      SP,SP,#+76
   \   000000F8   0xBDF0             POP      {R4-R7,PC}       ;; return
   2975          }
   2976          #endif /* _FS_RPATH >= 2 */
   2977          #endif /* _FS_RPATH >= 1 */
   2978          
   2979          
   2980          
   2981          #if _FS_MINIMIZE <= 2
   2982          /*-----------------------------------------------------------------------*/
   2983          /* Seek File R/W Pointer                                                 */
   2984          /*-----------------------------------------------------------------------*/
   2985          

   \                                 In section .text, align 2, keep-with-next
   2986          FRESULT f_lseek (
   2987          	FIL* fp,		/* Pointer to the file object */
   2988          	DWORD ofs		/* File pointer from top of file */
   2989          )
   2990          {
   \                     f_lseek: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   2991          	FRESULT res;
   2992          	DWORD clst, bcs, nsect, ifptr;
   2993          #if _USE_FASTSEEK
   2994          	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2995          #endif
   2996          
   2997          
   2998          	res = validate(fp);					/* Check validity of the object */
   \   00000008   0x.... 0x....      BL       validate
   \   0000000C   0x0005             MOVS     R5,R0
   2999          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   0000000E   0xF040 0x8091      BNE.W    ??f_lseek_0
   3000          	if (fp->err)						/* Check error */
   \   00000012   0x79E0             LDRB     R0,[R4, #+7]
   \   00000014   0x0001             MOVS     R1,R0
   \   00000016   0xF040 0x808E      BNE.W    ??f_lseek_1
   3001          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   3002          
   3003          #if _USE_FASTSEEK
   3004          	if (fp->cltbl) {	/* Fast seek */
   3005          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   3006          			tbl = fp->cltbl;
   3007          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   3008          			cl = fp->sclust;			/* Top of the chain */
   3009          			if (cl) {
   3010          				do {
   3011          					/* Get a fragment */
   3012          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   3013          					do {
   3014          						pcl = cl; ncl++;
   3015          						cl = get_fat(fp->fs, cl);
   3016          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   3017          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3018          					} while (cl == pcl + 1);
   3019          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   3020          						*tbl++ = ncl; *tbl++ = tcl;
   3021          					}
   3022          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   3023          			}
   3024          			*fp->cltbl = ulen;	/* Number of items used */
   3025          			if (ulen <= tlen)
   3026          				*tbl = 0;		/* Terminate table */
   3027          			else
   3028          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   3029          
   3030          		} else {						/* Fast seek */
   3031          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   3032          				ofs = fp->fsize;
   3033          			fp->fptr = ofs;				/* Set file pointer */
   3034          			if (ofs) {
   3035          				fp->clust = clmt_clust(fp, ofs - 1);
   3036          				dsc = clust2sect(fp->fs, fp->clust);
   3037          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   3038          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   3039          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   3040          #if !_FS_TINY
   3041          #if !_FS_READONLY
   3042          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   3043          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3044          							ABORT(fp->fs, FR_DISK_ERR);
   3045          						fp->flag &= ~FA__DIRTY;
   3046          					}
   3047          #endif
   3048          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   3049          						ABORT(fp->fs, FR_DISK_ERR);
   3050          #endif
   3051          					fp->dsect = dsc;
   3052          				}
   3053          			}
   3054          		}
   3055          	} else
   3056          #endif
   3057          
   3058          	/* Normal Seek */
   3059          	{
   3060          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   3061          #if !_FS_READONLY
   3062          			 && !(fp->flag & FA_WRITE)
   3063          #endif
   3064          			) ofs = fp->fsize;
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x42B0             CMP      R0,R6
   \   0000001E   0xD203             BCS.N    ??f_lseek_2
   \   00000020   0x79A1             LDRB     R1,[R4, #+6]
   \   00000022   0x0789             LSLS     R1,R1,#+30
   \   00000024   0xD400             BMI.N    ??f_lseek_2
   \   00000026   0x4606             MOV      R6,R0
   3065          
   3066          		ifptr = fp->fptr;
   \                     ??f_lseek_2: (+1)
   \   00000028   0x68A1             LDR      R1,[R4, #+8]
   3067          		fp->fptr = nsect = 0;
   \   0000002A   0x2700             MOVS     R7,#+0
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x60A0             STR      R0,[R4, #+8]
   3068          		if (ofs) {
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD052             BEQ.N    ??f_lseek_3
   3069          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x7882             LDRB     R2,[R0, #+2]
   \   00000038   0xEA4F 0x2842      LSL      R8,R2,#+9
   3070          			if (ifptr > 0 &&
   3071          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD00F             BEQ.N    ??f_lseek_4
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0xFBB1 0xF2F8      UDIV     R2,R1,R8
   \   00000046   0x1E73             SUBS     R3,R6,#+1
   \   00000048   0xFBB3 0xF3F8      UDIV     R3,R3,R8
   \   0000004C   0x4293             CMP      R3,R2
   \   0000004E   0xD307             BCC.N    ??f_lseek_4
   3072          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   00000050   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   00000054   0xEA21 0x0000      BIC      R0,R1,R0
   \   00000058   0x60A0             STR      R0,[R4, #+8]
   3073          				ofs -= fp->fptr;
   \   0000005A   0x1A36             SUBS     R6,R6,R0
   3074          				clst = fp->clust;
   \   0000005C   0x6961             LDR      R1,[R4, #+20]
   \   0000005E   0xE00D             B.N      ??f_lseek_5
   3075          			} else {									/* When seek to back cluster, */
   3076          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_4: (+1)
   \   00000060   0x6921             LDR      R1,[R4, #+16]
   3077          #if !_FS_READONLY
   3078          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   00000062   0x2900             CMP      R1,#+0
   \   00000064   0xD109             BNE.N    ??f_lseek_6
   3079          					clst = create_chain(fp->fs, 0);
   \   00000066   0x4639             MOV      R1,R7
   \   00000068   0x.... 0x....      BL       create_chain
   \   0000006C   0x4601             MOV      R1,R0
   3080          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000006E   0x2901             CMP      R1,#+1
   \   00000070   0xD02E             BEQ.N    ??f_lseek_7
   3081          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \   00000072   0xF111 0x0F01      CMN      R1,#+1
   \   00000076   0xD050             BEQ.N    ??f_lseek_8
   3082          					fp->sclust = clst;
   \   00000078   0x6121             STR      R1,[R4, #+16]
   3083          				}
   3084          #endif
   3085          				fp->clust = clst;
   \                     ??f_lseek_6: (+1)
   \   0000007A   0x6161             STR      R1,[R4, #+20]
   3086          			}
   3087          			if (clst != 0) {
   \                     ??f_lseek_5: (+1)
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD112             BNE.N    ??f_lseek_9
   \   00000080   0xE02B             B.N      ??f_lseek_3
   3088          				while (ofs > bcs) {						/* Cluster following loop */
   3089          #if !_FS_READONLY
   3090          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   3091          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   3092          						if (clst == 0) {				/* When disk gets full, clip file size */
   3093          							ofs = bcs; break;
   3094          						}
   3095          					} else
   3096          #endif
   3097          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   \                     ??f_lseek_10: (+1)
   \   00000082   0x.... 0x....      BL       get_fat
   \   00000086   0x4601             MOV      R1,R0
   3098          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_11: (+1)
   \   00000088   0xF111 0x0F01      CMN      R1,#+1
   \   0000008C   0xD045             BEQ.N    ??f_lseek_8
   3099          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \   0000008E   0x2902             CMP      R1,#+2
   \   00000090   0xD31E             BCC.N    ??f_lseek_7
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6980             LDR      R0,[R0, #+24]
   \   00000096   0x4281             CMP      R1,R0
   \   00000098   0xD21A             BCS.N    ??f_lseek_7
   3100          					fp->clust = clst;
   \   0000009A   0x6161             STR      R1,[R4, #+20]
   3101          					fp->fptr += bcs;
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x4440             ADD      R0,R8,R0
   \   000000A0   0x60A0             STR      R0,[R4, #+8]
   3102          					ofs -= bcs;
   \   000000A2   0xEBA6 0x0608      SUB      R6,R6,R8
   \                     ??f_lseek_9: (+1)
   \   000000A6   0x45B0             CMP      R8,R6
   \   000000A8   0xD208             BCS.N    ??f_lseek_12
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x79A2             LDRB     R2,[R4, #+6]
   \   000000AE   0x0792             LSLS     R2,R2,#+30
   \   000000B0   0xD5E7             BPL.N    ??f_lseek_10
   \   000000B2   0x.... 0x....      BL       create_chain
   \   000000B6   0x0001             MOVS     R1,R0
   \   000000B8   0xD1E6             BNE.N    ??f_lseek_11
   \   000000BA   0x4646             MOV      R6,R8
   3103          				}
   3104          				fp->fptr += ofs;
   \                     ??f_lseek_12: (+1)
   \   000000BC   0x68A0             LDR      R0,[R4, #+8]
   \   000000BE   0x1830             ADDS     R0,R6,R0
   \   000000C0   0x60A0             STR      R0,[R4, #+8]
   3105          				if (ofs % SS(fp->fs)) {
   \   000000C2   0x05F0             LSLS     R0,R6,#+23
   \   000000C4   0xD009             BEQ.N    ??f_lseek_3
   3106          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x.... 0x....      BL       clust2sect
   \   000000CC   0x0007             MOVS     R7,R0
   3107          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   000000CE   0xD102             BNE.N    ??f_lseek_13
   \                     ??f_lseek_7: (+1)
   \   000000D0   0x2002             MOVS     R0,#+2
   \   000000D2   0x71E0             STRB     R0,[R4, #+7]
   \   000000D4   0xE02F             B.N      ??f_lseek_1
   3108          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_13: (+1)
   \   000000D6   0xEB07 0x2756      ADD      R7,R7,R6, LSR #+9
   3109          				}
   3110          			}
   3111          		}
   3112          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_3: (+1)
   \   000000DA   0x68A0             LDR      R0,[R4, #+8]
   \   000000DC   0x05C0             LSLS     R0,R0,#+23
   \   000000DE   0xD020             BEQ.N    ??f_lseek_14
   \   000000E0   0x69A2             LDR      R2,[R4, #+24]
   \   000000E2   0x4297             CMP      R7,R2
   \   000000E4   0xD01D             BEQ.N    ??f_lseek_14
   3113          #if !_FS_TINY
   3114          #if !_FS_READONLY
   3115          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   \   000000E6   0x79A0             LDRB     R0,[R4, #+6]
   \   000000E8   0x0640             LSLS     R0,R0,#+25
   \   000000EA   0xD50C             BPL.N    ??f_lseek_15
   3116          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000000EC   0x2301             MOVS     R3,#+1
   \   000000EE   0xF104 0x0124      ADD      R1,R4,#+36
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x7840             LDRB     R0,[R0, #+1]
   \   000000F6   0x.... 0x....      BL       disk_write
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD10D             BNE.N    ??f_lseek_8
   3117          					ABORT(fp->fs, FR_DISK_ERR);
   3118          				fp->flag &= ~FA__DIRTY;
   \   000000FE   0x79A0             LDRB     R0,[R4, #+6]
   \   00000100   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000104   0x71A0             STRB     R0,[R4, #+6]
   3119          			}
   3120          #endif
   3121          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_lseek_15: (+1)
   \   00000106   0x2301             MOVS     R3,#+1
   \   00000108   0x463A             MOV      R2,R7
   \   0000010A   0xF104 0x0124      ADD      R1,R4,#+36
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x7840             LDRB     R0,[R0, #+1]
   \   00000112   0x.... 0x....      BL       disk_read
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD002             BEQ.N    ??f_lseek_16
   3122          				ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8: (+1)
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x71E0             STRB     R0,[R4, #+7]
   \   0000011E   0xE00A             B.N      ??f_lseek_1
   3123          #endif
   3124          			fp->dsect = nsect;
   \                     ??f_lseek_16: (+1)
   \   00000120   0x61A7             STR      R7,[R4, #+24]
   3125          		}
   3126          #if !_FS_READONLY
   3127          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_14: (+1)
   \   00000122   0x68A0             LDR      R0,[R4, #+8]
   \   00000124   0x68E1             LDR      R1,[R4, #+12]
   \   00000126   0x4281             CMP      R1,R0
   \   00000128   0xD204             BCS.N    ??f_lseek_0
   3128          			fp->fsize = fp->fptr;
   \   0000012A   0x60E0             STR      R0,[R4, #+12]
   3129          			fp->flag |= FA__WRITTEN;
   \   0000012C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000012E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000132   0x71A0             STRB     R0,[R4, #+6]
   3130          		}
   3131          #endif
   3132          	}
   3133          
   3134          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_0: (+1)
   \   00000134   0x4628             MOV      R0,R5
   \                     ??f_lseek_1: (+1)
   \   00000136   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3135          }
   3136          
   3137          
   3138          
   3139          #if _FS_MINIMIZE <= 1
   3140          /*-----------------------------------------------------------------------*/
   3141          /* Create a Directory Object                                             */
   3142          /*-----------------------------------------------------------------------*/
   3143          

   \                                 In section .text, align 2, keep-with-next
   3144          FRESULT f_opendir (
   3145          	DIR* dp,			/* Pointer to directory object to create */
   3146          	const TCHAR* path	/* Pointer to the directory path */
   3147          )
   3148          {
   \                     f_opendir: (+1)
   \   00000000   0xB532             PUSH     {R1,R4,R5,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   3149          	FRESULT res;
   3150          	FATFS* fs;
   3151          	DEFINE_NAMEBUF;
   3152          
   3153          
   3154          	if (!dp) return FR_INVALID_OBJECT;
   \   00000006   0xD101             BNE.N    ??f_opendir_0
   \   00000008   0x2009             MOVS     R0,#+9
   \   0000000A   0xE02E             B.N      ??f_opendir_1
   3155          
   3156          	/* Get logical drive number */
   3157          	res = find_volume(&fs, &path, 0);
   \                     ??f_opendir_0: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xA904             ADD      R1,SP,#+16
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       find_volume
   \   00000016   0x0005             MOVS     R5,R0
   3158          	if (res == FR_OK) {
   \   00000018   0xD122             BNE.N    ??f_opendir_2
   3159          		dp->fs = fs;
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x6020             STR      R0,[R4, #+0]
   3160          		INIT_BUF(*dp);
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x61A0             STR      R0,[R4, #+24]
   3161          		res = follow_path(dp, path);			/* Follow the path to the directory */
   \   00000022   0x9904             LDR      R1,[SP, #+16]
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       follow_path
   \   0000002A   0x0005             MOVS     R5,R0
   3162          		FREE_BUF();
   3163          		if (res == FR_OK) {						/* Follow completed */
   \   0000002C   0xD115             BNE.N    ??f_opendir_3
   3164          			if (dp->dir) {						/* It is not the origin directory itself */
   \   0000002E   0x6961             LDR      R1,[R4, #+20]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD008             BEQ.N    ??f_opendir_4
   3165          				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
   \   00000034   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000036   0x06C0             LSLS     R0,R0,#+27
   \   00000038   0xD504             BPL.N    ??f_opendir_5
   3166          					dp->sclust = ld_clust(fs, dp->dir);
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x.... 0x....      BL       ld_clust
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0xE000             B.N      ??f_opendir_4
   3167          				else							/* The object is a file */
   3168          					res = FR_NO_PATH;
   \                     ??f_opendir_5: (+1)
   \   00000044   0x2505             MOVS     R5,#+5
   3169          			}
   3170          			if (res == FR_OK) {
   \                     ??f_opendir_4: (+1)
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0xD107             BNE.N    ??f_opendir_3
   3171          				dp->id = fs->id;
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x88C0             LDRH     R0,[R0, #+6]
   \   0000004E   0x80A0             STRH     R0,[R4, #+4]
   3172          				res = dir_sdi(dp, 0);			/* Rewind directory */
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       dir_sdi
   \   00000058   0x4605             MOV      R5,R0
   3173          #if _FS_LOCK
   3174          				if (res == FR_OK) {
   3175          					if (dp->sclust) {
   3176          						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
   3177          						if (!dp->lockid)
   3178          							res = FR_TOO_MANY_OPEN_FILES;
   3179          					} else {
   3180          						dp->lockid = 0;	/* Root directory need not to be locked */
   3181          					}
   3182          				}
   3183          #endif
   3184          			}
   3185          		}
   3186          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_3: (+1)
   \   0000005A   0x2D04             CMP      R5,#+4
   \   0000005C   0xD100             BNE.N    ??f_opendir_2
   \   0000005E   0x2505             MOVS     R5,#+5
   3187          	}
   3188          	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
   \                     ??f_opendir_2: (+1)
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0xD001             BEQ.N    ??f_opendir_6
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x6020             STR      R0,[R4, #+0]
   3189          
   3190          	LEAVE_FF(fs, res);
   \                     ??f_opendir_6: (+1)
   \   00000068   0x4628             MOV      R0,R5
   \                     ??f_opendir_1: (+1)
   \   0000006A   0xB005             ADD      SP,SP,#+20
   \   0000006C   0xBD30             POP      {R4,R5,PC}       ;; return
   3191          }
   3192          
   3193          
   3194          
   3195          
   3196          /*-----------------------------------------------------------------------*/
   3197          /* Close Directory                                                       */
   3198          /*-----------------------------------------------------------------------*/
   3199          

   \                                 In section .text, align 2, keep-with-next
   3200          FRESULT f_closedir (
   3201          	DIR *dp		/* Pointer to the directory object to be closed */
   3202          )
   3203          {
   \                     f_closedir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   3204          	FRESULT res;
   3205          
   3206          
   3207          	res = validate(dp);
   \   00000004   0x.... 0x....      BL       validate
   3208          	if (res == FR_OK) {
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD101             BNE.N    ??f_closedir_0
   3209          #if _FS_REENTRANT
   3210          		FATFS *fs = dp->fs;
   3211          #endif
   3212          #if _FS_LOCK
   3213          		if (dp->lockid)				/* Decrement sub-directory open counter */
   3214          			res = dec_lock(dp->lockid);
   3215          		if (res == FR_OK)
   3216          #endif
   3217          			dp->fs = 0;				/* Invalidate directory object */
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6021             STR      R1,[R4, #+0]
   3218          #if _FS_REENTRANT
   3219          		unlock_fs(fs, FR_OK);		/* Unlock volume */
   3220          #endif
   3221          	}
   3222          	return res;
   \                     ??f_closedir_0: (+1)
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   3223          }
   3224          
   3225          
   3226          
   3227          
   3228          /*-----------------------------------------------------------------------*/
   3229          /* Read Directory Entries in Sequence                                    */
   3230          /*-----------------------------------------------------------------------*/
   3231          

   \                                 In section .text, align 2, keep-with-next
   3232          FRESULT f_readdir (
   3233          	DIR* dp,			/* Pointer to the open directory object */
   3234          	FILINFO* fno		/* Pointer to file information to return */
   3235          )
   3236          {
   \                     f_readdir: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3237          	FRESULT res;
   3238          	DEFINE_NAMEBUF;
   3239          
   3240          
   3241          	res = validate(dp);						/* Check validity of the object */
   \   00000006   0x.... 0x....      BL       validate
   3242          	if (res == FR_OK) {
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0xD11E             BNE.N    ??f_readdir_0
   3243          		if (!fno) {
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD104             BNE.N    ??f_readdir_1
   3244          			res = dir_sdi(dp, 0);			/* Rewind the directory object */
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       dir_sdi
   \   0000001A   0xBD3E             POP      {R1-R5,PC}
   3245          		} else {
   3246          			INIT_BUF(*dp);
   \                     ??f_readdir_1: (+1)
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x61A0             STR      R0,[R4, #+24]
   3247          			res = dir_read(dp, 0);			/* Read an item */
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       dir_read
   3248          			if (res == FR_NO_FILE) {		/* Reached end of directory */
   \   00000028   0x2804             CMP      R0,#+4
   \   0000002A   0xD101             BNE.N    ??f_readdir_2
   3249          				dp->sect = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   3250          				res = FR_OK;
   3251          			}
   3252          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2: (+1)
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0xD10B             BNE.N    ??f_readdir_0
   3253          				get_fileinfo(dp, fno);		/* Get the object information */
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       get_fileinfo
   3254          				res = dir_next(dp, 0);		/* Increment index for next */
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       dir_next
   3255          				if (res == FR_NO_FILE) {
   \   00000044   0x2804             CMP      R0,#+4
   \   00000046   0xD101             BNE.N    ??f_readdir_0
   3256          					dp->sect = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6120             STR      R0,[R4, #+16]
   3257          					res = FR_OK;
   3258          				}
   3259          			}
   3260          			FREE_BUF();
   3261          		}
   3262          	}
   3263          
   3264          	LEAVE_FF(dp->fs, res);
   \                     ??f_readdir_0: (+1)
   \   0000004C   0xBD3E             POP      {R1-R5,PC}       ;; return
   3265          }
   3266          
   3267          
   3268          
   3269          #if _USE_FIND
   3270          /*-----------------------------------------------------------------------*/
   3271          /* Find next file                                                        */
   3272          /*-----------------------------------------------------------------------*/
   3273          

   \                                 In section .text, align 2, keep-with-next
   3274          FRESULT f_findnext (
   3275          	DIR* dp,		/* Pointer to the open directory object */
   3276          	FILINFO* fno	/* Pointer to the file information structure */
   3277          )
   3278          {
   \                     f_findnext: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3279          	FRESULT res;
   3280          
   3281          
   3282          	for (;;) {
   3283          		res = f_readdir(dp, fno);		/* Get a directory item */
   \                     ??f_findnext_0: (+1)
   \   00000006   0x4629             MOV      R1,R5
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       f_readdir
   \   0000000E   0x0006             MOVS     R6,R0
   3284          		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
   \   00000010   0xD10D             BNE.N    ??f_findnext_1
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD00B             BEQ.N    ??f_findnext_1
   \   00000016   0x7A68             LDRB     R0,[R5, #+9]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD008             BEQ.N    ??f_findnext_1
   3285          #if _USE_LFN
   3286          		if (fno->lfname && pattern_matching(dp->pat, fno->lfname, 0, 0)) break;	/* Test for LFN if exist */
   3287          #endif
   3288          		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;	/* Test for SFN */
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0xF105 0x0109      ADD      R1,R5,#+9
   \   00000024   0x69E0             LDR      R0,[R4, #+28]
   \   00000026   0x.... 0x....      BL       pattern_matching
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD0EB             BEQ.N    ??f_findnext_0
   3289          	}
   3290          	return res;
   \                     ??f_findnext_1: (+1)
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
   3291          
   3292          }
   3293          
   3294          
   3295          
   3296          /*-----------------------------------------------------------------------*/
   3297          /* Find first file                                                       */
   3298          /*-----------------------------------------------------------------------*/
   3299          

   \                                 In section .text, align 2, keep-with-next
   3300          FRESULT f_findfirst (
   3301          	DIR* dp,				/* Pointer to the blank directory object */
   3302          	FILINFO* fno,			/* Pointer to the file information structure */
   3303          	const TCHAR* path,		/* Pointer to the directory to open */
   3304          	const TCHAR* pattern	/* Pointer to the matching pattern */
   3305          )
   3306          {
   \                     f_findfirst: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   3307          	FRESULT res;
   3308          
   3309          
   3310          	dp->pat = pattern;		/* Save pointer to pattern string */
   \   00000008   0x61E3             STR      R3,[R4, #+28]
   3311          	res = f_opendir(dp, path);		/* Open the target directory */
   \   0000000A   0x.... 0x....      BL       f_opendir
   3312          	if (res == FR_OK)
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD104             BNE.N    ??f_findfirst_0
   3313          		res = f_findnext(dp, fno);	/* Find the first item */
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001A   0x....             B.N      f_findnext
   3314          	return res;
   \                     ??f_findfirst_0: (+1)
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3315          }
   3316          
   3317          #endif	/* _USE_FIND */
   3318          
   3319          
   3320          
   3321          #if _FS_MINIMIZE == 0
   3322          /*-----------------------------------------------------------------------*/
   3323          /* Get File Status                                                       */
   3324          /*-----------------------------------------------------------------------*/
   3325          

   \                                 In section .text, align 2, keep-with-next
   3326          FRESULT f_stat (
   3327          	const TCHAR* path,	/* Pointer to the file path */
   3328          	FILINFO* fno		/* Pointer to file information to return */
   3329          )
   3330          {
   \                     f_stat: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x460C             MOV      R4,R1
   3331          	FRESULT res;
   3332          	DIR dj;
   3333          	DEFINE_NAMEBUF;
   3334          
   3335          
   3336          	/* Get logical drive number */
   3337          	res = find_volume(&dj.fs, &path, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA90C             ADD      R1,SP,#+48
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       find_volume
   \   00000010   0x0005             MOVS     R5,R0
   3338          	if (res == FR_OK) {
   \   00000012   0xD112             BNE.N    ??f_stat_0
   3339          		INIT_BUF(dj);
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x9009             STR      R0,[SP, #+36]
   3340          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000018   0x990C             LDR      R1,[SP, #+48]
   \   0000001A   0xA803             ADD      R0,SP,#+12
   \   0000001C   0x.... 0x....      BL       follow_path
   \   00000020   0x0005             MOVS     R5,R0
   3341          		if (res == FR_OK) {				/* Follow completed */
   \   00000022   0xD10A             BNE.N    ??f_stat_0
   3342          			if (dj.dir) {		/* Found an object */
   \   00000024   0x9808             LDR      R0,[SP, #+32]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD006             BEQ.N    ??f_stat_1
   3343          				if (fno) get_fileinfo(&dj, fno);
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD005             BEQ.N    ??f_stat_0
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       get_fileinfo
   \   00000036   0xE000             B.N      ??f_stat_0
   3344          			} else {			/* It is root directory */
   3345          				res = FR_INVALID_NAME;
   \                     ??f_stat_1: (+1)
   \   00000038   0x2506             MOVS     R5,#+6
   3346          			}
   3347          		}
   3348          		FREE_BUF();
   3349          	}
   3350          
   3351          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0: (+1)
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0xB00D             ADD      SP,SP,#+52
   \   0000003E   0xBD30             POP      {R4,R5,PC}       ;; return
   3352          }
   3353          
   3354          
   3355          
   3356          #if !_FS_READONLY
   3357          /*-----------------------------------------------------------------------*/
   3358          /* Get Number of Free Clusters                                           */
   3359          /*-----------------------------------------------------------------------*/
   3360          

   \                                 In section .text, align 2, keep-with-next
   3361          FRESULT f_getfree (
   3362          	const TCHAR* path,	/* Path name of the logical drive number */
   3363          	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
   3364          	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
   3365          )
   3366          {
   \                     f_getfree: (+1)
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4614             MOV      R4,R2
   3367          	FRESULT res;
   3368          	FATFS *fs;
   3369          	DWORD n, clst, sect, stat;
   3370          	UINT i;
   3371          	BYTE fat, *p;
   3372          
   3373          
   3374          	/* Get logical drive number */
   3375          	res = find_volume(fatfs, &path, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xA901             ADD      R1,SP,#+4
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       find_volume
   \   00000014   0x0007             MOVS     R7,R0
   3376          	fs = *fatfs;
   \   00000016   0x6826             LDR      R6,[R4, #+0]
   3377          	if (res == FR_OK) {
   \   00000018   0xD15F             BNE.N    ??f_getfree_0
   3378          		/* If free_clust is valid, return it without full cluster scan */
   3379          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   0000001A   0x6930             LDR      R0,[R6, #+16]
   \   0000001C   0x69B4             LDR      R4,[R6, #+24]
   \   0000001E   0x1EA1             SUBS     R1,R4,#+2
   \   00000020   0x4281             CMP      R1,R0
   \   00000022   0xD301             BCC.N    ??f_getfree_1
   3380          			*nclst = fs->free_clust;
   \   00000024   0x6028             STR      R0,[R5, #+0]
   \   00000026   0xE058             B.N      ??f_getfree_0
   3381          		} else {
   3382          			/* Get number of free clusters */
   3383          			fat = fs->fs_type;
   \                     ??f_getfree_1: (+1)
   \   00000028   0xF896 0x9000      LDRB     R9,[R6, #+0]
   3384          			n = 0;
   \   0000002C   0xF04F 0x0800      MOV      R8,#+0
   3385          			if (fat == FS_FAT12) {
   \   00000030   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000034   0xD116             BNE.N    ??f_getfree_2
   3386          				clst = 2;
   \   00000036   0x2402             MOVS     R4,#+2
   3387          				do {
   3388          					stat = get_fat(fs, clst);
   \                     ??f_getfree_3: (+1)
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       get_fat
   3389          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   00000040   0xF110 0x0F01      CMN      R0,#+1
   \   00000044   0xD101             BNE.N    ??f_getfree_4
   \   00000046   0x2701             MOVS     R7,#+1
   \   00000048   0xE03F             B.N      ??f_getfree_5
   3390          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4: (+1)
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??f_getfree_6
   \   0000004E   0x2702             MOVS     R7,#+2
   \   00000050   0xE03B             B.N      ??f_getfree_5
   3391          					if (stat == 0) n++;
   \                     ??f_getfree_6: (+1)
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD101             BNE.N    ??f_getfree_7
   \   00000056   0xF108 0x0801      ADD      R8,R8,#+1
   3392          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_7: (+1)
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
   \   0000005C   0x69B0             LDR      R0,[R6, #+24]
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD3EA             BCC.N    ??f_getfree_3
   \   00000062   0xE032             B.N      ??f_getfree_5
   3393          			} else {
   3394          				clst = fs->n_fatent;
   3395          				sect = fs->fatbase;
   \                     ??f_getfree_2: (+1)
   \   00000064   0xF8D6 0xA024      LDR      R10,[R6, #+36]
   3396          				i = 0; p = 0;
   \   00000068   0x4641             MOV      R1,R8
   \   0000006A   0x4608             MOV      R0,R1
   3397          				do {
   3398          					if (!i) {
   \                     ??f_getfree_8: (+1)
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD10C             BNE.N    ??f_getfree_9
   3399          						res = move_window(fs, sect++);
   \   00000070   0x4651             MOV      R1,R10
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x.... 0x....      BL       move_window
   \   00000078   0x4607             MOV      R7,R0
   \   0000007A   0xF10A 0x0A01      ADD      R10,R10,#+1
   3400          						if (res != FR_OK) break;
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0xD123             BNE.N    ??f_getfree_5
   3401          						p = fs->win;
   \   00000082   0xF106 0x0034      ADD      R0,R6,#+52
   3402          						i = SS(fs);
   \   00000086   0xF44F 0x7100      MOV      R1,#+512
   3403          					}
   3404          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9: (+1)
   \   0000008A   0x7842             LDRB     R2,[R0, #+1]
   \   0000008C   0x7803             LDRB     R3,[R0, #+0]
   \   0000008E   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000092   0xD107             BNE.N    ??f_getfree_10
   3405          						if (LD_WORD(p) == 0) n++;
   \   00000094   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   00000098   0xD101             BNE.N    ??f_getfree_11
   \   0000009A   0xF108 0x0801      ADD      R8,R8,#+1
   3406          						p += 2; i -= 2;
   \                     ??f_getfree_11: (+1)
   \   0000009E   0x1C80             ADDS     R0,R0,#+2
   \   000000A0   0x1E89             SUBS     R1,R1,#+2
   \   000000A2   0xE010             B.N      ??f_getfree_12
   3407          					} else {
   3408          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_10: (+1)
   \   000000A4   0xF890 0xC003      LDRB     R12,[R0, #+3]
   \   000000A8   0xF890 0xE002      LDRB     LR,[R0, #+2]
   \   000000AC   0xEA4F 0x4E0E      LSL      LR,LR,#+16
   \   000000B0   0xEA4E 0x6C0C      ORR      R12,LR,R12, LSL #+24
   \   000000B4   0xEA4C 0x2202      ORR      R2,R12,R2, LSL #+8
   \   000000B8   0x431A             ORRS     R2,R3,R2
   \   000000BA   0x0112             LSLS     R2,R2,#+4
   \   000000BC   0xD101             BNE.N    ??f_getfree_13
   \   000000BE   0xF108 0x0801      ADD      R8,R8,#+1
   3409          						p += 4; i -= 4;
   \                     ??f_getfree_13: (+1)
   \   000000C2   0x1D00             ADDS     R0,R0,#+4
   \   000000C4   0x1F09             SUBS     R1,R1,#+4
   3410          					}
   3411          				} while (--clst);
   \                     ??f_getfree_12: (+1)
   \   000000C6   0x1E64             SUBS     R4,R4,#+1
   \   000000C8   0xD1D0             BNE.N    ??f_getfree_8
   3412          			}
   3413          			fs->free_clust = n;
   \                     ??f_getfree_5: (+1)
   \   000000CA   0xF8C6 0x8010      STR      R8,[R6, #+16]
   3414          			fs->fsi_flag |= 1;
   \   000000CE   0x7970             LDRB     R0,[R6, #+5]
   \   000000D0   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000D4   0x7170             STRB     R0,[R6, #+5]
   3415          			*nclst = n;
   \   000000D6   0xF8C5 0x8000      STR      R8,[R5, #+0]
   3416          		}
   3417          	}
   3418          	LEAVE_FF(fs, res);
   \                     ??f_getfree_0: (+1)
   \   000000DA   0x4638             MOV      R0,R7
   \   000000DC   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3419          }
   3420          
   3421          
   3422          
   3423          
   3424          /*-----------------------------------------------------------------------*/
   3425          /* Truncate File                                                         */
   3426          /*-----------------------------------------------------------------------*/
   3427          

   \                                 In section .text, align 2, keep-with-next
   3428          FRESULT f_truncate (
   3429          	FIL* fp		/* Pointer to the file object */
   3430          )
   3431          {
   \                     f_truncate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   3432          	FRESULT res;
   3433          	DWORD ncl;
   3434          
   3435          
   3436          	res = validate(fp);						/* Check validity of the object */
   \   00000004   0x.... 0x....      BL       validate
   \   00000008   0x0005             MOVS     R5,R0
   3437          	if (res == FR_OK) {
   \   0000000A   0xD108             BNE.N    ??f_truncate_0
   3438          		if (fp->err) {						/* Check error */
   \   0000000C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD001             BEQ.N    ??f_truncate_1
   3439          			res = (FRESULT)fp->err;
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xE003             B.N      ??f_truncate_0
   3440          		} else {
   3441          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1: (+1)
   \   00000016   0x79A0             LDRB     R0,[R4, #+6]
   \   00000018   0x0780             LSLS     R0,R0,#+30
   \   0000001A   0xD400             BMI.N    ??f_truncate_0
   3442          				res = FR_DENIED;
   \   0000001C   0x2507             MOVS     R5,#+7
   3443          		}
   3444          	}
   3445          	if (res == FR_OK) {
   \                     ??f_truncate_0: (+1)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xD148             BNE.N    ??f_truncate_2
   3446          		if (fp->fsize > fp->fptr) {
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x68E1             LDR      R1,[R4, #+12]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD241             BCS.N    ??f_truncate_3
   3447          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   0000002A   0x60E0             STR      R0,[R4, #+12]
   3448          			fp->flag |= FA__WRITTEN;
   \   0000002C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000002E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000032   0x71A0             STRB     R0,[R4, #+6]
   3449          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68A1             LDR      R1,[R4, #+8]
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD106             BNE.N    ??f_truncate_4
   3450          				res = remove_chain(fp->fs, fp->sclust);
   \   0000003C   0x6921             LDR      R1,[R4, #+16]
   \   0000003E   0x.... 0x....      BL       remove_chain
   \   00000042   0x4605             MOV      R5,R0
   3451          				fp->sclust = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6120             STR      R0,[R4, #+16]
   \   00000048   0xE01C             B.N      ??f_truncate_5
   3452          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3453          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4: (+1)
   \   0000004A   0x6961             LDR      R1,[R4, #+20]
   \   0000004C   0x.... 0x....      BL       get_fat
   \   00000050   0x4606             MOV      R6,R0
   3454          				res = FR_OK;
   3455          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   00000052   0xF116 0x0F01      CMN      R6,#+1
   \   00000056   0xD100             BNE.N    ??f_truncate_6
   \   00000058   0x2501             MOVS     R5,#+1
   3456          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_6: (+1)
   \   0000005A   0x2E01             CMP      R6,#+1
   \   0000005C   0xD100             BNE.N    ??f_truncate_7
   \   0000005E   0x2502             MOVS     R5,#+2
   3457          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_7: (+1)
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0xD10F             BNE.N    ??f_truncate_5
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6981             LDR      R1,[R0, #+24]
   \   00000068   0x428E             CMP      R6,R1
   \   0000006A   0xD20B             BCS.N    ??f_truncate_5
   3458          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   0000006C   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000070   0x6961             LDR      R1,[R4, #+20]
   \   00000072   0x.... 0x....      BL       put_fat
   \   00000076   0x0005             MOVS     R5,R0
   3459          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000078   0xD104             BNE.N    ??f_truncate_5
   \   0000007A   0x4631             MOV      R1,R6
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x.... 0x....      BL       remove_chain
   \   00000082   0x4605             MOV      R5,R0
   3460          				}
   3461          			}
   3462          #if !_FS_TINY
   3463          			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
   \                     ??f_truncate_5: (+1)
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0xD112             BNE.N    ??f_truncate_3
   \   00000088   0x79A0             LDRB     R0,[R4, #+6]
   \   0000008A   0x0640             LSLS     R0,R0,#+25
   \   0000008C   0xD50F             BPL.N    ??f_truncate_3
   3464          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000008E   0x2301             MOVS     R3,#+1
   \   00000090   0x69A2             LDR      R2,[R4, #+24]
   \   00000092   0xF104 0x0124      ADD      R1,R4,#+36
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x7840             LDRB     R0,[R0, #+1]
   \   0000009A   0x.... 0x....      BL       disk_write
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD001             BEQ.N    ??f_truncate_8
   3465          					res = FR_DISK_ERR;
   \   000000A2   0x2501             MOVS     R5,#+1
   \   000000A4   0xE003             B.N      ??f_truncate_3
   3466          				else
   3467          					fp->flag &= ~FA__DIRTY;
   \                     ??f_truncate_8: (+1)
   \   000000A6   0x79A0             LDRB     R0,[R4, #+6]
   \   000000A8   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   000000AC   0x71A0             STRB     R0,[R4, #+6]
   3468          			}
   3469          #endif
   3470          		}
   3471          		if (res != FR_OK) fp->err = (FRESULT)res;
   \                     ??f_truncate_3: (+1)
   \   000000AE   0x0028             MOVS     R0,R5
   \   000000B0   0xD000             BEQ.N    ??f_truncate_2
   \   000000B2   0x71E5             STRB     R5,[R4, #+7]
   3472          	}
   3473          
   3474          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2: (+1)
   \   000000B4   0x4628             MOV      R0,R5
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
   3475          }
   3476          
   3477          
   3478          
   3479          
   3480          /*-----------------------------------------------------------------------*/
   3481          /* Delete a File or Directory                                            */
   3482          /*-----------------------------------------------------------------------*/
   3483          

   \                                 In section .text, align 2, keep-with-next
   3484          FRESULT f_unlink (
   3485          	const TCHAR* path		/* Pointer to the file or directory path */
   3486          )
   3487          {
   \                     f_unlink: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   3488          	FRESULT res;
   3489          	DIR dj, sdj;
   3490          	BYTE *dir;
   3491          	DWORD dclst = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   3492          	DEFINE_NAMEBUF;
   3493          
   3494          
   3495          	/* Get logical drive number */
   3496          	res = find_volume(&dj.fs, &path, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA913             ADD      R1,SP,#+76
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       find_volume
   \   00000010   0x0005             MOVS     R5,R0
   3497          	if (res == FR_OK) {
   \   00000012   0xD152             BNE.N    ??f_unlink_0
   3498          		INIT_BUF(dj);
   \   00000014   0xA808             ADD      R0,SP,#+32
   \   00000016   0x9006             STR      R0,[SP, #+24]
   3499          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000018   0x9913             LDR      R1,[SP, #+76]
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       follow_path
   \   00000020   0x0005             MOVS     R5,R0
   3500          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   00000022   0xD104             BNE.N    ??f_unlink_1
   \   00000024   0x9806             LDR      R0,[SP, #+24]
   \   00000026   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000028   0x0680             LSLS     R0,R0,#+26
   \   0000002A   0xD500             BPL.N    ??f_unlink_1
   3501          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   0000002C   0x2506             MOVS     R5,#+6
   3502          #if _FS_LOCK
   3503          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
   3504          #endif
   3505          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD143             BNE.N    ??f_unlink_0
   3506          			dir = dj.dir;
   \   00000032   0x9E05             LDR      R6,[SP, #+20]
   3507          			if (!dir) {
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD101             BNE.N    ??f_unlink_2
   3508          				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
   \   00000038   0x2506             MOVS     R5,#+6
   \   0000003A   0xE003             B.N      ??f_unlink_3
   3509          			} else {
   3510          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_2: (+1)
   \   0000003C   0x7AF0             LDRB     R0,[R6, #+11]
   \   0000003E   0x07C0             LSLS     R0,R0,#+31
   \   00000040   0xD500             BPL.N    ??f_unlink_3
   3511          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   00000042   0x2507             MOVS     R5,#+7
   3512          			}
   3513          			if (res == FR_OK) {
   \                     ??f_unlink_3: (+1)
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0xD124             BNE.N    ??f_unlink_4
   3514          				dclst = ld_clust(dj.fs, dir);
   \   00000048   0x4631             MOV      R1,R6
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x.... 0x....      BL       ld_clust
   \   00000050   0x0004             MOVS     R4,R0
   3515          				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
   \   00000052   0xD01E             BEQ.N    ??f_unlink_4
   \   00000054   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000056   0x06C0             LSLS     R0,R0,#+27
   \   00000058   0xD51B             BPL.N    ??f_unlink_4
   3516          #if _FS_RPATH
   3517          					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x6940             LDR      R0,[R0, #+20]
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD101             BNE.N    ??f_unlink_5
   3518          						res = FR_DENIED;
   \   00000062   0x2507             MOVS     R5,#+7
   \   00000064   0xE015             B.N      ??f_unlink_4
   3519          					} else
   3520          #endif
   3521          					{
   3522          						mem_cpy(&sdj, &dj, sizeof (DIR));	/* Open the sub-directory */
   \                     ??f_unlink_5: (+1)
   \   00000066   0x2220             MOVS     R2,#+32
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0xA80B             ADD      R0,SP,#+44
   \   0000006C   0x.... 0x....      BL       mem_cpy
   3523          						sdj.sclust = dclst;
   \   00000070   0x940D             STR      R4,[SP, #+52]
   3524          						res = dir_sdi(&sdj, 2);
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0xA80B             ADD      R0,SP,#+44
   \   00000076   0x.... 0x....      BL       dir_sdi
   \   0000007A   0x0005             MOVS     R5,R0
   3525          						if (res == FR_OK) {
   \   0000007C   0xD109             BNE.N    ??f_unlink_4
   3526          							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xA80B             ADD      R0,SP,#+44
   \   00000082   0x.... 0x....      BL       dir_read
   \   00000086   0x0005             MOVS     R5,R0
   3527          							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
   \   00000088   0xD100             BNE.N    ??f_unlink_6
   \   0000008A   0x2507             MOVS     R5,#+7
   3528          							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
   \                     ??f_unlink_6: (+1)
   \   0000008C   0x2D04             CMP      R5,#+4
   \   0000008E   0xD100             BNE.N    ??f_unlink_4
   \   00000090   0x2500             MOVS     R5,#+0
   3529          						}
   3530          					}
   3531          				}
   3532          			}
   3533          			if (res == FR_OK) {
   \                     ??f_unlink_4: (+1)
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0xD111             BNE.N    ??f_unlink_0
   3534          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   00000096   0x4668             MOV      R0,SP
   \   00000098   0x.... 0x....      BL       dir_remove
   \   0000009C   0x0005             MOVS     R5,R0
   3535          				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
   \   0000009E   0xD106             BNE.N    ??f_unlink_7
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD004             BEQ.N    ??f_unlink_7
   3536          					res = remove_chain(dj.fs, dclst);
   \   000000A4   0x4621             MOV      R1,R4
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x.... 0x....      BL       remove_chain
   \   000000AC   0x4605             MOV      R5,R0
   3537          				if (res == FR_OK) res = sync_fs(dj.fs);
   \                     ??f_unlink_7: (+1)
   \   000000AE   0x0028             MOVS     R0,R5
   \   000000B0   0xD103             BNE.N    ??f_unlink_0
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x.... 0x....      BL       sync_fs
   \   000000B8   0x4605             MOV      R5,R0
   3538          			}
   3539          		}
   3540          		FREE_BUF();
   3541          	}
   3542          
   3543          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0: (+1)
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0xB014             ADD      SP,SP,#+80
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
   3544          }
   3545          
   3546          
   3547          
   3548          
   3549          /*-----------------------------------------------------------------------*/
   3550          /* Create a Directory                                                    */
   3551          /*-----------------------------------------------------------------------*/
   3552          

   \                                 In section .text, align 2, keep-with-next
   3553          FRESULT f_mkdir (
   3554          	const TCHAR* path		/* Pointer to the directory path */
   3555          )
   3556          {
   \                     f_mkdir: (+1)
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   3557          	FRESULT res;
   3558          	DIR dj;
   3559          	BYTE *dir, n;
   3560          	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x4604             MOV      R4,R0
   3561          	DEFINE_NAMEBUF;
   3562          
   3563          
   3564          	/* Get logical drive number */
   3565          	res = find_volume(&dj.fs, &path, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA90C             ADD      R1,SP,#+48
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       find_volume
   \   00000016   0x0005             MOVS     R5,R0
   3566          	if (res == FR_OK) {
   \   00000018   0xF040 0x80B1      BNE.W    ??f_mkdir_0
   3567          		INIT_BUF(dj);
   \   0000001C   0xA808             ADD      R0,SP,#+32
   \   0000001E   0x9006             STR      R0,[SP, #+24]
   3568          		res = follow_path(&dj, path);			/* Follow the file path */
   \   00000020   0x990C             LDR      R1,[SP, #+48]
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       follow_path
   \   00000028   0x0005             MOVS     R5,R0
   3569          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   0000002A   0xD100             BNE.N    ??f_mkdir_1
   \   0000002C   0x2508             MOVS     R5,#+8
   3570          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
   \                     ??f_mkdir_1: (+1)
   \   0000002E   0x2D04             CMP      R5,#+4
   \   00000030   0xD104             BNE.N    ??f_mkdir_2
   \   00000032   0x9806             LDR      R0,[SP, #+24]
   \   00000034   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000036   0x0680             LSLS     R0,R0,#+26
   \   00000038   0xD500             BPL.N    ??f_mkdir_2
   3571          			res = FR_INVALID_NAME;
   \   0000003A   0x2506             MOVS     R5,#+6
   3572          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_2: (+1)
   \   0000003C   0x2D04             CMP      R5,#+4
   \   0000003E   0xF040 0x809E      BNE.W    ??f_mkdir_0
   3573          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x.... 0x....      BL       create_chain
   \   0000004A   0x4606             MOV      R6,R0
   3574          			res = FR_OK;
   \   0000004C   0x2500             MOVS     R5,#+0
   3575          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD100             BNE.N    ??f_mkdir_3
   \   00000052   0x2507             MOVS     R5,#+7
   3576          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_3: (+1)
   \   00000054   0x2E01             CMP      R6,#+1
   \   00000056   0xD100             BNE.N    ??f_mkdir_4
   \   00000058   0x2502             MOVS     R5,#+2
   3577          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_4: (+1)
   \   0000005A   0xF116 0x0F01      CMN      R6,#+1
   \   0000005E   0xD100             BNE.N    ??f_mkdir_5
   \   00000060   0x2501             MOVS     R5,#+1
   3578          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_5: (+1)
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0xD103             BNE.N    ??f_mkdir_6
   3579          				res = sync_window(dj.fs);
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x.... 0x....      BL       sync_window
   \   0000006C   0x4605             MOV      R5,R0
   3580          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_6: (+1)
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xD15B             BNE.N    ??f_mkdir_7
   3581          				dsc = clust2sect(dj.fs, dcl);
   \   00000072   0x4631             MOV      R1,R6
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x.... 0x....      BL       clust2sect
   \   0000007A   0x4607             MOV      R7,R0
   3582          				dir = dj.fs->win;
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0xF100 0x0834      ADD      R8,R0,#+52
   3583          				mem_set(dir, 0, SS(dj.fs));
   \   00000082   0xF44F 0x7200      MOV      R2,#+512
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x4640             MOV      R0,R8
   \   0000008A   0x.... 0x....      BL       mem_set
   3584          				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
   \   0000008E   0x220B             MOVS     R2,#+11
   \   00000090   0x2120             MOVS     R1,#+32
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x.... 0x....      BL       mem_set
   3585          				dir[DIR_Name] = '.';
   \   00000098   0x202E             MOVS     R0,#+46
   \   0000009A   0xF888 0x0000      STRB     R0,[R8, #+0]
   3586          				dir[DIR_Attr] = AM_DIR;
   \   0000009E   0x2010             MOVS     R0,#+16
   \   000000A0   0xF888 0x000B      STRB     R0,[R8, #+11]
   3587          				ST_DWORD(dir + DIR_WrtTime, tm);
   \   000000A4   0xF888 0x4016      STRB     R4,[R8, #+22]
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0xB280             UXTH     R0,R0
   \   000000AC   0x0A00             LSRS     R0,R0,#+8
   \   000000AE   0xF888 0x0017      STRB     R0,[R8, #+23]
   \   000000B2   0x0C20             LSRS     R0,R4,#+16
   \   000000B4   0xF888 0x0018      STRB     R0,[R8, #+24]
   \   000000B8   0x0E20             LSRS     R0,R4,#+24
   \   000000BA   0xF888 0x0019      STRB     R0,[R8, #+25]
   3588          				st_clust(dir, dcl);
   \   000000BE   0x4631             MOV      R1,R6
   \   000000C0   0x4640             MOV      R0,R8
   \   000000C2   0x.... 0x....      BL       st_clust
   3589          				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
   \   000000C6   0x2220             MOVS     R2,#+32
   \   000000C8   0x4641             MOV      R1,R8
   \   000000CA   0xF108 0x0020      ADD      R0,R8,#+32
   \   000000CE   0x.... 0x....      BL       mem_cpy
   3590          				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
   \   000000D2   0x202E             MOVS     R0,#+46
   \   000000D4   0xF888 0x0021      STRB     R0,[R8, #+33]
   \   000000D8   0x9902             LDR      R1,[SP, #+8]
   3591          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x2803             CMP      R0,#+3
   \   000000E0   0xD104             BNE.N    ??f_mkdir_8
   \   000000E2   0x9800             LDR      R0,[SP, #+0]
   \   000000E4   0x6A80             LDR      R0,[R0, #+40]
   \   000000E6   0x4281             CMP      R1,R0
   \   000000E8   0xD100             BNE.N    ??f_mkdir_8
   3592          					pcl = 0;
   \   000000EA   0x2100             MOVS     R1,#+0
   3593          				st_clust(dir + SZ_DIRE, pcl);
   \                     ??f_mkdir_8: (+1)
   \   000000EC   0xF108 0x0020      ADD      R0,R8,#+32
   \   000000F0   0x.... 0x....      BL       st_clust
   3594          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0xF890 0x9002      LDRB     R9,[R0, #+2]
   \   000000FA   0xE007             B.N      ??f_mkdir_9
   3595          					dj.fs->winsect = dsc++;
   3596          					dj.fs->wflag = 1;
   3597          					res = sync_window(dj.fs);
   3598          					if (res != FR_OK) break;
   3599          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_10: (+1)
   \   000000FC   0xF44F 0x7200      MOV      R2,#+512
   \   00000100   0x2100             MOVS     R1,#+0
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0x.... 0x....      BL       mem_set
   \   00000108   0xF1A9 0x0901      SUB      R9,R9,#+1
   \                     ??f_mkdir_9: (+1)
   \   0000010C   0x4648             MOV      R0,R9
   \   0000010E   0xB2C0             UXTB     R0,R0
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD00A             BEQ.N    ??f_mkdir_7
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0x6307             STR      R7,[R0, #+48]
   \   00000118   0x1C7F             ADDS     R7,R7,#+1
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x9900             LDR      R1,[SP, #+0]
   \   0000011E   0x7108             STRB     R0,[R1, #+4]
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   \   00000122   0x.... 0x....      BL       sync_window
   \   00000126   0x0005             MOVS     R5,R0
   \   00000128   0xD0E8             BEQ.N    ??f_mkdir_10
   3600          				}
   3601          			}
   3602          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_7: (+1)
   \   0000012A   0x0028             MOVS     R0,R5
   \   0000012C   0xD103             BNE.N    ??f_mkdir_11
   \   0000012E   0x4668             MOV      R0,SP
   \   00000130   0x.... 0x....      BL       dir_register
   \   00000134   0x4605             MOV      R5,R0
   3603          			if (res != FR_OK) {
   \                     ??f_mkdir_11: (+1)
   \   00000136   0x0028             MOVS     R0,R5
   \   00000138   0xD004             BEQ.N    ??f_mkdir_12
   3604          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   0000013A   0x4631             MOV      R1,R6
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0x.... 0x....      BL       remove_chain
   \   00000142   0xE01C             B.N      ??f_mkdir_0
   3605          			} else {
   3606          				dir = dj.dir;
   \                     ??f_mkdir_12: (+1)
   \   00000144   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   3607          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   00000148   0x2010             MOVS     R0,#+16
   \   0000014A   0xF888 0x000B      STRB     R0,[R8, #+11]
   3608          				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
   \   0000014E   0xF888 0x4016      STRB     R4,[R8, #+22]
   \   00000152   0x4620             MOV      R0,R4
   \   00000154   0xB280             UXTH     R0,R0
   \   00000156   0x0A00             LSRS     R0,R0,#+8
   \   00000158   0xF888 0x0017      STRB     R0,[R8, #+23]
   \   0000015C   0x0C20             LSRS     R0,R4,#+16
   \   0000015E   0xF888 0x0018      STRB     R0,[R8, #+24]
   \   00000162   0x0E20             LSRS     R0,R4,#+24
   \   00000164   0xF888 0x0019      STRB     R0,[R8, #+25]
   3609          				st_clust(dir, dcl);					/* Table start cluster */
   \   00000168   0x4631             MOV      R1,R6
   \   0000016A   0x4640             MOV      R0,R8
   \   0000016C   0x.... 0x....      BL       st_clust
   3610          				dj.fs->wflag = 1;
   \   00000170   0x2001             MOVS     R0,#+1
   \   00000172   0x9900             LDR      R1,[SP, #+0]
   \   00000174   0x7108             STRB     R0,[R1, #+4]
   3611          				res = sync_fs(dj.fs);
   \   00000176   0x9800             LDR      R0,[SP, #+0]
   \   00000178   0x.... 0x....      BL       sync_fs
   \   0000017C   0x4605             MOV      R5,R0
   3612          			}
   3613          		}
   3614          		FREE_BUF();
   3615          	}
   3616          
   3617          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0: (+1)
   \   0000017E   0x4628             MOV      R0,R5
   \   00000180   0xB00D             ADD      SP,SP,#+52
   \   00000182   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   3618          }
   3619          
   3620          
   3621          
   3622          
   3623          /*-----------------------------------------------------------------------*/
   3624          /* Change Attribute                                                      */
   3625          /*-----------------------------------------------------------------------*/
   3626          

   \                                 In section .text, align 2, keep-with-next
   3627          FRESULT f_chmod (
   3628          	const TCHAR* path,	/* Pointer to the file path */
   3629          	BYTE attr,			/* Attribute bits */
   3630          	BYTE mask			/* Attribute mask to change */
   3631          )
   3632          {
   \                     f_chmod: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   3633          	FRESULT res;
   3634          	DIR dj;
   3635          	BYTE *dir;
   3636          	DEFINE_NAMEBUF;
   3637          
   3638          
   3639          	/* Get logical drive number */
   3640          	res = find_volume(&dj.fs, &path, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA90C             ADD      R1,SP,#+48
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       find_volume
   3641          	if (res == FR_OK) {
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD121             BNE.N    ??f_chmod_0
   3642          		INIT_BUF(dj);
   \   00000016   0xA808             ADD      R0,SP,#+32
   \   00000018   0x9006             STR      R0,[SP, #+24]
   3643          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000001A   0x990C             LDR      R1,[SP, #+48]
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       follow_path
   3644          		FREE_BUF();
   3645          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD104             BNE.N    ??f_chmod_1
   \   00000026   0x9906             LDR      R1,[SP, #+24]
   \   00000028   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000002A   0x0689             LSLS     R1,R1,#+26
   \   0000002C   0xD500             BPL.N    ??f_chmod_1
   3646          			res = FR_INVALID_NAME;
   \   0000002E   0x2006             MOVS     R0,#+6
   3647          		if (res == FR_OK) {
   \                     ??f_chmod_1: (+1)
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0xD112             BNE.N    ??f_chmod_0
   3648          			dir = dj.dir;
   \   00000034   0x9805             LDR      R0,[SP, #+20]
   3649          			if (!dir) {						/* Is it a root directory? */
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??f_chmod_2
   3650          				res = FR_INVALID_NAME;
   \   0000003A   0x2006             MOVS     R0,#+6
   \   0000003C   0xE00D             B.N      ??f_chmod_0
   3651          			} else {						/* File or sub directory */
   3652          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_2: (+1)
   \   0000003E   0xF005 0x0527      AND      R5,R5,#0x27
   3653          				dir[DIR_Attr] = (attr & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00000042   0xEA05 0x0104      AND      R1,R5,R4
   \   00000046   0x7AC2             LDRB     R2,[R0, #+11]
   \   00000048   0x43AA             BICS     R2,R2,R5
   \   0000004A   0x4311             ORRS     R1,R2,R1
   \   0000004C   0x72C1             STRB     R1,[R0, #+11]
   3654          				dj.fs->wflag = 1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x9900             LDR      R1,[SP, #+0]
   \   00000052   0x7108             STRB     R0,[R1, #+4]
   3655          				res = sync_fs(dj.fs);
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x.... 0x....      BL       sync_fs
   3656          			}
   3657          		}
   3658          	}
   3659          
   3660          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0: (+1)
   \   0000005A   0xB00D             ADD      SP,SP,#+52
   \   0000005C   0xBD30             POP      {R4,R5,PC}       ;; return
   3661          }
   3662          
   3663          
   3664          
   3665          
   3666          /*-----------------------------------------------------------------------*/
   3667          /* Rename File/Directory                                                 */
   3668          /*-----------------------------------------------------------------------*/
   3669          

   \                                 In section .text, align 2, keep-with-next
   3670          FRESULT f_rename (
   3671          	const TCHAR* path_old,	/* Pointer to the object to be renamed */
   3672          	const TCHAR* path_new	/* Pointer to the new name */
   3673          )
   3674          {
   \                     f_rename: (+1)
   \   00000000   0xB533             PUSH     {R0,R1,R4,R5,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
   3675          	FRESULT res;
   3676          	DIR djo, djn;
   3677          	BYTE buf[21], *dir;
   3678          	DWORD dw;
   3679          	DEFINE_NAMEBUF;
   3680          
   3681          
   3682          	/* Get logical drive number of the source object */
   3683          	res = find_volume(&djo.fs, &path_old, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA919             ADD      R1,SP,#+100
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       find_volume
   \   0000000E   0x0004             MOVS     R4,R0
   3684          	if (res == FR_OK) {
   \   00000010   0xD177             BNE.N    ??f_rename_0
   3685          		djn.fs = djo.fs;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x9008             STR      R0,[SP, #+32]
   3686          		INIT_BUF(djo);
   \   00000016   0xA810             ADD      R0,SP,#+64
   \   00000018   0x9006             STR      R0,[SP, #+24]
   3687          		res = follow_path(&djo, path_old);		/* Check old object */
   \   0000001A   0x9919             LDR      R1,[SP, #+100]
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       follow_path
   \   00000022   0x0004             MOVS     R4,R0
   3688          		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
   \   00000024   0xD104             BNE.N    ??f_rename_1
   \   00000026   0x9806             LDR      R0,[SP, #+24]
   \   00000028   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002A   0x0680             LSLS     R0,R0,#+26
   \   0000002C   0xD500             BPL.N    ??f_rename_1
   3689          			res = FR_INVALID_NAME;
   \   0000002E   0x2406             MOVS     R4,#+6
   3690          #if _FS_LOCK
   3691          		if (res == FR_OK) res = chk_lock(&djo, 2);
   3692          #endif
   3693          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_1: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xD166             BNE.N    ??f_rename_0
   3694          			if (!djo.dir) {						/* Is root dir? */
   \   00000034   0x9805             LDR      R0,[SP, #+20]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??f_rename_2
   3695          				res = FR_NO_FILE;
   \   0000003A   0x2404             MOVS     R4,#+4
   \   0000003C   0xE061             B.N      ??f_rename_0
   3696          			} else {
   3697          				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about object except name */
   \                     ??f_rename_2: (+1)
   \   0000003E   0x2215             MOVS     R2,#+21
   \   00000040   0xF100 0x010B      ADD      R1,R0,#+11
   \   00000044   0xA813             ADD      R0,SP,#+76
   \   00000046   0x.... 0x....      BL       mem_cpy
   3698          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
   \   0000004A   0x2220             MOVS     R2,#+32
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0xA808             ADD      R0,SP,#+32
   \   00000050   0x.... 0x....      BL       mem_cpy
   3699          				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
   \   00000054   0xA81A             ADD      R0,SP,#+104
   \   00000056   0x.... 0x....      BL       get_ldnumber
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD405             BMI.N    ??f_rename_3
   3700          					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
   \   0000005E   0x991A             LDR      R1,[SP, #+104]
   \   00000060   0xA808             ADD      R0,SP,#+32
   \   00000062   0x.... 0x....      BL       follow_path
   \   00000066   0x4604             MOV      R4,R0
   \   00000068   0xE000             B.N      ??f_rename_4
   3701          				else
   3702          					res = FR_INVALID_DRIVE;
   \                     ??f_rename_3: (+1)
   \   0000006A   0x240B             MOVS     R4,#+11
   3703          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \                     ??f_rename_4: (+1)
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0xD100             BNE.N    ??f_rename_5
   \   00000070   0x2408             MOVS     R4,#+8
   3704          				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
   \                     ??f_rename_5: (+1)
   \   00000072   0x2C04             CMP      R4,#+4
   \   00000074   0xD145             BNE.N    ??f_rename_0
   3705          					res = dir_register(&djn);			/* Register the new entry */
   \   00000076   0xA808             ADD      R0,SP,#+32
   \   00000078   0x.... 0x....      BL       dir_register
   \   0000007C   0x0004             MOVS     R4,R0
   3706          					if (res == FR_OK) {
   \   0000007E   0xD140             BNE.N    ??f_rename_0
   3707          /* Start of critical section where any interruption can cause a cross-link */
   3708          						dir = djn.dir;					/* Copy information about object except name */
   \   00000080   0x9D0D             LDR      R5,[SP, #+52]
   3709          						mem_cpy(dir + 13, buf + 2, 19);
   \   00000082   0x2213             MOVS     R2,#+19
   \   00000084   0xF10D 0x014E      ADD      R1,SP,#+78
   \   00000088   0xF105 0x000D      ADD      R0,R5,#+13
   \   0000008C   0x.... 0x....      BL       mem_cpy
   3710          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   00000090   0xF89D 0x004C      LDRB     R0,[SP, #+76]
   \   00000094   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000098   0x72E8             STRB     R0,[R5, #+11]
   3711          						djo.fs->wflag = 1;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x9900             LDR      R1,[SP, #+0]
   \   0000009E   0x7108             STRB     R0,[R1, #+4]
   3712          						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the sub-directory if needed */
   \   000000A0   0x7AE8             LDRB     R0,[R5, #+11]
   \   000000A2   0x06C0             LSLS     R0,R0,#+27
   \   000000A4   0xD522             BPL.N    ??f_rename_6
   \   000000A6   0x9802             LDR      R0,[SP, #+8]
   \   000000A8   0x990A             LDR      R1,[SP, #+40]
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xD01E             BEQ.N    ??f_rename_6
   3713          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   000000AE   0x4629             MOV      R1,R5
   \   000000B0   0x9800             LDR      R0,[SP, #+0]
   \   000000B2   0x.... 0x....      BL       ld_clust
   \   000000B6   0x4601             MOV      R1,R0
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x.... 0x....      BL       clust2sect
   \   000000BE   0x0001             MOVS     R1,R0
   3714          							if (!dw) {
   \   000000C0   0xD101             BNE.N    ??f_rename_7
   3715          								res = FR_INT_ERR;
   \   000000C2   0x2402             MOVS     R4,#+2
   \   000000C4   0xE012             B.N      ??f_rename_6
   3716          							} else {
   3717          								res = move_window(djo.fs, dw);
   \                     ??f_rename_7: (+1)
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x.... 0x....      BL       move_window
   \   000000CC   0x4604             MOV      R4,R0
   3718          								dir = djo.fs->win + SZ_DIRE * 1;	/* Ptr to .. entry */
   \   000000CE   0x9800             LDR      R0,[SP, #+0]
   \   000000D0   0xF100 0x0554      ADD      R5,R0,#+84
   3719          								if (res == FR_OK && dir[1] == '.') {
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0xD109             BNE.N    ??f_rename_6
   \   000000D8   0x7868             LDRB     R0,[R5, #+1]
   \   000000DA   0x282E             CMP      R0,#+46
   \   000000DC   0xD106             BNE.N    ??f_rename_6
   3720          									st_clust(dir, djn.sclust);
   \   000000DE   0x990A             LDR      R1,[SP, #+40]
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x.... 0x....      BL       st_clust
   3721          									djo.fs->wflag = 1;
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x9900             LDR      R1,[SP, #+0]
   \   000000EA   0x7108             STRB     R0,[R1, #+4]
   3722          								}
   3723          							}
   3724          						}
   3725          						if (res == FR_OK) {
   \                     ??f_rename_6: (+1)
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0xD108             BNE.N    ??f_rename_0
   3726          							res = dir_remove(&djo);		/* Remove old entry */
   \   000000F0   0x4668             MOV      R0,SP
   \   000000F2   0x.... 0x....      BL       dir_remove
   \   000000F6   0x0004             MOVS     R4,R0
   3727          							if (res == FR_OK)
   \   000000F8   0xD103             BNE.N    ??f_rename_0
   3728          								res = sync_fs(djo.fs);
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0x.... 0x....      BL       sync_fs
   \   00000100   0x4604             MOV      R4,R0
   3729          						}
   3730          /* End of critical section */
   3731          					}
   3732          				}
   3733          			}
   3734          		}
   3735          		FREE_BUF();
   3736          	}
   3737          
   3738          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0: (+1)
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0xB01B             ADD      SP,SP,#+108
   \   00000106   0xBD30             POP      {R4,R5,PC}       ;; return
   3739          }
   3740          
   3741          
   3742          
   3743          
   3744          /*-----------------------------------------------------------------------*/
   3745          /* Change Timestamp                                                      */
   3746          /*-----------------------------------------------------------------------*/
   3747          

   \                                 In section .text, align 2, keep-with-next
   3748          FRESULT f_utime (
   3749          	const TCHAR* path,	/* Pointer to the file/directory name */
   3750          	const FILINFO* fno	/* Pointer to the time stamp to be set */
   3751          )
   3752          {
   \                     f_utime: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x460C             MOV      R4,R1
   3753          	FRESULT res;
   3754          	DIR dj;
   3755          	BYTE *dir;
   3756          	DEFINE_NAMEBUF;
   3757          
   3758          
   3759          	/* Get logical drive number */
   3760          	res = find_volume(&dj.fs, &path, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA90B             ADD      R1,SP,#+44
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       find_volume
   3761          	if (res == FR_OK) {
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0xD123             BNE.N    ??f_utime_0
   3762          		INIT_BUF(dj);
   \   00000014   0xA808             ADD      R0,SP,#+32
   \   00000016   0x9006             STR      R0,[SP, #+24]
   3763          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000018   0x990B             LDR      R1,[SP, #+44]
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       follow_path
   3764          		FREE_BUF();
   3765          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0xD104             BNE.N    ??f_utime_1
   \   00000024   0x9906             LDR      R1,[SP, #+24]
   \   00000026   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000028   0x0689             LSLS     R1,R1,#+26
   \   0000002A   0xD500             BPL.N    ??f_utime_1
   3766          			res = FR_INVALID_NAME;
   \   0000002C   0x2006             MOVS     R0,#+6
   3767          		if (res == FR_OK) {
   \                     ??f_utime_1: (+1)
   \   0000002E   0x0001             MOVS     R1,R0
   \   00000030   0xD114             BNE.N    ??f_utime_0
   3768          			dir = dj.dir;
   \   00000032   0x9805             LDR      R0,[SP, #+20]
   3769          			if (!dir) {					/* Root directory */
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??f_utime_2
   3770          				res = FR_INVALID_NAME;
   \   00000038   0x2006             MOVS     R0,#+6
   \   0000003A   0xE00F             B.N      ??f_utime_0
   3771          			} else {					/* File or sub-directory */
   3772          				ST_WORD(dir + DIR_WrtTime, fno->ftime);
   \                     ??f_utime_2: (+1)
   \   0000003C   0x88E1             LDRH     R1,[R4, #+6]
   \   0000003E   0x7581             STRB     R1,[R0, #+22]
   \   00000040   0x88E1             LDRH     R1,[R4, #+6]
   \   00000042   0x0A09             LSRS     R1,R1,#+8
   \   00000044   0x75C1             STRB     R1,[R0, #+23]
   3773          				ST_WORD(dir + DIR_WrtDate, fno->fdate);
   \   00000046   0x88A1             LDRH     R1,[R4, #+4]
   \   00000048   0x7601             STRB     R1,[R0, #+24]
   \   0000004A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000004C   0x0A09             LSRS     R1,R1,#+8
   \   0000004E   0x7641             STRB     R1,[R0, #+25]
   3774          				dj.fs->wflag = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x9900             LDR      R1,[SP, #+0]
   \   00000054   0x7108             STRB     R0,[R1, #+4]
   3775          				res = sync_fs(dj.fs);
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x.... 0x....      BL       sync_fs
   3776          			}
   3777          		}
   3778          	}
   3779          
   3780          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0: (+1)
   \   0000005C   0xB00C             ADD      SP,SP,#+48
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
   3781          }
   3782          
   3783          #endif /* !_FS_READONLY */
   3784          #endif /* _FS_MINIMIZE == 0 */
   3785          #endif /* _FS_MINIMIZE <= 1 */
   3786          #endif /* _FS_MINIMIZE <= 2 */
   3787          
   3788          
   3789          
   3790          
   3791          #if _USE_LABEL
   3792          /*-----------------------------------------------------------------------*/
   3793          /* Get volume label                                                      */
   3794          /*-----------------------------------------------------------------------*/
   3795          

   \                                 In section .text, align 2, keep-with-next
   3796          FRESULT f_getlabel (
   3797          	const TCHAR* path,	/* Path name of the logical drive number */
   3798          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   3799          	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
   3800          )
   3801          {
   \                     f_getlabel: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4614             MOV      R4,R2
   3802          	FRESULT res;
   3803          	DIR dj;
   3804          	UINT i, j;
   3805          #if _USE_LFN && _LFN_UNICODE
   3806          	WCHAR w;
   3807          #endif
   3808          
   3809          
   3810          	/* Get logical drive number */
   3811          	res = find_volume(&dj.fs, &path, 0);
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xA909             ADD      R1,SP,#+36
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       find_volume
   \   00000012   0x0006             MOVS     R6,R0
   3812          
   3813          	/* Get volume label */
   3814          	if (res == FR_OK && label) {
   \   00000014   0xD122             BNE.N    ??f_getlabel_0
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD020             BEQ.N    ??f_getlabel_0
   3815          		dj.sclust = 0;					/* Open root directory */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9002             STR      R0,[SP, #+8]
   3816          		res = dir_sdi(&dj, 0);
   \   0000001E   0x4601             MOV      R1,R0
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       dir_sdi
   \   00000026   0x0006             MOVS     R6,R0
   3817          		if (res == FR_OK) {
   \   00000028   0xD118             BNE.N    ??f_getlabel_0
   3818          			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x.... 0x....      BL       dir_read
   \   00000032   0x0006             MOVS     R6,R0
   3819          			if (res == FR_OK) {			/* A volume label is exist */
   \   00000034   0xD10D             BNE.N    ??f_getlabel_1
   3820          #if _USE_LFN && _LFN_UNICODE
   3821          				i = j = 0;
   3822          				do {
   3823          					w = (i < 11) ? dj.dir[i++] : ' ';
   3824          					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
   3825          						w = w << 8 | dj.dir[i++];
   3826          					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
   3827          				} while (j < 11);
   3828          #else
   3829          				mem_cpy(label, dj.dir, 11);
   \   00000036   0x220B             MOVS     R2,#+11
   \   00000038   0x9905             LDR      R1,[SP, #+20]
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       mem_cpy
   3830          #endif
   3831          				j = 11;
   \   00000040   0x200B             MOVS     R0,#+11
   3832          				do {
   3833          					label[j] = 0;
   \                     ??f_getlabel_2: (+1)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x5429             STRB     R1,[R5, R0]
   3834          					if (!j) break;
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD003             BEQ.N    ??f_getlabel_1
   3835          				} while (label[--j] == ' ');
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x5C29             LDRB     R1,[R5, R0]
   \   0000004E   0x2920             CMP      R1,#+32
   \   00000050   0xD0F7             BEQ.N    ??f_getlabel_2
   3836          			}
   3837          			if (res == FR_NO_FILE) {	/* No label, return nul string */
   \                     ??f_getlabel_1: (+1)
   \   00000052   0x2E04             CMP      R6,#+4
   \   00000054   0xD102             BNE.N    ??f_getlabel_0
   3838          				label[0] = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x7028             STRB     R0,[R5, #+0]
   3839          				res = FR_OK;
   \   0000005A   0x4606             MOV      R6,R0
   3840          			}
   3841          		}
   3842          	}
   3843          
   3844          	/* Get volume serial number */
   3845          	if (res == FR_OK && vsn) {
   \                     ??f_getlabel_0: (+1)
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xD11C             BNE.N    ??f_getlabel_3
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0xD01A             BEQ.N    ??f_getlabel_3
   3846          		res = move_window(dj.fs, dj.fs->volbase);
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x6A01             LDR      R1,[R0, #+32]
   \   00000068   0x.... 0x....      BL       move_window
   \   0000006C   0x0006             MOVS     R6,R0
   3847          		if (res == FR_OK) {
   \   0000006E   0xD114             BNE.N    ??f_getlabel_3
   3848          			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD101             BNE.N    ??f_getlabel_4
   \   00000078   0x2043             MOVS     R0,#+67
   \   0000007A   0xE000             B.N      ??f_getlabel_5
   \                     ??f_getlabel_4: (+1)
   \   0000007C   0x2027             MOVS     R0,#+39
   3849          			*vsn = LD_DWORD(&dj.fs->win[i]);
   \                     ??f_getlabel_5: (+1)
   \   0000007E   0x9900             LDR      R1,[SP, #+0]
   \   00000080   0x4408             ADD      R0,R1,R0
   \   00000082   0x3034             ADDS     R0,R0,#+52
   \   00000084   0x78C1             LDRB     R1,[R0, #+3]
   \   00000086   0x7882             LDRB     R2,[R0, #+2]
   \   00000088   0x0412             LSLS     R2,R2,#+16
   \   0000008A   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000008E   0x7842             LDRB     R2,[R0, #+1]
   \   00000090   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x4308             ORRS     R0,R0,R1
   \   00000098   0x6020             STR      R0,[R4, #+0]
   3850          		}
   3851          	}
   3852          
   3853          	LEAVE_FF(dj.fs, res);
   \                     ??f_getlabel_3: (+1)
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0xB00A             ADD      SP,SP,#+40
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
   3854          }
   3855          
   3856          
   3857          
   3858          #if !_FS_READONLY
   3859          /*-----------------------------------------------------------------------*/
   3860          /* Set volume label                                                      */
   3861          /*-----------------------------------------------------------------------*/
   3862          

   \                                 In section .text, align 2, keep-with-next
   3863          FRESULT f_setlabel (
   3864          	const TCHAR* label	/* Pointer to the volume label to set */
   3865          )
   3866          {
   \                     f_setlabel: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   3867          	FRESULT res;
   3868          	DIR dj;
   3869          	BYTE vn[11];
   3870          	UINT i, j, sl;
   3871          	WCHAR w;
   3872          	DWORD tm;
   3873          
   3874          
   3875          	/* Get logical drive number */
   3876          	res = find_volume(&dj.fs, &label, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA90C             ADD      R1,SP,#+48
   \   00000008   0xA803             ADD      R0,SP,#+12
   \   0000000A   0x.... 0x....      BL       find_volume
   3877          	if (res) LEAVE_FF(dj.fs, res);
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xF040 0x80AD      BNE.W    ??f_setlabel_0
   3878          
   3879          	/* Create a volume label in directory form */
   3880          	vn[0] = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3881          	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
   \   0000001A   0x4604             MOV      R4,R0
   \   0000001C   0xE000             B.N      ??f_setlabel_1
   \                     ??f_setlabel_2: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??f_setlabel_1: (+1)
   \   00000020   0x980C             LDR      R0,[SP, #+48]
   \   00000022   0x5D00             LDRB     R0,[R0, R4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD1FA             BNE.N    ??f_setlabel_2
   3882          	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
   \                     ??f_setlabel_3: (+1)
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD007             BEQ.N    ??f_setlabel_4
   \   0000002C   0x980C             LDR      R0,[SP, #+48]
   \   0000002E   0x4420             ADD      R0,R0,R4
   \   00000030   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \   00000034   0x2820             CMP      R0,#+32
   \   00000036   0xD101             BNE.N    ??f_setlabel_4
   \   00000038   0x1E64             SUBS     R4,R4,#+1
   \   0000003A   0xE7F5             B.N      ??f_setlabel_3
   3883          	if (sl) {	/* Create volume label in directory form */
   \                     ??f_setlabel_4: (+1)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD037             BEQ.N    ??f_setlabel_5
   3884          		i = j = 0;
   \   00000040   0x2500             MOVS     R5,#+0
   \   00000042   0x462E             MOV      R6,R5
   3885          		do {
   3886          #if _USE_LFN && _LFN_UNICODE
   3887          			w = ff_convert(ff_wtoupper(label[i++]), 0);
   3888          #else
   3889          			w = (BYTE)label[i++];
   \                     ??f_setlabel_6: (+1)
   \   00000044   0x980C             LDR      R0,[SP, #+48]
   \   00000046   0x5D87             LDRB     R7,[R0, R6]
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   3890          			if (IsDBCS1(w))
   3891          				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   3892          #if _USE_LFN
   3893          			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   3894          #else
   3895          			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
   \   0000004A   0xF1A7 0x0061      SUB      R0,R7,#+97
   \   0000004E   0x281A             CMP      R0,#+26
   \   00000050   0xD201             BCS.N    ??f_setlabel_7
   \   00000052   0x3F20             SUBS     R7,R7,#+32
   \   00000054   0xB2BF             UXTH     R7,R7
   3896          #ifdef _EXCVT
   3897          			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
   \                     ??f_setlabel_7: (+1)
   \   00000056   0x2F80             CMP      R7,#+128
   \   00000058   0xDB04             BLT.N    ??f_setlabel_8
   \   0000005A   0x.... 0x....      ADR.W    R0,ExCvt
   \   0000005E   0x4438             ADD      R0,R0,R7
   \   00000060   0xF810 0x7C80      LDRB     R7,[R0, #-128]
   3898          #else
   3899          			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
   3900          #endif
   3901          #endif
   3902          #endif
   3903          			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
   \                     ??f_setlabel_8: (+1)
   \   00000064   0x2F00             CMP      R7,#+0
   \   00000066   0xD021             BEQ.N    ??f_setlabel_9
   \   00000068   0x4639             MOV      R1,R7
   \   0000006A   0x.... 0x....      ADR.W    R0,?_1
   \   0000006E   0x.... 0x....      BL       chk_chr
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD11A             BNE.N    ??f_setlabel_9
   \   00000076   0x2FFF             CMP      R7,#+255
   \   00000078   0xDD01             BLE.N    ??f_setlabel_10
   \   0000007A   0x200A             MOVS     R0,#+10
   \   0000007C   0xE000             B.N      ??f_setlabel_11
   \                     ??f_setlabel_10: (+1)
   \   0000007E   0x200B             MOVS     R0,#+11
   \                     ??f_setlabel_11: (+1)
   \   00000080   0x4285             CMP      R5,R0
   \   00000082   0xD213             BCS.N    ??f_setlabel_9
   3904          				LEAVE_FF(dj.fs, FR_INVALID_NAME);
   3905          			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x2FFF             CMP      R7,#+255
   \   00000088   0xDD02             BLE.N    ??f_setlabel_12
   \   0000008A   0x1239             ASRS     R1,R7,#+8
   \   0000008C   0x5541             STRB     R1,[R0, R5]
   \   0000008E   0x1C6D             ADDS     R5,R5,#+1
   3906          			vn[j++] = (BYTE)w;
   \                     ??f_setlabel_12: (+1)
   \   00000090   0x5547             STRB     R7,[R0, R5]
   \   00000092   0x1C6D             ADDS     R5,R5,#+1
   3907          		} while (i < sl);
   \   00000094   0x42A6             CMP      R6,R4
   \   00000096   0xD3D5             BCC.N    ??f_setlabel_6
   3908          		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
   \                     ??f_setlabel_13: (+1)
   \   00000098   0x2D0B             CMP      R5,#+11
   \   0000009A   0xD203             BCS.N    ??f_setlabel_14
   \   0000009C   0x2120             MOVS     R1,#+32
   \   0000009E   0x5541             STRB     R1,[R0, R5]
   \   000000A0   0x1C6D             ADDS     R5,R5,#+1
   \   000000A2   0xE7F9             B.N      ??f_setlabel_13
   3909          		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
   \                     ??f_setlabel_14: (+1)
   \   000000A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A8   0x28E5             CMP      R0,#+229
   \   000000AA   0xD101             BNE.N    ??f_setlabel_5
   \                     ??f_setlabel_9: (+1)
   \   000000AC   0x2006             MOVS     R0,#+6
   \   000000AE   0xE05E             B.N      ??f_setlabel_0
   3910          	}
   3911          
   3912          	/* Set volume label */
   3913          	dj.sclust = 0;					/* Open root directory */
   \                     ??f_setlabel_5: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x9005             STR      R0,[SP, #+20]
   3914          	res = dir_sdi(&dj, 0);
   \   000000B4   0x4601             MOV      R1,R0
   \   000000B6   0xA803             ADD      R0,SP,#+12
   \   000000B8   0x.... 0x....      BL       dir_sdi
   3915          	if (res == FR_OK) {
   \   000000BC   0x0001             MOVS     R1,R0
   \   000000BE   0xD156             BNE.N    ??f_setlabel_0
   3916          		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0xA803             ADD      R0,SP,#+12
   \   000000C4   0x.... 0x....      BL       dir_read
   3917          		if (res == FR_OK) {			/* A volume label is found */
   \   000000C8   0x0001             MOVS     R1,R0
   \   000000CA   0xD121             BNE.N    ??f_setlabel_15
   3918          			if (vn[0]) {
   \   000000CC   0x9808             LDR      R0,[SP, #+32]
   \   000000CE   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000D2   0x2900             CMP      R1,#+0
   \   000000D4   0xD013             BEQ.N    ??f_setlabel_16
   3919          				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
   \   000000D6   0x220B             MOVS     R2,#+11
   \   000000D8   0x4669             MOV      R1,SP
   \   000000DA   0x.... 0x....      BL       mem_cpy
   3920          				tm = GET_FATTIME();
   \   000000DE   0x.... 0x....      BL       get_fattime
   3921          				ST_DWORD(dj.dir + DIR_WrtTime, tm);
   \   000000E2   0x9908             LDR      R1,[SP, #+32]
   \   000000E4   0x7588             STRB     R0,[R1, #+22]
   \   000000E6   0x4601             MOV      R1,R0
   \   000000E8   0xB289             UXTH     R1,R1
   \   000000EA   0x0A09             LSRS     R1,R1,#+8
   \   000000EC   0x9A08             LDR      R2,[SP, #+32]
   \   000000EE   0x75D1             STRB     R1,[R2, #+23]
   \   000000F0   0x0C01             LSRS     R1,R0,#+16
   \   000000F2   0x9A08             LDR      R2,[SP, #+32]
   \   000000F4   0x7611             STRB     R1,[R2, #+24]
   \   000000F6   0x0E00             LSRS     R0,R0,#+24
   \   000000F8   0x9908             LDR      R1,[SP, #+32]
   \   000000FA   0x7648             STRB     R0,[R1, #+25]
   \   000000FC   0xE001             B.N      ??f_setlabel_17
   3922          			} else {
   3923          				dj.dir[0] = DDEM;			/* Remove the volume label */
   \                     ??f_setlabel_16: (+1)
   \   000000FE   0x21E5             MOVS     R1,#+229
   \   00000100   0x7001             STRB     R1,[R0, #+0]
   3924          			}
   3925          			dj.fs->wflag = 1;
   \                     ??f_setlabel_17: (+1)
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x9903             LDR      R1,[SP, #+12]
   \   00000106   0x7108             STRB     R0,[R1, #+4]
   3926          			res = sync_fs(dj.fs);
   \   00000108   0x9803             LDR      R0,[SP, #+12]
   \   0000010A   0x.... 0x....      BL       sync_fs
   \   0000010E   0xE02E             B.N      ??f_setlabel_0
   3927          		} else {					/* No volume label is found or error */
   3928          			if (res == FR_NO_FILE) {
   \                     ??f_setlabel_15: (+1)
   \   00000110   0x2804             CMP      R0,#+4
   \   00000112   0xD12C             BNE.N    ??f_setlabel_0
   3929          				res = FR_OK;
   \   00000114   0x2000             MOVS     R0,#+0
   3930          				if (vn[0]) {				/* Create volume label as new */
   \   00000116   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000011A   0x2900             CMP      R1,#+0
   \   0000011C   0xD027             BEQ.N    ??f_setlabel_0
   3931          					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
   \   0000011E   0x2101             MOVS     R1,#+1
   \   00000120   0xA803             ADD      R0,SP,#+12
   \   00000122   0x.... 0x....      BL       dir_alloc
   3932          					if (res == FR_OK) {
   \   00000126   0x0001             MOVS     R1,R0
   \   00000128   0xD121             BNE.N    ??f_setlabel_0
   3933          						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
   \   0000012A   0x2220             MOVS     R2,#+32
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0x9808             LDR      R0,[SP, #+32]
   \   00000130   0x.... 0x....      BL       mem_set
   3934          						mem_cpy(dj.dir, vn, 11);
   \   00000134   0x220B             MOVS     R2,#+11
   \   00000136   0x4669             MOV      R1,SP
   \   00000138   0x9808             LDR      R0,[SP, #+32]
   \   0000013A   0x.... 0x....      BL       mem_cpy
   3935          						dj.dir[DIR_Attr] = AM_VOL;
   \   0000013E   0x2008             MOVS     R0,#+8
   \   00000140   0x9908             LDR      R1,[SP, #+32]
   \   00000142   0x72C8             STRB     R0,[R1, #+11]
   3936          						tm = GET_FATTIME();
   \   00000144   0x.... 0x....      BL       get_fattime
   3937          						ST_DWORD(dj.dir + DIR_WrtTime, tm);
   \   00000148   0x9908             LDR      R1,[SP, #+32]
   \   0000014A   0x7588             STRB     R0,[R1, #+22]
   \   0000014C   0x4601             MOV      R1,R0
   \   0000014E   0xB289             UXTH     R1,R1
   \   00000150   0x0A09             LSRS     R1,R1,#+8
   \   00000152   0x9A08             LDR      R2,[SP, #+32]
   \   00000154   0x75D1             STRB     R1,[R2, #+23]
   \   00000156   0x0C01             LSRS     R1,R0,#+16
   \   00000158   0x9A08             LDR      R2,[SP, #+32]
   \   0000015A   0x7611             STRB     R1,[R2, #+24]
   \   0000015C   0x0E00             LSRS     R0,R0,#+24
   \   0000015E   0x9908             LDR      R1,[SP, #+32]
   \   00000160   0x7648             STRB     R0,[R1, #+25]
   3938          						dj.fs->wflag = 1;
   \   00000162   0x2001             MOVS     R0,#+1
   \   00000164   0x9903             LDR      R1,[SP, #+12]
   \   00000166   0x7108             STRB     R0,[R1, #+4]
   3939          						res = sync_fs(dj.fs);
   \   00000168   0x9803             LDR      R0,[SP, #+12]
   \   0000016A   0x.... 0x....      BL       sync_fs
   3940          					}
   3941          				}
   3942          			}
   3943          		}
   3944          	}
   3945          
   3946          	LEAVE_FF(dj.fs, res);
   \                     ??f_setlabel_0: (+1)
   \   0000016E   0xB00D             ADD      SP,SP,#+52
   \   00000170   0xBDF0             POP      {R4-R7,PC}       ;; return
   3947          }
   3948          
   3949          #endif /* !_FS_READONLY */
   3950          #endif /* _USE_LABEL */
   3951          
   3952          
   3953          
   3954          /*-----------------------------------------------------------------------*/
   3955          /* Forward data to the stream directly (available on only tiny cfg)      */
   3956          /*-----------------------------------------------------------------------*/
   3957          #if _USE_FORWARD && _FS_TINY
   3958          
   3959          FRESULT f_forward (
   3960          	FIL* fp, 						/* Pointer to the file object */
   3961          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3962          	UINT btf,						/* Number of bytes to forward */
   3963          	UINT* bf						/* Pointer to number of bytes forwarded */
   3964          )
   3965          {
   3966          	FRESULT res;
   3967          	DWORD remain, clst, sect;
   3968          	UINT rcnt;
   3969          	BYTE csect;
   3970          
   3971          
   3972          	*bf = 0;	/* Clear transfer byte counter */
   3973          
   3974          	res = validate(fp);								/* Check validity of the object */
   3975          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3976          	if (fp->err)									/* Check error */
   3977          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   3978          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3979          		LEAVE_FF(fp->fs, FR_DENIED);
   3980          
   3981          	remain = fp->fsize - fp->fptr;
   3982          	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
   3983          
   3984          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3985          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   3986          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3987          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3988          			if (!csect) {							/* On the cluster boundary? */
   3989          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3990          					fp->sclust : get_fat(fp->fs, fp->clust);
   3991          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3992          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3993          				fp->clust = clst;					/* Update current cluster */
   3994          			}
   3995          		}
   3996          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3997          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3998          		sect += csect;
   3999          		if (move_window(fp->fs, sect) != FR_OK)		/* Move sector window */
   4000          			ABORT(fp->fs, FR_DISK_ERR);
   4001          		fp->dsect = sect;
   4002          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   4003          		if (rcnt > btf) rcnt = btf;
   4004          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   4005          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   4006          	}
   4007          
   4008          	LEAVE_FF(fp->fs, FR_OK);
   4009          }
   4010          #endif /* _USE_FORWARD */
   4011          
   4012          
   4013          
   4014          #if _USE_MKFS && !_FS_READONLY
   4015          /*-----------------------------------------------------------------------*/
   4016          /* Create file system on the logical drive                               */
   4017          /*-----------------------------------------------------------------------*/
   4018          #define N_ROOTDIR	512		/* Number of root directory entries for FAT12/16 */
   4019          #define N_FATS		1		/* Number of FATs (1 or 2) */
   4020          
   4021          
   4022          FRESULT f_mkfs (
   4023          	const TCHAR* path,	/* Logical drive number */
   4024          	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
   4025          	UINT au				/* Size of allocation unit in unit of byte or sector */
   4026          )
   4027          {
   4028          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   4029          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   4030          	int vol;
   4031          	BYTE fmt, md, sys, *tbl, pdrv, part;
   4032          	DWORD n_clst, vs, n, wsect;
   4033          	UINT i;
   4034          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   4035          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   4036          	FATFS *fs;
   4037          	DSTATUS stat;
   4038          #if _USE_TRIM
   4039          	DWORD eb[2];
   4040          #endif
   4041          
   4042          
   4043          	/* Check mounted drive and clear work area */
   4044          	if (sfd > 1) return FR_INVALID_PARAMETER;
   4045          	vol = get_ldnumber(&path);
   4046          	if (vol < 0) return FR_INVALID_DRIVE;
   4047          	fs = FatFs[vol];
   4048          	if (!fs) return FR_NOT_ENABLED;
   4049          	fs->fs_type = 0;
   4050          	pdrv = LD2PD(vol);	/* Physical drive */
   4051          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   4052          
   4053          	/* Get disk statics */
   4054          	stat = disk_initialize(pdrv);
   4055          	if (stat & STA_NOINIT) return FR_NOT_READY;
   4056          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   4057          #if _MAX_SS != _MIN_SS		/* Get disk sector size */
   4058          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
   4059          		return FR_DISK_ERR;
   4060          #endif
   4061          	if (_MULTI_PARTITION && part) {
   4062          		/* Get partition information from partition table in the MBR */
   4063          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   4064          		if (LD_WORD(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   4065          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   4066          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   4067          		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
   4068          		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
   4069          	} else {
   4070          		/* Create a partition in this function */
   4071          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   4072          			return FR_DISK_ERR;
   4073          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   4074          		n_vol -= b_vol;				/* Volume size */
   4075          	}
   4076          
   4077          	if (au & (au - 1)) au = 0;
   4078          	if (!au) {						/* AU auto selection */
   4079          		vs = n_vol / (2000 / (SS(fs) / 512));
   4080          		for (i = 0; vs < vst[i]; i++) ;
   4081          		au = cst[i];
   4082          	}
   4083          	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
   4084          	if (!au) au = 1;
   4085          	if (au > 128) au = 128;
   4086          
   4087          	/* Pre-compute number of clusters and FAT sub-type */
   4088          	n_clst = n_vol / au;
   4089          	fmt = FS_FAT12;
   4090          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   4091          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   4092          
   4093          	/* Determine offset and size of FAT structure */
   4094          	if (fmt == FS_FAT32) {
   4095          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   4096          		n_rsv = 32;
   4097          		n_dir = 0;
   4098          	} else {
   4099          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   4100          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   4101          		n_rsv = 1;
   4102          		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
   4103          	}
   4104          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   4105          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   4106          	b_data = b_dir + n_dir;				/* Data area start sector */
   4107          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   4108          
   4109          	/* Align data start sector to erase block boundary (for flash memory media) */
   4110          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   4111          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   4112          	n = (n - b_data) / N_FATS;
   4113          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   4114          		n_rsv += n;
   4115          		b_fat += n;
   4116          	} else {					/* FAT12/16: Expand FAT size */
   4117          		n_fat += n;
   4118          	}
   4119          
   4120          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   4121          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   4122          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   4123          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   4124          		return FR_MKFS_ABORTED;
   4125          
   4126          	/* Determine system ID in the partition table */
   4127          	if (fmt == FS_FAT32) {
   4128          		sys = 0x0C;		/* FAT32X */
   4129          	} else {
   4130          		if (fmt == FS_FAT12 && n_vol < 0x10000) {
   4131          			sys = 0x01;	/* FAT12(<65536) */
   4132          		} else {
   4133          			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
   4134          		}
   4135          	}
   4136          
   4137          	if (_MULTI_PARTITION && part) {
   4138          		/* Update system ID in the partition table */
   4139          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   4140          		tbl[4] = sys;
   4141          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
   4142          			return FR_DISK_ERR;
   4143          		md = 0xF8;
   4144          	} else {
   4145          		if (sfd) {	/* No partition table (SFD) */
   4146          			md = 0xF0;
   4147          		} else {	/* Create partition table (FDISK) */
   4148          			mem_set(fs->win, 0, SS(fs));
   4149          			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
   4150          			tbl[1] = 1;						/* Partition start head */
   4151          			tbl[2] = 1;						/* Partition start sector */
   4152          			tbl[3] = 0;						/* Partition start cylinder */
   4153          			tbl[4] = sys;					/* System type */
   4154          			tbl[5] = 254;					/* Partition end head */
   4155          			n = (b_vol + n_vol) / 63 / 255;
   4156          			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
   4157          			tbl[7] = (BYTE)n;				/* End cylinder */
   4158          			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
   4159          			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
   4160          			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
   4161          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
   4162          				return FR_DISK_ERR;
   4163          			md = 0xF8;
   4164          		}
   4165          	}
   4166          
   4167          	/* Create BPB in the VBR */
   4168          	tbl = fs->win;							/* Clear sector */
   4169          	mem_set(tbl, 0, SS(fs));
   4170          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   4171          	i = SS(fs);								/* Sector size */
   4172          	ST_WORD(tbl + BPB_BytsPerSec, i);
   4173          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   4174          	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
   4175          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   4176          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
   4177          	ST_WORD(tbl + BPB_RootEntCnt, i);
   4178          	if (n_vol < 0x10000) {					/* Number of total sectors */
   4179          		ST_WORD(tbl + BPB_TotSec16, n_vol);
   4180          	} else {
   4181          		ST_DWORD(tbl + BPB_TotSec32, n_vol);
   4182          	}
   4183          	tbl[BPB_Media] = md;					/* Media descriptor */
   4184          	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
   4185          	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
   4186          	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
   4187          	n = GET_FATTIME();						/* Use current time as VSN */
   4188          	if (fmt == FS_FAT32) {
   4189          		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
   4190          		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   4191          		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
   4192          		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
   4193          		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
   4194          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   4195          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   4196          		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   4197          	} else {
   4198          		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
   4199          		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   4200          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   4201          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   4202          		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   4203          	}
   4204          	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   4205          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   4206          		return FR_DISK_ERR;
   4207          	if (fmt == FS_FAT32)					/* Write backup VBR if needed (VBR + 6) */
   4208          		disk_write(pdrv, tbl, b_vol + 6, 1);
   4209          
   4210          	/* Initialize FAT area */
   4211          	wsect = b_fat;
   4212          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   4213          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   4214          		n = md;								/* Media descriptor byte */
   4215          		if (fmt != FS_FAT32) {
   4216          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   4217          			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
   4218          		} else {
   4219          			n |= 0xFFFFFF00;
   4220          			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
   4221          			ST_DWORD(tbl + 4, 0xFFFFFFFF);
   4222          			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
   4223          		}
   4224          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   4225          			return FR_DISK_ERR;
   4226          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   4227          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   4228          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   4229          				return FR_DISK_ERR;
   4230          		}
   4231          	}
   4232          
   4233          	/* Initialize root directory */
   4234          	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
   4235          	do {
   4236          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   4237          			return FR_DISK_ERR;
   4238          	} while (--i);
   4239          
   4240          #if _USE_TRIM	/* Erase data area if needed */
   4241          	{
   4242          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   4243          		disk_ioctl(pdrv, CTRL_TRIM, eb);
   4244          	}
   4245          #endif
   4246          
   4247          	/* Create FSINFO if needed */
   4248          	if (fmt == FS_FAT32) {
   4249          		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
   4250          		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
   4251          		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   4252          		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
   4253          		ST_WORD(tbl + BS_55AA, 0xAA55);
   4254          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
   4255          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
   4256          	}
   4257          
   4258          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   4259          }
   4260          
   4261          
   4262          
   4263          #if _MULTI_PARTITION
   4264          /*-----------------------------------------------------------------------*/
   4265          /* Create partition table on the physical drive                          */
   4266          /*-----------------------------------------------------------------------*/
   4267          
   4268          FRESULT f_fdisk (
   4269          	BYTE pdrv,			/* Physical drive number */
   4270          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   4271          	void* work			/* Pointer to the working buffer */
   4272          )
   4273          {
   4274          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   4275          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   4276          	DSTATUS stat;
   4277          	DWORD sz_disk, sz_part, s_part;
   4278          
   4279          
   4280          	stat = disk_initialize(pdrv);
   4281          	if (stat & STA_NOINIT) return FR_NOT_READY;
   4282          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   4283          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   4284          
   4285          	/* Determine CHS in the table regardless of the drive geometry */
   4286          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   4287          	if (n == 256) n--;
   4288          	e_hd = n - 1;
   4289          	sz_cyl = 63 * n;
   4290          	tot_cyl = sz_disk / sz_cyl;
   4291          
   4292          	/* Create partition table */
   4293          	mem_set(buf, 0, _MAX_SS);
   4294          	p = buf + MBR_Table; b_cyl = 0;
   4295          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   4296          		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   4297          		if (!p_cyl) continue;
   4298          		s_part = (DWORD)sz_cyl * b_cyl;
   4299          		sz_part = (DWORD)sz_cyl * p_cyl;
   4300          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   4301          			s_hd = 1;
   4302          			s_part += 63; sz_part -= 63;
   4303          		} else {
   4304          			s_hd = 0;
   4305          		}
   4306          		e_cyl = b_cyl + p_cyl - 1;
   4307          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   4308          
   4309          		/* Set partition table */
   4310          		p[1] = s_hd;						/* Start head */
   4311          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   4312          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   4313          		p[4] = 0x06;						/* System type (temporary setting) */
   4314          		p[5] = e_hd;						/* End head */
   4315          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   4316          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   4317          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   4318          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   4319          
   4320          		/* Next partition */
   4321          		b_cyl += p_cyl;
   4322          	}
   4323          	ST_WORD(p, 0xAA55);
   4324          
   4325          	/* Write it to the MBR */
   4326          	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
   4327          }
   4328          
   4329          
   4330          #endif /* _MULTI_PARTITION */
   4331          #endif /* _USE_MKFS && !_FS_READONLY */
   4332          
   4333          
   4334          
   4335          
   4336          #if _USE_STRFUNC
   4337          /*-----------------------------------------------------------------------*/
   4338          /* Get a string from the file                                            */
   4339          /*-----------------------------------------------------------------------*/
   4340          

   \                                 In section .text, align 2, keep-with-next
   4341          TCHAR* f_gets (
   4342          	TCHAR* buff,	/* Pointer to the string buffer to read */
   4343          	int len,		/* Size of string buffer (characters) */
   4344          	FIL* fp			/* Pointer to the file object */
   4345          )
   4346          {
   \                     f_gets: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   4347          	int n = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   4348          	TCHAR c, *p = buff;
   \   0000000C   0x46A0             MOV      R8,R4
   4349          	BYTE s[2];
   4350          	UINT rc;
   4351          
   4352          
   4353          	while (n < len - 1) {	/* Read characters until buffer gets filled */
   \                     ??f_gets_0: (+1)
   \   0000000E   0x1E68             SUBS     R0,R5,#+1
   \   00000010   0x4287             CMP      R7,R0
   \   00000012   0xDA12             BGE.N    ??f_gets_1
   4354          #if _USE_LFN && _LFN_UNICODE
   4355          #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
   4356          		f_read(fp, s, 1, &rc);
   4357          		if (rc != 1) break;
   4358          		c = s[0];
   4359          		if (c >= 0x80) {
   4360          			if (c < 0xC0) continue;	/* Skip stray trailer */
   4361          			if (c < 0xE0) {			/* Two-byte sequence */
   4362          				f_read(fp, s, 1, &rc);
   4363          				if (rc != 1) break;
   4364          				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
   4365          				if (c < 0x80) c = '?';
   4366          			} else {
   4367          				if (c < 0xF0) {		/* Three-byte sequence */
   4368          					f_read(fp, s, 2, &rc);
   4369          					if (rc != 2) break;
   4370          					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
   4371          					if (c < 0x800) c = '?';
   4372          				} else {			/* Reject four-byte sequence */
   4373          					c = '?';
   4374          				}
   4375          			}
   4376          		}
   4377          #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
   4378          		f_read(fp, s, 2, &rc);
   4379          		if (rc != 2) break;
   4380          		c = s[1] + (s[0] << 8);
   4381          #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
   4382          		f_read(fp, s, 2, &rc);
   4383          		if (rc != 2) break;
   4384          		c = s[0] + (s[1] << 8);
   4385          #else						/* Read a character in ANSI/OEM */
   4386          		f_read(fp, s, 1, &rc);
   4387          		if (rc != 1) break;
   4388          		c = s[0];
   4389          		if (IsDBCS1(c)) {
   4390          			f_read(fp, s, 1, &rc);
   4391          			if (rc != 1) break;
   4392          			c = (c << 8) + s[0];
   4393          		}
   4394          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   4395          		if (!c) c = '?';
   4396          #endif
   4397          #else						/* Read a character without conversion */
   4398          		f_read(fp, s, 1, &rc);
   \   00000014   0x466B             MOV      R3,SP
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x.... 0x....      BL       f_read
   4399          		if (rc != 1) break;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD109             BNE.N    ??f_gets_1
   4400          		c = s[0];
   \   00000026   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   4401          #endif
   4402          		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
   \   0000002A   0x4601             MOV      R1,R0
   \   0000002C   0x290D             CMP      R1,#+13
   \   0000002E   0xD0EE             BEQ.N    ??f_gets_0
   4403          		*p++ = c;
   \   00000030   0xF808 0x0B01      STRB     R0,[R8], #+1
   4404          		n++;
   \   00000034   0x1C7F             ADDS     R7,R7,#+1
   4405          		if (c == '\n') break;		/* Break on EOL */
   \   00000036   0x290A             CMP      R1,#+10
   \   00000038   0xD1E9             BNE.N    ??f_gets_0
   4406          	}
   4407          	*p = 0;
   \                     ??f_gets_1: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF888 0x0000      STRB     R0,[R8, #+0]
   4408          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD100             BNE.N    ??f_gets_2
   \   00000044   0x4604             MOV      R4,R0
   \                     ??f_gets_2: (+1)
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   4409          }
   4410          
   4411          
   4412          
   4413          
   4414          #if !_FS_READONLY
   4415          #include <stdarg.h>
   4416          /*-----------------------------------------------------------------------*/
   4417          /* Put a character to the file                                           */
   4418          /*-----------------------------------------------------------------------*/
   4419          
   4420          typedef struct {
   4421          	FIL* fp;
   4422          	int idx, nchr;
   4423          	BYTE buf[64];
   4424          } putbuff;
   4425          
   4426          

   \                                 In section .text, align 2, keep-with-next
   4427          static
   4428          void putc_bfd (
   4429          	putbuff* pb,
   4430          	TCHAR c
   4431          )
   4432          {
   \                     putc_bfd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   4433          	UINT bw;
   4434          	int i;
   4435          
   4436          
   4437          	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
   \   00000008   0x2D0A             CMP      R5,#+10
   \   0000000A   0xD102             BNE.N    ??putc_bfd_0
   4438          		putc_bfd(pb, '\r');
   \   0000000C   0x210D             MOVS     R1,#+13
   \   0000000E   0xF7FF 0xFFF7      BL       putc_bfd
   4439          
   4440          	i = pb->idx;	/* Buffer write index (-1:error) */
   \                     ??putc_bfd_0: (+1)
   \   00000012   0x6866             LDR      R6,[R4, #+4]
   4441          	if (i < 0) return;
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD416             BMI.N    ??putc_bfd_1
   4442          
   4443          #if _USE_LFN && _LFN_UNICODE
   4444          #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
   4445          	if (c < 0x80) {				/* 7-bit */
   4446          		pb->buf[i++] = (BYTE)c;
   4447          	} else {
   4448          		if (c < 0x800) {		/* 11-bit */
   4449          			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
   4450          		} else {				/* 16-bit */
   4451          			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
   4452          			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
   4453          		}
   4454          		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
   4455          	}
   4456          #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
   4457          	pb->buf[i++] = (BYTE)(c >> 8);
   4458          	pb->buf[i++] = (BYTE)c;
   4459          #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
   4460          	pb->buf[i++] = (BYTE)c;
   4461          	pb->buf[i++] = (BYTE)(c >> 8);
   4462          #else							/* Write a character in ANSI/OEM */
   4463          	c = ff_convert(c, 0);	/* Unicode -> OEM */
   4464          	if (!c) c = '?';
   4465          	if (c >= 0x100)
   4466          		pb->buf[i++] = (BYTE)(c >> 8);
   4467          	pb->buf[i++] = (BYTE)c;
   4468          #endif
   4469          #else							/* Write a character without conversion */
   4470          	pb->buf[i++] = (BYTE)c;
   \   00000018   0x19A0             ADDS     R0,R4,R6
   \   0000001A   0x7305             STRB     R5,[R0, #+12]
   \   0000001C   0x1C76             ADDS     R6,R6,#+1
   4471          #endif
   4472          
   4473          	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
   \   0000001E   0x2E3D             CMP      R6,#+61
   \   00000020   0xDB0D             BLT.N    ??putc_bfd_2
   4474          		f_write(pb->fp, pb->buf, (UINT)i, &bw);
   \   00000022   0x466B             MOV      R3,SP
   \   00000024   0x4632             MOV      R2,R6
   \   00000026   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       f_write
   4475          		i = (bw == (UINT)i) ? 0 : -1;
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x42B0             CMP      R0,R6
   \   00000034   0xD101             BNE.N    ??putc_bfd_3
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE001             B.N      ??putc_bfd_2
   \                     ??putc_bfd_3: (+1)
   \   0000003A   0xF04F 0x36FF      MOV      R6,#-1
   4476          	}
   4477          	pb->idx = i;
   \                     ??putc_bfd_2: (+1)
   \   0000003E   0x6066             STR      R6,[R4, #+4]
   4478          	pb->nchr++;
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   4479          }
   \                     ??putc_bfd_1: (+1)
   \   00000046   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   4480          
   4481          
   4482          

   \                                 In section .text, align 2, keep-with-next
   4483          int f_putc (
   4484          	TCHAR c,	/* A character to be output */
   4485          	FIL* fp		/* Pointer to the file object */
   4486          )
   4487          {
   \                     f_putc: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   4488          	putbuff pb;
   4489          	UINT nw;
   4490          
   4491          
   4492          	pb.fp = fp;			/* Initialize output buffer */
   \   00000004   0x9101             STR      R1,[SP, #+4]
   4493          	pb.nchr = pb.idx = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x9102             STR      R1,[SP, #+8]
   \   0000000A   0x9103             STR      R1,[SP, #+12]
   4494          
   4495          	putc_bfd(&pb, c);	/* Put a character */
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       putc_bfd
   4496          
   4497          	if (   pb.idx >= 0	/* Flush buffered characters to the file */
   4498          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4499          		&& (UINT)pb.idx == nw) return pb.nchr;
   \   00000014   0x9A02             LDR      R2,[SP, #+8]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD40C             BMI.N    ??f_putc_0
   \   0000001A   0x466B             MOV      R3,SP
   \   0000001C   0xA904             ADD      R1,SP,#+16
   \   0000001E   0x9801             LDR      R0,[SP, #+4]
   \   00000020   0x.... 0x....      BL       f_write
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD105             BNE.N    ??f_putc_0
   \   00000028   0x9802             LDR      R0,[SP, #+8]
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD101             BNE.N    ??f_putc_0
   \   00000030   0x9803             LDR      R0,[SP, #+12]
   \   00000032   0xE001             B.N      ??f_putc_1
   4500          	return EOF;
   \                     ??f_putc_0: (+1)
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??f_putc_1: (+1)
   \   00000038   0xB015             ADD      SP,SP,#+84
   \   0000003A   0xBD00             POP      {PC}             ;; return
   4501          }
   4502          
   4503          
   4504          
   4505          
   4506          /*-----------------------------------------------------------------------*/
   4507          /* Put a string to the file                                              */
   4508          /*-----------------------------------------------------------------------*/
   4509          

   \                                 In section .text, align 2, keep-with-next
   4510          int f_puts (
   4511          	const TCHAR* str,	/* Pointer to the string to be output */
   4512          	FIL* fp				/* Pointer to the file object */
   4513          )
   4514          {
   \                     f_puts: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x4604             MOV      R4,R0
   4515          	putbuff pb;
   4516          	UINT nw;
   4517          
   4518          
   4519          	pb.fp = fp;				/* Initialize output buffer */
   \   00000006   0x9101             STR      R1,[SP, #+4]
   4520          	pb.nchr = pb.idx = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9002             STR      R0,[SP, #+8]
   \   0000000C   0x9003             STR      R0,[SP, #+12]
   \   0000000E   0xE004             B.N      ??f_puts_0
   4521          
   4522          	while (*str)			/* Put the string */
   4523          		putc_bfd(&pb, *str++);
   \                     ??f_puts_1: (+1)
   \   00000010   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       putc_bfd
   \                     ??f_puts_0: (+1)
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD1F7             BNE.N    ??f_puts_1
   4524          
   4525          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   4526          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4527          		&& (UINT)pb.idx == nw) return pb.nchr;
   \   00000020   0x9A02             LDR      R2,[SP, #+8]
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD40C             BMI.N    ??f_puts_2
   \   00000026   0x466B             MOV      R3,SP
   \   00000028   0xA904             ADD      R1,SP,#+16
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0x.... 0x....      BL       f_write
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD105             BNE.N    ??f_puts_2
   \   00000034   0x9802             LDR      R0,[SP, #+8]
   \   00000036   0x9900             LDR      R1,[SP, #+0]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD101             BNE.N    ??f_puts_2
   \   0000003C   0x9803             LDR      R0,[SP, #+12]
   \   0000003E   0xE001             B.N      ??f_puts_3
   4528          	return EOF;
   \                     ??f_puts_2: (+1)
   \   00000040   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??f_puts_3: (+1)
   \   00000044   0xB014             ADD      SP,SP,#+80
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   4529          }
   4530          
   4531          
   4532          
   4533          
   4534          /*-----------------------------------------------------------------------*/
   4535          /* Put a formatted string to the file                                    */
   4536          /*-----------------------------------------------------------------------*/
   4537          

   \                                 In section .text, align 2, keep-with-next
   4538          int f_printf (
   4539          	FIL* fp,			/* Pointer to the file object */
   4540          	const TCHAR* fmt,	/* Pointer to the format string */
   4541          	...					/* Optional arguments... */
   4542          )
   4543          {
   \                     f_printf: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000006   0xB099             SUB      SP,SP,#+100
   \   00000008   0x460C             MOV      R4,R1
   4544          	va_list arp;
   4545          	BYTE f, r;
   4546          	UINT nw, i, j, w;
   4547          	DWORD v;
   4548          	TCHAR c, d, s[16], *p;
   4549          	putbuff pb;
   4550          
   4551          
   4552          	pb.fp = fp;				/* Initialize output buffer */
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   4553          	pb.nchr = pb.idx = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x9003             STR      R0,[SP, #+12]
   4554          
   4555          	va_start(arp, fmt);
   \   00000012   0xAF22             ADD      R7,SP,#+136
   \   00000014   0xE006             B.N      ??f_printf_0
   4556          
   4557          	for (;;) {
   4558          		c = *fmt++;
   4559          		if (c == 0) break;			/* End of string */
   4560          		if (c != '%') {				/* Non escape character */
   4561          			putc_bfd(&pb, c);
   4562          			continue;
   4563          		}
   4564          		w = f = 0;
   4565          		c = *fmt++;
   4566          		if (c == '0') {				/* Flag: '0' padding */
   4567          			f = 1; c = *fmt++;
   4568          		} else {
   4569          			if (c == '-') {			/* Flag: left justified */
   4570          				f = 2; c = *fmt++;
   4571          			}
   4572          		}
   4573          		while (IsDigit(c)) {		/* Precision */
   4574          			w = w * 10 + c - '0';
   4575          			c = *fmt++;
   4576          		}
   4577          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   4578          			f |= 4; c = *fmt++;
   4579          		}
   4580          		if (!c) break;
   4581          		d = c;
   4582          		if (IsLower(d)) d -= 0x20;
   4583          		switch (d) {				/* Type is... */
   4584          		case 'S' :					/* String */
   4585          			p = va_arg(arp, TCHAR*);
   4586          			for (j = 0; p[j]; j++) ;
   4587          			if (!(f & 2)) {
   4588          				while (j++ < w) putc_bfd(&pb, ' ');
   4589          			}
   4590          			while (*p) putc_bfd(&pb, *p++);
   4591          			while (j++ < w) putc_bfd(&pb, ' ');
   4592          			continue;
   4593          		case 'C' :					/* Character */
   4594          			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
   \                     ??f_printf_1: (+1)
   \   00000016   0xF857 0x0B04      LDR      R0,[R7], #+4
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       putc_bfd
   \                     ??f_printf_0: (+1)
   \   00000024   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xF000 0x80D7      BEQ.W    ??f_printf_2
   \   0000002E   0x2925             CMP      R1,#+37
   \   00000030   0xD174             BNE.N    ??f_printf_3
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0x4635             MOV      R5,R6
   \   00000036   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   0000003A   0x2930             CMP      R1,#+48
   \   0000003C   0xD103             BNE.N    ??f_printf_4
   \   0000003E   0x2601             MOVS     R6,#+1
   \   00000040   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000044   0xE00D             B.N      ??f_printf_5
   \                     ??f_printf_4: (+1)
   \   00000046   0x292D             CMP      R1,#+45
   \   00000048   0xD10B             BNE.N    ??f_printf_5
   \   0000004A   0x2602             MOVS     R6,#+2
   \   0000004C   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000050   0xE007             B.N      ??f_printf_5
   \                     ??f_printf_6: (+1)
   \   00000052   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000056   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   0000005A   0xF1A0 0x0530      SUB      R5,R0,#+48
   \   0000005E   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \                     ??f_printf_5: (+1)
   \   00000062   0xF1A1 0x0030      SUB      R0,R1,#+48
   \   00000066   0x280A             CMP      R0,#+10
   \   00000068   0xD3F3             BCC.N    ??f_printf_6
   \   0000006A   0x296C             CMP      R1,#+108
   \   0000006C   0xD001             BEQ.N    ??f_printf_7
   \   0000006E   0x294C             CMP      R1,#+76
   \   00000070   0xD103             BNE.N    ??f_printf_8
   \                     ??f_printf_7: (+1)
   \   00000072   0xF046 0x0604      ORR      R6,R6,#0x4
   \   00000076   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \                     ??f_printf_8: (+1)
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xF000 0x80AE      BEQ.W    ??f_printf_2
   \   00000080   0x468A             MOV      R10,R1
   \   00000082   0xF1AA 0x0061      SUB      R0,R10,#+97
   \   00000086   0x281A             CMP      R0,#+26
   \   00000088   0xD203             BCS.N    ??f_printf_9
   \   0000008A   0xF1AA 0x0A20      SUB      R10,R10,#+32
   \   0000008E   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??f_printf_9: (+1)
   \   00000092   0x4650             MOV      R0,R10
   \   00000094   0x2842             CMP      R0,#+66
   \   00000096   0xD037             BEQ.N    ??f_printf_10
   \   00000098   0x2843             CMP      R0,#+67
   \   0000009A   0xD0BC             BEQ.N    ??f_printf_1
   \   0000009C   0x2844             CMP      R0,#+68
   \   0000009E   0xD039             BEQ.N    ??f_printf_11
   \   000000A0   0x284F             CMP      R0,#+79
   \   000000A2   0xD035             BEQ.N    ??f_printf_12
   \   000000A4   0x2853             CMP      R0,#+83
   \   000000A6   0xD004             BEQ.N    ??f_printf_13
   \   000000A8   0x2855             CMP      R0,#+85
   \   000000AA   0xD033             BEQ.N    ??f_printf_11
   \   000000AC   0x2858             CMP      R0,#+88
   \   000000AE   0xD033             BEQ.N    ??f_printf_14
   \   000000B0   0xE034             B.N      ??f_printf_3
   \                     ??f_printf_13: (+1)
   \   000000B2   0xF857 0x8B04      LDR      R8,[R7], #+4
   \   000000B6   0xF04F 0x0B00      MOV      R11,#+0
   \   000000BA   0xE001             B.N      ??f_printf_15
   \                     ??f_printf_16: (+1)
   \   000000BC   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??f_printf_15: (+1)
   \   000000C0   0xF818 0x000B      LDRB     R0,[R8, R11]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD1F9             BNE.N    ??f_printf_16
   \   000000C8   0x07B0             LSLS     R0,R6,#+30
   \   000000CA   0xD409             BMI.N    ??f_printf_17
   \   000000CC   0xE003             B.N      ??f_printf_18
   \                     ??f_printf_19: (+1)
   \   000000CE   0x2120             MOVS     R1,#+32
   \   000000D0   0xA801             ADD      R0,SP,#+4
   \   000000D2   0x.... 0x....      BL       putc_bfd
   \                     ??f_printf_18: (+1)
   \   000000D6   0x4658             MOV      R0,R11
   \   000000D8   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000000DC   0x42A8             CMP      R0,R5
   \   000000DE   0xD3F6             BCC.N    ??f_printf_19
   \                     ??f_printf_17: (+1)
   \   000000E0   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD005             BEQ.N    ??f_printf_20
   \   000000E8   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   000000EC   0xA801             ADD      R0,SP,#+4
   \   000000EE   0x.... 0x....      BL       putc_bfd
   \   000000F2   0xE7F5             B.N      ??f_printf_17
   \                     ??f_printf_20: (+1)
   \   000000F4   0x4658             MOV      R0,R11
   \   000000F6   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000000FA   0x42A8             CMP      R0,R5
   \   000000FC   0xD292             BCS.N    ??f_printf_0
   \   000000FE   0x2120             MOVS     R1,#+32
   \   00000100   0xA801             ADD      R0,SP,#+4
   \   00000102   0x.... 0x....      BL       putc_bfd
   \   00000106   0xE7F5             B.N      ??f_printf_20
   4595          		case 'B' :					/* Binary */
   4596          			r = 2; break;
   \                     ??f_printf_10: (+1)
   \   00000108   0x2002             MOVS     R0,#+2
   4597          		case 'O' :					/* Octal */
   4598          			r = 8; break;
   4599          		case 'D' :					/* Signed decimal */
   4600          		case 'U' :					/* Unsigned decimal */
   4601          			r = 10; break;
   4602          		case 'X' :					/* Hexdecimal */
   4603          			r = 16; break;
   4604          		default:					/* Unknown type (pass-through) */
   4605          			putc_bfd(&pb, c); continue;
   4606          		}
   4607          
   4608          		/* Get an argument and put it in numeral */
   4609          		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
   \                     ??f_printf_21: (+1)
   \   0000010A   0xF857 0x2B04      LDR      R2,[R7], #+4
   \   0000010E   0xE009             B.N      ??f_printf_22
   \                     ??f_printf_12: (+1)
   \   00000110   0x2008             MOVS     R0,#+8
   \   00000112   0xE7FA             B.N      ??f_printf_21
   \                     ??f_printf_11: (+1)
   \   00000114   0x200A             MOVS     R0,#+10
   \   00000116   0xE7F8             B.N      ??f_printf_21
   \                     ??f_printf_14: (+1)
   \   00000118   0x2010             MOVS     R0,#+16
   \   0000011A   0xE7F6             B.N      ??f_printf_21
   \                     ??f_printf_3: (+1)
   \   0000011C   0xA801             ADD      R0,SP,#+4
   \   0000011E   0x.... 0x....      BL       putc_bfd
   \   00000122   0xE77F             B.N      ??f_printf_0
   4610          		if (d == 'D' && (v & 0x80000000)) {
   \                     ??f_printf_22: (+1)
   \   00000124   0xF1BA 0x0F44      CMP      R10,#+68
   \   00000128   0xD104             BNE.N    ??f_printf_23
   \   0000012A   0x2A00             CMP      R2,#+0
   \   0000012C   0xD502             BPL.N    ??f_printf_23
   4611          			v = 0 - v;
   \   0000012E   0x4252             RSBS     R2,R2,#+0
   4612          			f |= 8;
   \   00000130   0xF046 0x0608      ORR      R6,R6,#0x8
   4613          		}
   4614          		i = 0;
   \                     ??f_printf_23: (+1)
   \   00000134   0xF04F 0x0900      MOV      R9,#+0
   \   00000138   0xF10D 0x0850      ADD      R8,SP,#+80
   4615          		do {
   4616          			d = (TCHAR)(v % r); v /= r;
   \                     ??f_printf_24: (+1)
   \   0000013C   0xFBB2 0xF3F0      UDIV     R3,R2,R0
   \   00000140   0xFB00 0x2A13      MLS      R10,R0,R3,R2
   \   00000144   0xFA5F 0xFA8A      UXTB     R10,R10
   \   00000148   0x461A             MOV      R2,R3
   4617          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   \   0000014A   0x4653             MOV      R3,R10
   \   0000014C   0x2B0A             CMP      R3,#+10
   \   0000014E   0xDB07             BLT.N    ??f_printf_25
   \   00000150   0x2978             CMP      R1,#+120
   \   00000152   0xD101             BNE.N    ??f_printf_26
   \   00000154   0x2327             MOVS     R3,#+39
   \   00000156   0xE000             B.N      ??f_printf_27
   \                     ??f_printf_26: (+1)
   \   00000158   0x2307             MOVS     R3,#+7
   \                     ??f_printf_27: (+1)
   \   0000015A   0x449A             ADD      R10,R3,R10
   \   0000015C   0xFA5F 0xFA8A      UXTB     R10,R10
   4618          			s[i++] = d + '0';
   \                     ??f_printf_25: (+1)
   \   00000160   0xF10A 0x0330      ADD      R3,R10,#+48
   \   00000164   0xF808 0x3009      STRB     R3,[R8, R9]
   \   00000168   0xF109 0x0901      ADD      R9,R9,#+1
   4619          		} while (v && i < sizeof s / sizeof s[0]);
   \   0000016C   0x2A00             CMP      R2,#+0
   \   0000016E   0xD002             BEQ.N    ??f_printf_28
   \   00000170   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000174   0xD3E2             BCC.N    ??f_printf_24
   4620          		if (f & 8) s[i++] = '-';
   \                     ??f_printf_28: (+1)
   \   00000176   0x4630             MOV      R0,R6
   \   00000178   0x0700             LSLS     R0,R0,#+28
   \   0000017A   0xD504             BPL.N    ??f_printf_29
   \   0000017C   0x202D             MOVS     R0,#+45
   \   0000017E   0xF808 0x0009      STRB     R0,[R8, R9]
   \   00000182   0xF109 0x0901      ADD      R9,R9,#+1
   4621          		j = i; d = (f & 1) ? '0' : ' ';
   \                     ??f_printf_29: (+1)
   \   00000186   0x46CB             MOV      R11,R9
   \   00000188   0x4630             MOV      R0,R6
   \   0000018A   0x07C0             LSLS     R0,R0,#+31
   \   0000018C   0xD502             BPL.N    ??f_printf_30
   \   0000018E   0xF04F 0x0A30      MOV      R10,#+48
   \   00000192   0xE006             B.N      ??f_printf_31
   \                     ??f_printf_30: (+1)
   \   00000194   0xF04F 0x0A20      MOV      R10,#+32
   \   00000198   0xE003             B.N      ??f_printf_31
   4622          		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
   \                     ??f_printf_32: (+1)
   \   0000019A   0x4651             MOV      R1,R10
   \   0000019C   0xA801             ADD      R0,SP,#+4
   \   0000019E   0x.... 0x....      BL       putc_bfd
   \                     ??f_printf_31: (+1)
   \   000001A2   0x4630             MOV      R0,R6
   \   000001A4   0x0780             LSLS     R0,R0,#+30
   \   000001A6   0xD404             BMI.N    ??f_printf_33
   \   000001A8   0x4658             MOV      R0,R11
   \   000001AA   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000001AE   0x42A8             CMP      R0,R5
   \   000001B0   0xD3F3             BCC.N    ??f_printf_32
   4623          		do putc_bfd(&pb, s[--i]); while (i);
   \                     ??f_printf_33: (+1)
   \   000001B2   0xF1A9 0x0901      SUB      R9,R9,#+1
   \   000001B6   0xF818 0x1009      LDRB     R1,[R8, R9]
   \   000001BA   0xA801             ADD      R0,SP,#+4
   \   000001BC   0x.... 0x....      BL       putc_bfd
   \   000001C0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001C4   0xD1F5             BNE.N    ??f_printf_33
   4624          		while (j++ < w) putc_bfd(&pb, d);
   \                     ??f_printf_34: (+1)
   \   000001C6   0x4658             MOV      R0,R11
   \   000001C8   0xF100 0x0B01      ADD      R11,R0,#+1
   \   000001CC   0x42A8             CMP      R0,R5
   \   000001CE   0xF4BF 0xAF29      BCS.W    ??f_printf_0
   \   000001D2   0x4651             MOV      R1,R10
   \   000001D4   0xA801             ADD      R0,SP,#+4
   \   000001D6   0x.... 0x....      BL       putc_bfd
   \   000001DA   0xE7F4             B.N      ??f_printf_34
   4625          	}
   4626          
   4627          	va_end(arp);
   4628          
   4629          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   4630          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4631          		&& (UINT)pb.idx == nw) return pb.nchr;
   \                     ??f_printf_2: (+1)
   \   000001DC   0x9A02             LDR      R2,[SP, #+8]
   \   000001DE   0x2A00             CMP      R2,#+0
   \   000001E0   0xD40C             BMI.N    ??f_printf_35
   \   000001E2   0x466B             MOV      R3,SP
   \   000001E4   0xA904             ADD      R1,SP,#+16
   \   000001E6   0x9801             LDR      R0,[SP, #+4]
   \   000001E8   0x.... 0x....      BL       f_write
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD105             BNE.N    ??f_printf_35
   \   000001F0   0x9802             LDR      R0,[SP, #+8]
   \   000001F2   0x9900             LDR      R1,[SP, #+0]
   \   000001F4   0x4288             CMP      R0,R1
   \   000001F6   0xD101             BNE.N    ??f_printf_35
   \   000001F8   0x9803             LDR      R0,[SP, #+12]
   \   000001FA   0xE001             B.N      ??f_printf_36
   4632          	return EOF;
   \                     ??f_printf_35: (+1)
   \   000001FC   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??f_printf_36: (+1)
   \   00000200   0xB019             ADD      SP,SP,#+100
   \   00000202   0xE8BD 0x0FF0      POP      {R4-R11}
   \   00000206   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   4633          }
   4634          
   4635          /*------------------------------------------------------------/
   4636          / Open or create a file in append mode
   4637          /------------------------------------------------------------*/
   4638          

   \                                 In section .text, align 2, keep-with-next
   4639          FRESULT open_append (
   4640              FIL* fp,            /* [OUT] File object to create */
   4641              const char* path    /* [IN]  File name to be opened */
   4642          )
   4643          {
   \                     open_append: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   4644              FRESULT fr;
   4645          
   4646              /* Opens an existing file. If not exist, creates a new file. */
   4647              fr = f_open(fp, path, FA_WRITE | FA_OPEN_ALWAYS);
   \   00000004   0x2212             MOVS     R2,#+18
   \   00000006   0x.... 0x....      BL       f_open
   \   0000000A   0x0005             MOVS     R5,R0
   4648              if (fr == FR_OK) {
   \   0000000C   0xD108             BNE.N    ??open_append_0
   4649                  /* Seek to end of the file to append data */
   4650                  fr = f_lseek(fp, f_size(fp));
   \   0000000E   0x68E1             LDR      R1,[R4, #+12]
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       f_lseek
   \   00000016   0x0005             MOVS     R5,R0
   4651                  if (fr != FR_OK)
   \   00000018   0xD002             BEQ.N    ??open_append_0
   4652                      f_close(fp);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       f_close
   4653              }
   4654              return fr;
   \                     ??open_append_0: (+1)
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4655          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x22 0x2A          DC8 "\"*+,:;<=>?[]|\177"
   \              0x2B 0x2C    
   \              0x3A 0x3B    
   \              0x3C 0x3D    
   \              0x3E 0x3F    
   \              0x5B 0x5D    
   \              0x7C 0x7F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     ExCvt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x22 0x2A          DC8 "\"*+,.:;<=>?[]|\177"
   \              0x2B 0x2C    
   \              0x2E 0x3A    
   \              0x3B 0x3C    
   \              0x3D 0x3E    
   \              0x3F 0x5B    
   \              0x5D 0x7C    
   \              0x7F 0x00    
   4656          
   4657          #endif /* !_FS_READONLY */
   4658          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   check_fs
         8   -> move_window
       0   chk_chr
       0   clust2sect
      24   create_chain
        24   -> get_fat
        24   -> put_fat
      40   create_name
        40   -> chk_chr
        40   -> mem_set
      16   dir_alloc
        16   -> dir_next
        16   -> dir_sdi
        16   -> move_window
      16   dir_find
        16   -> dir_next
        16   -> dir_sdi
        16   -> mem_cmp
        16   -> move_window
      24   dir_next
        24   -> clust2sect
        24   -> create_chain
        24   -> get_fat
        24   -> mem_set
        24   -> sync_window
      16   dir_read
        16   -> dir_next
        16   -> move_window
      16   dir_register
        16   -> dir_alloc
        16   -> mem_cpy
        16   -> mem_set
        16   -> move_window
      16   dir_remove
        16   -> dir_sdi
        16   -> mem_set
        16   -> move_window
      24   dir_sdi
        24   -> clust2sect
        24   -> get_fat
      56   f_chdir
        56   -> find_volume
        56   -> follow_path
        56   -> ld_clust
       8   f_chdrive
         8   -> get_ldnumber
      64   f_chmod
        64   -> find_volume
        64   -> follow_path
        64   -> sync_fs
       8   f_close
         8   -> f_sync
         8   -> validate
       8   f_closedir
         8   -> validate
      16   f_findfirst
         0   -> f_findnext
        16   -> f_opendir
      16   f_findnext
        16   -> f_readdir
        16   -> pattern_matching
      96   f_getcwd
        96   -> dir_next
        96   -> dir_read
        96   -> dir_sdi
        96   -> find_volume
        96   -> get_fileinfo
        96   -> ld_clust
      40   f_getfree
        40   -> find_volume
        40   -> get_fat
        40   -> move_window
      56   f_getlabel
        56   -> dir_read
        56   -> dir_sdi
        56   -> find_volume
        56   -> mem_cpy
        56   -> move_window
      32   f_gets
        32   -> f_read
      24   f_lseek
        24   -> clust2sect
        24   -> create_chain
        24   -> disk_read
        24   -> disk_write
        24   -> get_fat
        24   -> validate
      80   f_mkdir
        80   -> clust2sect
        80   -> create_chain
        80   -> dir_register
        80   -> find_volume
        80   -> follow_path
        80   -> get_fattime
        80   -> mem_cpy
        80   -> mem_set
        80   -> remove_chain
        80   -> st_clust
        80   -> sync_fs
        80   -> sync_window
      24   f_mount
        24   -> find_volume
        24   -> get_ldnumber
      80   f_open
        80   -> dir_register
        80   -> find_volume
        80   -> follow_path
        80   -> get_fattime
        80   -> ld_clust
        80   -> move_window
        80   -> remove_chain
        80   -> st_clust
      32   f_opendir
        32   -> dir_sdi
        32   -> find_volume
        32   -> follow_path
        32   -> ld_clust
     144   f_printf
       144   -> f_write
       144   -> putc_bfd
      88   f_putc
        88   -> f_write
        88   -> putc_bfd
      88   f_puts
        88   -> f_write
        88   -> putc_bfd
      32   f_read
        32   -> clust2sect
        32   -> disk_read
        32   -> disk_write
        32   -> get_fat
        32   -> mem_cpy
        32   -> validate
      24   f_readdir
        24   -> dir_next
        24   -> dir_read
        24   -> dir_sdi
        24   -> get_fileinfo
        24   -> validate
     120   f_rename
       120   -> clust2sect
       120   -> dir_register
       120   -> dir_remove
       120   -> find_volume
       120   -> follow_path
       120   -> get_ldnumber
       120   -> ld_clust
       120   -> mem_cpy
       120   -> move_window
       120   -> st_clust
       120   -> sync_fs
      72   f_setlabel
        72   -> chk_chr
        72   -> dir_alloc
        72   -> dir_read
        72   -> dir_sdi
        72   -> find_volume
        72   -> get_fattime
        72   -> mem_cpy
        72   -> mem_set
        72   -> sync_fs
      64   f_stat
        64   -> find_volume
        64   -> follow_path
        64   -> get_fileinfo
      16   f_sync
        16   -> disk_write
        16   -> get_fattime
        16   -> move_window
        16   -> st_clust
         0   -> sync_fs
        16   -> validate
      16   f_truncate
        16   -> disk_write
        16   -> get_fat
        16   -> put_fat
        16   -> remove_chain
        16   -> validate
      96   f_unlink
        96   -> dir_read
        96   -> dir_remove
        96   -> dir_sdi
        96   -> find_volume
        96   -> follow_path
        96   -> ld_clust
        96   -> mem_cpy
        96   -> remove_chain
        96   -> sync_fs
      56   f_utime
        56   -> find_volume
        56   -> follow_path
        56   -> sync_fs
      32   f_write
        32   -> clust2sect
        32   -> create_chain
        32   -> disk_read
        32   -> disk_write
        32   -> mem_cpy
        32   -> validate
      40   find_volume
        40   -> check_fs
        40   -> disk_initialize
        40   -> disk_status
        40   -> get_ldnumber
        40   -> move_window
      16   follow_path
        16   -> create_name
        16   -> dir_find
        16   -> dir_sdi
        16   -> ld_clust
       0   get_achar
      24   get_fat
        24   -> move_window
       8   get_fileinfo
       4   get_ldnumber
       0   ld_clust
       4   mem_cmp
       0   mem_cpy
       0   mem_set
      16   move_window
        16   -> disk_read
        16   -> sync_window
      16   open_append
        16   -> f_close
        16   -> f_lseek
        16   -> f_open
      32   pattern_matching
        32   -> get_achar
        32   -> pattern_matching
      24   put_fat
        24   -> move_window
      24   putc_bfd
        24   -> f_write
        24   -> putc_bfd
      24   remove_chain
        24   -> get_fat
        24   -> put_fat
       0   st_clust
      16   sync_fs
        16   -> disk_ioctl
        16   -> disk_write
        16   -> mem_set
        16   -> sync_window
      24   sync_window
        24   -> disk_write
       8   validate
         8   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
      16  ?_0
      16  ?_1
       1  CurrVol
     128  ExCvt
      12  Fsid
          FatFs
     110  check_fs
      18  chk_chr
      24  clust2sect
     170  create_chain
     350  create_name
      72  dir_alloc
      72  dir_find
     230  dir_next
      92  dir_read
      56  dir_register
      52  dir_remove
     142  dir_sdi
      80  f_chdir
      24  f_chdrive
      94  f_chmod
      28  f_close
      18  f_closedir
      30  f_findfirst
      50  f_findnext
     250  f_getcwd
     224  f_getfree
     160  f_getlabel
      76  f_gets
     314  f_lseek
     390  f_mkdir
      86  f_mount
     338  f_open
     110  f_opendir
     522  f_printf
      60  f_putc
      72  f_puts
     342  f_read
      78  f_readdir
     264  f_rename
     370  f_setlabel
      64  f_stat
     162  f_sync
     184  f_truncate
     192  f_unlink
      96  f_utime
     410  f_write
     754  find_volume
     138  follow_path
      36  get_achar
     212  get_fat
     106  get_fileinfo
      72  get_ldnumber
      30  ld_clust
      30  mem_cmp
      20  mem_cpy
      16  mem_set
      54  move_window
      36  open_append
     156  pattern_matching
     250  put_fat
      72  putc_bfd
      96  remove_chain
      20  st_clust
     170  sync_fs
      82  sync_window
      48  validate

 
    13 bytes in section .bss
 9 058 bytes in section .text
 
 9 058 bytes of CODE memory
    13 bytes of DATA memory

Errors: none
Warnings: none
