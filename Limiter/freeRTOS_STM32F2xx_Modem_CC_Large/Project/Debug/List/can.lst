###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\can.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\can.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\can.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\can.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\can.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2014 Loop *************************************
      3          *
      4          * File Name          : OBDProtocol.c
      5          *
      6          * Author             : Digital Development Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 08/18/2014
     11          *
     12          * Description        : CAN1 Nox Sensor protocol
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          
     18          /*
     19          *********************************************************************************************************
     20          *                                             INCLUDE FILES
     21          *********************************************************************************************************
     22          */
     23          
     24          #define CAN_GLOBALS
     25          #include "includes.h"

   \                                 In section .bss, align 4
   \   __absolute int obd_debug
   \                     obd_debug:
   \   00000000                      DS8 4
     26          
     27          #define CANDATALEN 8
     28          
     29          #define TRAP_0x010	0x010
     30          #define TRAP_0x011	0x011
     31          #define TRAP_0x012	0x012
     32          #define TRAP_0x013	0x013
     33          
     34          
     35          #define MEMSIZE_CK		  0x100 //256byte
     36          #define ONEPACKET		    8
     37          
     38          #define DOWNLOAD_CK		  0
     39          #define DOWNLOAD_START	1
     40          #define DOWNLOAD_CRC	  2
     41          #define DOWNLOAD_PROG	  3
     42          #define DOWNLOAD_END	  4
     43          #define DOWNLOAD_WAIT	  5
     44          
     45          #define RESPONSE_DELAY	100
     46          
     47          #define DOWNLOAD_nCHECK	0
     48          #define DOWNLOAD_nPROGR	1
     49          
     50          INT32U  FileSize = 0;
     51          INT8U   dlMode = 0;
     52          INT16U  ramCRC;
     53          
     54          /*
     55          ********************************************************************************
     56          * Description : GUI_hexdisp
     57          * Arguments   : data, size
     58          * Return      : 
     59          * Note        : hex display
     60          ******************************************************************************** 
     61          */

   \                                 In section .text, align 2, keep-with-next
     62          void GUI_hexdisp(char *data, int size)
     63          {
   \                     GUI_hexdisp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     64          	int i;
     65          
     66          	for(i=0; i<size; i++){
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE010             B.N      ??GUI_hexdisp_0
     67          		if(i % 20 == 0) printk("\n");
   \                     ??GUI_hexdisp_1: (+1)
   \   0000000A   0x2014             MOVS     R0,#+20
   \   0000000C   0xFB96 0xF0F0      SDIV     R0,R6,R0
   \   00000010   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000014   0xEBB6 0x0081      SUBS     R0,R6,R1, LSL #+2
   \   00000018   0xD102             BNE.N    ??GUI_hexdisp_2
   \   0000001A   0x....             ADR.N    R0,??DataTable18  ;; "\n"
   \   0000001C   0x.... 0x....      BL       printk
     68          		printk("%02X ",data[i]);
   \                     ??GUI_hexdisp_2: (+1)
   \   00000020   0x5DA1             LDRB     R1,[R4, R6]
   \   00000022   0x.... 0x....      ADR.W    R0,?_1
   \   00000026   0x.... 0x....      BL       printk
     69          	}
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \                     ??GUI_hexdisp_0: (+1)
   \   0000002C   0x42AE             CMP      R6,R5
   \   0000002E   0xDBEC             BLT.N    ??GUI_hexdisp_1
     70          	printk("\n");
   \   00000030   0x....             ADR.N    R0,??DataTable18  ;; "\n"
   \   00000032   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000036   0x.... 0x....      B.W      printk
     71          }
     72          
     73          /*
     74          ********************************************************************************
     75          * Description : Init_CANcommRxProc
     76          * Arguments   : port
     77          * Return      : 
     78          * Note        : CAN Process
     79          ******************************************************************************** 
     80          */

   \                                 In section .text, align 2, keep-with-next
     81          void Init_CANcommRxProc(int port)
     82          {
   \                     Init_CANcommRxProc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     83          
     84          	portENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
     85          	CommReInit(port);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       CommReInit
     86          	portEXIT_CRITICAL();  
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      vPortExitCritical
     87          }
     88          
     89          /*
     90          ********************************************************************************
     91          * Description : CanSemaphore_Init
     92          * Arguments   : None
     93          * Return      : 
     94          * Note        : CAN Semaphore Init
     95          ******************************************************************************** 
     96          */

   \                                 In section .text, align 2, keep-with-next
     97          void CanSemaphore_Init(void)
     98          {
   \                     CanSemaphore_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     99          	BSP_CanSem = xSemaphoreCreateMutex();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable20
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       xQueueCreateMutex
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    100          	vSemaphoreCreateBinary(BSP_CanSem);
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       xQueueGenericCreate
   \   00000018   0x6020             STR      R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD006             BEQ.N    ??CanSemaphore_Init_0
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x4611             MOV      R1,R2
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      xQueueGenericSend
    101          }
   \                     ??CanSemaphore_Init_0: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    102          
    103          /*
    104          ********************************************************************************
    105          * Description : MakePackMassage
    106          * Arguments   : CanTxMsg *ptarget, INT32U id, INT8U type, INT8U rtr, INT8U *src, INT8U len
    107          * Return      : 
    108          * Note        : 
    109          ******************************************************************************** 
    110          */

   \                                 In section .text, align 2, keep-with-next
    111          int MakePackMassage(CanTxMsg *ptarget, INT32U id, INT8U type, INT8U rtr, INT8U *src, INT8U len)
    112          {
   \                     MakePackMassage: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    113          	int i=0;
   \   00000002   0x2400             MOVS     R4,#+0
    114          	if(type == CAN_STAN)
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0xD101             BNE.N    ??MakePackMassage_0
    115          		ptarget->StdId = id;
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0xE000             B.N      ??MakePackMassage_1
    116          	else
    117          		ptarget->ExtId = id;
   \                     ??MakePackMassage_0: (+1)
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    118          
    119          	ptarget->IDE = type;
   \                     ??MakePackMassage_1: (+1)
   \   0000000E   0x7202             STRB     R2,[R0, #+8]
    120          	ptarget->RTR = rtr;
   \   00000010   0x7243             STRB     R3,[R0, #+9]
   \   00000012   0x9903             LDR      R1,[SP, #+12]
    121          	ptarget->DLC = len;
   \   00000014   0x7281             STRB     R1,[R0, #+10]
    122          
    123          	for(i=0;i<len;i++)
   \   00000016   0x9A02             LDR      R2,[SP, #+8]
   \   00000018   0xE003             B.N      ??MakePackMassage_2
    124          	{
    125          		ptarget->Data[i] = src[i];
   \                     ??MakePackMassage_3: (+1)
   \   0000001A   0x5D13             LDRB     R3,[R2, R4]
   \   0000001C   0x1905             ADDS     R5,R0,R4
   \   0000001E   0x72EB             STRB     R3,[R5, #+11]
    126          	}
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \                     ??MakePackMassage_2: (+1)
   \   00000022   0x428C             CMP      R4,R1
   \   00000024   0xDBF9             BLT.N    ??MakePackMassage_3
    127          	return i;
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
    128          }
    129          
    130          /*
    131          ********************************************************************************
    132          * Description : SendCanMassage
    133          * Arguments   : CanTxMsg *src
    134          * Return      : 
    135          * Note        : 
    136          ******************************************************************************** 
    137          */

   \                                 In section .text, align 2, keep-with-next
    138          int SendCanMassage(CanTxMsg *src)
    139          {
   \                     SendCanMassage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    140          	if(BSP_CanSem == NULL)
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable20
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??SendCanMassage_0
    141          	{
    142          		printk("%s err\n",__func__);
   \   0000000E   0x.... 0x....      ADR.W    R1,`SendCanMassage::__func__`
   \   00000012   0x.... 0x....      ADR.W    R0,?_2
   \   00000016   0x.... 0x....      BL       printk
    143          		return ERROR;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
    144          	}
    145          	if(xSemaphoreTake(BSP_CanSem, ( portTickType ) 50 )  == pdTRUE)
   \                     ??SendCanMassage_0: (+1)
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2232             MOVS     R2,#+50
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0x.... 0x....      BL       xQueueGenericReceive
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD10C             BNE.N    ??SendCanMassage_1
    146          	{
    147          		CAN_Transmit(CAN1, src);
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable20_1  ;; 0x40006400
   \   00000032   0x.... 0x....      BL       CAN_Transmit
    148          		xSemaphoreGive(BSP_CanSem);
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0x461A             MOV      R2,R3
   \   0000003A   0x4611             MOV      R1,R2
   \   0000003C   0x6828             LDR      R0,[R5, #+0]
   \   0000003E   0x.... 0x....      BL       xQueueGenericSend
    149          		return OK;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    150          	}
    151          	return ERROR;
   \                     ??SendCanMassage_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    152          }
    153          
    154          /*
    155          ********************************************************************************
    156          * Description : CanTxFile
    157          * Arguments   : None
    158          * Return      : 
    159          * Note        : 
    160          ******************************************************************************** 
    161          */

   \                                 In section .text, align 4, keep-with-next
    162          INT8U CanTxFile(void) 
    163          {
   \                     CanTxFile: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0CE             SUB      SP,SP,#+312
    164          	INT8U buf[8], ret=0;
   \   00000006   0xF04F 0x0800      MOV      R8,#+0
    165          	BYTE tbuf[256];
    166          	INT16U quot, remain;
    167          	INT32U i=0;
   \   0000000A   0x4645             MOV      R5,R8
    168          	UINT br;
    169          	static INT8U nStatus = 0, CheckResponseCount = 0;
    170          	CanTxMsg       msg;
    171            INT16U SendCount=0;
   \   0000000C   0x462F             MOV      R7,R5
    172              
    173          	switch(nStatus) 
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable20_2
   \   00000012   0x7860             LDRB     R0,[R4, #+1]
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xF200 0x816D      BHI.W    ??CanTxFile_1
   \   0000001A   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??CanTxFile_0:
   \   0000001E   0x0006 0x0024      DC16     0x6,0x24,0x81,0xEF
   \              0x0081 0x00EF
   \   00000026   0x0146 0x0162      DC16     0x146,0x162
    174          	{
    175          	case DOWNLOAD_CK:
    176          		if(f_open(&fp1, "SCRPro.bin", FA_READ) == FR_OK) 
   \                     ??CanTxFile_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R6,??DataTable20_3
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x.... 0x....      ADR.W    R1,?_3
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0x.... 0x....      BL       f_open
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD10D             BNE.N    ??CanTxFile_3
    177          		{
    178          			ret = DOWNLOAD_nPROGR;
   \   0000003E   0xF04F 0x0801      MOV      R8,#+1
    179          			SendPacket = 0;
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000048   0x6008             STR      R0,[R1, #+0]
    180                nDlStatus = 0;
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable20_5
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    181                ramCRC = 0;
   \   00000050   0x80E0             STRH     R0,[R4, #+6]
    182          			dlMode = DOWNLOAD_START;
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    183          			//printk("in SCRPro.bin SDCard...\n");
    184          			nStatus = DOWNLOAD_START;
   \   00000056   0x7060             STRB     R0,[R4, #+1]
   \   00000058   0xE14C             B.N      ??CanTxFile_1
    185          		}
    186          		else
    187          		{
    188          			//if(fp1 != NULL)
    189          			f_close(&fp1);
   \                     ??CanTxFile_3: (+1)
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       f_close
    190          			ret = DOWNLOAD_nCHECK;
    191          			nStatus = DOWNLOAD_WAIT;
   \   00000060   0x2005             MOVS     R0,#+5
   \   00000062   0x7060             STRB     R0,[R4, #+1]
   \   00000064   0xE146             B.N      ??CanTxFile_1
    192          			//printk("not SCRPro.bin SDCard...\n");
    193          		}
    194          	  break;
    195          	case DOWNLOAD_START:
    196          		memset(buf,0x0,sizeof(buf));
   \                     ??CanTxFile_4: (+1)
   \   00000066   0x462A             MOV      R2,R5
   \   00000068   0x2108             MOVS     R1,#+8
   \   0000006A   0xA805             ADD      R0,SP,#+20
   \   0000006C   0x.... 0x....      BL       __aeabi_memset4
    197          		FileSize = f_size(&fp1);
   \   00000070   0x.... 0x....      LDR.W    R6,??DataTable20_3
   \   00000074   0x68F5             LDR      R5,[R6, #+12]
   \   00000076   0x60A5             STR      R5,[R4, #+8]
    198          		TotalPacket = FileSize/ONEPACKET + (FileSize % ONEPACKET ? 1 : 0);
   \   00000078   0xF005 0x0007      AND      R0,R5,#0x7
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x4180             SBCS     R0,R0,R0
   \   00000080   0x43C0             MVNS     R0,R0
   \   00000082   0x0FC0             LSRS     R0,R0,#+31
   \   00000084   0xEB00 0x00D5      ADD      R0,R0,R5, LSR #+3
   \   00000088   0x.... 0x....      LDR.W    R6,??DataTable20_6
   \   0000008C   0x6030             STR      R0,[R6, #+0]
    199          
    200          		buf[0] = FileSize & 0xFF;
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0xF88D 0x1014      STRB     R1,[SP, #+20]
    201          		buf[1] = (FileSize >> 8) & 0xFF;
   \   00000094   0xAF05             ADD      R7,SP,#+20
   \   00000096   0x0A29             LSRS     R1,R5,#+8
   \   00000098   0x7079             STRB     R1,[R7, #+1]
    202          		buf[2] = (FileSize >> 16) & 0xFF;
   \   0000009A   0x0C29             LSRS     R1,R5,#+16
   \   0000009C   0x70B9             STRB     R1,[R7, #+2]
    203          		buf[3] = (FileSize >> 24) & 0xFF;
   \   0000009E   0x0E29             LSRS     R1,R5,#+24
   \   000000A0   0x70F9             STRB     R1,[R7, #+3]
    204          
    205          		buf[4] = TotalPacket & 0xFF;
   \   000000A2   0x7138             STRB     R0,[R7, #+4]
    206          		buf[5] = (TotalPacket >> 8) & 0xFF;
   \   000000A4   0x0A01             LSRS     R1,R0,#+8
   \   000000A6   0x7179             STRB     R1,[R7, #+5]
    207          		buf[6] = (TotalPacket >> 16) & 0xFF;
   \   000000A8   0x0C01             LSRS     R1,R0,#+16
   \   000000AA   0x71B9             STRB     R1,[R7, #+6]
    208          		buf[7] = (TotalPacket >> 24) & 0xFF;
   \   000000AC   0x0E00             LSRS     R0,R0,#+24
   \   000000AE   0x71F8             STRB     R0,[R7, #+7]
    209          
    210          		memcpy(&buf[0], (char *)&FileSize,    4);
   \   000000B0   0x2204             MOVS     R2,#+4
   \   000000B2   0xF104 0x0108      ADD      R1,R4,#+8
   \   000000B6   0xA805             ADD      R0,SP,#+20
   \   000000B8   0x.... 0x....      BL       __aeabi_memcpy
    211          		memcpy(&buf[4], (char *)&TotalPacket, 4);
   \   000000BC   0x2204             MOVS     R2,#+4
   \   000000BE   0x4631             MOV      R1,R6
   \   000000C0   0xA806             ADD      R0,SP,#+24
   \   000000C2   0x.... 0x....      BL       __aeabi_memcpy
    212          		printk("file size = %01lu\n",FileSize);
   \   000000C6   0x4629             MOV      R1,R5
   \   000000C8   0x.... 0x....      ADR.W    R0,?_4
   \   000000CC   0x.... 0x....      BL       printk
    213          		printk("TotalPacket= %01lu\n",TotalPacket);
   \   000000D0   0x6831             LDR      R1,[R6, #+0]
   \   000000D2   0x.... 0x....      ADR.W    R0,?_5
   \   000000D6   0x.... 0x....      BL       printk
    214          		printk("[%02X][%02X][%02X][%02X][%02X][%02X][%02X][%02X]\n",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7]);
   \   000000DA   0x79F8             LDRB     R0,[R7, #+7]
   \   000000DC   0x9004             STR      R0,[SP, #+16]
   \   000000DE   0x79B8             LDRB     R0,[R7, #+6]
   \   000000E0   0x9003             STR      R0,[SP, #+12]
   \   000000E2   0x7978             LDRB     R0,[R7, #+5]
   \   000000E4   0x9002             STR      R0,[SP, #+8]
   \   000000E6   0x7938             LDRB     R0,[R7, #+4]
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x78F8             LDRB     R0,[R7, #+3]
   \   000000EC   0x9000             STR      R0,[SP, #+0]
   \   000000EE   0x78BB             LDRB     R3,[R7, #+2]
   \   000000F0   0x787A             LDRB     R2,[R7, #+1]
   \   000000F2   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \   000000F6   0x.... 0x....      ADR.W    R0,?_6
   \   000000FA   0x.... 0x....      BL       printk
    215          		
    216          		SendCount = MakePackMassage(&msg, 0x010, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   000000FE   0x2008             MOVS     R0,#+8
   \   00000100   0x9001             STR      R0,[SP, #+4]
   \   00000102   0xA805             ADD      R0,SP,#+20
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x4643             MOV      R3,R8
   \   00000108   0x461A             MOV      R2,R3
   \   0000010A   0x2110             MOVS     R1,#+16
   \   0000010C   0xA808             ADD      R0,SP,#+32
   \   0000010E   0x.... 0x....      BL       MakePackMassage
   \   00000112   0x4607             MOV      R7,R0
    217          		dlMode = DOWNLOAD_CRC;
   \   00000114   0x2002             MOVS     R0,#+2
   \   00000116   0x7020             STRB     R0,[R4, #+0]
    218          		ret = DOWNLOAD_nPROGR;
   \   00000118   0xF04F 0x0801      MOV      R8,#+1
    219          		nStatus = DOWNLOAD_CRC;
   \   0000011C   0x7060             STRB     R0,[R4, #+1]
    220          		break;
   \   0000011E   0xE0E9             B.N      ??CanTxFile_1
    221          
    222          	case DOWNLOAD_CRC:
    223          		if(nDlStatus == 1)
   \                     ??CanTxFile_5: (+1)
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000124   0x7800             LDRB     R0,[R0, #+0]
   \   00000126   0x2801             CMP      R0,#+1
   \   00000128   0xD158             BNE.N    ??CanTxFile_6
    224          		{
    225          			CheckResponseCount = 0;
   \   0000012A   0x4628             MOV      R0,R5
   \   0000012C   0x70A0             STRB     R0,[R4, #+2]
    226          			quot = FileSize / MEMSIZE_CK;
   \   0000012E   0x68A0             LDR      R0,[R4, #+8]
   \   00000130   0x0A07             LSRS     R7,R0,#+8
   \   00000132   0xB2BF             UXTH     R7,R7
    227          			remain = FileSize % MEMSIZE_CK;
   \   00000134   0xF000 0x08FF      AND      R8,R0,#0xFF
    228          			for(i=0; i<quot; i++)
   \   00000138   0x.... 0x....      LDR.W    R6,??DataTable20_3
   \   0000013C   0xE018             B.N      ??CanTxFile_7
    229          			{
    230          				memset((char *)tbuf,0x00,sizeof(tbuf));
   \                     ??CanTxFile_8: (+1)
   \   0000013E   0x2200             MOVS     R2,#+0
   \   00000140   0xF44F 0x7180      MOV      R1,#+256
   \   00000144   0xA80D             ADD      R0,SP,#+52
   \   00000146   0x.... 0x....      BL       __aeabi_memset4
    231          				f_lseek(&fp1,i*MEMSIZE_CK);
   \   0000014A   0x0229             LSLS     R1,R5,#+8
   \   0000014C   0x4630             MOV      R0,R6
   \   0000014E   0x.... 0x....      BL       f_lseek
    232          				f_read(&fp1, tbuf, MEMSIZE_CK, &br);
   \   00000152   0xAB07             ADD      R3,SP,#+28
   \   00000154   0xF44F 0x7280      MOV      R2,#+256
   \   00000158   0xA90D             ADD      R1,SP,#+52
   \   0000015A   0x4630             MOV      R0,R6
   \   0000015C   0x.... 0x....      BL       f_read
    233          				ramCRC = GenerateCRC((INT8U*)tbuf, MEMSIZE_CK, ramCRC);
   \   00000160   0x88E2             LDRH     R2,[R4, #+6]
   \   00000162   0xF44F 0x7180      MOV      R1,#+256
   \   00000166   0xA80D             ADD      R0,SP,#+52
   \   00000168   0x.... 0x....      BL       GenerateCRC
   \   0000016C   0x80E0             STRH     R0,[R4, #+6]
    234          			}
   \   0000016E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??CanTxFile_7: (+1)
   \   00000170   0x42BD             CMP      R5,R7
   \   00000172   0xD3E4             BCC.N    ??CanTxFile_8
    235          			if(remain){
   \   00000174   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000178   0xD016             BEQ.N    ??CanTxFile_9
    236          				memset((char *)tbuf,0x00,sizeof(tbuf));
   \   0000017A   0x2200             MOVS     R2,#+0
   \   0000017C   0xF44F 0x7180      MOV      R1,#+256
   \   00000180   0xA80D             ADD      R0,SP,#+52
   \   00000182   0x.... 0x....      BL       __aeabi_memset4
    237          				f_lseek(&fp1,i*MEMSIZE_CK);
   \   00000186   0x0229             LSLS     R1,R5,#+8
   \   00000188   0x4630             MOV      R0,R6
   \   0000018A   0x.... 0x....      BL       f_lseek
    238          				f_read(&fp1, tbuf, MEMSIZE_CK, &br);
   \   0000018E   0xAB07             ADD      R3,SP,#+28
   \   00000190   0xF44F 0x7280      MOV      R2,#+256
   \   00000194   0xA90D             ADD      R1,SP,#+52
   \   00000196   0x4630             MOV      R0,R6
   \   00000198   0x.... 0x....      BL       f_read
    239          				ramCRC = GenerateCRC((INT8U*)tbuf, remain, ramCRC);
   \   0000019C   0x88E2             LDRH     R2,[R4, #+6]
   \   0000019E   0x4641             MOV      R1,R8
   \   000001A0   0xA80D             ADD      R0,SP,#+52
   \   000001A2   0x.... 0x....      BL       GenerateCRC
   \   000001A6   0x80E0             STRH     R0,[R4, #+6]
    240          			}
    241          			memcpy(&buf[0], (char *)&ramCRC, 2);
   \                     ??CanTxFile_9: (+1)
   \   000001A8   0x2202             MOVS     R2,#+2
   \   000001AA   0x1DA1             ADDS     R1,R4,#+6
   \   000001AC   0xA805             ADD      R0,SP,#+20
   \   000001AE   0x.... 0x....      BL       __aeabi_memcpy
    242          			printk("CRC Code = [%04X]\n",ramCRC);
   \   000001B2   0x88E1             LDRH     R1,[R4, #+6]
   \   000001B4   0x.... 0x....      ADR.W    R0,?_7
   \   000001B8   0x.... 0x....      BL       printk
    243                SendCount = MakePackMassage(&msg, 0x011, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   000001BC   0x2008             MOVS     R0,#+8
   \   000001BE   0x9001             STR      R0,[SP, #+4]
   \   000001C0   0xA805             ADD      R0,SP,#+20
   \   000001C2   0x9000             STR      R0,[SP, #+0]
   \   000001C4   0x2300             MOVS     R3,#+0
   \   000001C6   0x461A             MOV      R2,R3
   \   000001C8   0x2111             MOVS     R1,#+17
   \   000001CA   0xA808             ADD      R0,SP,#+32
   \   000001CC   0x.... 0x....      BL       MakePackMassage
   \   000001D0   0x4607             MOV      R7,R0
    244          			dlMode = DOWNLOAD_PROG;
   \   000001D2   0x2003             MOVS     R0,#+3
   \   000001D4   0x7020             STRB     R0,[R4, #+0]
    245          			ret = DOWNLOAD_nPROGR;
   \   000001D6   0xF04F 0x0801      MOV      R8,#+1
    246          			nStatus = DOWNLOAD_PROG;
   \   000001DA   0x7060             STRB     R0,[R4, #+1]
    247          		}
    248          		if(CheckResponseCount++ >= RESPONSE_DELAY)	//Start packet을 전송후 응답이 없으면...Wait상태로 돌아가라...
   \                     ??CanTxFile_6: (+1)
   \   000001DC   0x78A0             LDRB     R0,[R4, #+2]
   \   000001DE   0x1C41             ADDS     R1,R0,#+1
   \   000001E0   0x70A1             STRB     R1,[R4, #+2]
   \   000001E2   0x2864             CMP      R0,#+100
   \   000001E4   0xF2C0 0x8086      BLT.W    ??CanTxFile_1
    249          		{
    250          			CheckResponseCount = 0;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x70A0             STRB     R0,[R4, #+2]
    251          			ret = DOWNLOAD_nCHECK;
   \   000001EC   0x4680             MOV      R8,R0
    252          			nStatus = DOWNLOAD_WAIT;
   \   000001EE   0x2005             MOVS     R0,#+5
   \   000001F0   0x7060             STRB     R0,[R4, #+1]
    253          			f_close(&fp1);
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   000001F6   0x.... 0x....      BL       f_close
   \   000001FA   0xE07B             B.N      ??CanTxFile_1
    254          		}
    255          		break;
    256          
    257          	case DOWNLOAD_PROG:
    258          		if(nDlStatus == 2)
   \                     ??CanTxFile_10: (+1)
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000200   0x7800             LDRB     R0,[R0, #+0]
   \   00000202   0x2802             CMP      R0,#+2
   \   00000204   0xD176             BNE.N    ??CanTxFile_1
    259          		{
    260          		if(dlMode != DOWNLOAD_PROG) return 0;
   \   00000206   0x7820             LDRB     R0,[R4, #+0]
   \   00000208   0x2803             CMP      R0,#+3
   \   0000020A   0xD151             BNE.N    ??CanTxFile_11
    261          		
    262          		if(SendPacket == TotalPacket-1)
   \   0000020C   0x.... 0x....      LDR.W    R5,??DataTable20_4
   \   00000210   0x682F             LDR      R7,[R5, #+0]
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x1E40             SUBS     R0,R0,#+1
   \   0000021A   0x4287             CMP      R7,R0
   \   0000021C   0xD124             BNE.N    ??CanTxFile_12
    263          		{
    264          			remain = FileSize % ONEPACKET;
   \   0000021E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000220   0xF010 0x0807      ANDS     R8,R0,#0x7
    265          			if(remain == 0) remain = ONEPACKET;
   \   00000224   0xD101             BNE.N    ??CanTxFile_13
   \   00000226   0xF04F 0x0808      MOV      R8,#+8
    266          
    267          			f_lseek(&fp1,SendPacket *ONEPACKET);
   \                     ??CanTxFile_13: (+1)
   \   0000022A   0x.... 0x....      LDR.W    R6,??DataTable20_3
   \   0000022E   0x00F9             LSLS     R1,R7,#+3
   \   00000230   0x4630             MOV      R0,R6
   \   00000232   0x.... 0x....      BL       f_lseek
    268          			f_read(&fp1, buf,remain, &br);
   \   00000236   0xAB07             ADD      R3,SP,#+28
   \   00000238   0x4642             MOV      R2,R8
   \   0000023A   0xA905             ADD      R1,SP,#+20
   \   0000023C   0x4630             MOV      R0,R6
   \   0000023E   0x.... 0x....      BL       f_read
    269                SendCount = MakePackMassage(&msg, 0x012, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   00000242   0x2008             MOVS     R0,#+8
   \   00000244   0x9001             STR      R0,[SP, #+4]
   \   00000246   0xA805             ADD      R0,SP,#+20
   \   00000248   0x9000             STR      R0,[SP, #+0]
   \   0000024A   0x2300             MOVS     R3,#+0
   \   0000024C   0x461A             MOV      R2,R3
   \   0000024E   0x2112             MOVS     R1,#+18
   \   00000250   0xA808             ADD      R0,SP,#+32
   \   00000252   0x.... 0x....      BL       MakePackMassage
   \   00000256   0x4607             MOV      R7,R0
    270          			dlMode = DOWNLOAD_END;
   \   00000258   0x2004             MOVS     R0,#+4
   \   0000025A   0x7020             STRB     R0,[R4, #+0]
    271          			f_close(&fp1);
   \   0000025C   0x4630             MOV      R0,R6
   \   0000025E   0x.... 0x....      BL       f_close
    272          			nStatus = DOWNLOAD_END;
   \   00000262   0x2004             MOVS     R0,#+4
   \   00000264   0x7060             STRB     R0,[R4, #+1]
   \   00000266   0xE01A             B.N      ??CanTxFile_14
    273          		}
    274          		else
    275          		{
    276          			memset((char *)buf,0x00,sizeof(buf));
   \                     ??CanTxFile_12: (+1)
   \   00000268   0x4642             MOV      R2,R8
   \   0000026A   0x2108             MOVS     R1,#+8
   \   0000026C   0xA805             ADD      R0,SP,#+20
   \   0000026E   0x.... 0x....      BL       __aeabi_memset4
    277          			f_lseek(&fp1,SendPacket *ONEPACKET);
   \   00000272   0x....             LDR.N    R6,??DataTable20_3
   \   00000274   0x00F9             LSLS     R1,R7,#+3
   \   00000276   0x4630             MOV      R0,R6
   \   00000278   0x.... 0x....      BL       f_lseek
    278          			f_read(&fp1, buf, ONEPACKET, &br);
   \   0000027C   0xAB07             ADD      R3,SP,#+28
   \   0000027E   0x2208             MOVS     R2,#+8
   \   00000280   0xA905             ADD      R1,SP,#+20
   \   00000282   0x4630             MOV      R0,R6
   \   00000284   0x.... 0x....      BL       f_read
    279                SendCount = MakePackMassage(&msg, 0x012, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   00000288   0x2008             MOVS     R0,#+8
   \   0000028A   0x9001             STR      R0,[SP, #+4]
   \   0000028C   0xA805             ADD      R0,SP,#+20
   \   0000028E   0x9000             STR      R0,[SP, #+0]
   \   00000290   0x4643             MOV      R3,R8
   \   00000292   0x461A             MOV      R2,R3
   \   00000294   0x2112             MOVS     R1,#+18
   \   00000296   0xA808             ADD      R0,SP,#+32
   \   00000298   0x.... 0x....      BL       MakePackMassage
   \   0000029C   0x4607             MOV      R7,R0
    280          		}
    281          		ret = DOWNLOAD_PROG;
   \                     ??CanTxFile_14: (+1)
   \   0000029E   0xF04F 0x0803      MOV      R8,#+3
    282          		SendPacket++;
   \   000002A2   0x6828             LDR      R0,[R5, #+0]
   \   000002A4   0x1C40             ADDS     R0,R0,#+1
   \   000002A6   0x6028             STR      R0,[R5, #+0]
   \   000002A8   0xE024             B.N      ??CanTxFile_1
    283          		}
    284          		break;
    285          
    286          	case DOWNLOAD_END:
    287          		if(dlMode != DOWNLOAD_END) return 0;
   \                     ??CanTxFile_15: (+1)
   \   000002AA   0x7820             LDRB     R0,[R4, #+0]
   \   000002AC   0x2804             CMP      R0,#+4
   \   000002AE   0xD001             BEQ.N    ??CanTxFile_16
   \                     ??CanTxFile_11: (+1)
   \   000002B0   0x4628             MOV      R0,R5
   \   000002B2   0xE026             B.N      ??CanTxFile_17
    288          		buf[0] = 0x01;
   \                     ??CanTxFile_16: (+1)
   \   000002B4   0x2001             MOVS     R0,#+1
   \   000002B6   0xF88D 0x0014      STRB     R0,[SP, #+20]
    289              SendCount = MakePackMassage(&msg, 0x013, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   000002BA   0x2008             MOVS     R0,#+8
   \   000002BC   0x9001             STR      R0,[SP, #+4]
   \   000002BE   0xA805             ADD      R0,SP,#+20
   \   000002C0   0x9000             STR      R0,[SP, #+0]
   \   000002C2   0x462B             MOV      R3,R5
   \   000002C4   0x461A             MOV      R2,R3
   \   000002C6   0x2113             MOVS     R1,#+19
   \   000002C8   0xA808             ADD      R0,SP,#+32
   \   000002CA   0x.... 0x....      BL       MakePackMassage
   \   000002CE   0x4607             MOV      R7,R0
    290          		ret = DOWNLOAD_PROG;
   \   000002D0   0xF04F 0x0803      MOV      R8,#+3
    291          		printk("download end.....\n");
   \   000002D4   0x.... 0x....      ADR.W    R0,?_8
   \   000002D8   0x.... 0x....      BL       printk
    292          		nStatus = DOWNLOAD_WAIT;
   \   000002DC   0x2005             MOVS     R0,#+5
   \   000002DE   0x7060             STRB     R0,[R4, #+1]
    293          		break;
   \   000002E0   0xE008             B.N      ??CanTxFile_1
    294          	case DOWNLOAD_WAIT:
    295              nStatus = 0;
   \                     ??CanTxFile_18: (+1)
   \   000002E2   0x4628             MOV      R0,R5
   \   000002E4   0x7060             STRB     R0,[R4, #+1]
    296              Flags.DownloadFlag = 0;
   \   000002E6   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000002EA   0x8801             LDRH     R1,[R0, #+0]
   \   000002EC   0xF64F 0x72BF      MOVW     R2,#+65471
   \   000002F0   0x4011             ANDS     R1,R2,R1
   \   000002F2   0x8001             STRH     R1,[R0, #+0]
    297          		ret = DOWNLOAD_nCHECK;
    298          		break;
    299          
    300          	default:
    301          		break;
    302          	}
    303            if (SendCount ) SendCanMassage(&msg); 
   \                     ??CanTxFile_1: (+1)
   \   000002F4   0xB2BF             UXTH     R7,R7
   \   000002F6   0x2F00             CMP      R7,#+0
   \   000002F8   0xD002             BEQ.N    ??CanTxFile_19
   \   000002FA   0xA808             ADD      R0,SP,#+32
   \   000002FC   0x.... 0x....      BL       SendCanMassage
    304          	return ret;
   \                     ??CanTxFile_19: (+1)
   \   00000300   0x4640             MOV      R0,R8
   \                     ??CanTxFile_17: (+1)
   \   00000302   0xB04E             ADD      SP,SP,#+312
   \   00000304   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    305          
    306          }
    307          
    308          /*
    309          ********************************************************************************
    310          * Description : CanFotaFile
    311          * Arguments   : None
    312          * Return      : 
    313          * Note        : 
    314          ******************************************************************************** 
    315          */

   \                                 In section .text, align 4, keep-with-next
    316          INT8U CanFotaFile(void) 
    317          {
   \                     CanFotaFile: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0CD             SUB      SP,SP,#+308
    318          	INT8U buf[8], ret=0;
   \   00000004   0x2600             MOVS     R6,#+0
    319          	BYTE tbuf[256];
    320          	INT16U quot, remain;
    321          	INT32U i=0;
   \   00000006   0x4635             MOV      R5,R6
    322          	static INT8U nStatus = 0, CheckResponseCount = 0;
    323          	CanTxMsg       msg;
    324            INT16U SendCount=0;
   \   00000008   0x462F             MOV      R7,R5
    325              
    326          	switch(nStatus) 
   \   0000000A   0x....             LDR.N    R4,??DataTable20_2
   \   0000000C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xF200 0x8147      BHI.W    ??CanFotaFile_1
   \   00000014   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??CanFotaFile_0:
   \   00000018   0x0006 0x0011      DC16     0x6,0x11,0x6C,0xCB
   \              0x006C 0x00CB
   \   00000020   0x011D 0x013C      DC16     0x11D,0x13C
    327          	{
    328          	case DOWNLOAD_CK:
    329              ret = DOWNLOAD_nPROGR;
   \                     ??CanFotaFile_2: (+1)
   \   00000024   0x2601             MOVS     R6,#+1
    330              SendPacket = 0;
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x....             LDR.N    R1,??DataTable20_4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    331              nDlStatus = 0;
   \   0000002C   0x....             LDR.N    R1,??DataTable20_5
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    332              ramCRC = 0;
   \   00000030   0x80E0             STRH     R0,[R4, #+6]
    333              dlMode = DOWNLOAD_START;
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x7020             STRB     R0,[R4, #+0]
    334              //printk("in SCRPro.bin SDCard...\n");
    335              nStatus = DOWNLOAD_START;
   \   00000036   0x70E0             STRB     R0,[R4, #+3]
    336          	  break;
   \   00000038   0xE133             B.N      ??CanFotaFile_1
    337          	case DOWNLOAD_START:
    338          		memset(buf,0x0,sizeof(buf));
   \                     ??CanFotaFile_3: (+1)
   \   0000003A   0x462A             MOV      R2,R5
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0xA805             ADD      R0,SP,#+20
   \   00000040   0x.... 0x....      BL       __aeabi_memset4
    339          		FileSize = Setting.ECUFW_Size;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000048   0x6805             LDR      R5,[R0, #+0]
   \   0000004A   0x60A5             STR      R5,[R4, #+8]
    340          		TotalPacket = FileSize/ONEPACKET + (FileSize % ONEPACKET ? 1 : 0);
   \   0000004C   0xF005 0x0007      AND      R0,R5,#0x7
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x4180             SBCS     R0,R0,R0
   \   00000054   0x43C0             MVNS     R0,R0
   \   00000056   0x0FC0             LSRS     R0,R0,#+31
   \   00000058   0xEB00 0x00D5      ADD      R0,R0,R5, LSR #+3
   \   0000005C   0x....             LDR.N    R6,??DataTable20_6
   \   0000005E   0x6030             STR      R0,[R6, #+0]
    341          
    342          		buf[0] = FileSize & 0xFF;
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0xF88D 0x1014      STRB     R1,[SP, #+20]
    343          		buf[1] = (FileSize >> 8) & 0xFF;
   \   00000066   0xAF05             ADD      R7,SP,#+20
   \   00000068   0x0A29             LSRS     R1,R5,#+8
   \   0000006A   0x7079             STRB     R1,[R7, #+1]
    344          		buf[2] = (FileSize >> 16) & 0xFF;
   \   0000006C   0x0C29             LSRS     R1,R5,#+16
   \   0000006E   0x70B9             STRB     R1,[R7, #+2]
    345          		buf[3] = (FileSize >> 24) & 0xFF;
   \   00000070   0x0E29             LSRS     R1,R5,#+24
   \   00000072   0x70F9             STRB     R1,[R7, #+3]
    346          
    347          		buf[4] = TotalPacket & 0xFF;
   \   00000074   0x7138             STRB     R0,[R7, #+4]
    348          		buf[5] = (TotalPacket >> 8) & 0xFF;
   \   00000076   0x0A01             LSRS     R1,R0,#+8
   \   00000078   0x7179             STRB     R1,[R7, #+5]
    349          		buf[6] = (TotalPacket >> 16) & 0xFF;
   \   0000007A   0x0C01             LSRS     R1,R0,#+16
   \   0000007C   0x71B9             STRB     R1,[R7, #+6]
    350          		buf[7] = (TotalPacket >> 24) & 0xFF;
   \   0000007E   0x0E00             LSRS     R0,R0,#+24
   \   00000080   0x71F8             STRB     R0,[R7, #+7]
    351          
    352          		memcpy(&buf[0], (char *)&FileSize,    4);
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000088   0xA805             ADD      R0,SP,#+20
   \   0000008A   0x.... 0x....      BL       __aeabi_memcpy
    353          		memcpy(&buf[4], (char *)&TotalPacket, 4);
   \   0000008E   0x2204             MOVS     R2,#+4
   \   00000090   0x4631             MOV      R1,R6
   \   00000092   0xA806             ADD      R0,SP,#+24
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy
    354          		printk("file size = %01lu\n",FileSize);
   \   00000098   0x4629             MOV      R1,R5
   \   0000009A   0x.... 0x....      ADR.W    R0,?_4
   \   0000009E   0x.... 0x....      BL       printk
    355          		printk("TotalPacket= %01lu\n",TotalPacket);
   \   000000A2   0x6831             LDR      R1,[R6, #+0]
   \   000000A4   0x.... 0x....      ADR.W    R0,?_5
   \   000000A8   0x.... 0x....      BL       printk
    356          		printk("[%02X][%02X][%02X][%02X][%02X][%02X][%02X][%02X]\n",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7]);
   \   000000AC   0x79F8             LDRB     R0,[R7, #+7]
   \   000000AE   0x9004             STR      R0,[SP, #+16]
   \   000000B0   0x79B8             LDRB     R0,[R7, #+6]
   \   000000B2   0x9003             STR      R0,[SP, #+12]
   \   000000B4   0x7978             LDRB     R0,[R7, #+5]
   \   000000B6   0x9002             STR      R0,[SP, #+8]
   \   000000B8   0x7938             LDRB     R0,[R7, #+4]
   \   000000BA   0x9001             STR      R0,[SP, #+4]
   \   000000BC   0x78F8             LDRB     R0,[R7, #+3]
   \   000000BE   0x9000             STR      R0,[SP, #+0]
   \   000000C0   0x78BB             LDRB     R3,[R7, #+2]
   \   000000C2   0x787A             LDRB     R2,[R7, #+1]
   \   000000C4   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \   000000C8   0x.... 0x....      ADR.W    R0,?_6
   \   000000CC   0x.... 0x....      BL       printk
    357          		
    358          		SendCount = MakePackMassage(&msg, 0x010, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   000000D0   0x2008             MOVS     R0,#+8
   \   000000D2   0x9001             STR      R0,[SP, #+4]
   \   000000D4   0xA805             ADD      R0,SP,#+20
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x2300             MOVS     R3,#+0
   \   000000DA   0x461A             MOV      R2,R3
   \   000000DC   0x2110             MOVS     R1,#+16
   \   000000DE   0xA807             ADD      R0,SP,#+28
   \   000000E0   0x.... 0x....      BL       MakePackMassage
   \   000000E4   0x4607             MOV      R7,R0
    359          		dlMode = DOWNLOAD_CRC;
   \   000000E6   0x2002             MOVS     R0,#+2
   \   000000E8   0x7020             STRB     R0,[R4, #+0]
    360          		ret = DOWNLOAD_nPROGR;
   \   000000EA   0x2601             MOVS     R6,#+1
    361          		nStatus = DOWNLOAD_CRC;
   \   000000EC   0x70E0             STRB     R0,[R4, #+3]
    362          		break;
   \   000000EE   0xE0D8             B.N      ??CanFotaFile_1
    363          
    364          	case DOWNLOAD_CRC:
    365          		if(nDlStatus == 1)
   \                     ??CanFotaFile_4: (+1)
   \   000000F0   0x....             LDR.N    R0,??DataTable20_5
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xD14E             BNE.N    ??CanFotaFile_5
    366          		{
    367          			CheckResponseCount = 0;
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x7120             STRB     R0,[R4, #+4]
    368          			quot = FileSize / MEMSIZE_CK;
   \   000000FC   0x68A0             LDR      R0,[R4, #+8]
   \   000000FE   0x0A06             LSRS     R6,R0,#+8
   \   00000100   0xB2B6             UXTH     R6,R6
    369          			remain = FileSize % MEMSIZE_CK;
   \   00000102   0xF000 0x07FF      AND      R7,R0,#0xFF
    370          			for(i=0; i<quot; i++)
   \   00000106   0xE015             B.N      ??CanFotaFile_6
    371          			{
    372          				memset((char *)tbuf,0x00,sizeof(tbuf));
   \                     ??CanFotaFile_7: (+1)
   \   00000108   0x2200             MOVS     R2,#+0
   \   0000010A   0xF44F 0x7180      MOV      R1,#+256
   \   0000010E   0xA80C             ADD      R0,SP,#+48
   \   00000110   0x.... 0x....      BL       __aeabi_memset4
    373          				SPI_FLASH_BufferRead(tbuf, ECUDATA_SECTOR+(i*MEMSIZE_CK), sizeof(tbuf));
   \   00000114   0xF44F 0x7280      MOV      R2,#+256
   \   00000118   0x0228             LSLS     R0,R5,#+8
   \   0000011A   0xF500 0x0158      ADD      R1,R0,#+14155776
   \   0000011E   0xA80C             ADD      R0,SP,#+48
   \   00000120   0x.... 0x....      BL       SPI_FLASH_BufferRead
    374          				ramCRC = GenerateCRC((INT8U*)tbuf, MEMSIZE_CK, ramCRC);
   \   00000124   0x88E2             LDRH     R2,[R4, #+6]
   \   00000126   0xF44F 0x7180      MOV      R1,#+256
   \   0000012A   0xA80C             ADD      R0,SP,#+48
   \   0000012C   0x.... 0x....      BL       GenerateCRC
   \   00000130   0x80E0             STRH     R0,[R4, #+6]
    375          			}
   \   00000132   0x1C6D             ADDS     R5,R5,#+1
   \                     ??CanFotaFile_6: (+1)
   \   00000134   0x42B5             CMP      R5,R6
   \   00000136   0xD3E7             BCC.N    ??CanFotaFile_7
    376          			if(remain){
   \   00000138   0x2F00             CMP      R7,#+0
   \   0000013A   0xD013             BEQ.N    ??CanFotaFile_8
    377          				memset((char *)tbuf,0x00,sizeof(tbuf));
   \   0000013C   0x2200             MOVS     R2,#+0
   \   0000013E   0xF44F 0x7180      MOV      R1,#+256
   \   00000142   0xA80C             ADD      R0,SP,#+48
   \   00000144   0x.... 0x....      BL       __aeabi_memset4
    378          				SPI_FLASH_BufferRead(tbuf, ECUDATA_SECTOR+(i*MEMSIZE_CK), sizeof(tbuf));
   \   00000148   0xF44F 0x7280      MOV      R2,#+256
   \   0000014C   0x0228             LSLS     R0,R5,#+8
   \   0000014E   0xF500 0x0158      ADD      R1,R0,#+14155776
   \   00000152   0xA80C             ADD      R0,SP,#+48
   \   00000154   0x.... 0x....      BL       SPI_FLASH_BufferRead
    379          				ramCRC = GenerateCRC((INT8U*)tbuf, remain, ramCRC);
   \   00000158   0x88E2             LDRH     R2,[R4, #+6]
   \   0000015A   0x4639             MOV      R1,R7
   \   0000015C   0xA80C             ADD      R0,SP,#+48
   \   0000015E   0x.... 0x....      BL       GenerateCRC
   \   00000162   0x80E0             STRH     R0,[R4, #+6]
    380          			}
    381          			memcpy(&buf[0], (char *)&ramCRC, 2);
   \                     ??CanFotaFile_8: (+1)
   \   00000164   0x2202             MOVS     R2,#+2
   \   00000166   0x1DA1             ADDS     R1,R4,#+6
   \   00000168   0xA805             ADD      R0,SP,#+20
   \   0000016A   0x.... 0x....      BL       __aeabi_memcpy
    382          			printk("CRC Code = [%04X]\n",ramCRC);
   \   0000016E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000170   0x.... 0x....      ADR.W    R0,?_7
   \   00000174   0x.... 0x....      BL       printk
    383                SendCount = MakePackMassage(&msg, 0x011, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   00000178   0x2008             MOVS     R0,#+8
   \   0000017A   0x9001             STR      R0,[SP, #+4]
   \   0000017C   0xA805             ADD      R0,SP,#+20
   \   0000017E   0x9000             STR      R0,[SP, #+0]
   \   00000180   0x2300             MOVS     R3,#+0
   \   00000182   0x461A             MOV      R2,R3
   \   00000184   0x2111             MOVS     R1,#+17
   \   00000186   0xA807             ADD      R0,SP,#+28
   \   00000188   0x.... 0x....      BL       MakePackMassage
   \   0000018C   0x4607             MOV      R7,R0
    384          			dlMode = DOWNLOAD_PROG;
   \   0000018E   0x2003             MOVS     R0,#+3
   \   00000190   0x7020             STRB     R0,[R4, #+0]
    385          			ret = DOWNLOAD_nPROGR;
   \   00000192   0x2601             MOVS     R6,#+1
    386          			nStatus = DOWNLOAD_PROG;
   \   00000194   0x70E0             STRB     R0,[R4, #+3]
    387          		}
    388          		if(CheckResponseCount++ >= RESPONSE_DELAY)	//Start packet을 전송후 응답이 없으면...Wait상태로 돌아가라...
   \                     ??CanFotaFile_5: (+1)
   \   00000196   0x7920             LDRB     R0,[R4, #+4]
   \   00000198   0x1C41             ADDS     R1,R0,#+1
   \   0000019A   0x7121             STRB     R1,[R4, #+4]
   \   0000019C   0x2864             CMP      R0,#+100
   \   0000019E   0xF2C0 0x8080      BLT.W    ??CanFotaFile_1
    389          		{
    390          			CheckResponseCount = 0;
   \   000001A2   0x2000             MOVS     R0,#+0
   \   000001A4   0x7120             STRB     R0,[R4, #+4]
    391          			ret = DOWNLOAD_nCHECK;
   \   000001A6   0x4606             MOV      R6,R0
    392          			nStatus = DOWNLOAD_WAIT;
   \   000001A8   0x2005             MOVS     R0,#+5
   \   000001AA   0x70E0             STRB     R0,[R4, #+3]
   \   000001AC   0xE079             B.N      ??CanFotaFile_1
    393          		}
    394          		break;
    395          
    396          	case DOWNLOAD_PROG:
    397          		if(nDlStatus == 2)
   \                     ??CanFotaFile_9: (+1)
   \   000001AE   0x....             LDR.N    R0,??DataTable20_5
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0x2802             CMP      R0,#+2
   \   000001B4   0xD175             BNE.N    ??CanFotaFile_1
    398          		{
    399          		if(dlMode != DOWNLOAD_PROG) return 0;
   \   000001B6   0x7820             LDRB     R0,[R4, #+0]
   \   000001B8   0x2803             CMP      R0,#+3
   \   000001BA   0xD14D             BNE.N    ??CanFotaFile_10
    400                if(ramCRC != Setting.ECUFW_CRC16) return 0;
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   000001C0   0x88E1             LDRH     R1,[R4, #+6]
   \   000001C2   0x8882             LDRH     R2,[R0, #+4]
   \   000001C4   0x4291             CMP      R1,R2
   \   000001C6   0xD147             BNE.N    ??CanFotaFile_10
    401                if(Setting.ECUFW_flag) for(i=0; i<100; i++){;;};  //DCU FOTA 업데이트시 CAN데이터 전송 시간지연
   \   000001C8   0x7980             LDRB     R0,[R0, #+6]
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD101             BNE.N    ??CanFotaFile_11
   \   000001CE   0xE002             B.N      ??CanFotaFile_12
   \                     ??CanFotaFile_13: (+1)
   \   000001D0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??CanFotaFile_11: (+1)
   \   000001D2   0x2D64             CMP      R5,#+100
   \   000001D4   0xD3FC             BCC.N    ??CanFotaFile_13
    402          		
    403          		if(SendPacket == TotalPacket-1)
   \                     ??CanFotaFile_12: (+1)
   \   000001D6   0x....             LDR.N    R5,??DataTable20_4
   \   000001D8   0x682E             LDR      R6,[R5, #+0]
   \   000001DA   0x....             LDR.N    R0,??DataTable20_6
   \   000001DC   0x6800             LDR      R0,[R0, #+0]
   \   000001DE   0x1E40             SUBS     R0,R0,#+1
   \   000001E0   0x4286             CMP      R6,R0
   \   000001E2   0xD11A             BNE.N    ??CanFotaFile_14
    404          		{
    405          			remain = FileSize % ONEPACKET;
   \   000001E4   0x7A20             LDRB     R0,[R4, #+8]
   \   000001E6   0xF010 0x0707      ANDS     R7,R0,#0x7
    406          			if(remain == 0) remain = ONEPACKET;
   \   000001EA   0xD100             BNE.N    ??CanFotaFile_15
   \   000001EC   0x2708             MOVS     R7,#+8
    407                
    408                SPI_FLASH_BufferRead(buf, ECUDATA_SECTOR+(SendPacket*ONEPACKET), remain);
   \                     ??CanFotaFile_15: (+1)
   \   000001EE   0x463A             MOV      R2,R7
   \   000001F0   0x00F0             LSLS     R0,R6,#+3
   \   000001F2   0xF500 0x0158      ADD      R1,R0,#+14155776
   \   000001F6   0xA805             ADD      R0,SP,#+20
   \   000001F8   0x.... 0x....      BL       SPI_FLASH_BufferRead
    409                SendCount = MakePackMassage(&msg, 0x012, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   000001FC   0x2008             MOVS     R0,#+8
   \   000001FE   0x9001             STR      R0,[SP, #+4]
   \   00000200   0xA805             ADD      R0,SP,#+20
   \   00000202   0x9000             STR      R0,[SP, #+0]
   \   00000204   0x2300             MOVS     R3,#+0
   \   00000206   0x461A             MOV      R2,R3
   \   00000208   0x2112             MOVS     R1,#+18
   \   0000020A   0xA807             ADD      R0,SP,#+28
   \   0000020C   0x.... 0x....      BL       MakePackMassage
   \   00000210   0x4607             MOV      R7,R0
    410          			dlMode = DOWNLOAD_END;
   \   00000212   0x2004             MOVS     R0,#+4
   \   00000214   0x7020             STRB     R0,[R4, #+0]
    411          			nStatus = DOWNLOAD_END;
   \   00000216   0x70E0             STRB     R0,[R4, #+3]
   \   00000218   0xE016             B.N      ??CanFotaFile_16
    412          		}
    413          		else
    414          		{
    415                memset((char *)buf,0x00,sizeof(buf));
   \                     ??CanFotaFile_14: (+1)
   \   0000021A   0x463A             MOV      R2,R7
   \   0000021C   0x2108             MOVS     R1,#+8
   \   0000021E   0xA805             ADD      R0,SP,#+20
   \   00000220   0x.... 0x....      BL       __aeabi_memset4
    416                SPI_FLASH_BufferRead(buf, ECUDATA_SECTOR+(SendPacket*ONEPACKET), ONEPACKET);
   \   00000224   0x2208             MOVS     R2,#+8
   \   00000226   0x00F0             LSLS     R0,R6,#+3
   \   00000228   0xF500 0x0158      ADD      R1,R0,#+14155776
   \   0000022C   0xA805             ADD      R0,SP,#+20
   \   0000022E   0x.... 0x....      BL       SPI_FLASH_BufferRead
    417                SendCount = MakePackMassage(&msg, 0x012, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   00000232   0x2008             MOVS     R0,#+8
   \   00000234   0x9001             STR      R0,[SP, #+4]
   \   00000236   0xA805             ADD      R0,SP,#+20
   \   00000238   0x9000             STR      R0,[SP, #+0]
   \   0000023A   0x463B             MOV      R3,R7
   \   0000023C   0x461A             MOV      R2,R3
   \   0000023E   0x2112             MOVS     R1,#+18
   \   00000240   0xA807             ADD      R0,SP,#+28
   \   00000242   0x.... 0x....      BL       MakePackMassage
   \   00000246   0x4607             MOV      R7,R0
    418          		}
    419          		ret = DOWNLOAD_PROG;
   \                     ??CanFotaFile_16: (+1)
   \   00000248   0x2603             MOVS     R6,#+3
    420          		SendPacket++;
   \   0000024A   0x6828             LDR      R0,[R5, #+0]
   \   0000024C   0x1C40             ADDS     R0,R0,#+1
   \   0000024E   0x6028             STR      R0,[R5, #+0]
   \   00000250   0xE027             B.N      ??CanFotaFile_1
    421          		}
    422          		break;
    423          
    424          	case DOWNLOAD_END:
    425          		if(dlMode != DOWNLOAD_END) return 0;
   \                     ??CanFotaFile_17: (+1)
   \   00000252   0x7820             LDRB     R0,[R4, #+0]
   \   00000254   0x2804             CMP      R0,#+4
   \   00000256   0xD001             BEQ.N    ??CanFotaFile_18
   \                     ??CanFotaFile_10: (+1)
   \   00000258   0x4628             MOV      R0,R5
   \   0000025A   0xE029             B.N      ??CanFotaFile_19
    426          		buf[0] = 0x01;
   \                     ??CanFotaFile_18: (+1)
   \   0000025C   0x2001             MOVS     R0,#+1
   \   0000025E   0xF88D 0x0014      STRB     R0,[SP, #+20]
    427              SendCount = MakePackMassage(&msg, 0x013, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   00000262   0x2008             MOVS     R0,#+8
   \   00000264   0x9001             STR      R0,[SP, #+4]
   \   00000266   0xA805             ADD      R0,SP,#+20
   \   00000268   0x9000             STR      R0,[SP, #+0]
   \   0000026A   0x462B             MOV      R3,R5
   \   0000026C   0x461A             MOV      R2,R3
   \   0000026E   0x2113             MOVS     R1,#+19
   \   00000270   0xA807             ADD      R0,SP,#+28
   \   00000272   0x.... 0x....      BL       MakePackMassage
   \   00000276   0x4607             MOV      R7,R0
    428              Setting.ECUFW_flag = 2;
   \   00000278   0x2002             MOVS     R0,#+2
   \   0000027A   0x.... 0x....      LDR.W    R1,??DataTable23_1
   \   0000027E   0x7188             STRB     R0,[R1, #+6]
    429          		ret = DOWNLOAD_PROG;
   \   00000280   0x2603             MOVS     R6,#+3
    430          		printk("download end.....\n");
   \   00000282   0x.... 0x....      ADR.W    R0,?_8
   \   00000286   0x.... 0x....      BL       printk
    431          		nStatus = DOWNLOAD_WAIT;
   \   0000028A   0x2005             MOVS     R0,#+5
   \   0000028C   0x70E0             STRB     R0,[R4, #+3]
    432          		break;
   \   0000028E   0xE008             B.N      ??CanFotaFile_1
    433          	case DOWNLOAD_WAIT:
    434              nStatus = 0;
   \                     ??CanFotaFile_20: (+1)
   \   00000290   0x4628             MOV      R0,R5
   \   00000292   0x70E0             STRB     R0,[R4, #+3]
    435              Flags.DownloadFlag = 0;
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000298   0x8801             LDRH     R1,[R0, #+0]
   \   0000029A   0xF64F 0x72BF      MOVW     R2,#+65471
   \   0000029E   0x4011             ANDS     R1,R2,R1
   \   000002A0   0x8001             STRH     R1,[R0, #+0]
    436          		ret = DOWNLOAD_nCHECK;
    437          		break;
    438          
    439          	default:
    440          		break;
    441          	}
    442            if (SendCount ) SendCanMassage(&msg); 
   \                     ??CanFotaFile_1: (+1)
   \   000002A2   0xB2BF             UXTH     R7,R7
   \   000002A4   0x2F00             CMP      R7,#+0
   \   000002A6   0xD002             BEQ.N    ??CanFotaFile_21
   \   000002A8   0xA807             ADD      R0,SP,#+28
   \   000002AA   0x.... 0x....      BL       SendCanMassage
    443          	return ret;
   \                     ??CanFotaFile_21: (+1)
   \   000002AE   0x4630             MOV      R0,R6
   \                     ??CanFotaFile_19: (+1)
   \   000002B0   0xB04D             ADD      SP,SP,#+308
   \   000002B2   0xBDF0             POP      {R4-R7,PC}       ;; return
    444          
    445          }

   \                                 In section .bss, align 4
   \                     dlMode:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 1
   \                     ramCRC:
   \   00000006                      DS8 2
   \                     FileSize:
   \   00000008                      DS8 4
    446          /*
    447          ********************************************************************************
    448          * Description : CAN_Decode
    449          * Arguments   : info
    450          * Return      : 
    451          * Note        : CAN data process
    452          ******************************************************************************** 
    453          */

   \                                 In section .text, align 2, keep-with-next
    454          void CAN_Decode(void)
    455          {
   \                     CAN_Decode: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
    456          	CanTxMsg       msg;	
    457            INT8U buf[20], map_x;
    458          	INT16U SendCount = 0, buf16b;
   \   00000004   0x2500             MOVS     R5,#+0
    459            INT16S sbuf16b;
    460          	INT32U buf32b, addr;
    461          
    462            if(Can_RxMsg.id < 0x100) {
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable24
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xF200 0x8140      BHI.W    ??CAN_Decode_0
    463              if(Can_RxMsg.id == 0x010) {
   \   00000012   0x2810             CMP      R0,#+16
   \   00000014   0xD112             BNE.N    ??CAN_Decode_1
    464                if(Can_RxMsg.data[0] == 0x00)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   0000001A   0x79E1             LDRB     R1,[R4, #+7]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD106             BNE.N    ??CAN_Decode_2
    465                {
    466                  nDlStatus = 1;				//Packet Count Ok...
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    467                  printk("DL Packet Count Ok....\n");
   \   00000024   0x.... 0x....      ADR.W    R0,?_9
   \   00000028   0x.... 0x....      BL       printk
   \   0000002C   0xE131             B.N      ??CAN_Decode_0
    468                }
    469                else
    470                {
    471                  nDlStatus = 4;				//Packet Count Error.....
   \                     ??CAN_Decode_2: (+1)
   \   0000002E   0x2104             MOVS     R1,#+4
   \   00000030   0x7001             STRB     R1,[R0, #+0]
    472                  printk("DL Packet Count Error....\n");
   \   00000032   0x.... 0x....      ADR.W    R0,?_10
   \   00000036   0x.... 0x....      BL       printk
   \   0000003A   0xE12A             B.N      ??CAN_Decode_0
    473                }
    474              }
    475              else if(Can_RxMsg.id == 0x011) {
   \                     ??CAN_Decode_1: (+1)
   \   0000003C   0x2811             CMP      R0,#+17
   \   0000003E   0xD112             BNE.N    ??CAN_Decode_3
    476                if (Can_RxMsg.data[0] == 0x00)//CAN ID 0x11 Download Start(File CRC)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000044   0x79E1             LDRB     R1,[R4, #+7]
   \   00000046   0x2900             CMP      R1,#+0
   \   00000048   0xD106             BNE.N    ??CAN_Decode_4
    477                {
    478                  nDlStatus = 2;
   \   0000004A   0x2102             MOVS     R1,#+2
   \   0000004C   0x7001             STRB     R1,[R0, #+0]
    479                  printk("DL CRC Response Ok....\n");
   \   0000004E   0x.... 0x....      ADR.W    R0,?_11
   \   00000052   0x.... 0x....      BL       printk
   \   00000056   0xE11C             B.N      ??CAN_Decode_0
    480                }
    481                else
    482                {
    483                  nDlStatus = 4;
   \                     ??CAN_Decode_4: (+1)
   \   00000058   0x2104             MOVS     R1,#+4
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
    484                  printk("DL CRC Error....\n");        
   \   0000005C   0x.... 0x....      ADR.W    R0,?_12
   \   00000060   0x.... 0x....      BL       printk
   \   00000064   0xE115             B.N      ??CAN_Decode_0
    485                }
    486              }
    487              else if(Can_RxMsg.id ==0x013) {
   \                     ??CAN_Decode_3: (+1)
   \   00000066   0x2813             CMP      R0,#+19
   \   00000068   0xD123             BNE.N    ??CAN_Decode_5
    488                if (Can_RxMsg.data[0] == 0x00) //CAN ID 0x13 Download End
   \   0000006A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD117             BNE.N    ??CAN_Decode_6
    489                {
    490                  if(Setting.ECUFW_flag) {
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000074   0xF890 0x10C5      LDRB     R1,[R0, #+197]
   \   00000078   0x2900             CMP      R1,#+0
   \   0000007A   0xD008             BEQ.N    ??CAN_Decode_7
    491                    Setting.ECUFW_flag = 0;
   \   0000007C   0x4629             MOV      R1,R5
   \   0000007E   0xF880 0x10C5      STRB     R1,[R0, #+197]
    492                    addr = DRV_SETTING_PARM + offsetof(st_Setting, ECUFW_flag);
    493                    FRAMMultiWrite((u8 *)&Setting.ECUFW_flag, addr, 1);
   \   00000082   0x2201             MOVS     R2,#+1
   \   00000084   0xF240 0x11C5      MOVW     R1,#+453
   \   00000088   0x30C5             ADDS     R0,R0,#+197
   \   0000008A   0x.... 0x....      BL       FRAMMultiWrite
    494                  }
    495                  nDlStatus = 3;
   \                     ??CAN_Decode_7: (+1)
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000094   0x7008             STRB     R0,[R1, #+0]
    496                  printk("DL soucess Ok....\n");
   \   00000096   0x.... 0x....      ADR.W    R0,?_13
   \   0000009A   0x.... 0x....      BL       printk
   \   0000009E   0xE0F8             B.N      ??CAN_Decode_0
    497                }
    498                else
    499                {
    500                  nDlStatus = 4;
   \                     ??CAN_Decode_6: (+1)
   \   000000A0   0x2004             MOVS     R0,#+4
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
    501                  printk("DL soucess Error....\n");
   \   000000A8   0x.... 0x....      ADR.W    R0,?_14
   \   000000AC   0x.... 0x....      BL       printk
   \   000000B0   0xE0EF             B.N      ??CAN_Decode_0
    502                }
    503              }
    504              else if(Can_RxMsg.id == 0x30) {
   \                     ??CAN_Decode_5: (+1)
   \   000000B2   0x2830             CMP      R0,#+48
   \   000000B4   0xD127             BNE.N    ??CAN_Decode_8
    505                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[0], 2);
   \   000000B6   0x2202             MOVS     R2,#+2
   \   000000B8   0x1DE1             ADDS     R1,R4,#+7
   \   000000BA   0xA802             ADD      R0,SP,#+8
   \   000000BC   0x.... 0x....      BL       __aeabi_memcpy
    506                ReadValue.DpfValue.T[0] =  buf16b;
   \   000000C0   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000000C4   0xF106 0x0712      ADD      R7,R6,#+18
   \   000000C8   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000CC   0x8038             STRH     R0,[R7, #+0]
    507                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[2], 2);
   \   000000CE   0x2202             MOVS     R2,#+2
   \   000000D0   0xF104 0x0109      ADD      R1,R4,#+9
   \   000000D4   0xA802             ADD      R0,SP,#+8
   \   000000D6   0x.... 0x....      BL       __aeabi_memcpy
    508                ReadValue.DpfValue.T[1] =  buf16b;
   \   000000DA   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000DE   0x8078             STRH     R0,[R7, #+2]
    509                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[4], 2);
   \   000000E0   0x2202             MOVS     R2,#+2
   \   000000E2   0xF104 0x010B      ADD      R1,R4,#+11
   \   000000E6   0xA802             ADD      R0,SP,#+8
   \   000000E8   0x.... 0x....      BL       __aeabi_memcpy
    510                ReadValue.DpfValue.T[2] =  buf16b;
   \   000000EC   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000F0   0x80B8             STRH     R0,[R7, #+4]
    511                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[6], 2);
   \   000000F2   0x2202             MOVS     R2,#+2
   \   000000F4   0xF104 0x010D      ADD      R1,R4,#+13
   \   000000F8   0xA802             ADD      R0,SP,#+8
   \   000000FA   0x.... 0x....      BL       __aeabi_memcpy
    512                ReadValue.DpfValue.T[3] =  buf16b;
   \   000000FE   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000102   0x80F8             STRH     R0,[R7, #+6]
   \   00000104   0xE0C5             B.N      ??CAN_Decode_0
    513              }
    514              else if(Can_RxMsg.id == 0x31) {
   \                     ??CAN_Decode_8: (+1)
   \   00000106   0x2831             CMP      R0,#+49
   \   00000108   0xD124             BNE.N    ??CAN_Decode_9
    515                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[0], 2);
   \   0000010A   0x2202             MOVS     R2,#+2
   \   0000010C   0x1DE1             ADDS     R1,R4,#+7
   \   0000010E   0xA802             ADD      R0,SP,#+8
   \   00000110   0x.... 0x....      BL       __aeabi_memcpy
    516                ReadValue.DpfValue.P =  buf16b;
   \   00000114   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   00000118   0xF106 0x0712      ADD      R7,R6,#+18
   \   0000011C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000120   0x8138             STRH     R0,[R7, #+8]
    517                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[2], 2);
   \   00000122   0x2202             MOVS     R2,#+2
   \   00000124   0xF104 0x0109      ADD      R1,R4,#+9
   \   00000128   0xA802             ADD      R0,SP,#+8
   \   0000012A   0x.... 0x....      BL       __aeabi_memcpy
    518                ReadValue.DpfValue.Rate =  buf16b;    
   \   0000012E   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000132   0x8178             STRH     R0,[R7, #+10]
    519                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[4], 2);
   \   00000134   0x2202             MOVS     R2,#+2
   \   00000136   0xF104 0x010B      ADD      R1,R4,#+11
   \   0000013A   0xA802             ADD      R0,SP,#+8
   \   0000013C   0x.... 0x....      BL       __aeabi_memcpy
    520                //
    521                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[6], 2);
   \   00000140   0x2202             MOVS     R2,#+2
   \   00000142   0xF104 0x010D      ADD      R1,R4,#+13
   \   00000146   0xA802             ADD      R0,SP,#+8
   \   00000148   0x.... 0x....      BL       __aeabi_memcpy
    522                ReadValue.DpfValue.IHC =  buf16b;
   \   0000014C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000150   0x81B8             STRH     R0,[R7, #+12]
   \   00000152   0xE09E             B.N      ??CAN_Decode_0
    523              }
    524              else if(Can_RxMsg.id == 0x32) {
   \                     ??CAN_Decode_9: (+1)
   \   00000154   0x2832             CMP      R0,#+50
   \   00000156   0xD11D             BNE.N    ??CAN_Decode_10
    525                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[0], 2);
   \   00000158   0x2202             MOVS     R2,#+2
   \   0000015A   0x1DE1             ADDS     R1,R4,#+7
   \   0000015C   0xA802             ADD      R0,SP,#+8
   \   0000015E   0x.... 0x....      BL       __aeabi_memcpy
    526                ReadValue.DpfValue.f_REG =  buf16b;
   \   00000162   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   00000166   0xF106 0x0712      ADD      R7,R6,#+18
   \   0000016A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000016E   0x81F8             STRH     R0,[R7, #+14]
    527                ReadValue.DpfValue.CarType = Can_RxMsg.data[2]; 
   \   00000170   0x7A60             LDRB     R0,[R4, #+9]
   \   00000172   0x7438             STRB     R0,[R7, #+16]
    528                ReadValue.DpfValue.FPD = Can_RxMsg.data[3]; 
   \   00000174   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000176   0x7478             STRB     R0,[R7, #+17]
    529                ReadValue.DpfValue.Error.B = Can_RxMsg.data[4]; 
   \   00000178   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000017A   0x74B8             STRB     R0,[R7, #+18]
    530                ReadValue.DpfValue.Check.B = Can_RxMsg.data[5];
   \   0000017C   0x7B20             LDRB     R0,[R4, #+12]
   \   0000017E   0x74F8             STRB     R0,[R7, #+19]
    531                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[6], 2);
   \   00000180   0x2202             MOVS     R2,#+2
   \   00000182   0xF104 0x010D      ADD      R1,R4,#+13
   \   00000186   0xA802             ADD      R0,SP,#+8
   \   00000188   0x.... 0x....      BL       __aeabi_memcpy
    532                ReadValue.DpfValue.t_REG =  buf16b;      
   \   0000018C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000190   0x82B8             STRH     R0,[R7, #+20]
   \   00000192   0xE07E             B.N      ??CAN_Decode_0
    533              }
    534              else if(Can_RxMsg.id == 0x33) {
   \                     ??CAN_Decode_10: (+1)
   \   00000194   0x2833             CMP      R0,#+51
   \   00000196   0xD11F             BNE.N    ??CAN_Decode_11
    535                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[0], 2);
   \   00000198   0x2202             MOVS     R2,#+2
   \   0000019A   0x1DE1             ADDS     R1,R4,#+7
   \   0000019C   0xA802             ADD      R0,SP,#+8
   \   0000019E   0x.... 0x....      BL       __aeabi_memcpy
    536                ReadValue.DpfValue.n_REG =  buf16b;
   \   000001A2   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000001A6   0xF106 0x0712      ADD      R7,R6,#+18
   \   000001AA   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000001AE   0x82F8             STRH     R0,[R7, #+22]
    537                ReadValue.DpfValue.Sig.B = Can_RxMsg.data[2];
   \   000001B0   0x7A60             LDRB     R0,[R4, #+9]
   \   000001B2   0x7638             STRB     R0,[R7, #+24]
    538                ReadValue.DpfValue.Sts.B = Can_RxMsg.data[3];
   \   000001B4   0x7AA0             LDRB     R0,[R4, #+10]
   \   000001B6   0x7678             STRB     R0,[R7, #+25]
    539                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[4], 2);
   \   000001B8   0x2202             MOVS     R2,#+2
   \   000001BA   0xF104 0x010B      ADD      R1,R4,#+11
   \   000001BE   0xA802             ADD      R0,SP,#+8
   \   000001C0   0x.... 0x....      BL       __aeabi_memcpy
    540                ReadValue.DpfValue.t_OffSCR =  buf16b;
   \   000001C4   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000001C8   0x8770             STRH     R0,[R6, #+58]
    541                ReadValue.DpfValue.RegenStartKey = Can_RxMsg.data[6];
   \   000001CA   0x7B60             LDRB     R0,[R4, #+13]
   \   000001CC   0xF106 0x012D      ADD      R1,R6,#+45
   \   000001D0   0x7308             STRB     R0,[R1, #+12]
    542                ReadValue.DpfValue.Lock = Can_RxMsg.data[7];
   \   000001D2   0x7BA0             LDRB     R0,[R4, #+14]
   \   000001D4   0x76B8             STRB     R0,[R7, #+26]
   \   000001D6   0xE05C             B.N      ??CAN_Decode_0
    543              }
    544              else if(Can_RxMsg.id == 0x34) {
   \                     ??CAN_Decode_11: (+1)
   \   000001D8   0x2834             CMP      R0,#+52
   \   000001DA   0xD113             BNE.N    ??CAN_Decode_12
    545                memcpy( (char*)&buf32b, (char *)&Can_RxMsg.data[0], 4);
   \   000001DC   0x2204             MOVS     R2,#+4
   \   000001DE   0x1DE1             ADDS     R1,R4,#+7
   \   000001E0   0xA803             ADD      R0,SP,#+12
   \   000001E2   0x.... 0x....      BL       __aeabi_memcpy
    546                ReadValue.DpfValue.DrvTime =  buf32b;
   \   000001E6   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000001EA   0x362D             ADDS     R6,R6,#+45
   \   000001EC   0x9803             LDR      R0,[SP, #+12]
   \   000001EE   0x6030             STR      R0,[R6, #+0]
    547                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[4], 2);
   \   000001F0   0x2202             MOVS     R2,#+2
   \   000001F2   0xF104 0x010B      ADD      R1,R4,#+11
   \   000001F6   0xA802             ADD      R0,SP,#+8
   \   000001F8   0x.... 0x....      BL       __aeabi_memcpy
    548                ReadValue.DpfValue.baseP1 =  buf16b;
   \   000001FC   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000200   0x80B0             STRH     R0,[R6, #+4]
   \   00000202   0xE046             B.N      ??CAN_Decode_0
    549              } 
    550              else if(Can_RxMsg.id == 0x35) {
   \                     ??CAN_Decode_12: (+1)
   \   00000204   0x2835             CMP      R0,#+53
   \   00000206   0xD11D             BNE.N    ??CAN_Decode_13
    551                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[0], 2);
   \   00000208   0x2202             MOVS     R2,#+2
   \   0000020A   0x1DE1             ADDS     R1,R4,#+7
   \   0000020C   0xA802             ADD      R0,SP,#+8
   \   0000020E   0x.... 0x....      BL       __aeabi_memcpy
    552                ReadValue.DpfValue.f_SCR =  buf16b;
   \   00000212   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   00000216   0x362D             ADDS     R6,R6,#+45
   \   00000218   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000021C   0x80F0             STRH     R0,[R6, #+6]
    553                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[2], 2);
   \   0000021E   0x2202             MOVS     R2,#+2
   \   00000220   0xF104 0x0109      ADD      R1,R4,#+9
   \   00000224   0xA802             ADD      R0,SP,#+8
   \   00000226   0x.... 0x....      BL       __aeabi_memcpy
    554                ReadValue.DpfValue.t_SCR =  buf16b;
   \   0000022A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000022E   0x8130             STRH     R0,[R6, #+8]
    555                memcpy( (char*)&buf16b, (char *)&Can_RxMsg.data[4], 2);
   \   00000230   0x2202             MOVS     R2,#+2
   \   00000232   0xF104 0x010B      ADD      R1,R4,#+11
   \   00000236   0xA802             ADD      R0,SP,#+8
   \   00000238   0x.... 0x....      BL       __aeabi_memcpy
    556                ReadValue.DpfValue.n_SCR =  buf16b;
   \   0000023C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000240   0x8170             STRH     R0,[R6, #+10]
   \   00000242   0xE026             B.N      ??CAN_Decode_0
    557              }     
    558              else if(Can_RxMsg.id == 0x98) {//ID : 0x98
   \                     ??CAN_Decode_13: (+1)
   \   00000244   0x2898             CMP      R0,#+152
   \   00000246   0xD111             BNE.N    ??CAN_Decode_14
    559                memcpy((char *)&buf32b,&Can_RxMsg.data[0],4);
   \   00000248   0x2204             MOVS     R2,#+4
   \   0000024A   0x1DE1             ADDS     R1,R4,#+7
   \   0000024C   0xA803             ADD      R0,SP,#+12
   \   0000024E   0x.... 0x....      BL       __aeabi_memcpy
    560                ScrValue.curXk = buf32b;
   \   00000252   0x.... 0x....      LDR.W    R6,??DataTable24_4
   \   00000256   0x9803             LDR      R0,[SP, #+12]
   \   00000258   0x6030             STR      R0,[R6, #+0]
    561                memcpy((char *)&buf32b,&Can_RxMsg.data[4],4);
   \   0000025A   0x2204             MOVS     R2,#+4
   \   0000025C   0xF104 0x010B      ADD      R1,R4,#+11
   \   00000260   0xA803             ADD      R0,SP,#+12
   \   00000262   0x.... 0x....      BL       __aeabi_memcpy
    562                ScrValue.Xc = buf32b;
   \   00000266   0x9803             LDR      R0,[SP, #+12]
   \   00000268   0x6070             STR      R0,[R6, #+4]
   \   0000026A   0xE012             B.N      ??CAN_Decode_0
    563              }
    564              else if(Can_RxMsg.id == 0x99) {//ID : 0x99
   \                     ??CAN_Decode_14: (+1)
   \   0000026C   0x2899             CMP      R0,#+153
   \   0000026E   0xD110             BNE.N    ??CAN_Decode_0
    565                memcpy((char *)&buf32b,&Can_RxMsg.data[0],4);
   \   00000270   0x2204             MOVS     R2,#+4
   \   00000272   0x1DE1             ADDS     R1,R4,#+7
   \   00000274   0xA803             ADD      R0,SP,#+12
   \   00000276   0x.... 0x....      BL       __aeabi_memcpy
    566                ScrValue.H1k = buf32b;
   \   0000027A   0x.... 0x....      LDR.W    R6,??DataTable24_4
   \   0000027E   0x9803             LDR      R0,[SP, #+12]
   \   00000280   0x60B0             STR      R0,[R6, #+8]
    567                memcpy((char *)&buf32b,&Can_RxMsg.data[4],4);
   \   00000282   0x2204             MOVS     R2,#+4
   \   00000284   0xF104 0x010B      ADD      R1,R4,#+11
   \   00000288   0xA803             ADD      R0,SP,#+12
   \   0000028A   0x.... 0x....      BL       __aeabi_memcpy
    568                ScrValue.H2k = buf32b;
   \   0000028E   0x9803             LDR      R0,[SP, #+12]
   \   00000290   0x60F0             STR      R0,[R6, #+12]
    569              }
    570            }
    571            /////////////////////////////////////////ID 0x100~0x14F
    572            if(Can_RxMsg.id >= 0x100 && Can_RxMsg.id < 0x150) {
   \                     ??CAN_Decode_0: (+1)
   \   00000292   0x6820             LDR      R0,[R4, #+0]
   \   00000294   0xF5A0 0x7180      SUB      R1,R0,#+256
   \   00000298   0x2950             CMP      R1,#+80
   \   0000029A   0xF080 0x81F2      BCS.W    ??CAN_Decode_15
    573              if(Can_RxMsg.id == 0x100) {//ID : 0x100
   \   0000029E   0xF5B0 0x7F80      CMP      R0,#+256
   \   000002A2   0xD12D             BNE.N    ??CAN_Decode_16
    574          //       memcpy((char *)&buf16b,&Can_RxMsg.data[0],2);
    575          //       ReadValue.Ver   = buf16b;
    576                 ReadValue.Ver = (Can_RxMsg.data[1] / 0x10*1000) + (Can_RxMsg.data[1] % 0x10*100) + (Can_RxMsg.data[0] / 0x10*10) + (Can_RxMsg.data[0] % 0x10);
   \   000002A4   0x7A22             LDRB     R2,[R4, #+8]
   \   000002A6   0x79E1             LDRB     R1,[R4, #+7]
   \   000002A8   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000002AC   0x4610             MOV      R0,R2
   \   000002AE   0x0900             LSRS     R0,R0,#+4
   \   000002B0   0xF44F 0x737A      MOV      R3,#+1000
   \   000002B4   0x10D7             ASRS     R7,R2,#+3
   \   000002B6   0xEB02 0x7717      ADD      R7,R2,R7, LSR #+28
   \   000002BA   0x113F             ASRS     R7,R7,#+4
   \   000002BC   0xEBA2 0x1207      SUB      R2,R2,R7, LSL #+4
   \   000002C0   0x2764             MOVS     R7,#+100
   \   000002C2   0x437A             MULS     R2,R7,R2
   \   000002C4   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000002C8   0x4608             MOV      R0,R1
   \   000002CA   0x0900             LSRS     R0,R0,#+4
   \   000002CC   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \   000002D0   0xEB02 0x0043      ADD      R0,R2,R3, LSL #+1
   \   000002D4   0x1808             ADDS     R0,R1,R0
   \   000002D6   0x10CA             ASRS     R2,R1,#+3
   \   000002D8   0xEB01 0x7112      ADD      R1,R1,R2, LSR #+28
   \   000002DC   0x1109             ASRS     R1,R1,#+4
   \   000002DE   0xEBA0 0x1001      SUB      R0,R0,R1, LSL #+4
   \   000002E2   0xF106 0x013A      ADD      R1,R6,#+58
   \   000002E6   0x8048             STRH     R0,[R1, #+2]
    577                 memcpy((char *)&buf16b,&Can_RxMsg.data[6],2);
   \   000002E8   0x2202             MOVS     R2,#+2
   \   000002EA   0xF104 0x010D      ADD      R1,R4,#+13
   \   000002EE   0xA802             ADD      R0,SP,#+8
   \   000002F0   0x.... 0x....      BL       __aeabi_memcpy
    578                 ReadValue.TankTemp = buf16b;      
   \   000002F4   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000002F8   0xF106 0x015E      ADD      R1,R6,#+94
   \   000002FC   0x8048             STRH     R0,[R1, #+2]
   \   000002FE   0xE1C0             B.N      ??CAN_Decode_15
    579              }
    580              else if(Can_RxMsg.id == 0x101) {
   \                     ??CAN_Decode_16: (+1)
   \   00000300   0xF240 0x1101      MOVW     R1,#+257
   \   00000304   0x4288             CMP      R0,R1
   \   00000306   0xD123             BNE.N    ??CAN_Decode_17
    581                ReadValue.Err.B = Can_RxMsg.data[0];
   \   00000308   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   0000030C   0xF106 0x073A      ADD      R7,R6,#+58
   \   00000310   0x79E0             LDRB     R0,[R4, #+7]
   \   00000312   0x7738             STRB     R0,[R7, #+28]
    582                memcpy((char *)&buf16b,&Can_RxMsg.data[2],2);
   \   00000314   0x2202             MOVS     R2,#+2
   \   00000316   0xF104 0x0109      ADD      R1,R4,#+9
   \   0000031A   0xA802             ADD      R0,SP,#+8
   \   0000031C   0x.... 0x....      BL       __aeabi_memcpy
    583                ReadValue.Chk.W = buf16b;
   \   00000320   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000324   0x83F8             STRH     R0,[R7, #+30]
    584                memcpy((char *)&buf16b,&Can_RxMsg.data[4],2);
   \   00000326   0x2202             MOVS     R2,#+2
   \   00000328   0xF104 0x010B      ADD      R1,R4,#+11
   \   0000032C   0xA802             ADD      R0,SP,#+8
   \   0000032E   0x.... 0x....      BL       __aeabi_memcpy
    585                ReadValue.Sig.W = buf16b;
   \   00000332   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000336   0x8438             STRH     R0,[R7, #+32]
    586                memcpy((char *)&buf16b,&Can_RxMsg.data[6],2);
   \   00000338   0x2202             MOVS     R2,#+2
   \   0000033A   0xF104 0x010D      ADD      R1,R4,#+13
   \   0000033E   0xA802             ADD      R0,SP,#+8
   \   00000340   0x.... 0x....      BL       __aeabi_memcpy
    587                ReadValue.UreaQuality = buf16b;
   \   00000344   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000348   0xF106 0x0168      ADD      R1,R6,#+104
   \   0000034C   0x81C8             STRH     R0,[R1, #+14]
   \   0000034E   0xE198             B.N      ??CAN_Decode_15
    588              }
    589              else if(Can_RxMsg.id == 0x102) {
   \                     ??CAN_Decode_17: (+1)
   \   00000350   0xF5B0 0x7F81      CMP      R0,#+258
   \   00000354   0xD134             BNE.N    ??CAN_Decode_18
    590                memcpy((char *)&buf16b,&Can_RxMsg.data[0],2);
   \   00000356   0x2202             MOVS     R2,#+2
   \   00000358   0x1DE1             ADDS     R1,R4,#+7
   \   0000035A   0xA802             ADD      R0,SP,#+8
   \   0000035C   0x.... 0x....      BL       __aeabi_memcpy
    591                ReadValue.NOxIn = (INT16S)buf16b;
   \   00000360   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   00000364   0xF106 0x073A      ADD      R7,R6,#+58
   \   00000368   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000036C   0x80B8             STRH     R0,[R7, #+4]
    592                if(ReadValue.NOxIn < 0) ReadValue.NOxIn = 0;
   \   0000036E   0x2800             CMP      R0,#+0
   \   00000370   0xD501             BPL.N    ??CAN_Decode_19
   \   00000372   0x4628             MOV      R0,R5
   \   00000374   0x80B8             STRH     R0,[R7, #+4]
    593                memcpy((char *)&buf16b,&Can_RxMsg.data[2],2);
   \                     ??CAN_Decode_19: (+1)
   \   00000376   0x2202             MOVS     R2,#+2
   \   00000378   0xF104 0x0109      ADD      R1,R4,#+9
   \   0000037C   0xA802             ADD      R0,SP,#+8
   \   0000037E   0x.... 0x....      BL       __aeabi_memcpy
    594                ReadValue.NOxOut = (INT16S)buf16b;
   \   00000382   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000386   0x80F8             STRH     R0,[R7, #+6]
    595                if(ReadValue.NOxOut < 0) ReadValue.NOxOut = 0;
   \   00000388   0x2800             CMP      R0,#+0
   \   0000038A   0xD501             BPL.N    ??CAN_Decode_20
   \   0000038C   0x4628             MOV      R0,R5
   \   0000038E   0x80F8             STRH     R0,[R7, #+6]
    596                memcpy((char *)&buf16b,&Can_RxMsg.data[4],2);
   \                     ??CAN_Decode_20: (+1)
   \   00000390   0x2202             MOVS     R2,#+2
   \   00000392   0xF104 0x010B      ADD      R1,R4,#+11
   \   00000396   0xA802             ADD      R0,SP,#+8
   \   00000398   0x.... 0x....      BL       __aeabi_memcpy
    597                ReadValue.MAF = buf16b;
   \   0000039C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000003A0   0x8138             STRH     R0,[R7, #+8]
    598                memcpy((char *)&buf16b,&Can_RxMsg.data[6],2);
   \   000003A2   0x2202             MOVS     R2,#+2
   \   000003A4   0xF104 0x010D      ADD      R1,R4,#+13
   \   000003A8   0xA802             ADD      R0,SP,#+8
   \   000003AA   0x.... 0x....      BL       __aeabi_memcpy
    599                ReadValue.Maf_temp = buf16b;
   \   000003AE   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000003B2   0x8478             STRH     R0,[R7, #+34]
    600                if(ReadValue.Maf_temp < 0) ReadValue.Maf_temp = 0; 
   \   000003B4   0x2800             CMP      R0,#+0
   \   000003B6   0xF140 0x8164      BPL.W    ??CAN_Decode_15
   \   000003BA   0x4628             MOV      R0,R5
   \   000003BC   0x8478             STRH     R0,[R7, #+34]
   \   000003BE   0xE160             B.N      ??CAN_Decode_15
    601              }
    602              else if(Can_RxMsg.id == 0x103) {
   \                     ??CAN_Decode_18: (+1)
   \   000003C0   0xF240 0x1103      MOVW     R1,#+259
   \   000003C4   0x4288             CMP      R0,R1
   \   000003C6   0xD11E             BNE.N    ??CAN_Decode_21
    603                memcpy((char *)&buf16b,&Can_RxMsg.data[0],2);
   \   000003C8   0x2202             MOVS     R2,#+2
   \   000003CA   0x1DE1             ADDS     R1,R4,#+7
   \   000003CC   0xA802             ADD      R0,SP,#+8
   \   000003CE   0x.... 0x....      BL       __aeabi_memcpy
    604                ReadValue.TempIn = buf16b;
   \   000003D2   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000003D6   0xF106 0x073A      ADD      R7,R6,#+58
   \   000003DA   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000003DE   0x8178             STRH     R0,[R7, #+10]
    605                memcpy((char *)&buf16b,&Can_RxMsg.data[2],2);
   \   000003E0   0x2202             MOVS     R2,#+2
   \   000003E2   0xF104 0x0109      ADD      R1,R4,#+9
   \   000003E6   0xA802             ADD      R0,SP,#+8
   \   000003E8   0x.... 0x....      BL       __aeabi_memcpy
    606                ReadValue.TempOut = buf16b;
   \   000003EC   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000003F0   0x81B8             STRH     R0,[R7, #+12]
    607            		memcpy((char *)&buf16b,&Can_RxMsg.data[4],2);
   \   000003F2   0x2202             MOVS     R2,#+2
   \   000003F4   0xF104 0x010B      ADD      R1,R4,#+11
   \   000003F8   0xA802             ADD      R0,SP,#+8
   \   000003FA   0x.... 0x....      BL       __aeabi_memcpy
    608                ReadValue.Tavg = buf16b;
   \   000003FE   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000402   0x81F8             STRH     R0,[R7, #+14]
   \   00000404   0xE13D             B.N      ??CAN_Decode_15
    609            		//memcpy((char *)&buf16b,&Can_RxMsg.data[6],2);
    610                //ReadValue.TankTemp = buf16b;
    611              }
    612              else if(Can_RxMsg.id == 0x104) {
   \                     ??CAN_Decode_21: (+1)
   \   00000406   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000040A   0xD113             BNE.N    ??CAN_Decode_22
    613                memcpy((char *)&buf32b,&Can_RxMsg.data[0],4);
   \   0000040C   0x2204             MOVS     R2,#+4
   \   0000040E   0x1DE1             ADDS     R1,R4,#+7
   \   00000410   0xA803             ADD      R0,SP,#+12
   \   00000412   0x.... 0x....      BL       __aeabi_memcpy
    614                ReadValue.DosingRatehouer = buf32b;
   \   00000416   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   0000041A   0xF106 0x073A      ADD      R7,R6,#+58
   \   0000041E   0x9803             LDR      R0,[SP, #+12]
   \   00000420   0x6178             STR      R0,[R7, #+20]
    615                memcpy((char *)&buf32b,&Can_RxMsg.data[4],4);  //테스트후 원상 복귀
   \   00000422   0x2204             MOVS     R2,#+4
   \   00000424   0xF104 0x010B      ADD      R1,R4,#+11
   \   00000428   0xA803             ADD      R0,SP,#+12
   \   0000042A   0x.... 0x....      BL       __aeabi_memcpy
    616                ReadValue.TotalDosingRate = buf32b;
   \   0000042E   0x9803             LDR      R0,[SP, #+12]
   \   00000430   0x61B8             STR      R0,[R7, #+24]
   \   00000432   0xE126             B.N      ??CAN_Decode_15
    617              }
    618              else if(Can_RxMsg.id == 0x105) {
   \                     ??CAN_Decode_22: (+1)
   \   00000434   0xF240 0x1105      MOVW     R1,#+261
   \   00000438   0x4288             CMP      R0,R1
   \   0000043A   0xD111             BNE.N    ??CAN_Decode_23
    619                memcpy((char *)&buf32b,&Can_RxMsg.data[0],4);
   \   0000043C   0x2204             MOVS     R2,#+4
   \   0000043E   0x1DE1             ADDS     R1,R4,#+7
   \   00000440   0xA803             ADD      R0,SP,#+12
   \   00000442   0x.... 0x....      BL       __aeabi_memcpy
    620                ScrValue.Kl = buf32b;
   \   00000446   0x.... 0x....      LDR.W    R6,??DataTable24_4
   \   0000044A   0x9803             LDR      R0,[SP, #+12]
   \   0000044C   0x61F0             STR      R0,[R6, #+28]
    621                memcpy((char *)&buf32b,&Can_RxMsg.data[4],4);
   \   0000044E   0x2204             MOVS     R2,#+4
   \   00000450   0xF104 0x010B      ADD      R1,R4,#+11
   \   00000454   0xA803             ADD      R0,SP,#+12
   \   00000456   0x.... 0x....      BL       __aeabi_memcpy
    622                ScrValue.Kp = buf32b;
   \   0000045A   0x9803             LDR      R0,[SP, #+12]
   \   0000045C   0x6230             STR      R0,[R6, #+32]
   \   0000045E   0xE110             B.N      ??CAN_Decode_15
    623              }
    624              else if(Can_RxMsg.id == 0x106) {
   \                     ??CAN_Decode_23: (+1)
   \   00000460   0xF5B0 0x7F83      CMP      R0,#+262
   \   00000464   0xD111             BNE.N    ??CAN_Decode_24
    625                memcpy((char *)&buf32b,&Can_RxMsg.data[0],4);
   \   00000466   0x2204             MOVS     R2,#+4
   \   00000468   0x1DE1             ADDS     R1,R4,#+7
   \   0000046A   0xA803             ADD      R0,SP,#+12
   \   0000046C   0x.... 0x....      BL       __aeabi_memcpy
    626                ScrValue.Vk = buf32b;
   \   00000470   0x.... 0x....      LDR.W    R6,??DataTable24_4
   \   00000474   0x9803             LDR      R0,[SP, #+12]
   \   00000476   0x6170             STR      R0,[R6, #+20]
    627                memcpy((char *)&buf32b,&Can_RxMsg.data[4],4);
   \   00000478   0x2204             MOVS     R2,#+4
   \   0000047A   0xF104 0x010B      ADD      R1,R4,#+11
   \   0000047E   0xA803             ADD      R0,SP,#+12
   \   00000480   0x.... 0x....      BL       __aeabi_memcpy
    628                ScrValue.Gamma = buf32b;
   \   00000484   0x9803             LDR      R0,[SP, #+12]
   \   00000486   0x61B0             STR      R0,[R6, #+24]
   \   00000488   0xE0FB             B.N      ??CAN_Decode_15
    629              }
    630              else if(Can_RxMsg.id == 0x107) {
   \                     ??CAN_Decode_24: (+1)
   \   0000048A   0xF240 0x1107      MOVW     R1,#+263
   \   0000048E   0x4288             CMP      R0,R1
   \   00000490   0xD122             BNE.N    ??CAN_Decode_25
    631                memcpy((char *)&buf16b,&Can_RxMsg.data[0],2);
   \   00000492   0x2202             MOVS     R2,#+2
   \   00000494   0x1DE1             ADDS     R1,R4,#+7
   \   00000496   0xA802             ADD      R0,SP,#+8
   \   00000498   0x.... 0x....      BL       __aeabi_memcpy
    632            		ReadValue.BV = buf16b;
   \   0000049C   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000004A0   0xF106 0x075E      ADD      R7,R6,#+94
   \   000004A4   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000004A8   0x80F8             STRH     R0,[R7, #+6]
    633           		  //memcpy((char *)&buf16b,&Can_RxMsg.data[2],2);
    634                ReadValue.UreaLevel = Can_RxMsg.data[2];
   \   000004AA   0x7A60             LDRB     R0,[R4, #+9]
   \   000004AC   0x7038             STRB     R0,[R7, #+0]
    635                memcpy((char *)&buf16b,&Can_RxMsg.data[4],2);
   \   000004AE   0x2202             MOVS     R2,#+2
   \   000004B0   0xF104 0x010B      ADD      R1,R4,#+11
   \   000004B4   0xA802             ADD      R0,SP,#+8
   \   000004B6   0x.... 0x....      BL       __aeabi_memcpy
    636                ReadValue.SupplyP = buf16b;
   \   000004BA   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000004BE   0xF106 0x013A      ADD      R1,R6,#+58
   \   000004C2   0x8248             STRH     R0,[R1, #+18]
    637                memcpy((char *)&buf16b,&Can_RxMsg.data[6],2);
   \   000004C4   0x2202             MOVS     R2,#+2
   \   000004C6   0xF104 0x010D      ADD      R1,R4,#+13
   \   000004CA   0xA802             ADD      R0,SP,#+8
   \   000004CC   0x.... 0x....      BL       __aeabi_memcpy
    638                ReadValue.DosingDuty = buf16b;
   \   000004D0   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000004D4   0x80B8             STRH     R0,[R7, #+4]
   \   000004D6   0xE0D4             B.N      ??CAN_Decode_15
    639              }
    640              else if(Can_RxMsg.id == 0x108) {
   \                     ??CAN_Decode_25: (+1)
   \   000004D8   0xF5B0 0x7F84      CMP      R0,#+264
   \   000004DC   0xD121             BNE.N    ??CAN_Decode_26
    641                memcpy((char *)&buf32b,&Can_RxMsg.data[0],4);
   \   000004DE   0x2204             MOVS     R2,#+4
   \   000004E0   0x1DE1             ADDS     R1,R4,#+7
   \   000004E2   0xA803             ADD      R0,SP,#+12
   \   000004E4   0x.... 0x....      BL       __aeabi_memcpy
    642                ScrValue.curXh = buf32b;   
   \   000004E8   0x9803             LDR      R0,[SP, #+12]
   \   000004EA   0x.... 0x....      LDR.W    R1,??DataTable24_4
   \   000004EE   0x6108             STR      R0,[R1, #+16]
    643                memcpy((char *)&buf16b,&Can_RxMsg.data[4],2);
   \   000004F0   0x2202             MOVS     R2,#+2
   \   000004F2   0xF104 0x010B      ADD      R1,R4,#+11
   \   000004F6   0xA802             ADD      R0,SP,#+8
   \   000004F8   0x.... 0x....      BL       __aeabi_memcpy
    644                ReadValue.StatusAlpha = buf16b;
   \   000004FC   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   00000500   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000504   0xF106 0x015E      ADD      R1,R6,#+94
   \   00000508   0x8108             STRH     R0,[R1, #+8]
    645                memcpy((char *)&buf16b,&Can_RxMsg.data[6],2);
   \   0000050A   0x2202             MOVS     R2,#+2
   \   0000050C   0xF104 0x010D      ADD      R1,R4,#+13
   \   00000510   0xA802             ADD      R0,SP,#+8
   \   00000512   0x.... 0x....      BL       __aeabi_memcpy
    646                ReadValue.Reduction = buf16b;
   \   00000516   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000051A   0xF106 0x0168      ADD      R1,R6,#+104
   \   0000051E   0x8188             STRH     R0,[R1, #+12]
   \   00000520   0xE0AF             B.N      ??CAN_Decode_15
    647              }
    648              else if(Can_RxMsg.id == 0x109) { 
   \                     ??CAN_Decode_26: (+1)
   \   00000522   0xF240 0x1109      MOVW     R1,#+265
   \   00000526   0x4288             CMP      R0,R1
   \   00000528   0xD11F             BNE.N    ??CAN_Decode_27
    649                memcpy((char *)&buf16b,&Can_RxMsg.data[0],2);
   \   0000052A   0x2202             MOVS     R2,#+2
   \   0000052C   0x1DE1             ADDS     R1,R4,#+7
   \   0000052E   0xA802             ADD      R0,SP,#+8
   \   00000530   0x.... 0x....      BL       __aeabi_memcpy
    650                NoxO2[0] = buf16b;
   \   00000534   0x.... 0x....      LDR.W    R6,??DataTable24_5
   \   00000538   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000053C   0x8030             STRH     R0,[R6, #+0]
    651                memcpy((char *)&buf16b,&Can_RxMsg.data[2],2);
   \   0000053E   0x2202             MOVS     R2,#+2
   \   00000540   0xF104 0x0109      ADD      R1,R4,#+9
   \   00000544   0xA802             ADD      R0,SP,#+8
   \   00000546   0x.... 0x....      BL       __aeabi_memcpy
    652                NoxO2[1] = buf16b;
   \   0000054A   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000054E   0x8070             STRH     R0,[R6, #+2]
    653                NoxFail[0] = Can_RxMsg.data[4];
   \   00000550   0x.... 0x....      LDR.W    R0,??DataTable24_6
   \   00000554   0x7AE1             LDRB     R1,[R4, #+11]
   \   00000556   0x7001             STRB     R1,[R0, #+0]
    654                NoxFail[1] = Can_RxMsg.data[5];
   \   00000558   0x7B21             LDRB     R1,[R4, #+12]
   \   0000055A   0x7041             STRB     R1,[R0, #+1]
    655                NoxErr[0] = Can_RxMsg.data[6];
   \   0000055C   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   00000560   0x7B61             LDRB     R1,[R4, #+13]
   \   00000562   0x7001             STRB     R1,[R0, #+0]
    656                NoxErr[1] = Can_RxMsg.data[7];
   \   00000564   0x7BA1             LDRB     R1,[R4, #+14]
   \   00000566   0x7041             STRB     R1,[R0, #+1]
   \   00000568   0xE08B             B.N      ??CAN_Decode_15
    657              }
    658              else if(Can_RxMsg.id == 0x110) {
   \                     ??CAN_Decode_27: (+1)
   \   0000056A   0xF5B0 0x7F88      CMP      R0,#+272
   \   0000056E   0xD10E             BNE.N    ??CAN_Decode_28
    659                NoxData[0][0] = Can_RxMsg.data[0];
   \   00000570   0x.... 0x....      LDR.W    R0,??DataTable24_8
   \   00000574   0x79E1             LDRB     R1,[R4, #+7]
   \   00000576   0x7001             STRB     R1,[R0, #+0]
    660                NoxData[0][1] = Can_RxMsg.data[1];
   \   00000578   0x7A21             LDRB     R1,[R4, #+8]
   \   0000057A   0x7041             STRB     R1,[R0, #+1]
    661                NoxData[0][2] = Can_RxMsg.data[2];
   \   0000057C   0x7A61             LDRB     R1,[R4, #+9]
   \   0000057E   0x7081             STRB     R1,[R0, #+2]
    662                NoxData[1][0] = Can_RxMsg.data[4];
   \   00000580   0x7AE1             LDRB     R1,[R4, #+11]
   \   00000582   0x70C1             STRB     R1,[R0, #+3]
    663                NoxData[1][1] = Can_RxMsg.data[5];
   \   00000584   0x7B21             LDRB     R1,[R4, #+12]
   \   00000586   0x7101             STRB     R1,[R0, #+4]
    664                NoxData[1][2] = Can_RxMsg.data[6];
   \   00000588   0x7B61             LDRB     R1,[R4, #+13]
   \   0000058A   0x7141             STRB     R1,[R0, #+5]
   \   0000058C   0xE079             B.N      ??CAN_Decode_15
    665              }
    666              else if(Can_RxMsg.id == 0x115) {
   \                     ??CAN_Decode_28: (+1)
   \   0000058E   0xF240 0x1115      MOVW     R1,#+277
   \   00000592   0x4288             CMP      R0,R1
   \   00000594   0xD10F             BNE.N    ??CAN_Decode_29
    667                ResponseTime((char *)&buf[0]);
   \   00000596   0xA804             ADD      R0,SP,#+16
   \   00000598   0x.... 0x....      BL       ResponseTime
    668                SendCount = MakePackMassage(&msg, 0x116, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   0000059C   0x2008             MOVS     R0,#+8
   \   0000059E   0x9001             STR      R0,[SP, #+4]
   \   000005A0   0xA804             ADD      R0,SP,#+16
   \   000005A2   0x9000             STR      R0,[SP, #+0]
   \   000005A4   0x462B             MOV      R3,R5
   \   000005A6   0x461A             MOV      R2,R3
   \   000005A8   0xF44F 0x718B      MOV      R1,#+278
   \   000005AC   0xA809             ADD      R0,SP,#+36
   \   000005AE   0x.... 0x....      BL       MakePackMassage
   \   000005B2   0x4605             MOV      R5,R0
   \   000005B4   0xE065             B.N      ??CAN_Decode_15
    669              }
    670              else if(Can_RxMsg.id == 0x116) {
   \                     ??CAN_Decode_29: (+1)
   \   000005B6   0xF5B0 0x7F8B      CMP      R0,#+278
   \   000005BA   0xD103             BNE.N    ??CAN_Decode_30
    671                TimeParsorSet((char *)&Can_RxMsg.data[0]);
   \   000005BC   0x1DE0             ADDS     R0,R4,#+7
   \   000005BE   0x.... 0x....      BL       TimeParsorSet
   \   000005C2   0xE05E             B.N      ??CAN_Decode_15
    672              }
    673              else if(Can_RxMsg.id == 0x117) {
   \                     ??CAN_Decode_30: (+1)
   \   000005C4   0xF240 0x1117      MOVW     R1,#+279
   \   000005C8   0x4288             CMP      R0,R1
   \   000005CA   0xD120             BNE.N    ??CAN_Decode_31
    674           		  memcpy((char *)&sbuf16b,&Can_RxMsg.data[0],2);
   \   000005CC   0x2202             MOVS     R2,#+2
   \   000005CE   0x1DE1             ADDS     R1,R4,#+7
   \   000005D0   0xF10D 0x000A      ADD      R0,SP,#+10
   \   000005D4   0x.... 0x....      BL       __aeabi_memcpy
    675          			ReadValue.Formula1 = sbuf16b;
   \   000005D8   0x.... 0x....      LDR.W    R6,??DataTable24_3
   \   000005DC   0x3668             ADDS     R6,R6,#+104
   \   000005DE   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   000005E2   0x6030             STR      R0,[R6, #+0]
    676           		  memcpy((char *)&sbuf16b,&Can_RxMsg.data[2],2);
   \   000005E4   0x2202             MOVS     R2,#+2
   \   000005E6   0xF104 0x0109      ADD      R1,R4,#+9
   \   000005EA   0xF10D 0x000A      ADD      R0,SP,#+10
   \   000005EE   0x.... 0x....      BL       __aeabi_memcpy
    677          			ReadValue.Formula2 = sbuf16b;
   \   000005F2   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   000005F6   0x6070             STR      R0,[R6, #+4]
    678           		  memcpy((char *)&sbuf16b,&Can_RxMsg.data[4],2);
   \   000005F8   0x2202             MOVS     R2,#+2
   \   000005FA   0xF104 0x010B      ADD      R1,R4,#+11
   \   000005FE   0xF10D 0x000A      ADD      R0,SP,#+10
   \   00000602   0x.... 0x....      BL       __aeabi_memcpy
    679          			ReadValue.Formula3 = sbuf16b;
   \   00000606   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000060A   0x60B0             STR      R0,[R6, #+8]
   \   0000060C   0xE039             B.N      ??CAN_Decode_15
    680              }
    681              else if(Can_RxMsg.id == 0x11A) {
   \                     ??CAN_Decode_31: (+1)
   \   0000060E   0xF5B0 0x7F8D      CMP      R0,#+282
   \   00000612   0xD104             BNE.N    ??CAN_Decode_32
    682          			ReadValue.LimitStep = Can_RxMsg.data[0];
   \   00000614   0x79E0             LDRB     R0,[R4, #+7]
   \   00000616   0x.... 0x....      LDR.W    R1,??DataTable24_9
   \   0000061A   0x7048             STRB     R0,[R1, #+1]
   \   0000061C   0xE031             B.N      ??CAN_Decode_15
    683              }    
    684              else if(Can_RxMsg.id > 0x140 && Can_RxMsg.id < 0x145) {
   \                     ??CAN_Decode_32: (+1)
   \   0000061E   0xF2A0 0x1141      SUBW     R1,R0,#+321
   \   00000622   0x2904             CMP      R1,#+4
   \   00000624   0xD211             BCS.N    ??CAN_Decode_33
    685                memcpy((char *)&Par_Buf[Par_Cnt*8],&Can_RxMsg.data[0],8);
   \   00000626   0x.... 0x....      LDR.W    R6,??DataTable24_10
   \   0000062A   0x7837             LDRB     R7,[R6, #+0]
   \   0000062C   0x2208             MOVS     R2,#+8
   \   0000062E   0x1DE1             ADDS     R1,R4,#+7
   \   00000630   0x.... 0x....      LDR.W    R0,??DataTable24_11
   \   00000634   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \   00000638   0x.... 0x....      BL       __aeabi_memcpy
    686                Par_Cnt++;
   \   0000063C   0x1C78             ADDS     R0,R7,#+1
   \   0000063E   0x7030             STRB     R0,[R6, #+0]
    687                Par_Time = 0;
   \   00000640   0x4628             MOV      R0,R5
   \   00000642   0x.... 0x....      LDR.W    R1,??DataTable24_12
   \   00000646   0x8008             STRH     R0,[R1, #+0]
   \   00000648   0xE01B             B.N      ??CAN_Decode_15
    688              }
    689              else if(Can_RxMsg.id == 0x145) {
   \                     ??CAN_Decode_33: (+1)
   \   0000064A   0xD11A             BNE.N    ??CAN_Decode_15
    690                memcpy((char *)&Par_Buf[32],&Can_RxMsg.data[0],8);
   \   0000064C   0x2208             MOVS     R2,#+8
   \   0000064E   0x1DE1             ADDS     R1,R4,#+7
   \   00000650   0x.... 0x....      LDR.W    R0,??DataTable24_13
   \   00000654   0x.... 0x....      BL       __aeabi_memcpy
    691                Par_Cnt++;
   \   00000658   0x.... 0x....      LDR.W    R6,??DataTable24_10
   \   0000065C   0x7837             LDRB     R7,[R6, #+0]
   \   0000065E   0x1C78             ADDS     R0,R7,#+1
   \   00000660   0x7030             STRB     R0,[R6, #+0]
    692                Par_Time = 0;
   \   00000662   0x4629             MOV      R1,R5
   \   00000664   0x.... 0x....      LDR.W    R2,??DataTable24_12
   \   00000668   0x8011             STRH     R1,[R2, #+0]
    693                if(Par_Cnt == 5 && Par_Flag) {
   \   0000066A   0xB2C0             UXTB     R0,R0
   \   0000066C   0x2805             CMP      R0,#+5
   \   0000066E   0xD108             BNE.N    ??CAN_Decode_15
   \   00000670   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   00000674   0x7801             LDRB     R1,[R0, #+0]
   \   00000676   0x000A             MOVS     R2,R1
   \   00000678   0xD003             BEQ.N    ??CAN_Decode_15
    694                  Par_Flag++;
   \   0000067A   0x1C49             ADDS     R1,R1,#+1
   \   0000067C   0x7001             STRB     R1,[R0, #+0]
    695                  Par_Cnt = 0;
   \   0000067E   0x4628             MOV      R0,R5
   \   00000680   0x7030             STRB     R0,[R6, #+0]
    696                }
    697              }  
    698            }
    699            /////////////////////////////////////////ID 0x160~0x1A9
    700            if(Can_RxMsg.id > 0x160 && Can_RxMsg.id < 0x1A9) {
   \                     ??CAN_Decode_15: (+1)
   \   00000682   0x6820             LDR      R0,[R4, #+0]
   \   00000684   0xF2A0 0x1161      SUBW     R1,R0,#+353
   \   00000688   0x2948             CMP      R1,#+72
   \   0000068A   0xD224             BCS.N    ??CAN_Decode_34
    701              map_x = (INT8U)(Can_RxMsg.id - 0x161);
   \   0000068C   0xF1A0 0x0761      SUB      R7,R0,#+97
   \   00000690   0xB2FF             UXTB     R7,R7
    702              memcpy( (char *)&ScrMap.AlpaMap.row[map_x].col[0], &Can_RxMsg.data[0], CANDATALEN);
   \   00000692   0x2208             MOVS     R2,#+8
   \   00000694   0x1DE1             ADDS     R1,R4,#+7
   \   00000696   0x.... 0x....      LDR.W    R0,??DataTable24_15
   \   0000069A   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \   0000069E   0x3060             ADDS     R0,R0,#+96
   \   000006A0   0x.... 0x....      BL       __aeabi_memcpy
    703          		SendCount = 0;
   \   000006A4   0x2500             MOVS     R5,#+0
    704              if(map_x == 71 && ServerRW) {
   \   000006A6   0x2F47             CMP      R7,#+71
   \   000006A8   0xD115             BNE.N    ??CAN_Decode_34
   \   000006AA   0x.... 0x....      LDR.W    R0,??DataTable24_16
   \   000006AE   0x7801             LDRB     R1,[R0, #+0]
   \   000006B0   0x000A             MOVS     R2,R1
   \   000006B2   0xD010             BEQ.N    ??CAN_Decode_34
    705                ServerRW++;
   \   000006B4   0x1C49             ADDS     R1,R1,#+1
   \   000006B6   0x7001             STRB     R1,[R0, #+0]
    706                buf[0] = 0x01;
   \   000006B8   0x2001             MOVS     R0,#+1
   \   000006BA   0xF88D 0x0010      STRB     R0,[SP, #+16]
    707              	SendCount = MakePackMassage(&msg, 0x1B0, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   000006BE   0x2008             MOVS     R0,#+8
   \   000006C0   0x9001             STR      R0,[SP, #+4]
   \   000006C2   0xA804             ADD      R0,SP,#+16
   \   000006C4   0x9000             STR      R0,[SP, #+0]
   \   000006C6   0x462B             MOV      R3,R5
   \   000006C8   0x461A             MOV      R2,R3
   \   000006CA   0xF44F 0x71D8      MOV      R1,#+432
   \   000006CE   0xA809             ADD      R0,SP,#+36
   \   000006D0   0x.... 0x....      BL       MakePackMassage
   \   000006D4   0x4605             MOV      R5,R0
    708              }
    709            }
    710            /////////////////////////////////////////ID 0x1B0~0x1B7
    711            if(Can_RxMsg.id > 0x1B0 && Can_RxMsg.id < 0x1B7) {
   \                     ??CAN_Decode_34: (+1)
   \   000006D6   0x6820             LDR      R0,[R4, #+0]
   \   000006D8   0xF2A0 0x11B1      SUBW     R1,R0,#+433
   \   000006DC   0x2906             CMP      R1,#+6
   \   000006DE   0xD20A             BCS.N    ??CAN_Decode_35
    712              map_x = (INT8U)(Can_RxMsg.id - 0x1B1);
    713              memcpy( (char *)&ScrMap.BaseTemp[map_x * 4], &Can_RxMsg.data[0], CANDATALEN);
   \   000006E0   0x2208             MOVS     R2,#+8
   \   000006E2   0x1DE1             ADDS     R1,R4,#+7
   \   000006E4   0x.... 0x....      LDR.W    R3,??DataTable24_15
   \   000006E8   0x304F             ADDS     R0,R0,#+79
   \   000006EA   0xB2C0             UXTB     R0,R0
   \   000006EC   0xEB03 0x00C0      ADD      R0,R3,R0, LSL #+3
   \   000006F0   0x.... 0x....      BL       __aeabi_memcpy
    714          //    if(map_x == 5 && ((ServerRW & 0x03) == 0x03)) ServerRW++;
    715          		SendCount = 0;
   \   000006F4   0x2500             MOVS     R5,#+0
    716            }
    717            /////////////////////////////////////////ID 0x1C0~0x1C7
    718            if(Can_RxMsg.id > 0x1C0 && Can_RxMsg.id < 0x1C7) {
   \                     ??CAN_Decode_35: (+1)
   \   000006F6   0x6820             LDR      R0,[R4, #+0]
   \   000006F8   0xF2A0 0x11C1      SUBW     R1,R0,#+449
   \   000006FC   0x2906             CMP      R1,#+6
   \   000006FE   0xD213             BCS.N    ??CAN_Decode_36
    719              map_x = (INT8U)(Can_RxMsg.id - 0x1C1);
   \   00000700   0xF100 0x073F      ADD      R7,R0,#+63
   \   00000704   0xB2FF             UXTB     R7,R7
    720              memcpy( (char *)&ScrMap.BaseMaf[map_x * 4], &Can_RxMsg.data[0], CANDATALEN);
   \   00000706   0x2208             MOVS     R2,#+8
   \   00000708   0x1DE1             ADDS     R1,R4,#+7
   \   0000070A   0x....             LDR.N    R0,??DataTable24_15
   \   0000070C   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \   00000710   0x3030             ADDS     R0,R0,#+48
   \   00000712   0x.... 0x....      BL       __aeabi_memcpy
    721              if(map_x == 5 && ServerRW) ServerRW++;
   \   00000716   0x2F05             CMP      R7,#+5
   \   00000718   0xD105             BNE.N    ??CAN_Decode_37
   \   0000071A   0x....             LDR.N    R0,??DataTable24_16
   \   0000071C   0x7801             LDRB     R1,[R0, #+0]
   \   0000071E   0x000A             MOVS     R2,R1
   \   00000720   0xD001             BEQ.N    ??CAN_Decode_37
   \   00000722   0x1C49             ADDS     R1,R1,#+1
   \   00000724   0x7001             STRB     R1,[R0, #+0]
    722          		SendCount = 0;
   \                     ??CAN_Decode_37: (+1)
   \   00000726   0x2500             MOVS     R5,#+0
    723            }
    724            /////////////////////////////////////////ID 0x140~0x147
    725            if(Can_RxMsg.id > 0x140 && Can_RxMsg.id < 0x147) {
   \                     ??CAN_Decode_36: (+1)
   \   00000728   0x6826             LDR      R6,[R4, #+0]
   \   0000072A   0xF2A6 0x1041      SUBW     R0,R6,#+321
   \   0000072E   0x2806             CMP      R0,#+6
   \   00000730   0xD213             BCS.N    ??CAN_Decode_38
    726              map_x = (INT8U)(Can_RxMsg.id - 0x141);
   \   00000732   0x4630             MOV      R0,R6
   \   00000734   0xF1A0 0x0741      SUB      R7,R0,#+65
   \   00000738   0xB2FF             UXTB     R7,R7
    727              memcpy( (char *)&SysCtl+(map_x*8), &Can_RxMsg.data[0], CANDATALEN);
   \   0000073A   0x2208             MOVS     R2,#+8
   \   0000073C   0x1DE1             ADDS     R1,R4,#+7
   \   0000073E   0x....             LDR.N    R0,??DataTable24_17
   \   00000740   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \   00000744   0x.... 0x....      BL       __aeabi_memcpy
    728              if(map_x == 5 && ServerRW) {
   \   00000748   0x2F05             CMP      R7,#+5
   \   0000074A   0xD105             BNE.N    ??CAN_Decode_39
   \   0000074C   0x....             LDR.N    R0,??DataTable24_16
   \   0000074E   0x7801             LDRB     R1,[R0, #+0]
   \   00000750   0x000A             MOVS     R2,R1
   \   00000752   0xD001             BEQ.N    ??CAN_Decode_39
    729                ServerRW++;
   \   00000754   0x1C49             ADDS     R1,R1,#+1
   \   00000756   0x7001             STRB     R1,[R0, #+0]
    730              }
    731          		SendCount = 0;
   \                     ??CAN_Decode_39: (+1)
   \   00000758   0x2500             MOVS     R5,#+0
    732            }
    733            /////////////////////////////////////////ID 0x200~
    734            if(Can_RxMsg.id >= 0x200) {
   \                     ??CAN_Decode_38: (+1)
   \   0000075A   0xF5B6 0x7F00      CMP      R6,#+512
   \   0000075E   0xD34B             BCC.N    ??CAN_Decode_40
    735              if(Can_RxMsg.id == 0x200) {
   \   00000760   0xD111             BNE.N    ??CAN_Decode_41
    736                memcpy(buf, &ModemInfo.LpIP, 6);
   \   00000762   0x2206             MOVS     R2,#+6
   \   00000764   0x....             LDR.N    R1,??DataTable24_18
   \   00000766   0xA804             ADD      R0,SP,#+16
   \   00000768   0x.... 0x....      BL       __aeabi_memcpy
    737                SendCount = MakePackMassage(&msg, 0x201, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   0000076C   0x2008             MOVS     R0,#+8
   \   0000076E   0x9001             STR      R0,[SP, #+4]
   \   00000770   0xA804             ADD      R0,SP,#+16
   \   00000772   0x9000             STR      R0,[SP, #+0]
   \   00000774   0x2300             MOVS     R3,#+0
   \   00000776   0x461A             MOV      R2,R3
   \   00000778   0xF240 0x2101      MOVW     R1,#+513
   \   0000077C   0xA809             ADD      R0,SP,#+36
   \   0000077E   0x.... 0x....      BL       MakePackMassage
   \   00000782   0x4605             MOV      R5,R0
   \   00000784   0xE038             B.N      ??CAN_Decode_40
    738              }
    739              else if(Can_RxMsg.id == 0x202) {
   \                     ??CAN_Decode_41: (+1)
   \   00000786   0xF240 0x2002      MOVW     R0,#+514
   \   0000078A   0x4286             CMP      R6,R0
   \   0000078C   0xD115             BNE.N    ??CAN_Decode_42
    740               memcpy((char *)&ModemInfo.LpIP, &Can_RxMsg.data[0], 4);
   \   0000078E   0x....             LDR.N    R6,??DataTable24_19
   \   00000790   0x2204             MOVS     R2,#+4
   \   00000792   0x1DE1             ADDS     R1,R4,#+7
   \   00000794   0xF106 0x0020      ADD      R0,R6,#+32
   \   00000798   0x.... 0x....      BL       __aeabi_memcpy
    741               memcpy((char *)&ModemInfo.LpPort, &Can_RxMsg.data[4], 2);
   \   0000079C   0x2202             MOVS     R2,#+2
   \   0000079E   0xF104 0x010B      ADD      R1,R4,#+11
   \   000007A2   0xF106 0x0024      ADD      R0,R6,#+36
   \   000007A6   0x.... 0x....      BL       __aeabi_memcpy
    742               addr = MODEM_INFO + (u8 *)&ModemInfo.LpIP - (u8 *)&ModemInfo;
    743               FRAMMultiWrite((u8 *)&ModemInfo.LpIP, addr, sizeof(ModemInfo.LpIP)+sizeof(ModemInfo.LpPort));
   \   000007AA   0x2206             MOVS     R2,#+6
   \   000007AC   0xF44F 0x7118      MOV      R1,#+608
   \   000007B0   0xF106 0x0020      ADD      R0,R6,#+32
   \   000007B4   0x.... 0x....      BL       FRAMMultiWrite
   \   000007B8   0xE01E             B.N      ??CAN_Decode_40
    744              }
    745              else if(Can_RxMsg.id == 0x703) { //DPF Crack Signal
   \                     ??CAN_Decode_42: (+1)
   \   000007BA   0xF240 0x7003      MOVW     R0,#+1795
   \   000007BE   0x4286             CMP      R6,R0
   \   000007C0   0xD103             BNE.N    ??CAN_Decode_43
    746                ReadValue.DPF_Crack = Can_RxMsg.data[0];
   \   000007C2   0x79E0             LDRB     R0,[R4, #+7]
   \   000007C4   0x....             LDR.N    R1,??DataTable24_20
   \   000007C6   0x8208             STRH     R0,[R1, #+16]
   \   000007C8   0xE016             B.N      ??CAN_Decode_40
    747              }
    748              else if(Can_RxMsg.id == 0x705) { //PM Sensor Error    
   \                     ??CAN_Decode_43: (+1)
   \   000007CA   0xF240 0x7005      MOVW     R0,#+1797
   \   000007CE   0x4286             CMP      R6,R0
   \   000007D0   0xD112             BNE.N    ??CAN_Decode_40
    749                memcpy((char *)&buf16b,&Can_RxMsg.data[0],2);
   \   000007D2   0x2202             MOVS     R2,#+2
   \   000007D4   0x1DE1             ADDS     R1,R4,#+7
   \   000007D6   0xA802             ADD      R0,SP,#+8
   \   000007D8   0x.... 0x....      BL       __aeabi_memcpy
    750                ReadValue.PM1_Error.K = buf16b;  
   \   000007DC   0x....             LDR.N    R6,??DataTable24_3
   \   000007DE   0x3668             ADDS     R6,R6,#+104
   \   000007E0   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000007E4   0x8270             STRH     R0,[R6, #+18]
    751                memcpy((char *)&buf16b,&Can_RxMsg.data[4],2);
   \   000007E6   0x2202             MOVS     R2,#+2
   \   000007E8   0xF104 0x010B      ADD      R1,R4,#+11
   \   000007EC   0xA802             ADD      R0,SP,#+8
   \   000007EE   0x.... 0x....      BL       __aeabi_memcpy
    752                ReadValue.PM2_Error.K = buf16b;
   \   000007F2   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000007F6   0x82B0             STRH     R0,[R6, #+20]
    753              }    
    754          //    else if(Can_RxMsg.id == 0x14FF0055) {           //PM 센서
    755          //      memcpy((char *)&buf16b, &Can_RxMsg.data[0], 2 );
    756          //      ReadValue.PM_Senser1 = buf16b;
    757          //      memcpy((char *)&buf16b, &Can_RxMsg.data[2], 2 );
    758          //      ReadValue.PM_Senser2 = buf16b;
    759          //      memcpy((char *)&buf16b, &Can_RxMsg.data[4], 2 );
    760          //      ReadValue.PM_Senser3 = buf16b;
    761          //      memcpy((char *)&buf16b, &Can_RxMsg.data[6], 2 );
    762          //      ReadValue.PM_Senser4 = buf16b;
    763          //    }  
    764            }
    765          	if (SendCount )
   \                     ??CAN_Decode_40: (+1)
   \   000007F8   0xB2AD             UXTH     R5,R5
   \   000007FA   0x2D00             CMP      R5,#+0
   \   000007FC   0xD002             BEQ.N    ??CAN_Decode_44
    766          		SendCanMassage(&msg);  
   \   000007FE   0xA809             ADD      R0,SP,#+36
   \   00000800   0x.... 0x....      BL       SendCanMassage
    767          }
   \                     ??CAN_Decode_44: (+1)
   \   00000804   0xB00F             ADD      SP,SP,#+60
   \   00000806   0xBDF0             POP      {R4-R7,PC}       ;; return
    768          
    769          /*
    770          ********************************************************************************
    771          * Description : Server_TxData_Loop
    772          * Arguments   : teCommand com, unsigned short idx, unsigned short cnt, unsigned int len, u8* data
    773          * Return      : 
    774          * Note        : CAN data process
    775          ******************************************************************************** 
    776          */

   \                                 In section .text, align 2, keep-with-next
    777          void Server_TxData_Loop(teCommand com, unsigned short idx, unsigned short cnt, unsigned int len, u8* data)
    778          {
   \                     Server_TxData_Loop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    779            Modem_TxData_Loop(com, idx, cnt, len, data);
   \   00000004   0x9C04             LDR      R4,[SP, #+16]
   \   00000006   0x9400             STR      R4,[SP, #+0]
   \   00000008   0x.... 0x....      BL       Modem_TxData_Loop
    780            ServerRW = 0x00;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable24_16
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    781          }
   \   00000012   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    782          
    783          /*
    784          ********************************************************************************
    785          * Description : Task_CAN
    786          * Arguments   : *p_arg
    787          * Return      : 
    788          * Note        : CAN task process
    789          ******************************************************************************** 
    790          */

   \                                 In section .text, align 2, keep-with-next
    791          void Task_CAN(void *p_arg)
    792          {
   \                     Task_CAN: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4604             MOV      R4,R0
    793            INT8U buf[8];
    794            INT16U CANid;
    795            INT32U Tmrtime = 500;
    796          	CanTxMsg msg;	
    797          	sysinfo_t *s = (sysinfo_t *)p_arg 	;
    798          
    799          	Init_CANcommRxProc(CAN1_PORT);
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       Init_CANcommRxProc
    800          	CanSemaphore_Init();
   \   0000000E   0x.... 0x....      BL       CanSemaphore_Init
    801            
    802          	Flags1.RegenOBD = 0;
    803          	Flags1.RegenOffOBD = 0;		
   \   00000012   0x....             LDR.N    R5,??DataTable24_21
   \   00000014   0x8828             LDRH     R0,[R5, #+0]
   \   00000016   0xF24E 0x71FF      MOVW     R1,#+59391
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x8028             STRH     R0,[R5, #+0]
   \   0000001E   0x....             LDR.N    R6,??DataTable24_16
   \   00000020   0xE029             B.N      ??Task_CAN_0
    804          	for(;;)
    805          	{
    806          		s->twatchCanFlag = 1;
    807          		if(TmrChk(TMR_CANTRAPINTERVAL) == 0) { // Slave로 GPS, 시간 전송 
    808                if(ServerRW) Tmrtime = 50;
    809                else Tmrtime = 500;
    810                
    811                if(ServerRW == 0x01 || ServerRW == 0x65) {      // DCU MAP Read
    812                  buf[0] = 0x01;
    813                  buf[1] = 0x00;
    814                  CANid = 0x160;
    815                  ServerRW++;
    816                }
    817                else if(ServerRW > 0x10 && ServerRW < 0x65) {   //DCU MAP Write:ServerRw+82
    818                  memcpy( (char *)&buf, (char *)&ScrMap+((ServerRW-0x11)*8), CANDATALEN);
    819                  if((ServerRW-0x11) < 6) {
    820                    CANid = 0x1B1+(ServerRW-0x11);
    821                  }
    822                  else if((ServerRW-0x17) < 6) {
    823                    CANid = 0x1C1+(ServerRW-0x17);
    824                  }
    825                  else if((ServerRW-0x1D) < 72) {
    826                    CANid = 0x161+(ServerRW-0x1D);
    827                  }
    828                  ServerRW++;
    829                }
    830                else if(ServerRW == 0xA1 || ServerRW == 0xB7) { // DCU Parameter Read
    831                  buf[0] = 0x01;
    832                  buf[1] = 0x00;
    833                  CANid = 0x140;
    834                  ServerRW++;
    835                }
    836                else if(ServerRW > 0xB0 && ServerRW < 0xB7) {   //DCU Parameter Write:ServerRw+6
    837                  Tmrtime = 100;
    838                  memcpy( (char *)&buf, (char *)&SysCtl+((ServerRW-0xB1)*8), CANDATALEN);
    839                  CANid = 0x141+(ServerRW-0xB1);
    840                  ServerRW++;
    841                }
    842                else if(ServerRW == 0x04) {
    843                    Server_TxData_Loop(CM_P1SD, 0, 1, sizeof(stScrMap), (u8*)&ScrMap);
    844                }
    845                else if(ServerRW == 0x68) {
    846                    Server_TxData_Loop(CM_P1SC, 0, 1, sizeof(stScrMap), (u8*)&ScrMap);
    847                }
    848                else if(ServerRW == 0xA3) {
    849                    Server_TxData_Loop(CM_P2SD, 0, 1, sizeof(stSysControl), (u8*)&SysCtl);
    850                }
    851                else if(ServerRW == 0xB9) {
    852                    Server_TxData_Loop(CM_P2SC, 0, 1, sizeof(stSysControl), (u8*)&SysCtl);
    853                }
    854                else {
    855                  buf[0] = ReadValue.Speed;
    856                  buf[1] = GPS_Valid;
    857                  buf[2] = s->tm_ptr.tm_year;
    858                  buf[3] = s->tm_ptr.tm_mon;
    859                  buf[4] = s->tm_ptr.tm_mday;
    860                  buf[5] = s->tm_ptr.tm_hour;
    861                  buf[6] = s->tm_ptr.tm_min;
    862                  buf[7] = s->tm_ptr.tm_sec;
    863                  CANid = 0x119;
    864                  if(Flags1.RegenOBD || Flags1.RegenOffOBD) {
    865                    if(Flags1.RegenOBD) buf[0] = 0x01;
    866                    else if(Flags1.RegenOffOBD) buf[0] = 0x00;
   \                     ??Task_CAN_1: (+1)
   \   00000022   0xF3C1 0x3200      UBFX     R2,R1,#+12,#+1
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD002             BEQ.N    ??Task_CAN_2
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0xF88D 0x2008      STRB     R2,[SP, #+8]
    867                    buf[1] = 0x00;
   \                     ??Task_CAN_2: (+1)
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x7042             STRB     R2,[R0, #+1]
    868                    CANid = 0x20;
   \   00000034   0xF04F 0x0920      MOV      R9,#+32
    869                    Flags1.RegenOBD = 0;
    870                    Flags1.RegenOffOBD = 0;
   \   00000038   0xF24E 0x70FF      MOVW     R0,#+59391
   \   0000003C   0x4008             ANDS     R0,R0,R1
   \   0000003E   0x8028             STRH     R0,[R5, #+0]
    871                  }
    872                }
    873                MakePackMassage(&msg, CANid, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \                     ??Task_CAN_3: (+1)
   \   00000040   0x2008             MOVS     R0,#+8
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0xA802             ADD      R0,SP,#+8
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0x461A             MOV      R2,R3
   \   0000004C   0xFA1F 0xF989      UXTH     R9,R9
   \   00000050   0x4649             MOV      R1,R9
   \   00000052   0xA804             ADD      R0,SP,#+16
   \   00000054   0x.... 0x....      BL       MakePackMassage
    874                SendCanMassage(&msg);
   \   00000058   0xA804             ADD      R0,SP,#+16
   \   0000005A   0x.... 0x....      BL       SendCanMassage
    875                TmrSetT(TMR_CANTRAPINTERVAL, Tmrtime);
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x2006             MOVS     R0,#+6
   \   00000062   0x.... 0x....      BL       TmrSetT
    876                TmrStart(TMR_CANTRAPINTERVAL);
   \   00000066   0x2006             MOVS     R0,#+6
   \   00000068   0x.... 0x....      BL       TmrStart
    877              }
    878              vTaskDelay(1);    
   \                     ??Task_CAN_4: (+1)
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x.... 0x....      BL       vTaskDelay
    879          		s->twatchCanFlag = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x71E0             STRB     R0,[R4, #+7]
   \                     ??Task_CAN_0: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x71E0             STRB     R0,[R4, #+7]
   \   0000007A   0x2006             MOVS     R0,#+6
   \   0000007C   0x.... 0x....      BL       TmrChk
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD1F3             BNE.N    ??Task_CAN_4
   \   00000084   0x7837             LDRB     R7,[R6, #+0]
   \   00000086   0x0038             MOVS     R0,R7
   \   00000088   0xD002             BEQ.N    ??Task_CAN_5
   \   0000008A   0xF04F 0x0832      MOV      R8,#+50
   \   0000008E   0xE001             B.N      ??Task_CAN_6
   \                     ??Task_CAN_5: (+1)
   \   00000090   0xF44F 0x78FA      MOV      R8,#+500
   \                     ??Task_CAN_6: (+1)
   \   00000094   0x46BA             MOV      R10,R7
   \   00000096   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000009A   0xD002             BEQ.N    ??Task_CAN_7
   \   0000009C   0xF1BA 0x0F65      CMP      R10,#+101
   \   000000A0   0xD10A             BNE.N    ??Task_CAN_8
   \                     ??Task_CAN_7: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   000000AE   0xF44F 0x79B0      MOV      R9,#+352
   \   000000B2   0x1C78             ADDS     R0,R7,#+1
   \   000000B4   0x7030             STRB     R0,[R6, #+0]
   \   000000B6   0xE7C3             B.N      ??Task_CAN_3
   \                     ??Task_CAN_8: (+1)
   \   000000B8   0xF1A0 0x0111      SUB      R1,R0,#+17
   \   000000BC   0x2954             CMP      R1,#+84
   \   000000BE   0xD21F             BCS.N    ??Task_CAN_9
   \   000000C0   0x2208             MOVS     R2,#+8
   \   000000C2   0x....             LDR.N    R0,??DataTable24_15
   \   000000C4   0xEB00 0x00CA      ADD      R0,R0,R10, LSL #+3
   \   000000C8   0xF1A0 0x0188      SUB      R1,R0,#+136
   \   000000CC   0xA802             ADD      R0,SP,#+8
   \   000000CE   0x.... 0x....      BL       __aeabi_memcpy
   \   000000D2   0xF1AA 0x0011      SUB      R0,R10,#+17
   \   000000D6   0x2806             CMP      R0,#+6
   \   000000D8   0xDA02             BGE.N    ??Task_CAN_10
   \   000000DA   0xF507 0x79D0      ADD      R9,R7,#+416
   \   000000DE   0xE00C             B.N      ??Task_CAN_11
   \                     ??Task_CAN_10: (+1)
   \   000000E0   0xF1AA 0x0017      SUB      R0,R10,#+23
   \   000000E4   0x2806             CMP      R0,#+6
   \   000000E6   0xDA02             BGE.N    ??Task_CAN_12
   \   000000E8   0xF507 0x79D5      ADD      R9,R7,#+426
   \   000000EC   0xE005             B.N      ??Task_CAN_11
   \                     ??Task_CAN_12: (+1)
   \   000000EE   0xF1AA 0x001D      SUB      R0,R10,#+29
   \   000000F2   0x2848             CMP      R0,#+72
   \   000000F4   0xDA01             BGE.N    ??Task_CAN_11
   \   000000F6   0xF507 0x79A2      ADD      R9,R7,#+324
   \                     ??Task_CAN_11: (+1)
   \   000000FA   0x1C78             ADDS     R0,R7,#+1
   \   000000FC   0x7030             STRB     R0,[R6, #+0]
   \   000000FE   0xE79F             B.N      ??Task_CAN_3
   \                     ??Task_CAN_9: (+1)
   \   00000100   0xF1BA 0x0FA1      CMP      R10,#+161
   \   00000104   0xD002             BEQ.N    ??Task_CAN_13
   \   00000106   0xF1BA 0x0FB7      CMP      R10,#+183
   \   0000010A   0xD10A             BNE.N    ??Task_CAN_14
   \                     ??Task_CAN_13: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   00000118   0xF44F 0x79A0      MOV      R9,#+320
   \   0000011C   0x1C78             ADDS     R0,R7,#+1
   \   0000011E   0x7030             STRB     R0,[R6, #+0]
   \   00000120   0xE78E             B.N      ??Task_CAN_3
   \                     ??Task_CAN_14: (+1)
   \   00000122   0x38B1             SUBS     R0,R0,#+177
   \   00000124   0x2806             CMP      R0,#+6
   \   00000126   0xD20F             BCS.N    ??Task_CAN_15
   \   00000128   0xF04F 0x0864      MOV      R8,#+100
   \   0000012C   0x2208             MOVS     R2,#+8
   \   0000012E   0x....             LDR.N    R0,??DataTable24_17
   \   00000130   0xEB00 0x00CA      ADD      R0,R0,R10, LSL #+3
   \   00000134   0xF5A0 0x61B1      SUB      R1,R0,#+1416
   \   00000138   0xA802             ADD      R0,SP,#+8
   \   0000013A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000013E   0xF107 0x0990      ADD      R9,R7,#+144
   \   00000142   0x1C78             ADDS     R0,R7,#+1
   \   00000144   0x7030             STRB     R0,[R6, #+0]
   \   00000146   0xE77B             B.N      ??Task_CAN_3
   \                     ??Task_CAN_15: (+1)
   \   00000148   0xF1BA 0x0F04      CMP      R10,#+4
   \   0000014C   0xD109             BNE.N    ??Task_CAN_16
   \   0000014E   0x....             LDR.N    R0,??DataTable24_15
   \   00000150   0x9000             STR      R0,[SP, #+0]
   \   00000152   0xF44F 0x7328      MOV      R3,#+672
   \   00000156   0x2201             MOVS     R2,#+1
   \   00000158   0x2100             MOVS     R1,#+0
   \   0000015A   0x....             LDR.N    R0,??DataTable24_22  ;; 0x50315344
   \   0000015C   0x.... 0x....      BL       Server_TxData_Loop
   \   00000160   0xE76E             B.N      ??Task_CAN_3
   \                     ??Task_CAN_16: (+1)
   \   00000162   0xF1BA 0x0F68      CMP      R10,#+104
   \   00000166   0xD109             BNE.N    ??Task_CAN_17
   \   00000168   0x....             LDR.N    R0,??DataTable24_15
   \   0000016A   0x9000             STR      R0,[SP, #+0]
   \   0000016C   0xF44F 0x7328      MOV      R3,#+672
   \   00000170   0x2201             MOVS     R2,#+1
   \   00000172   0x2100             MOVS     R1,#+0
   \   00000174   0x....             LDR.N    R0,??DataTable24_23  ;; 0x50315343
   \   00000176   0x.... 0x....      BL       Server_TxData_Loop
   \   0000017A   0xE761             B.N      ??Task_CAN_3
   \                     ??Task_CAN_17: (+1)
   \   0000017C   0xF1BA 0x0FA3      CMP      R10,#+163
   \   00000180   0xD108             BNE.N    ??Task_CAN_18
   \   00000182   0x....             LDR.N    R0,??DataTable24_17
   \   00000184   0x9000             STR      R0,[SP, #+0]
   \   00000186   0x2330             MOVS     R3,#+48
   \   00000188   0x2201             MOVS     R2,#+1
   \   0000018A   0x2100             MOVS     R1,#+0
   \   0000018C   0x....             LDR.N    R0,??DataTable24_24  ;; 0x50325344
   \   0000018E   0x.... 0x....      BL       Server_TxData_Loop
   \   00000192   0xE755             B.N      ??Task_CAN_3
   \                     ??Task_CAN_18: (+1)
   \   00000194   0xF1BA 0x0FB9      CMP      R10,#+185
   \   00000198   0xD108             BNE.N    ??Task_CAN_19
   \   0000019A   0x....             LDR.N    R0,??DataTable24_17
   \   0000019C   0x9000             STR      R0,[SP, #+0]
   \   0000019E   0x2330             MOVS     R3,#+48
   \   000001A0   0x2201             MOVS     R2,#+1
   \   000001A2   0x2100             MOVS     R1,#+0
   \   000001A4   0x....             LDR.N    R0,??DataTable24_25  ;; 0x50325343
   \   000001A6   0x.... 0x....      BL       Server_TxData_Loop
   \   000001AA   0xE749             B.N      ??Task_CAN_3
   \                     ??Task_CAN_19: (+1)
   \   000001AC   0x....             LDR.N    R0,??DataTable24_3
   \   000001AE   0x7B00             LDRB     R0,[R0, #+12]
   \   000001B0   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000001B4   0xA802             ADD      R0,SP,#+8
   \   000001B6   0x....             LDR.N    R1,??DataTable24_26
   \   000001B8   0x7809             LDRB     R1,[R1, #+0]
   \   000001BA   0x7041             STRB     R1,[R0, #+1]
   \   000001BC   0x6B21             LDR      R1,[R4, #+48]
   \   000001BE   0x7081             STRB     R1,[R0, #+2]
   \   000001C0   0x6AE1             LDR      R1,[R4, #+44]
   \   000001C2   0x70C1             STRB     R1,[R0, #+3]
   \   000001C4   0x6AA1             LDR      R1,[R4, #+40]
   \   000001C6   0x7101             STRB     R1,[R0, #+4]
   \   000001C8   0x6A61             LDR      R1,[R4, #+36]
   \   000001CA   0xF88D 0x100D      STRB     R1,[SP, #+13]
   \   000001CE   0x6A21             LDR      R1,[R4, #+32]
   \   000001D0   0x7181             STRB     R1,[R0, #+6]
   \   000001D2   0x69E1             LDR      R1,[R4, #+28]
   \   000001D4   0x71C1             STRB     R1,[R0, #+7]
   \   000001D6   0xF240 0x1919      MOVW     R9,#+281
   \   000001DA   0x8829             LDRH     R1,[R5, #+0]
   \   000001DC   0xF44F 0x52C0      MOV      R2,#+6144
   \   000001E0   0x4211             TST      R1,R2
   \   000001E2   0xF43F 0xAF2D      BEQ.W    ??Task_CAN_3
   \   000001E6   0xF3C1 0x22C0      UBFX     R2,R1,#+11,#+1
   \   000001EA   0x2A00             CMP      R2,#+0
   \   000001EC   0xF43F 0xAF19      BEQ.W    ??Task_CAN_1
   \   000001F0   0x2201             MOVS     R2,#+1
   \   000001F2   0xF88D 0x2008      STRB     R2,[SP, #+8]
   \   000001F6   0xE71B             B.N      ??Task_CAN_2
    880          	}
    881          }
    882          
    883          
    884          /*
    885          ********************************************************************************
    886          * Description : obd_debug
    887          * Arguments   : *none
    888          * Return      : 
    889          * Note        : Nox Sensor On
    890          ******************************************************************************** 
    891          */

   \                                 In section .text, align 2, keep-with-next
    892          INT16U dbg_ob_debug_test(void)
    893          {
    894          	if ( obd_debug )
   \                     dbg_ob_debug_test: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24_27
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x1E49             SUBS     R1,R1,#+1
   \   00000006   0x4189             SBCS     R1,R1,R1
   \   00000008   0x0FC9             LSRS     R1,R1,#+31
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    895          		obd_debug = 0;
    896          	else
    897          		obd_debug = 1;
    898          
    899          	return NO_DISPLAY;
   \   0000000C   0x20C9             MOVS     R0,#+201
   \   0000000E   0x4770             BX       LR               ;; return
    900          }
    901          
    902          /*
    903          ********************************************************************************
    904          * Description : Send SaveFlag to SlaveOBD 
    905          * Arguments   : *none
    906          * Return      : 
    907          * Note        : 1 Second Proccess 
    908          ******************************************************************************** 
    909          */

   \                                 In section .text, align 2, keep-with-next
    910          void SendSaveFlag(void)
    911          {
   \                     SendSaveFlag: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    912            INT8U buf[8];
    913          	CanTxMsg msg;	
    914           
    915             buf[0] = 1;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0008      STRB     R0,[SP, #+8]
    916             MakePackMassage(&msg, 0x126, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x461A             MOV      R2,R3
   \   00000016   0xF44F 0x7193      MOV      R1,#+294
   \   0000001A   0xA804             ADD      R0,SP,#+16
   \   0000001C   0x.... 0x....      BL       MakePackMassage
    917             SendCanMassage(&msg);	
   \   00000020   0xA804             ADD      R0,SP,#+16
   \   00000022   0x.... 0x....      BL       SendCanMassage
    918          }
   \   00000026   0xB009             ADD      SP,SP,#+36
   \   00000028   0xBD00             POP      {PC}             ;; return
    919          
    920          /*
    921          ********************************************************************************
    922          * Description : Send Reset Signal to Device 
    923          * Arguments   : *none
    924          * Return      : 
    925          * Note        : Press Reset Button 
    926          ******************************************************************************** 
    927          */

   \                                 In section .text, align 2, keep-with-next
    928          void SendResetFlag(void)
    929          {
   \                     SendResetFlag: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    930            INT8U buf[8];
    931          	CanTxMsg msg;	
    932           
    933             buf[0] = 1;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0008      STRB     R0,[SP, #+8]
    934             MakePackMassage(&msg, 0x704, CAN_STAN, CAN_RTR_DATA, buf, CANDATALEN);
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x461A             MOV      R2,R3
   \   00000016   0xF240 0x7104      MOVW     R1,#+1796
   \   0000001A   0xA804             ADD      R0,SP,#+16
   \   0000001C   0x.... 0x....      BL       MakePackMassage
    935             SendCanMassage(&msg);	
   \   00000020   0xA804             ADD      R0,SP,#+16
   \   00000022   0x.... 0x....      BL       SendCanMassage
    936          }
   \   00000026   0xB009             ADD      SP,SP,#+36
   \   00000028   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x53 0x43          DC8 "SCRPro.bin"
   \              0x52 0x50    
   \              0x72 0x6F    
   \              0x2E 0x62    
   \              0x69 0x6E    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     BSP_CanSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     dlMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     fp1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     SendPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     nDlStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     TotalPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x66 0x69          DC8 "file size = %01lu\012"
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x20    
   \              0x3D 0x20    
   \              0x25 0x30    
   \              0x31 0x6C    
   \              0x75 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x54 0x6F          DC8 "TotalPacket= %01lu\012"
   \              0x74 0x61    
   \              0x6C 0x50    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x3D    
   \              0x20 0x25    
   \              0x30 0x31    
   \              0x6C 0x75    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x5B 0x25          DC8 "[%02X][%02X][%02X][%02X][%02X][%02X][%02X][%02X]\012"
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x5B 0x25    
   \              0x30 0x32    
   \              0x58 0x5D    
   \              0x0A 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x43 0x52          DC8 "CRC Code = [%04X]\012"
   \              0x43 0x20    
   \              0x43 0x6F    
   \              0x64 0x65    
   \              0x20 0x3D    
   \              0x20 0x5B    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x5D 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x64 0x6F          DC8 "download end.....\012"
   \              0x77 0x6E    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x65    
   \              0x6E 0x64    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     Setting+0xBF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     Can_RxMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     nDlStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x........         DC32     Setting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     ReadValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     ScrValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x........         DC32     NoxO2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x........         DC32     NoxFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     NoxErr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x........         DC32     NoxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     ReadValue+0x5E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     Par_Cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x........         DC32     Par_Buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x........         DC32     Par_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x........         DC32     Par_Buf+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x........         DC32     Par_Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x........         DC32     ScrMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \   00000000   0x........         DC32     ServerRW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \   00000000   0x........         DC32     SysCtl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \   00000000   0x........         DC32     ModemInfo+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \   00000000   0x........         DC32     ModemInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_20:
   \   00000000   0x........         DC32     ReadValue+0x68

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_21:
   \   00000000   0x........         DC32     Flags1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_22:
   \   00000000   0x50315344         DC32     0x50315344

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_23:
   \   00000000   0x50315343         DC32     0x50315343

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_24:
   \   00000000   0x50325344         DC32     0x50325344

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_25:
   \   00000000   0x50325343         DC32     0x50325343

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_26:
   \   00000000   0x........         DC32     GPS_Valid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_27:
   \   00000000   0x........         DC32     obd_debug

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x44 0x4C          DC8 "DL Packet Count Ok....\012"
   \              0x20 0x50    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x20    
   \              0x4F 0x6B    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x44 0x4C          DC8 "DL Packet Count Error....\012"
   \              0x20 0x50    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x20    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x20    
   \              0x45 0x72    
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x44 0x4C          DC8 "DL CRC Response Ok....\012"
   \              0x20 0x43    
   \              0x52 0x43    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x4F 0x6B    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x44 0x4C          DC8 "DL CRC Error....\012"
   \              0x20 0x43    
   \              0x52 0x43    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x44 0x4C          DC8 "DL soucess Ok....\012"
   \              0x20 0x73    
   \              0x6F 0x75    
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x20 0x4F    
   \              0x6B 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x44 0x4C          DC8 "DL soucess Error....\012"
   \              0x20 0x73    
   \              0x6F 0x75    
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x20 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      80   CAN_Decode
        80   -> FRAMMultiWrite
        80   -> MakePackMassage
        80   -> ResponseTime
        80   -> SendCanMassage
        80   -> TimeParsorSet
        80   -> __aeabi_memcpy
        80   -> printk
     328   CanFotaFile
       328   -> GenerateCRC
       328   -> MakePackMassage
       328   -> SPI_FLASH_BufferRead
       328   -> SendCanMassage
       328   -> __aeabi_memcpy
       328   -> __aeabi_memset4
       328   -> printk
       8   CanSemaphore_Init
         8   -> xQueueCreateMutex
         8   -> xQueueGenericCreate
         0   -> xQueueGenericSend
     336   CanTxFile
       336   -> GenerateCRC
       336   -> MakePackMassage
       336   -> SendCanMassage
       336   -> __aeabi_memcpy
       336   -> __aeabi_memset4
       336   -> f_close
       336   -> f_lseek
       336   -> f_open
       336   -> f_read
       336   -> printk
      16   GUI_hexdisp
         0   -> printk
        16   -> printk
       8   Init_CANcommRxProc
         8   -> CommReInit
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
       8   MakePackMassage
      16   SendCanMassage
        16   -> CAN_Transmit
        16   -> printk
        16   -> xQueueGenericReceive
        16   -> xQueueGenericSend
      40   SendResetFlag
        40   -> MakePackMassage
        40   -> SendCanMassage
      40   SendSaveFlag
        40   -> MakePackMassage
        40   -> SendCanMassage
      16   Server_TxData_Loop
        16   -> Modem_TxData_Loop
      72   Task_CAN
        72   -> CanSemaphore_Init
        72   -> Init_CANcommRxProc
        72   -> MakePackMassage
        72   -> SendCanMassage
        72   -> Server_TxData_Loop
        72   -> TmrChk
        72   -> TmrSetT
        72   -> TmrStart
        72   -> __aeabi_memcpy
        72   -> vTaskDelay
       0   dbg_ob_debug_test


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_25
       4  ??DataTable24_26
       4  ??DataTable24_27
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       2  ?_0
       8  ?_1
      28  ?_10
      24  ?_11
      20  ?_12
      20  ?_13
      24  ?_14
       8  ?_2
      12  ?_3
      20  ?_4
      20  ?_5
      52  ?_6
      20  ?_7
      20  ?_8
      24  ?_9
    2056  CAN_Decode
     692  CanFotaFile
      46  CanSemaphore_Init
     776  CanTxFile
      58  GUI_hexdisp
      22  Init_CANcommRxProc
      44  MakePackMassage
      74  SendCanMassage
      42  SendResetFlag
      42  SendSaveFlag
      20  Server_TxData_Loop
     504  Task_CAN
      16  dbg_ob_debug_test
      12  dlMode
          nStatus
          CheckResponseCount
          nStatus
          CheckResponseCount
          ramCRC
          FileSize
       4  obd_debug
      16  -- Other

 
    16 bytes in section .bss
     2 bytes in section .rodata
 4 860 bytes in section .text
 
 4 860 bytes of CODE  memory
     2 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
