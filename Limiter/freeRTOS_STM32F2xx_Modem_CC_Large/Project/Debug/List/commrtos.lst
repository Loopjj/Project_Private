###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Drv\commrtos.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Drv\commrtos.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\commrtos.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\commrtos.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Drv\commrtos.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2014 Loop *************************************
      3          *
      4          * File Name          : commrtos.c
      5          *
      6          * Author             : Digital Development Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 07/05/2014
     11          *
     12          * Description        : command background rtos configuration
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                             INCLUDE FILES
     20          *********************************************************************************************************
     21          */
     22          
     23          
     24          #define COMMRTOS_GLOBALS
     25          #include "includes.h"
     26          
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                           LOCAL CONSTANTS
     31          *********************************************************************************************************
     32          */
     33          
     34          #define TX_STAT_BUSY	1
     35          #define TX_STAT_IDLE	0
     36          
     37          #define comBLOCK_TIME_WAITING_FOR_INPUT	( ( portTickType ) 100 )
     38          			
     39          typedef xSemaphoreHandle	Com_Sem;
     40          /*
     41          *********************************************************************************************************
     42          *                                          LOCAL DATA TYPES
     43          *********************************************************************************************************
     44          */
     45          
     46          #ifdef PACK_STRUCT_USE_INCLUDES
     47          #  include "arch/bpstruct.h"
     48          #endif
     49          typedef struct {
     50          	INT16U	 RingBufRxCtr;					/* Rx 링 버퍼에 저장된 데이터 수					*/
     51          	Com_Sem  RingBufRxSem;					/* 수신 세마포어의 포인터							*/
     52          	INT8U	 *RingBufRxInPtr;				/* 다음 데이터를 저장할 곳을 가리키는 포인터		*/
     53          	INT8U	 *RingBufRxOutPtr;				/* 다음에 읽어갈 데이터를 가리키는 포인터			*/
     54          	INT8U	 RingBufRx[COMM_RX_BUF_SIZE]; 	/* 수신용 링 버퍼 저장영역(Rx)						*/
     55          
     56          	INT16U	 RingBufTxCtr;					/* Tx 링 버퍼에 저장된 데이터 수					*/
     57          	Com_Sem  RingBufTxSem;					/* 송신 세마포어의 포인터							*/
     58          	INT8U	 *RingBufTxInPtr;				/* 다음 데이터를 저장할 곳을 가리키는 포인터		*/
     59          	INT8U	 *RingBufTxOutPtr;			 	/* 다음에 읽어갈 데이터를 가리키는 포인터			*/
     60          	INT8U	 RingBufTx[COMM_TX_BUF_SIZE];	/* 송신용 링 버퍼 저장영역(Tx)						*/
     61          
     62          } COMM_RING_BUF;
     63          #ifdef PACK_STRUCT_USE_INCLUDES
     64          #  include "arch/epstruct.h"
     65          #endif
     66          
     67          
     68          /*
     69          *********************************************************************************************************
     70          *											 GLOBAL VARIABLE
     71          *********************************************************************************************************
     72          */
     73          
     74          INT8U		 tx_stat[MAXCOMM_CH] = {0};
     75          

   \                                 In section .bss, align 4
     76          COMM_RING_BUF CommBuf[MAXCOMM_CH];
   \                     CommBuf:
   \   00000000                      DS8 2740

   \                                 In section .data, align 4
   \                     tx_stat:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     77          
     78          USART_TypeDef *pUART_BASE[2] = {USART1,USART2};
   \                     pUART_BASE:
   \   00000008   0x40011000         DC32 40011000H, 40004400H
   \              0x40004400   
     79          
     80          
     81          /*
     82          *********************************************************************************************************
     83          *                                              FUNCTIONS
     84          *********************************************************************************************************
     85          */
     86          
     87          

   \                                 In section .text, align 2, keep-with-next
     88          INT16U Comm_GetTxBufCnt(INT8U ch)
     89          {
     90          	COMM_RING_BUF *pbuf;
     91          
     92          	pbuf = &CommBuf[ch];
     93          
     94          	return pbuf->RingBufTxCtr;
   \                     Comm_GetTxBufCnt: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000004   0xF44F 0x7209      MOV      R2,#+548
   \   00000008   0x4350             MULS     R0,R2,R0
   \   0000000A   0x4408             ADD      R0,R1,R0
   \   0000000C   0xF8B0 0x0210      LDRH     R0,[R0, #+528]
   \   00000010   0x4770             BX       LR               ;; return
     95          }
     96          
     97          

   \                                 In section .text, align 2, keep-with-next
     98          INT16U Comm_GetRxBufCnt(INT8U ch)
     99          {
    100          	COMM_RING_BUF *pbuf;
    101          
    102          	pbuf = &CommBuf[ch];
    103          
    104          	return pbuf->RingBufRxCtr;
   \                     Comm_GetRxBufCnt: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000004   0xF44F 0x7209      MOV      R2,#+548
   \   00000008   0x4350             MULS     R0,R2,R0
   \   0000000A   0x5A08             LDRH     R0,[R1, R0]
   \   0000000C   0x4770             BX       LR               ;; return
    105          }

   \                                 In section .text, align 2, keep-with-next
    106          INT8U Comm_balanceCheck(INT8U ch)
    107          {
    108          	INT8U ret;
    109          
    110          	COMM_RING_BUF *pbuf;
    111          
    112          	pbuf = &CommBuf[ch];
    113          
    114          	if(	pbuf->RingBufRxInPtr > pbuf->RingBufRxOutPtr)
   \                     Comm_balanceCheck: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000004   0xF44F 0x7209      MOV      R2,#+548
   \   00000008   0x4350             MULS     R0,R2,R0
   \   0000000A   0x4408             ADD      R0,R1,R0
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x4281             CMP      R1,R0
   \   00000012   0xD201             BCS.N    ??Comm_balanceCheck_0
    115          	{
    116          		ret = COMM_RX_UNBALANCE;
   \   00000014   0x2007             MOVS     R0,#+7
   \   00000016   0x4770             BX       LR
    117          	}
    118          	else
    119          		ret = COMM_NO_ERR;
   \                     ??Comm_balanceCheck_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
    120          	return ret;
   \   0000001A   0x4770             BX       LR               ;; return
    121          }
    122          
    123          
    124          

   \                                 In section .text, align 2, keep-with-next
    125          void Comm_Tx_Stat(INT8U ch, INT8U data)
    126          {
   \                     Comm_Tx_Stat: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    127          
    128          
    129          	portENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
    130          	tx_stat[ch] = data;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000000E   0x5505             STRB     R5,[R0, R4]
    131          	portEXIT_CRITICAL();
   \   00000010   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000014   0x.... 0x....      B.W      vPortExitCritical
    132          }
    133          
    134          

   \                                 In section .text, align 2, keep-with-next
    135          void __sub_Uart_RxInt(INT8U ch)
    136          {
   \                     __sub_Uart_RxInt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    137          	INT8U c;
    138          	
    139          	c = (INT8U)USART_ReceiveData(pUART_BASE[ch]);
   \   00000004   0x....             LDR.N    R0,??DataTable19_1
   \   00000006   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x.... 0x....      BL       USART_ReceiveData
    140          	CommPutRxChar(ch, c);
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x....             B.N      CommPutRxChar
    141          }
    142          

   \                                 In section .text, align 2, keep-with-next
    143          void __sub_Can_RxInt(INT8U ch, INT8U data)
    144          {
    145          	CommPutRxChar(ch, data);
   \                     __sub_Can_RxInt: (+1)
   \   00000000   0x....             B.N      CommPutRxChar
    146          }
    147          

   \                                 In section .text, align 2, keep-with-next
    148          void __sub_Uart_TxInt(INT8U ch)
    149          {
   \                     __sub_Uart_TxInt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    150          	INT8U c, err;
    151          
    152          	c = CommGetTxChar(ch, &err);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       CommGetTxChar
    153          	if(err != COMM_TX_EMPTY)
   \   0000000C   0x....             LDR.N    R2,??DataTable19_1
   \   0000000E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD006             BEQ.N    ??__sub_Uart_TxInt_0
    154          		USART_SendData(pUART_BASE[ch],c);	
   \   00000016   0x4601             MOV      R1,R0
   \   00000018   0xEB02 0x0084      ADD      R0,R2,R4, LSL #+2
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x.... 0x....      BL       USART_SendData
   \   00000022   0xBD13             POP      {R0,R1,R4,PC}
    155          	else{
    156          		tx_stat[ch] = TX_STAT_IDLE;
   \                     ??__sub_Uart_TxInt_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x5510             STRB     R0,[R2, R4]
    157          	}
    158          }
   \   00000028   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    159          
    160          

   \                                 In section .text, align 2, keep-with-next
    161          void CommInit(void)
    162          {
   \                     CommInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    163          	INT32U nCount;
    164          	COMM_RING_BUF *pbuf;
    165          
    166          	for(nCount=0;nCount<MAXCOMM_CH;nCount++)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE037             B.N      ??CommInit_0
    167          	{
    168          		pbuf = &CommBuf[nCount];
    169          		
    170          		pbuf->RingBufRxCtr = 0;
   \                     ??CommInit_1: (+1)
   \   00000006   0xF44F 0x7009      MOV      R0,#+548
   \   0000000A   0x4360             MULS     R0,R0,R4
   \   0000000C   0x....             LDR.N    R1,??DataTable19
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x520A             STRH     R2,[R1, R0]
    171          		pbuf->RingBufRxInPtr = &pbuf->RingBufRx[0];
   \   00000012   0x180D             ADDS     R5,R1,R0
   \   00000014   0x1D2E             ADDS     R6,R5,#+4
   \   00000016   0xF105 0x0010      ADD      R0,R5,#+16
   \   0000001A   0x6070             STR      R0,[R6, #+4]
    172          		pbuf->RingBufRxOutPtr = &pbuf->RingBufRx[0];
   \   0000001C   0x60B0             STR      R0,[R6, #+8]
    173          		pbuf->RingBufRxSem = NULL;
   \   0000001E   0x4610             MOV      R0,R2
   \   00000020   0x6030             STR      R0,[R6, #+0]
    174          		vSemaphoreCreateBinary(pbuf->RingBufRxSem);
   \   00000022   0x2203             MOVS     R2,#+3
   \   00000024   0x4601             MOV      R1,R0
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       xQueueGenericCreate
   \   0000002C   0x6030             STR      R0,[R6, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD004             BEQ.N    ??CommInit_2
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x461A             MOV      R2,R3
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x.... 0x....      BL       xQueueGenericSend
    175          
    176          		pbuf->RingBufTxCtr = 0;
   \                     ??CommInit_2: (+1)
   \   0000003C   0xF44F 0x7004      MOV      R0,#+528
   \   00000040   0x182E             ADDS     R6,R5,R0
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x8030             STRH     R0,[R6, #+0]
    177          		pbuf->RingBufTxInPtr = &pbuf->RingBufTx[0];
   \   00000046   0xF44F 0x7008      MOV      R0,#+544
   \   0000004A   0x4428             ADD      R0,R5,R0
   \   0000004C   0x60B0             STR      R0,[R6, #+8]
    178          		pbuf->RingBufTxOutPtr = &pbuf->RingBufTx[0];
   \   0000004E   0x60F0             STR      R0,[R6, #+12]
    179          		pbuf->RingBufTxSem = NULL;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6070             STR      R0,[R6, #+4]
    180          		vSemaphoreCreateBinary(pbuf->RingBufTxSem);
   \   00000054   0x2203             MOVS     R2,#+3
   \   00000056   0x4601             MOV      R1,R0
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       xQueueGenericCreate
   \   0000005E   0x6070             STR      R0,[R6, #+4]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD004             BEQ.N    ??CommInit_3
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x461A             MOV      R2,R3
   \   00000068   0x4611             MOV      R1,R2
   \   0000006A   0x.... 0x....      BL       xQueueGenericSend
    181          
    182          		tx_stat[nCount] = TX_STAT_IDLE;	
   \                     ??CommInit_3: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x....             LDR.N    R1,??DataTable19_1
   \   00000072   0x5508             STRB     R0,[R1, R4]
    183          	}
   \   00000074   0x1C64             ADDS     R4,R4,#+1
   \                     ??CommInit_0: (+1)
   \   00000076   0x2C05             CMP      R4,#+5
   \   00000078   0xD3C5             BCC.N    ??CommInit_1
    184          	//vSemaphoreCreateBinary(USB_TxSem);
    185          }
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    186          
    187          

   \                                 In section .text, align 2, keep-with-next
    188          void CommReInit(int num)
    189          {
   \                     CommReInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    190          
    191          	COMM_RING_BUF *pbuf;
    192          	//INT8U err;
    193          
    194          	pbuf = &CommBuf[num];
    195          
    196          	portENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    197          
    198          	pbuf->RingBufRxCtr    = 0;
   \   00000008   0xF44F 0x7009      MOV      R0,#+548
   \   0000000C   0x4360             MULS     R0,R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable19
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x520A             STRH     R2,[R1, R0]
    199          	pbuf->RingBufRxInPtr  = &pbuf->RingBufRx[0];
   \   00000014   0x4408             ADD      R0,R1,R0
   \   00000016   0xF100 0x0108      ADD      R1,R0,#+8
   \   0000001A   0xF100 0x0210      ADD      R2,R0,#+16
   \   0000001E   0x600A             STR      R2,[R1, #+0]
    200          	pbuf->RingBufRxOutPtr = &pbuf->RingBufRx[0];
   \   00000020   0x604A             STR      R2,[R1, #+4]
    201          
    202          	pbuf->RingBufTxCtr    = 0;
   \   00000022   0xF44F 0x7104      MOV      R1,#+528
   \   00000026   0x4401             ADD      R1,R0,R1
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x800A             STRH     R2,[R1, #+0]
    203          	pbuf->RingBufTxInPtr  = &pbuf->RingBufTx[0];
   \   0000002C   0xF44F 0x7208      MOV      R2,#+544
   \   00000030   0x4410             ADD      R0,R0,R2
   \   00000032   0x6088             STR      R0,[R1, #+8]
    204          	pbuf->RingBufTxOutPtr = &pbuf->RingBufTx[0];
   \   00000034   0x60C8             STR      R0,[R1, #+12]
    205          
    206          	tx_stat[num] = TX_STAT_IDLE;				
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x....             LDR.N    R1,??DataTable19_1
   \   0000003A   0x5508             STRB     R0,[R1, R4]
    207          
    208          	portEXIT_CRITICAL();
   \   0000003C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000040   0x.... 0x....      B.W      vPortExitCritical
    209          }
    210          
    211          

   \                                 In section .text, align 2, keep-with-next
    212          BOOLEAN CommIsEmpty(INT8U ch)
    213          {
   \                     CommIsEmpty: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    214          
    215          	BOOLEAN	empty;
    216          	COMM_RING_BUF *pbuf;
    217          
    218          	pbuf = &CommBuf[ch];
    219          
    220          	portENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    221          	if (pbuf->RingBufRxCtr > 0) {						 
   \   00000008   0x....             LDR.N    R0,??DataTable19
   \   0000000A   0xF44F 0x7109      MOV      R1,#+548
   \   0000000E   0x4361             MULS     R1,R1,R4
   \   00000010   0x5A40             LDRH     R0,[R0, R1]
   \   00000012   0x1E44             SUBS     R4,R0,#+1
   \   00000014   0x41A4             SBCS     R4,R4,R4
   \   00000016   0x0FE4             LSRS     R4,R4,#+31
    222          		empty = FALSE;									 
    223          	} else {
    224          		empty = TRUE;									 
    225          	}
    226          	portEXIT_CRITICAL();
   \   00000018   0x.... 0x....      BL       vPortExitCritical
    227          	return (empty);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    228          }
    229          
    230          

   \                                 In section .text, align 2, keep-with-next
    231          BOOLEAN CommIsFull(INT8U ch)
    232          {
   \                     CommIsFull: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    233          
    234          
    235          	BOOLEAN	full;
    236          	COMM_RING_BUF *pbuf;
    237          
    238          	pbuf = &CommBuf[ch];
    239          
    240          	portENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    241          	if (pbuf->RingBufTxCtr < COMM_TX_BUF_SIZE) {
   \   00000008   0x....             LDR.N    R0,??DataTable19
   \   0000000A   0xF44F 0x7109      MOV      R1,#+548
   \   0000000E   0x4361             MULS     R1,R1,R4
   \   00000010   0x4408             ADD      R0,R0,R1
   \   00000012   0xF8B0 0x0210      LDRH     R0,[R0, #+528]
   \   00000016   0x1E44             SUBS     R4,R0,#+1
   \   00000018   0x41A4             SBCS     R4,R4,R4
   \   0000001A   0x43E4             MVNS     R4,R4
   \   0000001C   0x0FE4             LSRS     R4,R4,#+31
    242          		full = FALSE;									  
    243          	} else {
    244          		full = TRUE;									
    245          	}
    246          	portEXIT_CRITICAL();
   \   0000001E   0x.... 0x....      BL       vPortExitCritical
    247          	return (full);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    248          }
    249          
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void CommPutRxChar(INT8U ch, INT8U c)
    252          {
   \                     CommPutRxChar: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    253          
    254          	COMM_RING_BUF *pbuf;
    255          
    256          	pbuf = &CommBuf[ch];
    257          	portENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
    258          	if (pbuf->RingBufRxCtr < COMM_RX_BUF_SIZE) {	
   \   0000000A   0xF44F 0x7009      MOV      R0,#+548
   \   0000000E   0x4368             MULS     R0,R0,R5
   \   00000010   0x....             LDR.N    R1,??DataTable19
   \   00000012   0x5A0A             LDRH     R2,[R1, R0]
   \   00000014   0xF5B2 0x7F00      CMP      R2,#+512
   \   00000018   0xDA0F             BGE.N    ??CommPutRxChar_0
    259          		pbuf->RingBufRxCtr++;							 
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x520A             STRH     R2,[R1, R0]
    260          		*pbuf->RingBufRxInPtr++ = c;						
   \   0000001E   0x4408             ADD      R0,R1,R0
   \   00000020   0x6881             LDR      R1,[R0, #+8]
   \   00000022   0x1C4A             ADDS     R2,R1,#+1
   \   00000024   0x6082             STR      R2,[R0, #+8]
   \   00000026   0x700C             STRB     R4,[R1, #+0]
    261          		if (pbuf->RingBufRxInPtr == &pbuf->RingBufRx[COMM_RX_BUF_SIZE]) { 
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0xF44F 0x7204      MOV      R2,#+528
   \   0000002E   0x4402             ADD      R2,R0,R2
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xD102             BNE.N    ??CommPutRxChar_0
    262          			pbuf->RingBufRxInPtr = &pbuf->RingBufRx[0];
   \   00000034   0xF100 0x0110      ADD      R1,R0,#+16
   \   00000038   0x6081             STR      R1,[R0, #+8]
    263          		}
    264          	}
    265          	portEXIT_CRITICAL();
   \                     ??CommPutRxChar_0: (+1)
   \   0000003A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000003E   0x.... 0x....      B.W      vPortExitCritical
    266          }
    267          

   \                                 In section .text, align 2, keep-with-next
    268          INT8U CommGetChar(INT8U ch, INT16U to, INT8U *err)
    269          {
   \                     CommGetChar: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x4614             MOV      R4,R2
    270          	INT8U c;
    271          
    272          	COMM_RING_BUF *pbuf;
    273          
    274          	pbuf = &CommBuf[ch];
    275          
    276          	if(pbuf->RingBufRxSem == NULL)
   \   00000006   0x....             LDR.N    R0,??DataTable19
   \   00000008   0xF44F 0x7209      MOV      R2,#+548
   \   0000000C   0x4372             MULS     R2,R2,R6
   \   0000000E   0x1885             ADDS     R5,R0,R2
   \   00000010   0x6868             LDR      R0,[R5, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD109             BNE.N    ??CommGetChar_0
    277          	{
    278          		printd("%s err\n",__func__);
   \   00000016   0x.... 0x....      ADR.W    R1,`CommGetChar::__func__`
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       printd
    279          		*err = (COMM_TX_TIMEOUT);
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    280          		return (NUL);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
    281          	}
    282          
    283          	if(xSemaphoreTake(pbuf->RingBufRxSem, ( portTickType ) to )  == pdTRUE)
   \                     ??CommGetChar_0: (+1)
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x460A             MOV      R2,R1
   \   0000002E   0x4619             MOV      R1,R3
   \   00000030   0x.... 0x....      BL       xQueueGenericReceive
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD132             BNE.N    ??CommGetChar_1
    284          	{
    285          		portENTER_CRITICAL();
   \   00000038   0x.... 0x....      BL       vPortEnterCritical
    286          		if ((pbuf->RingBufRxCtr > 0)  || (Comm_balanceCheck(ch) == COMM_RX_UNBALANCE) )
   \   0000003C   0x882F             LDRH     R7,[R5, #+0]
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0xD104             BNE.N    ??CommGetChar_2
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       Comm_balanceCheck
   \   00000048   0x2807             CMP      R0,#+7
   \   0000004A   0xD11C             BNE.N    ??CommGetChar_3
    287          		{
    288          			if(pbuf->RingBufRxCtr)
   \                     ??CommGetChar_2: (+1)
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0xD001             BEQ.N    ??CommGetChar_4
    289          				pbuf->RingBufRxCtr--;	
   \   00000050   0x1E78             SUBS     R0,R7,#+1
   \   00000052   0x8028             STRH     R0,[R5, #+0]
    290          
    291          			c = *pbuf->RingBufRxOutPtr++;					  
   \                     ??CommGetChar_4: (+1)
   \   00000054   0x68E8             LDR      R0,[R5, #+12]
   \   00000056   0x1C41             ADDS     R1,R0,#+1
   \   00000058   0x60E9             STR      R1,[R5, #+12]
   \   0000005A   0x7806             LDRB     R6,[R0, #+0]
    292          			if (pbuf->RingBufRxOutPtr == &pbuf->RingBufRx[COMM_RX_BUF_SIZE]) {	
   \   0000005C   0x4608             MOV      R0,R1
   \   0000005E   0xF44F 0x7104      MOV      R1,#+528
   \   00000062   0x4429             ADD      R1,R5,R1
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD102             BNE.N    ??CommGetChar_5
    293          				pbuf->RingBufRxOutPtr = &pbuf->RingBufRx[0];
   \   00000068   0xF105 0x0010      ADD      R0,R5,#+16
   \   0000006C   0x60E8             STR      R0,[R5, #+12]
    294          			}
    295          			portEXIT_CRITICAL();
   \                     ??CommGetChar_5: (+1)
   \   0000006E   0x.... 0x....      BL       vPortExitCritical
    296          			*err = COMM_NO_ERR;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7020             STRB     R0,[R4, #+0]
    297          			xSemaphoreGive(pbuf->RingBufRxSem);
   \   00000076   0x4603             MOV      R3,R0
   \   00000078   0x4602             MOV      R2,R0
   \   0000007A   0x4601             MOV      R1,R0
   \   0000007C   0x6868             LDR      R0,[R5, #+4]
   \   0000007E   0x.... 0x....      BL       xQueueGenericSend
    298          			return (c);
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0xBDF2             POP      {R1,R4-R7,PC}
    299          		}
    300          		else
    301          		{
    302          			portEXIT_CRITICAL();
   \                     ??CommGetChar_3: (+1)
   \   00000086   0x.... 0x....      BL       vPortExitCritical
    303          			*err = COMM_RX_EMPTY;
   \   0000008A   0x2002             MOVS     R0,#+2
   \   0000008C   0x7020             STRB     R0,[R4, #+0]
    304          			xSemaphoreGive(pbuf->RingBufRxSem);
   \   0000008E   0x2300             MOVS     R3,#+0
   \   00000090   0x461A             MOV      R2,R3
   \   00000092   0x4611             MOV      R1,R2
   \   00000094   0x6868             LDR      R0,[R5, #+4]
   \   00000096   0x.... 0x....      BL       xQueueGenericSend
    305          			return (NUL);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}
    306          		}
    307          	}
    308          	return (NUL);
   \                     ??CommGetChar_1: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    309          }
    310          
    311          

   \                                 In section .text, align 2, keep-with-next
    312          INT8U CommGetTxChar(INT8U ch, INT8U *err)
    313          {
   \                     CommGetTxChar: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    314          	INT8U c;
    315          	COMM_RING_BUF *pbuf;
    316          
    317          	pbuf = &CommBuf[ch];
    318          
    319          	if (pbuf->RingBufTxCtr > 0) {						 
   \   00000002   0x....             LDR.N    R2,??DataTable19
   \   00000004   0xF44F 0x7309      MOV      R3,#+548
   \   00000008   0x4358             MULS     R0,R3,R0
   \   0000000A   0x4402             ADD      R2,R2,R0
   \   0000000C   0xF44F 0x7004      MOV      R0,#+528
   \   00000010   0x1813             ADDS     R3,R2,R0
   \   00000012   0x8818             LDRH     R0,[R3, #+0]
   \   00000014   0x0004             MOVS     R4,R0
   \   00000016   0xD010             BEQ.N    ??CommGetTxChar_0
    320          		pbuf->RingBufTxCtr--;							
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x8018             STRH     R0,[R3, #+0]
    321          		c = *pbuf->RingBufTxOutPtr++;					
   \   0000001C   0x68D8             LDR      R0,[R3, #+12]
   \   0000001E   0x1C44             ADDS     R4,R0,#+1
   \   00000020   0x60DC             STR      R4,[R3, #+12]
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
    322          		if (pbuf->RingBufTxOutPtr == &pbuf->RingBufTx[COMM_TX_BUF_SIZE]) {	 
   \   00000024   0xF202 0x2521      ADDW     R5,R2,#+545
   \   00000028   0x42AC             CMP      R4,R5
   \   0000002A   0xD103             BNE.N    ??CommGetTxChar_1
    323          			pbuf->RingBufTxOutPtr = &pbuf->RingBufTx[0];
   \   0000002C   0xF44F 0x7408      MOV      R4,#+544
   \   00000030   0x4422             ADD      R2,R2,R4
   \   00000032   0x60DA             STR      R2,[R3, #+12]
    324          		}
    325          		*err = COMM_NO_ERR;
   \                     ??CommGetTxChar_1: (+1)
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x700A             STRB     R2,[R1, #+0]
    326          		return (c);								
   \   00000038   0xE002             B.N      ??CommGetTxChar_2
    327          	} else {
    328          		*err = COMM_TX_EMPTY;
   \                     ??CommGetTxChar_0: (+1)
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
    329          		return (NUL);									
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??CommGetTxChar_2: (+1)
   \   00000040   0xBC30             POP      {R4,R5}
   \   00000042   0x4770             BX       LR               ;; return
    330          	}
    331          
    332          
    333          }
    334          

   \                                 In section .text, align 2, keep-with-next
    335          void BSP_usart_int_en(INT8U ch)
    336          {
    337          	USART_ITConfig(pUART_BASE[ch], USART_IT_TC, ENABLE);
   \                     BSP_usart_int_en: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF240 0x6126      MOVW     R1,#+1574
   \   00000006   0x....             LDR.N    R3,??DataTable19_1
   \   00000008   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x.... 0x....      B.W      USART_ITConfig
    338          }
    339          
    340          

   \                                 In section .text, align 2, keep-with-next
    341          INT8U CommPutChar(INT8U ch, INT8U c, INT16U to)
    342          {
   \                     CommPutChar: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
    343          
    344          	COMM_RING_BUF *pbuf;
    345          
    346          	pbuf = &CommBuf[ch];
    347          
    348          	if(pbuf->RingBufTxSem == NULL)
   \   00000008   0x4625             MOV      R5,R4
   \   0000000A   0x....             LDR.N    R0,??DataTable19
   \   0000000C   0xF44F 0x7109      MOV      R1,#+548
   \   00000010   0x4369             MULS     R1,R1,R5
   \   00000012   0x1847             ADDS     R7,R0,R1
   \   00000014   0xF44F 0x7004      MOV      R0,#+528
   \   00000018   0xEB07 0x0800      ADD      R8,R7,R0
   \   0000001C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD107             BNE.N    ??CommPutChar_0
    349          	{
    350          		printk("%s err\n",__func__);
   \   00000024   0x.... 0x....      ADR.W    R1,`CommPutChar::__func__`
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       printk
    351          		return (COMM_TX_TIMEOUT);
   \   00000030   0x2006             MOVS     R0,#+6
   \   00000032   0xE036             B.N      ??CommPutChar_1
    352          	}
    353          	if(xSemaphoreTake(pbuf->RingBufTxSem, ( portTickType ) to )  == pdTRUE)
   \                     ??CommPutChar_0: (+1)
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x4619             MOV      R1,R3
   \   00000038   0x.... 0x....      BL       xQueueGenericReceive
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD12F             BNE.N    ??CommPutChar_2
    354          	{
    355          		portENTER_CRITICAL();
   \   00000040   0x.... 0x....      BL       vPortEnterCritical
    356          		pbuf->RingBufTxCtr++;								  
   \   00000044   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    357          		*pbuf->RingBufTxInPtr++ = c;							
   \   0000004E   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000052   0x1C41             ADDS     R1,R0,#+1
   \   00000054   0xF8C8 0x1008      STR      R1,[R8, #+8]
   \   00000058   0x7006             STRB     R6,[R0, #+0]
    358          		if (pbuf->RingBufTxInPtr == &pbuf->RingBufTx[COMM_TX_BUF_SIZE])
   \   0000005A   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000005E   0xF207 0x2121      ADDW     R1,R7,#+545
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD104             BNE.N    ??CommPutChar_3
    359          		{	 
    360          			pbuf->RingBufTxInPtr = &pbuf->RingBufTx[0];
   \   00000066   0xF44F 0x7008      MOV      R0,#+544
   \   0000006A   0x4438             ADD      R0,R7,R0
   \   0000006C   0xF8C8 0x0008      STR      R0,[R8, #+8]
    361          		}
    362          
    363          		if (pbuf->RingBufTxCtr == 1)
   \                     ??CommPutChar_3: (+1)
   \   00000070   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD111             BNE.N    ??CommPutChar_4
    364          		{						
    365          			if(tx_stat[ch]==TX_STAT_IDLE)
   \   00000078   0x....             LDR.N    R0,??DataTable19_1
   \   0000007A   0x5D41             LDRB     R1,[R0, R5]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD10A             BNE.N    ??CommPutChar_5
    366          			{
    367          				tx_stat[ch] = TX_STAT_BUSY;	
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x5541             STRB     R1,[R0, R5]
    368          				BSP_usart_int_en(ch);
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       BSP_usart_int_en
    369          				__sub_Uart_TxInt(ch);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       __sub_Uart_TxInt
    370          				portEXIT_CRITICAL();					
   \   00000090   0x.... 0x....      BL       vPortExitCritical
   \   00000094   0xE004             B.N      ??CommPutChar_2
    371          			}
    372          			else
    373          			{
    374          				portEXIT_CRITICAL();
   \                     ??CommPutChar_5: (+1)
   \   00000096   0x.... 0x....      BL       vPortExitCritical
   \   0000009A   0xE001             B.N      ??CommPutChar_2
    375          			}
    376          		}
    377          		else{
    378          			portEXIT_CRITICAL();
   \                     ??CommPutChar_4: (+1)
   \   0000009C   0x.... 0x....      BL       vPortExitCritical
    379          		}
    380          	}
    381          
    382          	return (COMM_NO_ERR);
   \                     ??CommPutChar_2: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??CommPutChar_1: (+1)
   \   000000A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    383          }
    384          

   \                                 In section .text, align 2, keep-with-next
    385          void modemPutCharStr(INT8U *pdata, INT32U SendCount)
    386          {
   \                     modemPutCharStr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    387          	int i;
    388          
    389          	//portENTER_CRITICAL();
    390          	for(i=0;i<SendCount;i++)
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE00B             B.N      ??modemPutCharStr_0
    391          	{
    392          		while(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET);
   \                     ??modemPutCharStr_1: (+1)
   \   0000000A   0x....             LDR.N    R7,??DataTable19_2  ;; 0x40004400
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x4638             MOV      R0,R7
   \   00000010   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD0F8             BEQ.N    ??modemPutCharStr_1
    393          		USART_SendData(USART2,pdata[i]);
   \   00000018   0x5DA1             LDRB     R1,[R4, R6]
   \   0000001A   0x4638             MOV      R0,R7
   \   0000001C   0x.... 0x....      BL       USART_SendData
    394           	}
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??modemPutCharStr_0: (+1)
   \   00000022   0x42AE             CMP      R6,R5
   \   00000024   0xD3F1             BCC.N    ??modemPutCharStr_1
    395          	//portEXIT_CRITICAL();
    396          }
   \   00000026   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    397          
    398          #if 1		//Serial Port USE

   \                                 In section .text, align 2, keep-with-next
    399          void CommPutCharStr(INT8U port, INT8U *pdata, INT32U SendCount)
    400          {
   \                     CommPutCharStr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    401          	int i;
    402          
    403          	//portENTER_CRITICAL();
    404          	for(i=0;i<SendCount;i++)
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE00B             B.N      ??CommPutCharStr_0
    405          	{
    406          		while(USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);
   \                     ??CommPutCharStr_1: (+1)
   \   0000000A   0x....             LDR.N    R7,??DataTable19_3  ;; 0x40011000
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x4638             MOV      R0,R7
   \   00000010   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD0F8             BEQ.N    ??CommPutCharStr_1
    407          		USART_SendData(USART1,pdata[i]);
   \   00000018   0x5DA1             LDRB     R1,[R4, R6]
   \   0000001A   0x4638             MOV      R0,R7
   \   0000001C   0x.... 0x....      BL       USART_SendData
    408           	}
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??CommPutCharStr_0: (+1)
   \   00000022   0x42AE             CMP      R6,R5
   \   00000024   0xD3F1             BCC.N    ??CommPutCharStr_1
    409          	//portEXIT_CRITICAL();
    410          }
   \   00000026   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     CommBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     tx_stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    
    411          
    412          
    413          #else		//USB USE
    414          
    415          #define USB_PACKET_SIZE	63
    416          //define DEV_EP_TX_DIS   0x0000
    417          //define DEV_EP_TX_STALL 0x0010
    418          #define DEV_EP_TX_NAK   0x0020
    419          //define DEV_EP_TX_VALID 0x0030
    420          
    421          void CommPutCharStr(INT8U port, INT8U *pdata, INT32U SendCount)
    422          {
    423          	INT32U i, packet_cnt, rest_packet_cnt;
    424          
    425          	if(port == GUI_PORT)
    426          	{
    427          		if( USB_TxSem != NULL)
    428          		{
    429          
    430          			if(xSemaphoreTake(USB_TxSem, ( portTickType ) 0 ) == pdTRUE )
    431          			{
    432          				if(SendCount > USB_PACKET_SIZE){					// 보낼 데이터가 63byte 이상이면 
    433          					
    434          					packet_cnt = SendCount / USB_PACKET_SIZE;			
    435          					rest_packet_cnt = SendCount % USB_PACKET_SIZE;
    436          
    437          					for(i=0; i<packet_cnt; i++){					// 63byte 단위로 나눠서 보낸다 
    438          					  USB_SIL_Write(EP1_IN, &pdata[i*USB_PACKET_SIZE], USB_PACKET_SIZE);
    439          					  SetEPTxValid(ENDP1);
    440          					  while(GetEPTxStatus(ENDP1) != DEV_EP_TX_NAK);// OS_Sched();
    441          				    }   
    442          					USB_SIL_Write(EP1_IN, &pdata[i*USB_PACKET_SIZE], rest_packet_cnt);
    443          				        SetEPTxValid(ENDP1);												
    444          				}
    445          				else{												// 보낼 데이터가 63byte 보다 작으면 
    446          					USB_SIL_Write(EP1_IN, pdata, SendCount);
    447          				        SetEPTxValid(ENDP1);
    448          				}
    449          				xSemaphoreGive(USB_TxSem);
    450          			}
    451          			else{
    452          				printk("sem pend err  %s\n",__func__);
    453          			}
    454          		}
    455          	}
    456          
    457          	
    458          }
    459          #endif
    460          
    461          
    462          
    463          /*
    464          ********************* (C) COPYRIGHT 2014 Loop ***************END OF FILE*****************************
    465          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_usart_int_en
         0   -> USART_ITConfig
      24   CommGetChar
        24   -> Comm_balanceCheck
        24   -> printd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
       8   CommGetTxChar
      16   CommInit
        16   -> xQueueGenericCreate
        16   -> xQueueGenericSend
       8   CommIsEmpty
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   CommIsFull
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      24   CommPutChar
        24   -> BSP_usart_int_en
        24   -> __sub_Uart_TxInt
        24   -> printk
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> xQueueGenericReceive
      24   CommPutCharStr
        24   -> USART_GetFlagStatus
        24   -> USART_SendData
      16   CommPutRxChar
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       8   CommReInit
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
       0   Comm_GetRxBufCnt
       0   Comm_GetTxBufCnt
      16   Comm_Tx_Stat
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       0   Comm_balanceCheck
       0   __sub_Can_RxInt
         0   -> CommPutRxChar
       8   __sub_Uart_RxInt
         0   -> CommPutRxChar
         8   -> USART_ReceiveData
      16   __sub_Uart_TxInt
        16   -> CommGetTxChar
        16   -> USART_SendData
      24   modemPutCharStr
        24   -> USART_GetFlagStatus
        24   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       8  ?_0
      18  BSP_usart_int_en
    2740  CommBuf
     162  CommGetChar
      68  CommGetTxChar
     124  CommInit
      32  CommIsEmpty
      38  CommIsFull
     166  CommPutChar
      40  CommPutCharStr
      66  CommPutRxChar
      68  CommReInit
      14  Comm_GetRxBufCnt
      18  Comm_GetTxBufCnt
      24  Comm_Tx_Stat
      28  Comm_balanceCheck
       2  __sub_Can_RxInt
      28  __sub_Uart_RxInt
      42  __sub_Uart_TxInt
      40  modemPutCharStr
      16  tx_stat
          pUART_BASE
      24  -- Other

 
 2 740 bytes in section .bss
    16 bytes in section .data
 1 026 bytes in section .text
 
 1 026 bytes of CODE memory
 2 756 bytes of DATA memory

Errors: none
Warnings: none
