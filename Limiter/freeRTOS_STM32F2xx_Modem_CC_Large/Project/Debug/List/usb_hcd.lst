###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_OTG_Driver\src\usb_hcd.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_OTG_Driver\src\usb_hcd.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usb_hcd.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usb_hcd.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_OTG_Driver\src\usb_hcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_hcd.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   Host Interface Layer
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usb_core.h"
     30          #include "usb_hcd.h"
     31          #include "usb_conf.h"
     32          #include "usb_bsp.h"
     33          
     34          
     35          /** @addtogroup USB_OTG_DRIVER
     36            * @{
     37            */
     38            
     39          /** @defgroup USB_HCD 
     40            * @brief This file is the interface between EFSL ans Host mass-storage class
     41            * @{
     42            */
     43          
     44          
     45          /** @defgroup USB_HCD_Private_Defines
     46            * @{
     47            */ 
     48          /**
     49            * @}
     50            */ 
     51           
     52          
     53          /** @defgroup USB_HCD_Private_TypesDefinitions
     54            * @{
     55            */ 
     56          /**
     57            * @}
     58            */ 
     59          
     60          
     61          
     62          /** @defgroup USB_HCD_Private_Macros
     63            * @{
     64            */ 
     65          /**
     66            * @}
     67            */ 
     68          
     69          
     70          /** @defgroup USB_HCD_Private_Variables
     71            * @{
     72            */ 
     73          /**
     74            * @}
     75            */ 
     76          
     77          
     78          /** @defgroup USB_HCD_Private_FunctionPrototypes
     79            * @{
     80            */ 
     81          /**
     82            * @}
     83            */ 
     84          
     85          
     86          /** @defgroup USB_HCD_Private_Functions
     87            * @{
     88            */ 
     89          
     90          /**
     91            * @brief  HCD_Init 
     92            *         Initialize the HOST portion of the driver.
     93            * @param  pdev: Selected device
     94            * @param  base_address: OTG base address
     95            * @retval Status
     96            */

   \                                 In section .text, align 2, keep-with-next
     97          uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
     98                            USB_OTG_CORE_ID_TypeDef coreID)
     99          {
   \                     HCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    100            uint8_t i = 0;
    101            pdev->host.ConnSts = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8C4 0x0310      STR      R0,[R4, #+784]
    102            
    103            for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
   \   0000000A   0xE00C             B.N      ??HCD_Init_0
    104            {
    105            pdev->host.ErrCnt[i]  = 0;
   \                     ??HCD_Init_1: (+1)
   \   0000000C   0xEB04 0x0280      ADD      R2,R4,R0, LSL #+2
   \   00000010   0xF44F 0x7345      MOV      R3,#+788
   \   00000014   0x441A             ADD      R2,R2,R3
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x6013             STR      R3,[R2, #+0]
    106            pdev->host.XferCnt[i]   = 0;
   \   0000001A   0x63D3             STR      R3,[R2, #+60]
    107            pdev->host.HC_Status[i]   = HC_IDLE;
   \   0000001C   0x461A             MOV      R2,R3
   \   0000001E   0x1823             ADDS     R3,R4,R0
   \   00000020   0xF883 0x238C      STRB     R2,[R3, #+908]
    108            }
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \                     ??HCD_Init_0: (+1)
   \   00000026   0x280F             CMP      R0,#+15
   \   00000028   0xDBF0             BLT.N    ??HCD_Init_1
    109            pdev->host.hc[0].max_packet  = 8; 
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0xF8A4 0x03B2      STRH     R0,[R4, #+946]
    110          
    111            USB_OTG_SelectCore(pdev, coreID);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       USB_OTG_SelectCore
    112          #ifndef DUAL_ROLE_MODE_ENABLED
    113            USB_OTG_DisableGlobalInt(pdev);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       USB_OTG_DisableGlobalInt
    114            USB_OTG_CoreInit(pdev);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       USB_OTG_CoreInit
    115          
    116            /* Force Host Mode*/
    117            USB_OTG_SetCurrentMode(pdev , HOST_MODE);
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       USB_OTG_SetCurrentMode
    118            USB_OTG_CoreInitHost(pdev);
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       USB_OTG_CoreInitHost
    119            USB_OTG_EnableGlobalInt(pdev);
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       USB_OTG_EnableGlobalInt
    120          #endif
    121             
    122            return 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    123          }
    124          
    125          
    126          /**
    127            * @brief  HCD_GetCurrentSpeed
    128            *         Get Current device Speed.
    129            * @param  pdev : Selected device
    130            * @retval Status
    131            */
    132          

   \                                 In section .text, align 2, keep-with-next
    133          uint32_t HCD_GetCurrentSpeed (USB_OTG_CORE_HANDLE *pdev)
    134          {    
    135              USB_OTG_HPRT0_TypeDef  HPRT0;
    136              HPRT0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
   \                     HCD_GetCurrentSpeed: (+1)
   \   00000000   0xF8D0 0x00CC      LDR      R0,[R0, #+204]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
    137              
    138              return HPRT0.b.prtspd;
   \   00000006   0xF3C0 0x4041      UBFX     R0,R0,#+17,#+2
   \   0000000A   0x4770             BX       LR               ;; return
    139          }
    140          
    141          /**
    142            * @brief  HCD_ResetPort
    143            *         Issues the reset command to device
    144            * @param  pdev : Selected device
    145            * @retval Status
    146            */

   \                                 In section .text, align 2, keep-with-next
    147          uint32_t HCD_ResetPort(USB_OTG_CORE_HANDLE *pdev)
    148          {
   \                     HCD_ResetPort: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    149            /*
    150            Before starting to drive a USB reset, the application waits for the OTG 
    151            interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), 
    152            which indicates that the bus is stable again after the electrical debounce 
    153            caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).
    154            */
    155            
    156            USB_OTG_ResetPort(pdev); 
   \   00000002   0x.... 0x....      BL       USB_OTG_ResetPort
    157            return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    158          }
    159          
    160          /**
    161            * @brief  HCD_IsDeviceConnected
    162            *         Check if the device is connected.
    163            * @param  pdev : Selected device
    164            * @retval Device connection status. 1 -> connected and 0 -> disconnected
    165            * 
    166            */

   \                                 In section .text, align 2, keep-with-next
    167          uint32_t HCD_IsDeviceConnected(USB_OTG_CORE_HANDLE *pdev)
    168          {
    169            return (pdev->host.ConnSts);
   \                     HCD_IsDeviceConnected: (+1)
   \   00000000   0xF8D0 0x0310      LDR      R0,[R0, #+784]
   \   00000004   0x4770             BX       LR               ;; return
    170          }
    171          
    172          /**
    173            * @brief  HCD_GetCurrentFrame 
    174            *         This function returns the frame number for sof packet
    175            * @param  pdev : Selected device
    176            * @retval Frame number
    177            * 
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          uint32_t HCD_GetCurrentFrame (USB_OTG_CORE_HANDLE *pdev) 
    180          {
    181           return (USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0xFFFF) ;
   \                     HCD_GetCurrentFrame: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
    182          }
    183          
    184          /**
    185            * @brief  HCD_GetURB_State 
    186            *         This function returns the last URBstate
    187            * @param  pdev: Selected device
    188            * @retval URB_STATE
    189            * 
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          URB_STATE HCD_GetURB_State (USB_OTG_CORE_HANDLE *pdev , uint8_t ch_num) 
    192          {
    193            return pdev->host.URB_State[ch_num] ;
   \                     HCD_GetURB_State: (+1)
   \   00000000   0x4408             ADD      R0,R0,R1
   \   00000002   0xF890 0x039B      LDRB     R0,[R0, #+923]
   \   00000006   0x4770             BX       LR               ;; return
    194          }
    195          
    196          /**
    197            * @brief  HCD_GetXferCnt 
    198            *         This function returns the last URBstate
    199            * @param  pdev: Selected device
    200            * @retval No. of data bytes transferred
    201            * 
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          uint32_t HCD_GetXferCnt (USB_OTG_CORE_HANDLE *pdev, uint8_t ch_num) 
    204          {
    205            return pdev->host.XferCnt[ch_num] ;
   \                     HCD_GetXferCnt: (+1)
   \   00000000   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000004   0xF8D0 0x0350      LDR      R0,[R0, #+848]
   \   00000008   0x4770             BX       LR               ;; return
    206          }
    207          
    208          
    209          
    210          /**
    211            * @brief  HCD_GetHCState 
    212            *         This function returns the HC Status 
    213            * @param  pdev: Selected device
    214            * @retval HC_STATUS
    215            * 
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          HC_STATUS HCD_GetHCState (USB_OTG_CORE_HANDLE *pdev ,  uint8_t ch_num) 
    218          {
    219            return pdev->host.HC_Status[ch_num] ;
   \                     HCD_GetHCState: (+1)
   \   00000000   0x4408             ADD      R0,R0,R1
   \   00000002   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   00000006   0x4770             BX       LR               ;; return
    220          }
    221          
    222          /**
    223            * @brief  HCD_HC_Init 
    224            *         This function prepare a HC and start a transfer
    225            * @param  pdev: Selected device
    226            * @param  hc_num: Channel number 
    227            * @retval status 
    228            */

   \                                 In section .text, align 2, keep-with-next
    229          uint32_t HCD_HC_Init (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
    230          {
    231            return USB_OTG_HC_Init(pdev, hc_num);  
   \                     HCD_HC_Init: (+1)
   \   00000000   0x.... 0x....      B.W      USB_OTG_HC_Init
    232          }
    233          
    234          /**
    235            * @brief  HCD_SubmitRequest 
    236            *         This function prepare a HC and start a transfer
    237            * @param  pdev: Selected device
    238            * @param  hc_num: Channel number 
    239            * @retval status
    240            */

   \                                 In section .text, align 2, keep-with-next
    241          uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
    242          {
    243            
    244            pdev->host.URB_State[hc_num] =   URB_IDLE;  
   \                     HCD_SubmitRequest: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x1843             ADDS     R3,R0,R1
   \   00000004   0xF883 0x239B      STRB     R2,[R3, #+923]
    245            pdev->host.hc[hc_num].xfer_count = 0 ;
   \   00000008   0xEB00 0x1341      ADD      R3,R0,R1, LSL #+5
   \   0000000C   0xF8C3 0x23C0      STR      R2,[R3, #+960]
    246            return USB_OTG_HC_StartXfer(pdev, hc_num);
   \   00000010   0x.... 0x....      B.W      USB_OTG_HC_StartXfer
    247          }
    248          
    249          
    250          /**
    251          * @}
    252          */ 
    253          
    254          /**
    255          * @}
    256          */ 
    257          
    258          /**
    259          * @}
    260          */
    261          
    262          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HCD_GetCurrentFrame
       0   HCD_GetCurrentSpeed
       0   HCD_GetHCState
       0   HCD_GetURB_State
       0   HCD_GetXferCnt
       0   HCD_HC_Init
         0   -> USB_OTG_HC_Init
       8   HCD_Init
         8   -> USB_OTG_CoreInit
         8   -> USB_OTG_CoreInitHost
         8   -> USB_OTG_DisableGlobalInt
         8   -> USB_OTG_EnableGlobalInt
         8   -> USB_OTG_SelectCore
         8   -> USB_OTG_SetCurrentMode
       0   HCD_IsDeviceConnected
       8   HCD_ResetPort
         8   -> USB_OTG_ResetPort
       0   HCD_SubmitRequest
         0   -> USB_OTG_HC_StartXfer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  HCD_GetCurrentFrame
      12  HCD_GetCurrentSpeed
       8  HCD_GetHCState
       8  HCD_GetURB_State
      10  HCD_GetXferCnt
       4  HCD_HC_Init
      90  HCD_Init
       6  HCD_IsDeviceConnected
      10  HCD_ResetPort
      20  HCD_SubmitRequest

 
 176 bytes in section .text
 
 176 bytes of CODE memory

Errors: none
Warnings: none
