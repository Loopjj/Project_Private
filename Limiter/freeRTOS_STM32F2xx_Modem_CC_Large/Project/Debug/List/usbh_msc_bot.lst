###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_bot.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_bot.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_msc_bot.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_msc_bot.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_bot.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_bot.c 
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file includes the mass storage related functions
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc_core.h"
     30          #include "usbh_msc_scsi.h"
     31          #include "usbh_msc_bot.h"
     32          #include "usbh_ioreq.h"
     33          #include "usbh_def.h"
     34          #include "usb_hcd_int.h"
     35          
     36          
     37          /** @addtogroup USBH_LIB
     38          * @{
     39          */
     40          
     41          /** @addtogroup USBH_CLASS
     42          * @{
     43          */
     44          
     45          /** @addtogroup USBH_MSC_CLASS
     46          * @{
     47          */
     48          
     49          /** @defgroup USBH_MSC_BOT 
     50          * @brief    This file includes the mass storage related functions
     51          * @{
     52          */ 
     53          
     54          
     55          /** @defgroup USBH_MSC_BOT_Private_TypesDefinitions
     56          * @{
     57          */ 
     58          /**
     59          * @}
     60          */ 
     61          
     62          /** @defgroup USBH_MSC_BOT_Private_Defines
     63          * @{
     64          */ 
     65          /**
     66          * @}
     67          */ 
     68          
     69          /** @defgroup USBH_MSC_BOT_Private_Macros
     70          * @{
     71          */ 
     72          /**
     73          * @}
     74          */ 
     75          
     76          
     77          /** @defgroup USBH_MSC_BOT_Private_Variables
     78          * @{
     79          */ 
     80          
     81          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     82            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     83              #pragma data_alignment=4   
     84            #endif
     85          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */ 

   \                                 In section .bss, align 4
     86          __ALIGN_BEGIN HostCBWPkt_TypeDef USBH_MSC_CBWData __ALIGN_END ;
   \                     USBH_MSC_CBWData:
   \   00000000                      DS8 32
     87          
     88          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     89            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     90              #pragma data_alignment=4   
     91            #endif
     92          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     93          __ALIGN_BEGIN HostCSWPkt_TypeDef USBH_MSC_CSWData __ALIGN_END ;
     94          
     95          
     96          static uint32_t BOTStallErrorCount;   /* Keeps count of STALL Error Cases*/
     97          
     98          /**
     99          * @}
    100          */ 
    101          
    102          
    103          /** @defgroup USBH_MSC_BOT_Private_FunctionPrototypes
    104          * @{
    105          */ 
    106          /**
    107          * @}
    108          */ 
    109          
    110          
    111          /** @defgroup USBH_MSC_BOT_Exported_Variables
    112          * @{
    113          */ 
    114          USBH_BOTXfer_TypeDef USBH_MSC_BOTXferParam; 
    115          /**
    116          * @}
    117          */ 
    118          
    119          
    120          /** @defgroup USBH_MSC_BOT_Private_Functions
    121          * @{
    122          */ 
    123          
    124          
    125          /**
    126          * @brief  USBH_MSC_Init 
    127          *         Initializes the mass storage parameters
    128          * @param  None
    129          * @retval None
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          void USBH_MSC_Init(USB_OTG_CORE_HANDLE *pdev )
    132          {
   \                     USBH_MSC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    133            if(HCD_IsDeviceConnected(pdev))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable3
   \   00000006   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00B             BEQ.N    ??USBH_MSC_Init_0
    134            {      
    135              USBH_MSC_CBWData.field.CBWSignature = USBH_MSC_BOT_CBW_SIGNATURE;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable3_2  ;; 0x43425355
   \   00000016   0x6001             STR      R1,[R0, #+0]
    136              USBH_MSC_CBWData.field.CBWTag = USBH_MSC_BOT_CBW_TAG;
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable3_3  ;; 0x20304050
   \   0000001C   0x6041             STR      R1,[R0, #+4]
    137              USBH_MSC_CBWData.field.CBWLUN = 0;  /*Only one LUN is supported*/
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7341             STRB     R1,[R0, #+13]
    138              USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;  
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x70E0             STRB     R0,[R4, #+3]
    139            }
    140            
    141            BOTStallErrorCount = 0;
   \                     ??USBH_MSC_Init_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6260             STR      R0,[R4, #+36]
    142            MSCErrorCount = 0;
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable3_4
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    143          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    144          
    145          /**
    146          * @brief  USBH_MSC_HandleBOTXfer 
    147          *         This function manages the different states of BOT transfer and 
    148          *         updates the status to upper layer.
    149          * @param  None
    150          * @retval None
    151          * 
    152          */

   \                                 In section .text, align 4, keep-with-next
    153          void USBH_MSC_HandleBOTXfer (USB_OTG_CORE_HANDLE *pdev ,USBH_HOST *phost)
    154          {
   \                     USBH_MSC_HandleBOTXfer: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
    155            uint8_t xferDirection, index;
    156            static uint32_t remainingDataLength;
    157            static uint8_t *datapointer , *datapointer_prev;
    158            static uint8_t error_direction;
    159            USBH_Status status;
    160            
    161            URB_STATE URB_Status = URB_IDLE;
    162            
    163            if(HCD_IsDeviceConnected(pdev))
   \   00000008   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x8167      BEQ.W    ??USBH_MSC_HandleBOTXfer_1
    164            {  
    165              
    166              switch (USBH_MSC_BOTXferParam.BOTState)
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable3
   \   00000016   0x7928             LDRB     R0,[R5, #+4]
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x2807             CMP      R0,#+7
   \   0000001C   0xF200 0x8160      BHI.W    ??USBH_MSC_HandleBOTXfer_1
   \   00000020   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??USBH_MSC_HandleBOTXfer_0:
   \   00000024   0x0008 0x0015      DC16     0x8,0x15,0x4B,0x9E
   \              0x004B 0x009E
   \   0000002C   0x00EA 0x0111      DC16     0xEA,0x111,0x13A,0x150
   \              0x013A 0x0150
    167              {
    168              case USBH_MSC_SEND_CBW:
    169                /* send CBW */    
    170                USBH_BulkSendData (pdev,
    171                                   &USBH_MSC_CBWData.CBWArray[0], 
    172                                   USBH_MSC_BOT_CBW_PACKET_LENGTH , 
    173                                   MSC_Machine.hc_num_out);
   \                     ??USBH_MSC_HandleBOTXfer_2: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   00000038   0x7843             LDRB     R3,[R0, #+1]
   \   0000003A   0x221F             MOVS     R2,#+31
   \   0000003C   0x....             LDR.N    R1,??DataTable3_1
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       USBH_BulkSendData
    174                
    175                USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SEND_CBW;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7168             STRB     R0,[R5, #+5]
    176                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SENT_CBW; 
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x7128             STRB     R0,[R5, #+4]
    177                break;
   \   0000004C   0xE148             B.N      ??USBH_MSC_HandleBOTXfer_1
    178                
    179              case USBH_MSC_SENT_CBW:
    180                URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_out);
   \                     ??USBH_MSC_HandleBOTXfer_3: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable3_5
   \   00000050   0x7841             LDRB     R1,[R0, #+1]
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       HCD_GetURB_State
    181                
    182                if(URB_Status == URB_DONE)
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD120             BNE.N    ??USBH_MSC_HandleBOTXfer_4
    183                { 
    184                  BOTStallErrorCount = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6268             STR      R0,[R5, #+36]
    185                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SENT_CBW; 
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x7168             STRB     R0,[R5, #+5]
    186                  
    187                  /* If the CBW Pkt is sent successful, then change the state */
    188                  xferDirection = (USBH_MSC_CBWData.field.CBWFlags & USB_REQ_DIR_MASK);
    189                  
    190                  if ( USBH_MSC_CBWData.field.CBWTransferLength != 0 )
   \   00000064   0x....             LDR.N    R0,??DataTable3_1
   \   00000066   0x6881             LDR      R1,[R0, #+8]
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD015             BEQ.N    ??USBH_MSC_HandleBOTXfer_5
    191                  {
    192                    remainingDataLength = USBH_MSC_CBWData.field.CBWTransferLength ;
   \   0000006C   0x62A9             STR      R1,[R5, #+40]
    193                    datapointer = USBH_MSC_BOTXferParam.pRxTxBuff;
   \   0000006E   0x68A9             LDR      R1,[R5, #+8]
   \   00000070   0x62E9             STR      R1,[R5, #+44]
    194                    datapointer_prev = datapointer;
   \   00000072   0x6329             STR      R1,[R5, #+48]
    195                    
    196                    /* If there is Data Transfer Stage */
    197                    if (xferDirection == USB_D2H)
   \   00000074   0x7B00             LDRB     R0,[R0, #+12]
   \   00000076   0xF3C0 0x10C0      UBFX     R0,R0,#+7,#+1
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD109             BNE.N    ??USBH_MSC_HandleBOTXfer_6
    198                    {
    199                      /* Data Direction is IN */
    200                      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAIN_STATE;
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0x7128             STRB     R0,[R5, #+4]
    201                      if(USBH_MSC_BOTXferParam.MSCStateCurrent == USBH_MSC_REQUEST_SENSE)
   \   00000082   0x78A8             LDRB     R0,[R5, #+2]
   \   00000084   0x2806             CMP      R0,#+6
   \   00000086   0xF040 0x812B      BNE.W    ??USBH_MSC_HandleBOTXfer_1
    202                        USB_RespWaitCount = 1;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x....             LDR.N    R1,??DataTable3_6
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
   \   00000090   0xE126             B.N      ??USBH_MSC_HandleBOTXfer_1
    203          
    204                    }
    205                    else
    206                    {
    207                      /* Data Direction is OUT */
    208                      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAOUT_STATE;
   \                     ??USBH_MSC_HandleBOTXfer_6: (+1)
   \   00000092   0x2004             MOVS     R0,#+4
   \   00000094   0x7128             STRB     R0,[R5, #+4]
   \   00000096   0xE123             B.N      ??USBH_MSC_HandleBOTXfer_1
    209                    } 
    210                  }
    211                  
    212                  else
    213                  {/* If there is NO Data Transfer Stage */
    214                    USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
   \                     ??USBH_MSC_HandleBOTXfer_5: (+1)
   \   00000098   0x2005             MOVS     R0,#+5
   \   0000009A   0x7128             STRB     R0,[R5, #+4]
   \   0000009C   0xE120             B.N      ??USBH_MSC_HandleBOTXfer_1
    215                  }
    216                  
    217                }   
    218                else if(URB_Status == URB_NOTREADY)
   \                     ??USBH_MSC_HandleBOTXfer_4: (+1)
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD102             BNE.N    ??USBH_MSC_HandleBOTXfer_7
    219                {
    220                  USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOTXferParam.BOTStateBkp;    
   \   000000A2   0x7968             LDRB     R0,[R5, #+5]
   \   000000A4   0x7128             STRB     R0,[R5, #+4]
   \   000000A6   0xE11B             B.N      ??USBH_MSC_HandleBOTXfer_1
    221                }     
    222                else if(URB_Status == URB_STALL)
   \                     ??USBH_MSC_HandleBOTXfer_7: (+1)
   \   000000A8   0x2804             CMP      R0,#+4
   \   000000AA   0xF040 0x8119      BNE.W    ??USBH_MSC_HandleBOTXfer_1
    223                {
    224                  error_direction = USBH_MSC_DIR_OUT;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF885 0x0020      STRB     R0,[R5, #+32]
    225                  USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
   \   000000B4   0x2008             MOVS     R0,#+8
   \   000000B6   0x7128             STRB     R0,[R5, #+4]
   \   000000B8   0xE112             B.N      ??USBH_MSC_HandleBOTXfer_1
    226                }
    227                break;
    228                
    229              case USBH_MSC_BOT_DATAIN_STATE:
    230                URB_Status =   HCD_GetURB_State(pdev , MSC_Machine.hc_num_in);
   \                     ??USBH_MSC_HandleBOTXfer_8: (+1)
   \   000000BA   0x....             LDR.N    R6,??DataTable3_5
   \   000000BC   0x7831             LDRB     R1,[R6, #+0]
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x.... 0x....      BL       HCD_GetURB_State
    231                if(URB_Status != URB_IDLE) USB_RespWaitCount = 0;
   \   000000C4   0x....             LDR.N    R7,??DataTable3_6
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD002             BEQ.N    ??USBH_MSC_HandleBOTXfer_9
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x7039             STRB     R1,[R7, #+0]
   \   000000CE   0xE007             B.N      ??USBH_MSC_HandleBOTXfer_10
    232                else if(USB_RespWaitCount > 100) {  // 1 sec
   \                     ??USBH_MSC_HandleBOTXfer_9: (+1)
   \   000000D0   0x7839             LDRB     R1,[R7, #+0]
   \   000000D2   0x2965             CMP      R1,#+101
   \   000000D4   0xDB04             BLT.N    ??USBH_MSC_HandleBOTXfer_10
    233                  phost->gState = HOST_ERROR_STATE;
   \   000000D6   0x210A             MOVS     R1,#+10
   \   000000D8   0xF888 0x1000      STRB     R1,[R8, #+0]
    234                  USB_RespWaitCount = 0;
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x7039             STRB     R1,[R7, #+0]
    235                }      
    236                /* BOT DATA IN stage */
    237                if((URB_Status == URB_DONE) ||(USBH_MSC_BOTXferParam.BOTStateBkp != USBH_MSC_BOT_DATAIN_STATE))
   \                     ??USBH_MSC_HandleBOTXfer_10: (+1)
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xD002             BEQ.N    ??USBH_MSC_HandleBOTXfer_11
   \   000000E4   0x7969             LDRB     R1,[R5, #+5]
   \   000000E6   0x2903             CMP      R1,#+3
   \   000000E8   0xD02F             BEQ.N    ??USBH_MSC_HandleBOTXfer_12
    238                {
    239                  BOTStallErrorCount = 0;
   \                     ??USBH_MSC_HandleBOTXfer_11: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x6268             STR      R0,[R5, #+36]
    240                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
   \   000000EE   0x2003             MOVS     R0,#+3
   \   000000F0   0x7168             STRB     R0,[R5, #+5]
    241                  
    242                  if(remainingDataLength > MSC_Machine.MSBulkInEpSize)
   \   000000F2   0x6AA8             LDR      R0,[R5, #+40]
   \   000000F4   0x88B2             LDRH     R2,[R6, #+4]
   \   000000F6   0x4282             CMP      R2,R0
   \   000000F8   0xD212             BCS.N    ??USBH_MSC_HandleBOTXfer_13
    243                  {
    244                    USBH_BulkReceiveData (pdev,
    245          	                        datapointer, 
    246          			        MSC_Machine.MSBulkInEpSize , 
    247          			        MSC_Machine.hc_num_in);
   \   000000FA   0x7833             LDRB     R3,[R6, #+0]
   \   000000FC   0x6AE9             LDR      R1,[R5, #+44]
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       USBH_BulkReceiveData
    248                    
    249                    remainingDataLength -= MSC_Machine.MSBulkInEpSize;
   \   00000104   0x88B0             LDRH     R0,[R6, #+4]
   \   00000106   0x6AA9             LDR      R1,[R5, #+40]
   \   00000108   0x1A09             SUBS     R1,R1,R0
   \   0000010A   0x62A9             STR      R1,[R5, #+40]
    250                    datapointer = datapointer + MSC_Machine.MSBulkInEpSize;
   \   0000010C   0x6AE9             LDR      R1,[R5, #+44]
   \   0000010E   0x4408             ADD      R0,R1,R0
   \   00000110   0x62E8             STR      R0,[R5, #+44]
    251                    if(USBH_MSC_BOTXferParam.MSCStateCurrent == USBH_MSC_REQUEST_SENSE)
   \   00000112   0x78A8             LDRB     R0,[R5, #+2]
   \   00000114   0x2806             CMP      R0,#+6
   \   00000116   0xF040 0x80E3      BNE.W    ??USBH_MSC_HandleBOTXfer_1
    252                      USB_RespWaitCount = 1;
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x7038             STRB     R0,[R7, #+0]
   \   0000011E   0xE0DF             B.N      ??USBH_MSC_HandleBOTXfer_1
    253                  }
    254                  else if ( remainingDataLength == 0)
   \                     ??USBH_MSC_HandleBOTXfer_13: (+1)
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD102             BNE.N    ??USBH_MSC_HandleBOTXfer_14
    255                  {
    256                    /* If value was 0, and successful transfer, then change the state */
    257                    USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
   \   00000124   0x2005             MOVS     R0,#+5
   \   00000126   0x7128             STRB     R0,[R5, #+4]
   \   00000128   0xE0DA             B.N      ??USBH_MSC_HandleBOTXfer_1
    258                  }
    259                  else
    260                  {       
    261                    USBH_BulkReceiveData (pdev,
    262          	                        datapointer, 
    263          			        remainingDataLength , 
    264          			        MSC_Machine.hc_num_in);
   \                     ??USBH_MSC_HandleBOTXfer_14: (+1)
   \   0000012A   0x7833             LDRB     R3,[R6, #+0]
   \   0000012C   0x4602             MOV      R2,R0
   \   0000012E   0xB292             UXTH     R2,R2
   \   00000130   0x6AE9             LDR      R1,[R5, #+44]
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       USBH_BulkReceiveData
    265                    
    266                    remainingDataLength = 0; /* Reset this value and keep in same state */
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x62A8             STR      R0,[R5, #+40]
    267                    if(USBH_MSC_BOTXferParam.MSCStateCurrent == USBH_MSC_REQUEST_SENSE)
   \   0000013C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000013E   0x2806             CMP      R0,#+6
   \   00000140   0xF040 0x80CE      BNE.W    ??USBH_MSC_HandleBOTXfer_1
    268                      USB_RespWaitCount = 1;
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0x7038             STRB     R0,[R7, #+0]
   \   00000148   0xE0CA             B.N      ??USBH_MSC_HandleBOTXfer_1
    269                  }
    270                }
    271                else if(URB_Status == URB_STALL)
   \                     ??USBH_MSC_HandleBOTXfer_12: (+1)
   \   0000014A   0x2804             CMP      R0,#+4
   \   0000014C   0xF040 0x80C8      BNE.W    ??USBH_MSC_HandleBOTXfer_1
    272                {
    273                  /* This is Data Stage STALL Condition */
    274                  
    275                  error_direction = USBH_MSC_DIR_IN;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xF885 0x0020      STRB     R0,[R5, #+32]
    276                  USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
   \   00000156   0x2007             MOVS     R0,#+7
   \   00000158   0x7128             STRB     R0,[R5, #+4]
    277                  
    278                  /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    279                  6.7.2 Host expects to receive data from the device
    280                  3. On a STALL condition receiving data, then:
    281                  The host shall accept the data received.
    282                  The host shall clear the Bulk-In pipe.
    283                  4. The host shall attempt to receive a CSW.
    284                  
    285                  USBH_MSC_BOTXferParam.BOTStateBkp is used to switch to the Original 
    286                  state after the ClearFeature Command is issued.
    287                  */
    288                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
   \   0000015A   0x2005             MOVS     R0,#+5
   \   0000015C   0x7168             STRB     R0,[R5, #+5]
   \   0000015E   0xE0BF             B.N      ??USBH_MSC_HandleBOTXfer_1
    289                  
    290                }     
    291                break;   
    292                
    293                
    294              case USBH_MSC_BOT_DATAOUT_STATE:
    295                /* BOT DATA OUT stage */
    296                URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_out);       
   \                     ??USBH_MSC_HandleBOTXfer_15: (+1)
   \   00000160   0x....             LDR.N    R6,??DataTable3_5
   \   00000162   0x7871             LDRB     R1,[R6, #+1]
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       HCD_GetURB_State
    297                if(URB_Status == URB_DONE)
   \   0000016A   0x2801             CMP      R0,#+1
   \   0000016C   0xD124             BNE.N    ??USBH_MSC_HandleBOTXfer_16
    298                {
    299                  BOTStallErrorCount = 0;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x6268             STR      R0,[R5, #+36]
    300                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAOUT_STATE;    
   \   00000172   0x2004             MOVS     R0,#+4
   \   00000174   0x7168             STRB     R0,[R5, #+5]
    301                  if(remainingDataLength > MSC_Machine.MSBulkOutEpSize)
   \   00000176   0x6AA8             LDR      R0,[R5, #+40]
   \   00000178   0x88F2             LDRH     R2,[R6, #+6]
   \   0000017A   0x4282             CMP      R2,R0
   \   0000017C   0xD20D             BCS.N    ??USBH_MSC_HandleBOTXfer_17
    302                  {
    303                    USBH_BulkSendData (pdev,
    304                                       datapointer, 
    305                                       MSC_Machine.MSBulkOutEpSize , 
    306                                       MSC_Machine.hc_num_out);
   \   0000017E   0x7873             LDRB     R3,[R6, #+1]
   \   00000180   0x6AE9             LDR      R1,[R5, #+44]
   \   00000182   0x4620             MOV      R0,R4
   \   00000184   0x.... 0x....      BL       USBH_BulkSendData
    307                    datapointer_prev = datapointer;
   \   00000188   0x6AE8             LDR      R0,[R5, #+44]
   \   0000018A   0x6328             STR      R0,[R5, #+48]
    308                    datapointer = datapointer + MSC_Machine.MSBulkOutEpSize;
   \   0000018C   0x88F1             LDRH     R1,[R6, #+6]
   \   0000018E   0x4408             ADD      R0,R0,R1
   \   00000190   0x62E8             STR      R0,[R5, #+44]
    309                    
    310                    remainingDataLength = remainingDataLength - MSC_Machine.MSBulkOutEpSize;
   \   00000192   0x6AA8             LDR      R0,[R5, #+40]
   \   00000194   0x1A40             SUBS     R0,R0,R1
   \   00000196   0x62A8             STR      R0,[R5, #+40]
   \   00000198   0xE0A2             B.N      ??USBH_MSC_HandleBOTXfer_1
    311                  }
    312                  else if ( remainingDataLength == 0)
   \                     ??USBH_MSC_HandleBOTXfer_17: (+1)
   \   0000019A   0x2800             CMP      R0,#+0
   \   0000019C   0xD102             BNE.N    ??USBH_MSC_HandleBOTXfer_18
    313                  {
    314                    /* If value was 0, and successful transfer, then change the state */
    315                    USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
   \   0000019E   0x2005             MOVS     R0,#+5
   \   000001A0   0x7128             STRB     R0,[R5, #+4]
   \   000001A2   0xE09D             B.N      ??USBH_MSC_HandleBOTXfer_1
    316                  }
    317                  else
    318                  {
    319                    USBH_BulkSendData (pdev,
    320          	                     datapointer, 
    321          			     remainingDataLength , 
    322          			     MSC_Machine.hc_num_out);
   \                     ??USBH_MSC_HandleBOTXfer_18: (+1)
   \   000001A4   0x7873             LDRB     R3,[R6, #+1]
   \   000001A6   0x4602             MOV      R2,R0
   \   000001A8   0xB292             UXTH     R2,R2
   \   000001AA   0x6AE9             LDR      R1,[R5, #+44]
   \   000001AC   0x4620             MOV      R0,R4
   \   000001AE   0x.... 0x....      BL       USBH_BulkSendData
    323                    
    324                    remainingDataLength = 0; /* Reset this value and keep in same state */   
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x62A8             STR      R0,[R5, #+40]
   \   000001B6   0xE093             B.N      ??USBH_MSC_HandleBOTXfer_1
    325                  }      
    326                }
    327                
    328                else if(URB_Status == URB_NOTREADY)
   \                     ??USBH_MSC_HandleBOTXfer_16: (+1)
   \   000001B8   0x2802             CMP      R0,#+2
   \   000001BA   0xD113             BNE.N    ??USBH_MSC_HandleBOTXfer_19
    329                {
    330                  if(datapointer != datapointer_prev)
   \   000001BC   0x6AE9             LDR      R1,[R5, #+44]
   \   000001BE   0x7873             LDRB     R3,[R6, #+1]
   \   000001C0   0x88F2             LDRH     R2,[R6, #+6]
   \   000001C2   0x6B28             LDR      R0,[R5, #+48]
   \   000001C4   0x4281             CMP      R1,R0
   \   000001C6   0xD008             BEQ.N    ??USBH_MSC_HandleBOTXfer_20
    331                  {
    332                    USBH_BulkSendData (pdev,
    333                                       (datapointer - MSC_Machine.MSBulkOutEpSize), 
    334                                       MSC_Machine.MSBulkOutEpSize , 
    335                                       MSC_Machine.hc_num_out);
   \   000001C8   0x4610             MOV      R0,R2
   \   000001CA   0x4252             RSBS     R2,R2,#+0
   \   000001CC   0x4411             ADD      R1,R1,R2
   \   000001CE   0x4602             MOV      R2,R0
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000001D6   0x.... 0x....      B.W      USBH_BulkSendData
    336                  }
    337                  else
    338                  {
    339                    USBH_BulkSendData (pdev,
    340                                       datapointer,
    341                                       MSC_Machine.MSBulkOutEpSize , 
    342                                       MSC_Machine.hc_num_out);
   \                     ??USBH_MSC_HandleBOTXfer_20: (+1)
   \   000001DA   0x4620             MOV      R0,R4
   \   000001DC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000001E0   0x.... 0x....      B.W      USBH_BulkSendData
    343                  }
    344                }
    345                
    346                else if(URB_Status == URB_STALL)
   \                     ??USBH_MSC_HandleBOTXfer_19: (+1)
   \   000001E4   0x2804             CMP      R0,#+4
   \   000001E6   0xD17B             BNE.N    ??USBH_MSC_HandleBOTXfer_1
    347                {
    348                  error_direction = USBH_MSC_DIR_OUT;
   \   000001E8   0x2001             MOVS     R0,#+1
   \   000001EA   0xF885 0x0020      STRB     R0,[R5, #+32]
    349                  USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
   \   000001EE   0x2008             MOVS     R0,#+8
   \   000001F0   0x7128             STRB     R0,[R5, #+4]
    350                  
    351                  /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    352                  6.7.3 Ho - Host expects to send data to the device
    353                  3. On a STALL condition sending data, then:
    354                  " The host shall clear the Bulk-Out pipe.
    355                  4. The host shall attempt to receive a CSW.
    356                  
    357                  The Above statement will do the clear the Bulk-Out pipe.
    358                  The Below statement will help in Getting the CSW.  
    359                  
    360                  USBH_MSC_BOTXferParam.BOTStateBkp is used to switch to the Original 
    361                  state after the ClearFeature Command is issued.
    362                  */
    363                  
    364                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
   \   000001F2   0x2005             MOVS     R0,#+5
   \   000001F4   0x7168             STRB     R0,[R5, #+5]
   \   000001F6   0xE073             B.N      ??USBH_MSC_HandleBOTXfer_1
    365                  
    366                }
    367                break;
    368                
    369              case USBH_MSC_RECEIVE_CSW_STATE:
    370                /* BOT CSW stage */     
    371                  /* NOTE: We cannot reset the BOTStallErrorCount here as it may come from 
    372                  the clearFeature from previous command */
    373                  
    374                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
   \                     ??USBH_MSC_HandleBOTXfer_21: (+1)
   \   000001F8   0x2005             MOVS     R0,#+5
   \   000001FA   0x7168             STRB     R0,[R5, #+5]
    375                  
    376                  USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
   \   000001FC   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000200   0x60A8             STR      R0,[R5, #+8]
    377                  USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
   \   00000202   0x203F             MOVS     R0,#+63
   \   00000204   0x81A8             STRH     R0,[R5, #+12]
    378                  
    379                  for(index = USBH_MSC_CSW_LENGTH; index != 0; index--)
   \   00000206   0x200D             MOVS     R0,#+13
   \   00000208   0xE004             B.N      ??USBH_MSC_HandleBOTXfer_22
    380                  {
    381                    USBH_MSC_CSWData.CSWArray[index] = 0;
   \                     ??USBH_MSC_HandleBOTXfer_23: (+1)
   \   0000020A   0x2100             MOVS     R1,#+0
   \   0000020C   0xB2C0             UXTB     R0,R0
   \   0000020E   0x182A             ADDS     R2,R5,R0
   \   00000210   0x7411             STRB     R1,[R2, #+16]
    382                  }
   \   00000212   0x1E40             SUBS     R0,R0,#+1
   \                     ??USBH_MSC_HandleBOTXfer_22: (+1)
   \   00000214   0x4601             MOV      R1,R0
   \   00000216   0xB2C9             UXTB     R1,R1
   \   00000218   0x2900             CMP      R1,#+0
   \   0000021A   0xD1F6             BNE.N    ??USBH_MSC_HandleBOTXfer_23
    383                  
    384                  USBH_MSC_CSWData.CSWArray[0] = 0;
   \   0000021C   0x2000             MOVS     R0,#+0
   \   0000021E   0x7428             STRB     R0,[R5, #+16]
    385                  
    386                  USBH_BulkReceiveData (pdev,
    387                                        USBH_MSC_BOTXferParam.pRxTxBuff, 
    388                                        USBH_MSC_CSW_MAX_LENGTH , 
    389                                        MSC_Machine.hc_num_in);
   \   00000220   0x....             LDR.N    R0,??DataTable3_5
   \   00000222   0x7803             LDRB     R3,[R0, #+0]
   \   00000224   0x223F             MOVS     R2,#+63
   \   00000226   0x68A9             LDR      R1,[R5, #+8]
   \   00000228   0x4620             MOV      R0,R4
   \   0000022A   0x.... 0x....      BL       USBH_BulkReceiveData
    390                  USBH_MSC_BOTXferParam.BOTState = USBH_MSC_DECODE_CSW;   
   \   0000022E   0x2006             MOVS     R0,#+6
   \   00000230   0x7128             STRB     R0,[R5, #+4]
    391                  if(USBH_MSC_BOTXferParam.MSCStateCurrent == USBH_MSC_TEST_UNIT_READY)
   \   00000232   0x....             LDR.N    R7,??DataTable3_6
   \   00000234   0x78A8             LDRB     R0,[R5, #+2]
   \   00000236   0x2803             CMP      R0,#+3
   \   00000238   0xD102             BNE.N    ??USBH_MSC_HandleBOTXfer_24
    392                    USB_RespWaitCount = 1;
   \   0000023A   0x2001             MOVS     R0,#+1
   \   0000023C   0x7038             STRB     R0,[R7, #+0]
   \   0000023E   0xE04F             B.N      ??USBH_MSC_HandleBOTXfer_1
    393                  else
    394                    USB_RespWaitCount = 0;
   \                     ??USBH_MSC_HandleBOTXfer_24: (+1)
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0x7038             STRB     R0,[R7, #+0]
   \   00000244   0xE04C             B.N      ??USBH_MSC_HandleBOTXfer_1
    395          
    396                break;
    397                
    398              case USBH_MSC_DECODE_CSW:
    399                URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_in);
   \                     ??USBH_MSC_HandleBOTXfer_25: (+1)
   \   00000246   0x....             LDR.N    R0,??DataTable3_5
   \   00000248   0x7801             LDRB     R1,[R0, #+0]
   \   0000024A   0x4620             MOV      R0,R4
   \   0000024C   0x.... 0x....      BL       HCD_GetURB_State
    400                if(URB_Status != URB_IDLE) USB_RespWaitCount = 0;
   \   00000250   0x....             LDR.N    R7,??DataTable3_6
   \   00000252   0x2800             CMP      R0,#+0
   \   00000254   0xD002             BEQ.N    ??USBH_MSC_HandleBOTXfer_26
   \   00000256   0x2100             MOVS     R1,#+0
   \   00000258   0x7039             STRB     R1,[R7, #+0]
   \   0000025A   0xE007             B.N      ??USBH_MSC_HandleBOTXfer_27
    401                else if(USB_RespWaitCount > 100) {  // 1 sec
   \                     ??USBH_MSC_HandleBOTXfer_26: (+1)
   \   0000025C   0x7839             LDRB     R1,[R7, #+0]
   \   0000025E   0x2965             CMP      R1,#+101
   \   00000260   0xDB04             BLT.N    ??USBH_MSC_HandleBOTXfer_27
    402                  phost->gState = HOST_ERROR_STATE;
   \   00000262   0x210A             MOVS     R1,#+10
   \   00000264   0xF888 0x1000      STRB     R1,[R8, #+0]
    403                  USB_RespWaitCount = 0;
   \   00000268   0x2100             MOVS     R1,#+0
   \   0000026A   0x7039             STRB     R1,[R7, #+0]
    404                }      
    405                /* Decode CSW */
    406                if(URB_Status == URB_DONE)
   \                     ??USBH_MSC_HandleBOTXfer_27: (+1)
   \   0000026C   0x2801             CMP      R0,#+1
   \   0000026E   0xD10B             BNE.N    ??USBH_MSC_HandleBOTXfer_28
    407                {
    408                  BOTStallErrorCount = 0;
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0x6268             STR      R0,[R5, #+36]
    409                  USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
   \   00000274   0x2005             MOVS     R0,#+5
   \   00000276   0x7168             STRB     R0,[R5, #+5]
    410                  
    411                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateCurrent ;
   \   00000278   0x78A8             LDRB     R0,[R5, #+2]
   \   0000027A   0x7028             STRB     R0,[R5, #+0]
    412                  
    413                  USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_DecodeCSW(pdev , phost);
   \   0000027C   0x4641             MOV      R1,R8
   \   0000027E   0x4620             MOV      R0,R4
   \   00000280   0x.... 0x....      BL       USBH_MSC_DecodeCSW
   \   00000284   0x73E8             STRB     R0,[R5, #+15]
   \   00000286   0xE02B             B.N      ??USBH_MSC_HandleBOTXfer_1
    414                }
    415                else if(URB_Status == URB_STALL)     
   \                     ??USBH_MSC_HandleBOTXfer_28: (+1)
   \   00000288   0x2804             CMP      R0,#+4
   \   0000028A   0xD129             BNE.N    ??USBH_MSC_HandleBOTXfer_1
    416                {
    417                  error_direction = USBH_MSC_DIR_IN;
   \   0000028C   0x2000             MOVS     R0,#+0
   \   0000028E   0xF885 0x0020      STRB     R0,[R5, #+32]
    418                  USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
   \   00000292   0x2007             MOVS     R0,#+7
   \   00000294   0x7128             STRB     R0,[R5, #+4]
   \   00000296   0xE023             B.N      ??USBH_MSC_HandleBOTXfer_1
    419                }
    420                break;
    421                
    422              case USBH_MSC_BOT_ERROR_IN: 
    423                status = USBH_MSC_BOT_Abort(pdev, phost, USBH_MSC_DIR_IN);
   \                     ??USBH_MSC_HandleBOTXfer_29: (+1)
   \   00000298   0x2200             MOVS     R2,#+0
   \   0000029A   0x4641             MOV      R1,R8
   \   0000029C   0x4620             MOV      R0,R4
   \   0000029E   0x.... 0x....      BL       USBH_MSC_BOT_Abort
    424                if (status == USBH_OK)
   \   000002A2   0x2800             CMP      R0,#+0
   \   000002A4   0xD109             BNE.N    ??USBH_MSC_HandleBOTXfer_30
    425                {
    426                  /* Check if the error was due in Both the directions */
    427                  if (error_direction == USBH_MSC_BOTH_DIR)
   \   000002A6   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   000002AA   0x2802             CMP      R0,#+2
   \   000002AC   0xD102             BNE.N    ??USBH_MSC_HandleBOTXfer_31
    428                  {/* If Both directions are Needed, Switch to OUT Direction */
    429                    USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_ERROR_OUT;
   \   000002AE   0x2008             MOVS     R0,#+8
   \   000002B0   0x7128             STRB     R0,[R5, #+4]
   \   000002B2   0xE015             B.N      ??USBH_MSC_HandleBOTXfer_1
    430                  }
    431                  else
    432                  {
    433                    /* Switch Back to the Original State, In many cases this will be 
    434                    USBH_MSC_RECEIVE_CSW_STATE state */
    435                    USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;
   \                     ??USBH_MSC_HandleBOTXfer_31: (+1)
   \   000002B4   0x7968             LDRB     R0,[R5, #+5]
   \   000002B6   0x7128             STRB     R0,[R5, #+4]
   \   000002B8   0xE012             B.N      ??USBH_MSC_HandleBOTXfer_1
    436                  }
    437                }
    438                else if (status == USBH_UNRECOVERED_ERROR)
   \                     ??USBH_MSC_HandleBOTXfer_30: (+1)
   \   000002BA   0x2804             CMP      R0,#+4
   \   000002BC   0xD110             BNE.N    ??USBH_MSC_HandleBOTXfer_1
    439                {
    440                  /* This means that there is a STALL Error limit, Do Reset Recovery */
    441                  USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
   \   000002BE   0x2002             MOVS     R0,#+2
   \   000002C0   0x73E8             STRB     R0,[R5, #+15]
   \   000002C2   0xE00D             B.N      ??USBH_MSC_HandleBOTXfer_1
    442                }
    443                break;
    444                
    445              case USBH_MSC_BOT_ERROR_OUT: 
    446                status = USBH_MSC_BOT_Abort(pdev, phost, USBH_MSC_DIR_OUT);
   \                     ??USBH_MSC_HandleBOTXfer_32: (+1)
   \   000002C4   0x2201             MOVS     R2,#+1
   \   000002C6   0x4641             MOV      R1,R8
   \   000002C8   0x4620             MOV      R0,R4
   \   000002CA   0x.... 0x....      BL       USBH_MSC_BOT_Abort
    447                if ( status == USBH_OK)
   \   000002CE   0x2800             CMP      R0,#+0
   \   000002D0   0xD102             BNE.N    ??USBH_MSC_HandleBOTXfer_33
    448                { /* Switch Back to the Original State */
    449                  USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;        
   \   000002D2   0x7968             LDRB     R0,[R5, #+5]
   \   000002D4   0x7128             STRB     R0,[R5, #+4]
   \   000002D6   0xE003             B.N      ??USBH_MSC_HandleBOTXfer_1
    450                }
    451                else if (status == USBH_UNRECOVERED_ERROR)
   \                     ??USBH_MSC_HandleBOTXfer_33: (+1)
   \   000002D8   0x2804             CMP      R0,#+4
   \   000002DA   0xD101             BNE.N    ??USBH_MSC_HandleBOTXfer_1
    452                {
    453                  /* This means that there is a STALL Error limit, Do Reset Recovery */
    454                  USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
   \   000002DC   0x2002             MOVS     R0,#+2
   \   000002DE   0x73E8             STRB     R0,[R5, #+15]
    455                }
    456                break;
    457                
    458              default:      
    459                break;
    460              }
    461            }
    462          }
   \                     ??USBH_MSC_HandleBOTXfer_1: (+1)
   \   000002E0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     USBH_MSC_BOTXferParam:
   \   00000000                      DS8 16
   \                     USBH_MSC_CSWData:
   \   00000010                      DS8 16
   \   00000020                      DS8 1
   \   00000021                      DS8 3
   \   00000024                      DS8 4
   \   00000028                      DS8 4
   \   0000002C                      DS8 4
   \   00000030                      DS8 4
    463          
    464          /**
    465          * @brief  USBH_MSC_BOT_Abort 
    466          *         This function manages the different Error handling for STALL
    467          * @param  direction : IN / OUT 
    468          * @retval None
    469          */

   \                                 In section .text, align 2, keep-with-next
    470          USBH_Status USBH_MSC_BOT_Abort(USB_OTG_CORE_HANDLE *pdev, 
    471                                         USBH_HOST *phost,
    472                                         uint8_t direction)
    473          {
   \                     USBH_MSC_BOT_Abort: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    474            USBH_Status status;
    475            
    476            status = USBH_BUSY;
   \   00000002   0x2301             MOVS     R3,#+1
    477            
    478            switch (direction)
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD002             BEQ.N    ??USBH_MSC_BOT_Abort_0
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD007             BEQ.N    ??USBH_MSC_BOT_Abort_1
   \   0000000C   0xE00C             B.N      ??USBH_MSC_BOT_Abort_2
    479            {
    480            case USBH_MSC_DIR_IN :
    481              /* send ClrFeture on Bulk IN endpoint */
    482              status = USBH_ClrFeature(pdev,
    483                                       phost,
    484                                       MSC_Machine.MSBulkInEp,
    485                                       MSC_Machine.hc_num_in);
   \                     ??USBH_MSC_BOT_Abort_0: (+1)
   \   0000000E   0x....             LDR.N    R2,??DataTable3_5
   \   00000010   0x7813             LDRB     R3,[R2, #+0]
   \   00000012   0x78D2             LDRB     R2,[R2, #+3]
   \   00000014   0x.... 0x....      BL       USBH_ClrFeature
   \   00000018   0x4603             MOV      R3,R0
    486              
    487              break;
   \   0000001A   0xE005             B.N      ??USBH_MSC_BOT_Abort_2
    488              
    489            case USBH_MSC_DIR_OUT :
    490              /*send ClrFeature on Bulk OUT endpoint */
    491              status = USBH_ClrFeature(pdev, 
    492                                       phost,
    493                                       MSC_Machine.MSBulkOutEp,
    494                                       MSC_Machine.hc_num_out);
   \                     ??USBH_MSC_BOT_Abort_1: (+1)
   \   0000001C   0x....             LDR.N    R2,??DataTable3_5
   \   0000001E   0x7853             LDRB     R3,[R2, #+1]
   \   00000020   0x7892             LDRB     R2,[R2, #+2]
   \   00000022   0x.... 0x....      BL       USBH_ClrFeature
   \   00000026   0x4603             MOV      R3,R0
    495              break;
    496              
    497            default:
    498              break;
    499            }
    500            
    501            BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
   \                     ??USBH_MSC_BOT_Abort_2: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable3
   \   0000002A   0x6A41             LDR      R1,[R0, #+36]
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x6241             STR      R1,[R0, #+36]
    502            if (BOTStallErrorCount > MAX_BULK_STALL_COUNT_LIMIT )
   \   00000030   0x2905             CMP      R1,#+5
   \   00000032   0xD300             BCC.N    ??USBH_MSC_BOT_Abort_3
    503            {
    504              status = USBH_UNRECOVERED_ERROR;
   \   00000034   0x2304             MOVS     R3,#+4
    505            }
    506            
    507            return status;
   \                     ??USBH_MSC_BOT_Abort_3: (+1)
   \   00000036   0x4618             MOV      R0,R3
   \   00000038   0xBD02             POP      {R1,PC}          ;; return
    508          }
    509          
    510          /**
    511          * @brief  USBH_MSC_DecodeCSW
    512          *         This function decodes the CSW received by the device and updates the
    513          *         same to upper layer.
    514          * @param  None
    515          * @retval On success USBH_MSC_OK, on failure USBH_MSC_FAIL
    516          * @notes
    517          *     Refer to USB Mass-Storage Class : BOT (www.usb.org)
    518          *    6.3.1 Valid CSW Conditions :
    519          *     The host shall consider the CSW valid when:
    520          *     1. dCSWSignature is equal to 53425355h
    521          *     2. the CSW is 13 (Dh) bytes in length,
    522          *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
    523          */
    524          

   \                                 In section .text, align 2, keep-with-next
    525          uint8_t USBH_MSC_DecodeCSW(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
    526          {
   \                     USBH_MSC_DecodeCSW: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    527            uint8_t status;
    528            uint32_t dataXferCount = 0;
    529            status = USBH_MSC_FAIL;
   \   00000004   0x2401             MOVS     R4,#+1
    530            
    531            if(HCD_IsDeviceConnected(pdev))
   \   00000006   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01E             BEQ.N    ??USBH_MSC_DecodeCSW_0
    532            {
    533              /*Checking if the transfer length is diffrent than 13*/
    534              dataXferCount = HCD_GetXferCnt(pdev, MSC_Machine.hc_num_in); 
    535              
    536              if(dataXferCount != USBH_MSC_CSW_LENGTH)
   \   0000000E   0x....             LDR.N    R0,??DataTable3_5
   \   00000010   0x7801             LDRB     R1,[R0, #+0]
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       HCD_GetXferCnt
   \   00000018   0x280D             CMP      R0,#+13
   \   0000001A   0xD001             BEQ.N    ??USBH_MSC_DecodeCSW_1
    537              {
    538                /*(4) Hi > Dn (Host expects to receive data from the device,
    539                Device intends to transfer no data)
    540                (5) Hi > Di (Host expects to receive data from the device,
    541                Device intends to send data to the host)
    542                (9) Ho > Dn (Host expects to send data to the device,
    543                Device intends to transfer no data)
    544                (11) Ho > Do  (Host expects to send data to the device,
    545                Device intends to receive data from the host)*/
    546                
    547                
    548                status = USBH_MSC_PHASE_ERROR;
   \   0000001C   0x2402             MOVS     R4,#+2
   \   0000001E   0xE015             B.N      ??USBH_MSC_DecodeCSW_0
    549              }
    550              else
    551              { /* CSW length is Correct */
    552                
    553                /* Check validity of the CSW Signature and CSWStatus */
    554                if(USBH_MSC_CSWData.field.CSWSignature == USBH_MSC_BOT_CSW_SIGNATURE)
   \                     ??USBH_MSC_DecodeCSW_1: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable3
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0x....             LDR.N    R2,??DataTable3_7  ;; 0x53425355
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD10F             BNE.N    ??USBH_MSC_DecodeCSW_2
    555                {/* Check Condition 1. dCSWSignature is equal to 53425355h */
    556                  
    557                  if(USBH_MSC_CSWData.field.CSWTag == USBH_MSC_CBWData.field.CBWTag)
   \   0000002A   0x6941             LDR      R1,[R0, #+20]
   \   0000002C   0x....             LDR.N    R2,??DataTable3_1
   \   0000002E   0x6852             LDR      R2,[R2, #+4]
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xD10B             BNE.N    ??USBH_MSC_DecodeCSW_0
    558                  {
    559                    /* Check Condition 3. dCSWTag matches the dCBWTag from the 
    560                    corresponding CBW */
    561                    
    562                    if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_OK) 
   \   00000034   0x7F00             LDRB     R0,[R0, #+28]
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0xD101             BNE.N    ??USBH_MSC_DecodeCSW_3
    563                    {
    564                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    565                      
    566                      Hn Host expects no data transfers
    567                      Hi Host expects to receive data from the device
    568                      Ho Host expects to send data to the device
    569                      
    570                      Dn Device intends to transfer no data
    571                      Di Device intends to send data to the host
    572                      Do Device intends to receive data from the host
    573                      
    574                      Section 6.7 
    575                      (1) Hn = Dn (Host expects no data transfers,
    576                      Device intends to transfer no data)
    577                      (6) Hi = Di (Host expects to receive data from the device,
    578                      Device intends to send data to the host)
    579                      (12) Ho = Do (Host expects to send data to the device, 
    580                      Device intends to receive data from the host)
    581                      
    582                      */
    583                      
    584                      status = USBH_MSC_OK;
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0xE006             B.N      ??USBH_MSC_DecodeCSW_0
    585                    }
    586                    else if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_FAIL)
   \                     ??USBH_MSC_DecodeCSW_3: (+1)
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD004             BEQ.N    ??USBH_MSC_DecodeCSW_0
    587                    {
    588                      status = USBH_MSC_FAIL;
    589                    }
    590                    
    591                    else if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_PHASE_ERROR)
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD102             BNE.N    ??USBH_MSC_DecodeCSW_0
    592                    { 
    593                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    594                      Section 6.7 
    595                      (2) Hn < Di ( Host expects no data transfers, 
    596                      Device intends to send data to the host)
    597                      (3) Hn < Do ( Host expects no data transfers, 
    598                      Device intends to receive data from the host)
    599                      (7) Hi < Di ( Host expects to receive data from the device, 
    600                      Device intends to send data to the host)
    601                      (8) Hi <> Do ( Host expects to receive data from the device, 
    602                      Device intends to receive data from the host)
    603                      (10) Ho <> Di (Host expects to send data to the device,
    604                      Di Device intends to send data to the host)
    605                      (13) Ho < Do (Host expects to send data to the device, 
    606                      Device intends to receive data from the host)
    607                      */
    608                      
    609                      status = USBH_MSC_PHASE_ERROR;
   \   00000046   0x2402             MOVS     R4,#+2
   \   00000048   0xE000             B.N      ??USBH_MSC_DecodeCSW_0
    610                    }
    611                  } /* CSW Tag Matching is Checked  */
    612                } /* CSW Signature Correct Checking */
    613                else
    614                {
    615                  /* If the CSW Signature is not valid, We sall return the Phase Error to
    616                  Upper Layers for Reset Recovery */
    617                  
    618                  status = USBH_MSC_PHASE_ERROR;
   \                     ??USBH_MSC_DecodeCSW_2: (+1)
   \   0000004A   0x2402             MOVS     R4,#+2
    619                }
    620              } /* CSW Length Check*/
    621            }
    622            
    623            USBH_MSC_BOTXferParam.BOTXferStatus  = status;
   \                     ??USBH_MSC_DecodeCSW_0: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable3
   \   0000004E   0x73C4             STRB     R4,[R0, #+15]
    624            return status;
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    625          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     USBH_MSC_BOTXferParam

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     USBH_MSC_CBWData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x43425355         DC32     0x43425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x20304050         DC32     0x20304050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     MSCErrorCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     MSC_Machine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     USB_RespWaitCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x53425355         DC32     0x53425355
    626          
    627          
    628          /**
    629          * @}
    630          */ 
    631          
    632          /**
    633          * @}
    634          */ 
    635          
    636          /**
    637          * @}
    638          */
    639          
    640          /**
    641          * @}
    642          */ 
    643          
    644          /**
    645          * @}
    646          */
    647          
    648          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    649          
    650          
    651          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USBH_MSC_BOT_Abort
         8   -> USBH_ClrFeature
      16   USBH_MSC_DecodeCSW
        16   -> HCD_GetXferCnt
        16   -> HCD_IsDeviceConnected
      24   USBH_MSC_HandleBOTXfer
        24   -> HCD_GetURB_State
        24   -> HCD_IsDeviceConnected
        24   -> USBH_BulkReceiveData
         0   -> USBH_BulkSendData
        24   -> USBH_BulkSendData
        24   -> USBH_MSC_BOT_Abort
        24   -> USBH_MSC_DecodeCSW
       8   USBH_MSC_Init
         8   -> HCD_IsDeviceConnected


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
      52  USBH_MSC_BOTXferParam
          USBH_MSC_CSWData
          error_direction
          BOTStallErrorCount
          remainingDataLength
          datapointer
          datapointer_prev
      58  USBH_MSC_BOT_Abort
      32  USBH_MSC_CBWData
      84  USBH_MSC_DecodeCSW
     740  USBH_MSC_HandleBOTXfer
      50  USBH_MSC_Init

 
  84 bytes in section .bss
 964 bytes in section .text
 
 964 bytes of CODE memory
  84 bytes of DATA memory

Errors: none
Warnings: none
