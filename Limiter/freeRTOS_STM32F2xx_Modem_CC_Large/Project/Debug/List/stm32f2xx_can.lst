###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\stm32f2xx_can.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\stm32f2xx_can.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    07-October-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           - Initialization and Configuration 
     10            *           - CAN Frames Transmission 
     11            *           - CAN Frames Reception    
     12            *           - Operation modes switch  
     13            *           - Error management          
     14            *           - Interrupts and flags        
     15            *         
     16            *  @verbatim
     17            *                               
     18            *          ===================================================================      
     19            *                                   How to use this driver
     20            *          ===================================================================
     21                          
     22            *          1.  Enable the CAN controller interface clock using 
     23            *                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     24            *              and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     25            *  @note   In case you are using CAN2 only, you have to enable the CAN1 clock.
     26            *     
     27            *          2. CAN pins configuration
     28            *               - Enable the clock for the CAN GPIOs using the following function:
     29            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30            *               - Connect the involved CAN pins to AF9 using the following function 
     31            *                   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     32            *                - Configure these CAN pins in alternate function mode by calling
     33            *                  the function  GPIO_Init();
     34            *    
     35            *          3.  Initialise and configure the CAN using CAN_Init() and 
     36            *               CAN_FilterInit() functions.   
     37            *               
     38            *          4.  Transmit the desired CAN frame using CAN_Transmit() function.
     39            *         
     40            *          5.  Check the transmission of a CAN frame using CAN_TransmitStatus()
     41            *              function.
     42            *               
     43            *          6.  Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     44            *              function.  
     45            *            
     46            *          7.  Receive a CAN frame using CAN_Recieve() function.
     47            *         
     48            *          8.  Release the receive FIFOs using CAN_FIFORelease() function.
     49            *               
     50            *          9. Return the number of pending received frames using 
     51            *              CAN_MessagePending() function.            
     52            *                   
     53            *          10. To control CAN events you can use one of the following two methods:
     54            *               - Check on CAN flags using the CAN_GetFlagStatus() function.  
     55            *               - Use CAN interrupts through the function CAN_ITConfig() at 
     56            *                 initialization phase and CAN_GetITStatus() function into 
     57            *                 interrupt routines to check if the event has occurred or not.
     58            *             After checking on a flag you should clear it using CAN_ClearFlag()
     59            *             function. And after checking on an interrupt event you should 
     60            *             clear it using CAN_ClearITPendingBit() function.            
     61            *               
     62            *              
     63            *  @endverbatim
     64            *         
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     69            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     70            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     71            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     72            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     73            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     76            ******************************************************************************  
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32f2xx_can.h"
     81          #include "stm32f2xx_rcc.h"
     82          
     83          /** @addtogroup STM32F2xx_StdPeriph_Driver
     84            * @{
     85            */
     86          
     87          /** @defgroup CAN 
     88            * @brief CAN driver modules
     89            * @{
     90            */ 
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          
     94          /* CAN Master Control Register bits */
     95          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     96          
     97          /* CAN Mailbox Transmit Request */
     98          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
     99          
    100          /* CAN Filter Master Register bits */
    101          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    102          
    103          /* Time out for INAK bit */
    104          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    105          /* Time out for SLAK bit */
    106          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    107          
    108          /* Flags in TSR register */
    109          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    110          /* Flags in RF1R register */
    111          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    112          /* Flags in RF0R register */
    113          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    114          /* Flags in MSR register */
    115          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    116          /* Flags in ESR register */
    117          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    118          
    119          /* Mailboxes definition */
    120          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    121          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    122          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    123          
    124          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    125          
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /* Private function prototypes -----------------------------------------------*/
    129          /* Private functions ---------------------------------------------------------*/
    130          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    131          
    132          /** @defgroup CAN_Private_Functions
    133            * @{
    134            */
    135          
    136          /** @defgroup CAN_Group1 Initialization and Configuration functions
    137           *  @brief    Initialization and Configuration functions 
    138           *
    139          @verbatim    
    140           ===============================================================================
    141                                Initialization and Configuration functions
    142           ===============================================================================  
    143            This section provides functions allowing to 
    144             - Initialize the CAN peripherals : Prescaler, operating mode, the maximum number 
    145               of time quanta to perform resynchronization, the number of time quanta in
    146               Bit Segment 1 and 2 and many other modes. 
    147               Refer to  @ref CAN_InitTypeDef  for more details.
    148             - Configures the CAN reception filter.                                      
    149             - Select the start bank filter for slave CAN.
    150             - Enables or disables the Debug Freeze mode for CAN
    151             - Enables or disables the CAN Time Trigger Operation communication mode
    152             
    153          @endverbatim
    154            * @{
    155            */
    156            
    157          /**
    158            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    159            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    160            * @retval None.
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          void CAN_DeInit(CAN_TypeDef* CANx)
    163          {
   \                     CAN_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    164            /* Check the parameters */
    165            assert_param(IS_CAN_ALL_PERIPH(CANx));
    166           
    167            if (CANx == CAN1)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable6  ;; 0x40006400
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD10B             BNE.N    ??CAN_DeInit_0
    168            {
    169              /* Enable CAN1 reset state */
    170              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF04F 0x7000      MOV      R0,#+33554432
   \   00000010   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    171              /* Release CAN1 from reset state */
    172              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF04F 0x7000      MOV      R0,#+33554432
   \   0000001A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    173            }
    174            else
    175            {  
    176              /* Enable CAN2 reset state */
    177              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_0: (+1)
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000028   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    178              /* Release CAN2 from reset state */
    179              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000032   0xE8BD 0x4004      POP      {R2,LR}
   \   00000036   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    180            }
    181          }
    182          
    183          /**
    184            * @brief  Initializes the CAN peripheral according to the specified
    185            *         parameters in the CAN_InitStruct.
    186            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    187            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    188            *         the configuration information for the CAN peripheral.
    189            * @retval Constant indicates initialization succeed which will be 
    190            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    191            */

   \                                 In section .text, align 2, keep-with-next
    192          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    193          {
   \                     CAN_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    194            uint8_t InitStatus = CAN_InitStatus_Failed;
   \   00000002   0x2200             MOVS     R2,#+0
    195            uint32_t wait_ack = 0x00000000;
   \   00000004   0x4613             MOV      R3,R2
    196            /* Check the parameters */
    197            assert_param(IS_CAN_ALL_PERIPH(CANx));
    198            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    199            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    200            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    201            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    202            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    204            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    205            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    206            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    207            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    208            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    209          
    210            /* Exit from sleep mode */
    211            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
   \   00000006   0x6804             LDR      R4,[R0, #+0]
   \   00000008   0xF06F 0x0502      MVN      R5,#+2
   \   0000000C   0x402C             ANDS     R4,R5,R4
   \   0000000E   0x6004             STR      R4,[R0, #+0]
    212          
    213            /* Request initialisation */
    214            CANx->MCR |= CAN_MCR_INRQ ;
   \   00000010   0x6804             LDR      R4,[R0, #+0]
   \   00000012   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000016   0x6004             STR      R4,[R0, #+0]
   \   00000018   0xE000             B.N      ??CAN_Init_0
    215          
    216            /* Wait the acknowledge */
    217            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    218            {
    219              wait_ack++;
   \                     ??CAN_Init_1: (+1)
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
    220            }
   \                     ??CAN_Init_0: (+1)
   \   0000001C   0x6844             LDR      R4,[R0, #+4]
   \   0000001E   0x07E4             LSLS     R4,R4,#+31
   \   00000020   0xD403             BMI.N    ??CAN_Init_2
   \   00000022   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000026   0x42A3             CMP      R3,R4
   \   00000028   0xD1F7             BNE.N    ??CAN_Init_1
    221          
    222            /* Check acknowledge */
    223            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_2: (+1)
   \   0000002A   0x6843             LDR      R3,[R0, #+4]
   \   0000002C   0x07DB             LSLS     R3,R3,#+31
   \   0000002E   0xD569             BPL.N    ??CAN_Init_3
    224            {
    225              InitStatus = CAN_InitStatus_Failed;
    226            }
    227            else 
    228            {
    229              /* Set the time triggered communication mode */
    230              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \   00000030   0x798A             LDRB     R2,[R1, #+6]
   \   00000032   0x2A01             CMP      R2,#+1
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0xD103             BNE.N    ??CAN_Init_4
    231              {
    232                CANx->MCR |= CAN_MCR_TTCM;
   \   00000038   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000003C   0x6002             STR      R2,[R0, #+0]
   \   0000003E   0xE003             B.N      ??CAN_Init_5
    233              }
    234              else
    235              {
    236                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
   \                     ??CAN_Init_4: (+1)
   \   00000040   0xF06F 0x0380      MVN      R3,#+128
   \   00000044   0x401A             ANDS     R2,R3,R2
   \   00000046   0x6002             STR      R2,[R0, #+0]
    237              }
    238          
    239              /* Set the automatic bus-off management */
    240              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_5: (+1)
   \   00000048   0x79CA             LDRB     R2,[R1, #+7]
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0x6802             LDR      R2,[R0, #+0]
   \   0000004E   0xD103             BNE.N    ??CAN_Init_6
    241              {
    242                CANx->MCR |= CAN_MCR_ABOM;
   \   00000050   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000054   0x6002             STR      R2,[R0, #+0]
   \   00000056   0xE003             B.N      ??CAN_Init_7
    243              }
    244              else
    245              {
    246                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
   \                     ??CAN_Init_6: (+1)
   \   00000058   0xF06F 0x0340      MVN      R3,#+64
   \   0000005C   0x401A             ANDS     R2,R3,R2
   \   0000005E   0x6002             STR      R2,[R0, #+0]
    247              }
    248          
    249              /* Set the automatic wake-up mode */
    250              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_7: (+1)
   \   00000060   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000062   0x2A01             CMP      R2,#+1
   \   00000064   0x6802             LDR      R2,[R0, #+0]
   \   00000066   0xD103             BNE.N    ??CAN_Init_8
    251              {
    252                CANx->MCR |= CAN_MCR_AWUM;
   \   00000068   0xF042 0x0220      ORR      R2,R2,#0x20
   \   0000006C   0x6002             STR      R2,[R0, #+0]
   \   0000006E   0xE003             B.N      ??CAN_Init_9
    253              }
    254              else
    255              {
    256                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
   \                     ??CAN_Init_8: (+1)
   \   00000070   0xF06F 0x0320      MVN      R3,#+32
   \   00000074   0x401A             ANDS     R2,R3,R2
   \   00000076   0x6002             STR      R2,[R0, #+0]
    257              }
    258          
    259              /* Set the no automatic retransmission */
    260              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_9: (+1)
   \   00000078   0x7A4A             LDRB     R2,[R1, #+9]
   \   0000007A   0x2A01             CMP      R2,#+1
   \   0000007C   0x6802             LDR      R2,[R0, #+0]
   \   0000007E   0xD103             BNE.N    ??CAN_Init_10
    261              {
    262                CANx->MCR |= CAN_MCR_NART;
   \   00000080   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000084   0x6002             STR      R2,[R0, #+0]
   \   00000086   0xE003             B.N      ??CAN_Init_11
    263              }
    264              else
    265              {
    266                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
   \                     ??CAN_Init_10: (+1)
   \   00000088   0xF06F 0x0310      MVN      R3,#+16
   \   0000008C   0x401A             ANDS     R2,R3,R2
   \   0000008E   0x6002             STR      R2,[R0, #+0]
    267              }
    268          
    269              /* Set the receive FIFO locked mode */
    270              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_11: (+1)
   \   00000090   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000092   0x2A01             CMP      R2,#+1
   \   00000094   0x6802             LDR      R2,[R0, #+0]
   \   00000096   0xD103             BNE.N    ??CAN_Init_12
    271              {
    272                CANx->MCR |= CAN_MCR_RFLM;
   \   00000098   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000009C   0x6002             STR      R2,[R0, #+0]
   \   0000009E   0xE003             B.N      ??CAN_Init_13
    273              }
    274              else
    275              {
    276                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
   \                     ??CAN_Init_12: (+1)
   \   000000A0   0xF06F 0x0308      MVN      R3,#+8
   \   000000A4   0x401A             ANDS     R2,R3,R2
   \   000000A6   0x6002             STR      R2,[R0, #+0]
    277              }
    278          
    279              /* Set the transmit FIFO priority */
    280              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_13: (+1)
   \   000000A8   0x7ACA             LDRB     R2,[R1, #+11]
   \   000000AA   0x2A01             CMP      R2,#+1
   \   000000AC   0x6802             LDR      R2,[R0, #+0]
   \   000000AE   0xD103             BNE.N    ??CAN_Init_14
    281              {
    282                CANx->MCR |= CAN_MCR_TXFP;
   \   000000B0   0xF042 0x0204      ORR      R2,R2,#0x4
   \   000000B4   0x6002             STR      R2,[R0, #+0]
   \   000000B6   0xE003             B.N      ??CAN_Init_15
    283              }
    284              else
    285              {
    286                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
   \                     ??CAN_Init_14: (+1)
   \   000000B8   0xF06F 0x0304      MVN      R3,#+4
   \   000000BC   0x401A             ANDS     R2,R3,R2
   \   000000BE   0x6002             STR      R2,[R0, #+0]
    287              }
    288          
    289              /* Set the bit timing register */
    290              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    291                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    292                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    293                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    294                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_15: (+1)
   \   000000C0   0x788A             LDRB     R2,[R1, #+2]
   \   000000C2   0x78CB             LDRB     R3,[R1, #+3]
   \   000000C4   0x061B             LSLS     R3,R3,#+24
   \   000000C6   0xEA43 0x7282      ORR      R2,R3,R2, LSL #+30
   \   000000CA   0x790B             LDRB     R3,[R1, #+4]
   \   000000CC   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   000000D0   0x794B             LDRB     R3,[R1, #+5]
   \   000000D2   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   000000D6   0x8809             LDRH     R1,[R1, #+0]
   \   000000D8   0x1E49             SUBS     R1,R1,#+1
   \   000000DA   0x4311             ORRS     R1,R1,R2
   \   000000DC   0x61C1             STR      R1,[R0, #+28]
    295          
    296              /* Request leave initialisation */
    297              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0x0849             LSRS     R1,R1,#+1
   \   000000E2   0x0049             LSLS     R1,R1,#+1
   \   000000E4   0x6001             STR      R1,[R0, #+0]
    298          
    299             /* Wait the acknowledge */
    300             wait_ack = 0;
   \   000000E6   0x2300             MOVS     R3,#+0
   \   000000E8   0xE000             B.N      ??CAN_Init_16
    301          
    302             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    303             {
    304               wait_ack++;
   \                     ??CAN_Init_17: (+1)
   \   000000EA   0x1C5B             ADDS     R3,R3,#+1
    305             }
   \                     ??CAN_Init_16: (+1)
   \   000000EC   0x6841             LDR      R1,[R0, #+4]
   \   000000EE   0x07C9             LSLS     R1,R1,#+31
   \   000000F0   0xD503             BPL.N    ??CAN_Init_18
   \   000000F2   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000F6   0x428B             CMP      R3,R1
   \   000000F8   0xD1F7             BNE.N    ??CAN_Init_17
    306          
    307              /* ...and check acknowledged */
    308              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_18: (+1)
   \   000000FA   0x6840             LDR      R0,[R0, #+4]
    309              {
    310                InitStatus = CAN_InitStatus_Failed;
    311              }
    312              else
    313              {
    314                InitStatus = CAN_InitStatus_Success ;
   \   000000FC   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000100   0xF080 0x0201      EOR      R2,R0,#0x1
    315              }
    316            }
    317          
    318            /* At this step, return the status of initialization */
    319            return InitStatus;
   \                     ??CAN_Init_3: (+1)
   \   00000104   0x4610             MOV      R0,R2
   \   00000106   0xBC30             POP      {R4,R5}
   \   00000108   0x4770             BX       LR               ;; return
    320          }
    321          
    322          /**
    323            * @brief  Configures the CAN reception filter according to the specified
    324            *         parameters in the CAN_FilterInitStruct.
    325            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    326            *         contains the configuration information.
    327            * @retval None
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    330          {
   \                     CAN_FilterInit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    331            uint32_t filter_number_bit_pos = 0;
    332            /* Check the parameters */
    333            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    334            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    335            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    336            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    337            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    338          
    339            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7A82             LDRB     R2,[R0, #+10]
   \   00000006   0x4091             LSLS     R1,R1,R2
    340          
    341            /* Initialisation mode for the filter */
    342            CAN1->FMR |= FMR_FINIT;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   0000000C   0x6813             LDR      R3,[R2, #+0]
   \   0000000E   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000012   0x6013             STR      R3,[R2, #+0]
    343          
    344            /* Filter Deactivation */
    345            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000014   0x43CB             MVNS     R3,R1
   \   00000016   0x69D4             LDR      R4,[R2, #+28]
   \   00000018   0x401C             ANDS     R4,R3,R4
   \   0000001A   0x61D4             STR      R4,[R2, #+28]
    346          
    347            /* Filter Scale */
    348            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   0000001C   0x7B04             LDRB     R4,[R0, #+12]
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD113             BNE.N    ??CAN_FilterInit_0
    349            {
    350              /* 16-bit scale for the filter */
    351              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000022   0x68D4             LDR      R4,[R2, #+12]
   \   00000024   0x401C             ANDS     R4,R3,R4
   \   00000026   0x60D4             STR      R4,[R2, #+12]
    352          
    353              /* First 16-bit identifier and First 16-bit mask */
    354              /* Or First 16-bit identifier and Second 16-bit identifier */
    355              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    356                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    357                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000028   0x.... 0x....      LDR.W    R4,??DataTable6_2  ;; 0x40006640
   \   0000002C   0x88C5             LDRH     R5,[R0, #+6]
   \   0000002E   0x8846             LDRH     R6,[R0, #+2]
   \   00000030   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000034   0x7A86             LDRB     R6,[R0, #+10]
   \   00000036   0xF844 0x5036      STR      R5,[R4, R6, LSL #+3]
    358          
    359              /* Second 16-bit identifier and Second 16-bit mask */
    360              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    361              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    362                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    363                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   0000003A   0x7A85             LDRB     R5,[R0, #+10]
   \   0000003C   0xEB04 0x04C5      ADD      R4,R4,R5, LSL #+3
   \   00000040   0x8885             LDRH     R5,[R0, #+4]
   \   00000042   0x8806             LDRH     R6,[R0, #+0]
   \   00000044   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000048   0x6065             STR      R5,[R4, #+4]
    364            }
    365          
    366            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0: (+1)
   \   0000004A   0x7B04             LDRB     R4,[R0, #+12]
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xD113             BNE.N    ??CAN_FilterInit_1
    367            {
    368              /* 32-bit scale for the filter */
    369              CAN1->FS1R |= filter_number_bit_pos;
   \   00000050   0x68D4             LDR      R4,[R2, #+12]
   \   00000052   0x430C             ORRS     R4,R1,R4
   \   00000054   0x60D4             STR      R4,[R2, #+12]
    370              /* 32-bit identifier or First 32-bit identifier */
    371              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    372                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    373                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000056   0x.... 0x....      LDR.W    R4,??DataTable6_2  ;; 0x40006640
   \   0000005A   0x8805             LDRH     R5,[R0, #+0]
   \   0000005C   0x8846             LDRH     R6,[R0, #+2]
   \   0000005E   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000062   0x7A86             LDRB     R6,[R0, #+10]
   \   00000064   0xF844 0x5036      STR      R5,[R4, R6, LSL #+3]
    374              /* 32-bit mask or Second 32-bit identifier */
    375              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    376                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    377                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   00000068   0x7A85             LDRB     R5,[R0, #+10]
   \   0000006A   0xEB04 0x04C5      ADD      R4,R4,R5, LSL #+3
   \   0000006E   0x8885             LDRH     R5,[R0, #+4]
   \   00000070   0x88C6             LDRH     R6,[R0, #+6]
   \   00000072   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000076   0x6065             STR      R5,[R4, #+4]
    378            }
    379          
    380            /* Filter Mode */
    381            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1: (+1)
   \   00000078   0x7AC4             LDRB     R4,[R0, #+11]
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0x6854             LDR      R4,[R2, #+4]
   \   0000007E   0xD102             BNE.N    ??CAN_FilterInit_2
    382            {
    383              /*Id/Mask mode for the filter*/
    384              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000080   0x401C             ANDS     R4,R3,R4
   \   00000082   0x6054             STR      R4,[R2, #+4]
   \   00000084   0xE001             B.N      ??CAN_FilterInit_3
    385            }
    386            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    387            {
    388              /*Identifier list mode for the filter*/
    389              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_2: (+1)
   \   00000086   0x430C             ORRS     R4,R1,R4
   \   00000088   0x6054             STR      R4,[R2, #+4]
    390            }
    391          
    392            /* Filter FIFO assignment */
    393            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
   \                     ??CAN_FilterInit_3: (+1)
   \   0000008A   0x8904             LDRH     R4,[R0, #+8]
   \   0000008C   0x2C00             CMP      R4,#+0
   \   0000008E   0xD102             BNE.N    ??CAN_FilterInit_4
    394            {
    395              /* FIFO 0 assignation for the filter */
    396              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000090   0x6954             LDR      R4,[R2, #+20]
   \   00000092   0x4023             ANDS     R3,R3,R4
   \   00000094   0x6153             STR      R3,[R2, #+20]
    397            }
    398          
    399            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
   \                     ??CAN_FilterInit_4: (+1)
   \   00000096   0x8903             LDRH     R3,[R0, #+8]
   \   00000098   0x2B01             CMP      R3,#+1
   \   0000009A   0xD102             BNE.N    ??CAN_FilterInit_5
    400            {
    401              /* FIFO 1 assignation for the filter */
    402              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
   \   0000009C   0x6953             LDR      R3,[R2, #+20]
   \   0000009E   0x430B             ORRS     R3,R1,R3
   \   000000A0   0x6153             STR      R3,[R2, #+20]
    403            }
    404            
    405            /* Filter activation */
    406            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5: (+1)
   \   000000A2   0x7B40             LDRB     R0,[R0, #+13]
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD102             BNE.N    ??CAN_FilterInit_6
    407            {
    408              CAN1->FA1R |= filter_number_bit_pos;
   \   000000A8   0x69D0             LDR      R0,[R2, #+28]
   \   000000AA   0x4308             ORRS     R0,R1,R0
   \   000000AC   0x61D0             STR      R0,[R2, #+28]
    409            }
    410          
    411            /* Leave the initialisation mode for the filter */
    412            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6: (+1)
   \   000000AE   0x6810             LDR      R0,[R2, #+0]
   \   000000B0   0x0840             LSRS     R0,R0,#+1
   \   000000B2   0x0040             LSLS     R0,R0,#+1
   \   000000B4   0x6010             STR      R0,[R2, #+0]
    413          }
   \   000000B6   0xBC70             POP      {R4-R6}
   \   000000B8   0x4770             BX       LR               ;; return
    414          
    415          /**
    416            * @brief  Fills each CAN_InitStruct member with its default value.
    417            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    418            * @retval None
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    421          {
    422            /* Reset CAN init structure parameters values */
    423            
    424            /* Initialize the time triggered communication mode */
    425            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7181             STRB     R1,[R0, #+6]
    426            
    427            /* Initialize the automatic bus-off management */
    428            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x71C1             STRB     R1,[R0, #+7]
    429            
    430            /* Initialize the automatic wake-up mode */
    431            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000006   0x7201             STRB     R1,[R0, #+8]
    432            
    433            /* Initialize the no automatic retransmission */
    434            CAN_InitStruct->CAN_NART = DISABLE;
   \   00000008   0x7241             STRB     R1,[R0, #+9]
    435            
    436            /* Initialize the receive FIFO locked mode */
    437            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   0000000A   0x7281             STRB     R1,[R0, #+10]
    438            
    439            /* Initialize the transmit FIFO priority */
    440            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   0000000C   0x72C1             STRB     R1,[R0, #+11]
    441            
    442            /* Initialize the CAN_Mode member */
    443            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    444            
    445            /* Initialize the CAN_SJW member */
    446            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   00000010   0x70C1             STRB     R1,[R0, #+3]
    447            
    448            /* Initialize the CAN_BS1 member */
    449            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x7101             STRB     R1,[R0, #+4]
    450            
    451            /* Initialize the CAN_BS2 member */
    452            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x7141             STRB     R1,[R0, #+5]
    453            
    454            /* Initialize the CAN_Prescaler member */
    455            CAN_InitStruct->CAN_Prescaler = 1;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x8001             STRH     R1,[R0, #+0]
    456          }
   \   0000001E   0x4770             BX       LR               ;; return
    457          
    458          /**
    459            * @brief  Select the start bank filter for slave CAN.
    460            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    461            * @retval None
    462            */

   \                                 In section .text, align 2, keep-with-next
    463          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    464          {
    465            /* Check the parameters */
    466            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    467            
    468            /* Enter Initialisation mode for the filter */
    469            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000A   0x600A             STR      R2,[R1, #+0]
    470            
    471            /* Select the start slave bank */
    472            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable6_3  ;; 0xffffc0f1
   \   00000012   0x401A             ANDS     R2,R3,R2
   \   00000014   0x600A             STR      R2,[R1, #+0]
    473            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0xEA42 0x2000      ORR      R0,R2,R0, LSL #+8
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    474            
    475            /* Leave Initialisation mode for the filter */
    476            CAN1->FMR &= ~FMR_FINIT;
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    477          }
   \   00000026   0x4770             BX       LR               ;; return
    478          
    479          /**
    480            * @brief  Enables or disables the DBG Freeze for CAN.
    481            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    482            * @param  NewState: new state of the CAN peripheral. 
    483            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    484            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    485            *          or DISABLE (CAN is working during debug).
    486            * @retval None
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_CAN_ALL_PERIPH(CANx));
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
    493            
    494            if (NewState != DISABLE)
   \                     CAN_DBGFreeze: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ.N    ??CAN_DBGFreeze_0
    495            {
    496              /* Enable Debug Freeze  */
    497              CANx->MCR |= MCR_DBF;
   \   00000006   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    498            }
    499            else
    500            {
    501              /* Disable Debug Freeze */
    502              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0: (+1)
   \   0000000E   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    503            }
    504          }
   \   00000014   0x4770             BX       LR               ;; return
    505          
    506          
    507          /**
    508            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    509            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    510            *         sent over the CAN bus.  
    511            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    512            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    513            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    514            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    515            *         in data byte 7. 
    516            * @retval None
    517            */

   \                                 In section .text, align 2, keep-with-next
    518          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    519          {
    520            /* Check the parameters */
    521            assert_param(IS_CAN_ALL_PERIPH(CANx));
    522            assert_param(IS_FUNCTIONAL_STATE(NewState));
    523            if (NewState != DISABLE)
   \                     CAN_TTComModeCmd: (+1)
   \   00000000   0xF44F 0x72C2      MOV      R2,#+388
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xD00F             BEQ.N    ??CAN_TTComModeCmd_0
    524            {
    525              /* Enable the TTCM mode */
    526              CANx->MCR |= CAN_MCR_TTCM;
   \   0000000C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000010   0x6001             STR      R1,[R0, #+0]
    527          
    528              /* Set TGT bits */
    529              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
   \   00000012   0x6810             LDR      R0,[R2, #+0]
   \   00000014   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000018   0x6010             STR      R0,[R2, #+0]
    530              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
   \   0000001A   0x6910             LDR      R0,[R2, #+16]
   \   0000001C   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000020   0x6110             STR      R0,[R2, #+16]
    531              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
   \   00000022   0x6A10             LDR      R0,[R2, #+32]
   \   00000024   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000028   0x6210             STR      R0,[R2, #+32]
   \   0000002A   0x4770             BX       LR
    532            }
    533            else
    534            {
    535              /* Disable the TTCM mode */
    536              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
   \                     ??CAN_TTComModeCmd_0: (+1)
   \   0000002C   0xF06F 0x0380      MVN      R3,#+128
   \   00000030   0x4019             ANDS     R1,R3,R1
   \   00000032   0x6001             STR      R1,[R0, #+0]
    537          
    538              /* Reset TGT bits */
    539              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
   \   00000034   0x6810             LDR      R0,[R2, #+0]
   \   00000036   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000003A   0x6010             STR      R0,[R2, #+0]
    540              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
   \   0000003C   0x6910             LDR      R0,[R2, #+16]
   \   0000003E   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000042   0x6110             STR      R0,[R2, #+16]
    541              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
   \   00000044   0x6A10             LDR      R0,[R2, #+32]
   \   00000046   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000004A   0x6210             STR      R0,[R2, #+32]
    542            }
    543          }
   \   0000004C   0x4770             BX       LR               ;; return
    544          /**
    545            * @}
    546            */
    547          
    548          
    549          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    550           *  @brief    CAN Frames Transmission functions 
    551           *
    552          @verbatim    
    553           ===============================================================================
    554                                CAN Frames Transmission functions
    555           ===============================================================================  
    556            This section provides functions allowing to 
    557             - Initiate and transmit a CAN frame message (if there is an empty mailbox).
    558             - Check the transmission status of a CAN Frame
    559             - Cancel a transmit request
    560             
    561          @endverbatim
    562            * @{
    563            */
    564          
    565          /**
    566            * @brief  Initiates and transmits a CAN frame message.
    567            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    568            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    569            * @retval The number of the mailbox that is used for transmission or
    570            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    571            */

   \                                 In section .text, align 2, keep-with-next
    572          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    573          {
   \                     CAN_Transmit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    574            uint8_t transmit_mailbox = 0;
    575            /* Check the parameters */
    576            assert_param(IS_CAN_ALL_PERIPH(CANx));
    577            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    578            assert_param(IS_CAN_RTR(TxMessage->RTR));
    579            assert_param(IS_CAN_DLC(TxMessage->DLC));
    580          
    581            /* Select one empty transmit mailbox */
    582            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x0152             LSLS     R2,R2,#+5
   \   00000006   0xD501             BPL.N    ??CAN_Transmit_0
    583            {
    584              transmit_mailbox = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xE00A             B.N      ??CAN_Transmit_1
    585            }
    586            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_0: (+1)
   \   0000000C   0x6882             LDR      R2,[R0, #+8]
   \   0000000E   0x0112             LSLS     R2,R2,#+4
   \   00000010   0xD501             BPL.N    ??CAN_Transmit_2
    587            {
    588              transmit_mailbox = 1;
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xE005             B.N      ??CAN_Transmit_1
    589            }
    590            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_2: (+1)
   \   00000016   0x6882             LDR      R2,[R0, #+8]
   \   00000018   0x00D2             LSLS     R2,R2,#+3
   \   0000001A   0xD501             BPL.N    ??CAN_Transmit_3
    591            {
    592              transmit_mailbox = 2;
   \   0000001C   0x2202             MOVS     R2,#+2
   \   0000001E   0xE000             B.N      ??CAN_Transmit_1
    593            }
    594            else
    595            {
    596              transmit_mailbox = CAN_TxStatus_NoMailBox;
   \                     ??CAN_Transmit_3: (+1)
   \   00000020   0x2204             MOVS     R2,#+4
    597            }
    598          
    599            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
   \                     ??CAN_Transmit_1: (+1)
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xD040             BEQ.N    ??CAN_Transmit_4
    600            {
    601              /* Set up the Id */
    602              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \   00000026   0xEB00 0x1002      ADD      R0,R0,R2, LSL #+4
   \   0000002A   0xF44F 0x73C0      MOV      R3,#+384
   \   0000002E   0x4418             ADD      R0,R0,R3
   \   00000030   0x6803             LDR      R3,[R0, #+0]
   \   00000032   0xF003 0x0301      AND      R3,R3,#0x1
   \   00000036   0x6003             STR      R3,[R0, #+0]
    603              if (TxMessage->IDE == CAN_Id_Standard)
   \   00000038   0x7A4B             LDRB     R3,[R1, #+9]
   \   0000003A   0x7A0C             LDRB     R4,[R1, #+8]
   \   0000003C   0x0025             MOVS     R5,R4
   \   0000003E   0xD106             BNE.N    ??CAN_Transmit_5
    604              {
    605                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    606                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    607                                                            TxMessage->RTR);
   \   00000040   0x6804             LDR      R4,[R0, #+0]
   \   00000042   0x680D             LDR      R5,[R1, #+0]
   \   00000044   0xEA43 0x5345      ORR      R3,R3,R5, LSL #+21
   \   00000048   0x4323             ORRS     R3,R3,R4
   \   0000004A   0x6003             STR      R3,[R0, #+0]
   \   0000004C   0xE006             B.N      ??CAN_Transmit_6
    608              }
    609              else
    610              {
    611                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    612                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    613                                                            TxMessage->IDE | \
    614                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_5: (+1)
   \   0000004E   0x6805             LDR      R5,[R0, #+0]
   \   00000050   0x684E             LDR      R6,[R1, #+4]
   \   00000052   0xEA44 0x04C6      ORR      R4,R4,R6, LSL #+3
   \   00000056   0x4323             ORRS     R3,R3,R4
   \   00000058   0x432B             ORRS     R3,R3,R5
   \   0000005A   0x6003             STR      R3,[R0, #+0]
    615              }
    616              
    617              /* Set up the DLC */
    618              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_6: (+1)
   \   0000005C   0x7A8B             LDRB     R3,[R1, #+10]
   \   0000005E   0xF003 0x030F      AND      R3,R3,#0xF
   \   00000062   0x728B             STRB     R3,[R1, #+10]
    619              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \   00000064   0x6843             LDR      R3,[R0, #+4]
   \   00000066   0x091B             LSRS     R3,R3,#+4
   \   00000068   0x011B             LSLS     R3,R3,#+4
   \   0000006A   0x6043             STR      R3,[R0, #+4]
    620              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \   0000006C   0x6843             LDR      R3,[R0, #+4]
   \   0000006E   0x7A8C             LDRB     R4,[R1, #+10]
   \   00000070   0x4323             ORRS     R3,R4,R3
   \   00000072   0x6043             STR      R3,[R0, #+4]
    621          
    622              /* Set up the data field */
    623              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    624                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    625                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    626                                                       ((uint32_t)TxMessage->Data[0]));
   \   00000074   0x7B8B             LDRB     R3,[R1, #+14]
   \   00000076   0x7B4C             LDRB     R4,[R1, #+13]
   \   00000078   0x0424             LSLS     R4,R4,#+16
   \   0000007A   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   0000007E   0x7B0C             LDRB     R4,[R1, #+12]
   \   00000080   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000084   0x7ACC             LDRB     R4,[R1, #+11]
   \   00000086   0x4323             ORRS     R3,R4,R3
   \   00000088   0x6083             STR      R3,[R0, #+8]
    627              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    628                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    629                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    630                                                       ((uint32_t)TxMessage->Data[4]));
   \   0000008A   0x7C8B             LDRB     R3,[R1, #+18]
   \   0000008C   0x7C4C             LDRB     R4,[R1, #+17]
   \   0000008E   0x0424             LSLS     R4,R4,#+16
   \   00000090   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   00000094   0x7C0C             LDRB     R4,[R1, #+16]
   \   00000096   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000009A   0x7BC9             LDRB     R1,[R1, #+15]
   \   0000009C   0x4319             ORRS     R1,R1,R3
   \   0000009E   0x60C1             STR      R1,[R0, #+12]
    631              /* Request transmission */
    632              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000A6   0x6001             STR      R1,[R0, #+0]
    633            }
    634            return transmit_mailbox;
   \                     ??CAN_Transmit_4: (+1)
   \   000000A8   0x4610             MOV      R0,R2
   \   000000AA   0xBC70             POP      {R4-R6}
   \   000000AC   0x4770             BX       LR               ;; return
    635          }
    636          
    637          /**
    638            * @brief  Checks the transmission status of a CAN Frame.
    639            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    640            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    641            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    642            *         CAN_TxStatus_Failed in an other case.
    643            */

   \                                 In section .text, align 2, keep-with-next
    644          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    645          {
    646            uint32_t state = 0;
   \                     CAN_TransmitStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    647          
    648            /* Check the parameters */
    649            assert_param(IS_CAN_ALL_PERIPH(CANx));
    650            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    651           
    652            switch (TransmitMailbox)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_TransmitStatus_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00D             BEQ.N    ??CAN_TransmitStatus_1
   \   0000000A   0xD306             BCC.N    ??CAN_TransmitStatus_2
   \   0000000C   0xE010             B.N      ??CAN_TransmitStatus_3
    653            {
    654              case (CAN_TXMAILBOX_0): 
    655                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
   \                     ??CAN_TransmitStatus_0: (+1)
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable6_4  ;; 0x4000003
   \   00000014   0xEA01 0x0200      AND      R2,R1,R0
    656                break;
   \   00000018   0xE00A             B.N      ??CAN_TransmitStatus_3
    657              case (CAN_TXMAILBOX_1): 
    658                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
   \                     ??CAN_TransmitStatus_2: (+1)
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable6_5  ;; 0x8000300
   \   00000020   0xEA01 0x0200      AND      R2,R1,R0
    659                break;
   \   00000024   0xE004             B.N      ??CAN_TransmitStatus_3
    660              case (CAN_TXMAILBOX_2): 
    661                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
   \                     ??CAN_TransmitStatus_1: (+1)
   \   00000026   0x6880             LDR      R0,[R0, #+8]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable6_6  ;; 0x10030000
   \   0000002C   0xEA01 0x0200      AND      R2,R1,R0
    662                break;
    663              default:
    664                state = CAN_TxStatus_Failed;
    665                break;
    666            }
    667            switch (state)
   \                     ??CAN_TransmitStatus_3: (+1)
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD00C             BEQ.N    ??CAN_TransmitStatus_4
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable6_4  ;; 0x4000003
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xD00A             BEQ.N    ??CAN_TransmitStatus_5
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable6_5  ;; 0x8000300
   \   00000040   0x4282             CMP      R2,R0
   \   00000042   0xD006             BEQ.N    ??CAN_TransmitStatus_5
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable6_6  ;; 0x10030000
   \   00000048   0x4282             CMP      R2,R0
   \   0000004A   0xD002             BEQ.N    ??CAN_TransmitStatus_5
   \   0000004C   0xE003             B.N      ??CAN_TransmitStatus_6
    668            {
    669                /* transmit pending  */
    670              case (0x0): state = CAN_TxStatus_Pending;
   \                     ??CAN_TransmitStatus_4: (+1)
   \   0000004E   0x2002             MOVS     R0,#+2
    671                break;
   \   00000050   0x4770             BX       LR
    672                /* transmit failed  */
    673               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    674                break;
    675               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    676                break;
    677               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    678                break;
    679                /* transmit succeeded  */
    680              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    681                break;
    682              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    683                break;
    684              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_5: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
    685                break;
   \   00000054   0x4770             BX       LR
    686              default: state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_6: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
    687                break;
    688            }
    689            return (uint8_t) state;
   \   00000058   0x4770             BX       LR               ;; return
    690          }
    691          
    692          /**
    693            * @brief  Cancels a transmit request.
    694            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    695            * @param  Mailbox: Mailbox number.
    696            * @retval None
    697            */

   \                                 In section .text, align 2, keep-with-next
    698          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    699          {
    700            /* Check the parameters */
    701            assert_param(IS_CAN_ALL_PERIPH(CANx));
    702            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    703            /* abort transmission */
    704            switch (Mailbox)
   \                     CAN_CancelTransmit: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD003             BEQ.N    ??CAN_CancelTransmit_0
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD00B             BEQ.N    ??CAN_CancelTransmit_1
   \   00000008   0xD305             BCC.N    ??CAN_CancelTransmit_2
   \   0000000A   0x4770             BX       LR
    705            {
    706              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0: (+1)
   \   0000000C   0x6881             LDR      R1,[R0, #+8]
   \   0000000E   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000012   0x6081             STR      R1,[R0, #+8]
    707                break;
   \   00000014   0x4770             BX       LR
    708              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2: (+1)
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000001C   0x6081             STR      R1,[R0, #+8]
    709                break;
   \   0000001E   0x4770             BX       LR
    710              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1: (+1)
   \   00000020   0x6881             LDR      R1,[R0, #+8]
   \   00000022   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   00000026   0x6081             STR      R1,[R0, #+8]
    711                break;
    712              default:
    713                break;
    714            }
    715          }
   \   00000028   0x4770             BX       LR               ;; return
    716          /**
    717            * @}
    718            */
    719          
    720          
    721          /** @defgroup CAN_Group3 CAN Frames Reception functions
    722           *  @brief    CAN Frames Reception functions 
    723           *
    724          @verbatim    
    725           ===============================================================================
    726                                CAN Frames Reception functions
    727           ===============================================================================  
    728            This section provides functions allowing to 
    729             -  Receive a correct CAN frame
    730             -  Release a specified receive FIFO (2 FIFOs are available)
    731             -  Return the number of the pending received CAN frames
    732             
    733          @endverbatim
    734            * @{
    735            */
    736          
    737          /**
    738            * @brief  Receives a correct CAN frame.
    739            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    740            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    741            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    742            *         CAN DLC, CAN data and FMI number.
    743            * @retval None
    744            */

   \                                 In section .text, align 2, keep-with-next
    745          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    746          {
   \                     CAN_Receive: (+1)
   \   00000000   0xB410             PUSH     {R4}
    747            /* Check the parameters */
    748            assert_param(IS_CAN_ALL_PERIPH(CANx));
    749            assert_param(IS_CAN_FIFO(FIFONumber));
    750            /* Get the Id */
    751            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \   00000002   0xEB00 0x1301      ADD      R3,R0,R1, LSL #+4
   \   00000006   0xF44F 0x74D8      MOV      R4,#+432
   \   0000000A   0x4423             ADD      R3,R3,R4
   \   0000000C   0x681C             LDR      R4,[R3, #+0]
   \   0000000E   0xF014 0x0404      ANDS     R4,R4,#0x4
   \   00000012   0x7214             STRB     R4,[R2, #+8]
    752            if (RxMessage->IDE == CAN_Id_Standard)
   \   00000014   0x681C             LDR      R4,[R3, #+0]
   \   00000016   0xD102             BNE.N    ??CAN_Receive_0
    753            {
    754              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000018   0x0D64             LSRS     R4,R4,#+21
   \   0000001A   0x6014             STR      R4,[R2, #+0]
   \   0000001C   0xE001             B.N      ??CAN_Receive_1
    755            }
    756            else
    757            {
    758              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0: (+1)
   \   0000001E   0x08E4             LSRS     R4,R4,#+3
   \   00000020   0x6054             STR      R4,[R2, #+4]
    759            }
    760            
    761            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \   00000022   0x681C             LDR      R4,[R3, #+0]
   \   00000024   0xF004 0x0402      AND      R4,R4,#0x2
   \   00000028   0x7254             STRB     R4,[R2, #+9]
    762            /* Get the DLC */
    763            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   0000002A   0x685C             LDR      R4,[R3, #+4]
   \   0000002C   0xF004 0x040F      AND      R4,R4,#0xF
   \   00000030   0x7294             STRB     R4,[R2, #+10]
    764            /* Get the FMI */
    765            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000032   0x685C             LDR      R4,[R3, #+4]
   \   00000034   0x0A24             LSRS     R4,R4,#+8
   \   00000036   0x74D4             STRB     R4,[R2, #+19]
    766            /* Get the data field */
    767            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000038   0x689C             LDR      R4,[R3, #+8]
   \   0000003A   0x72D4             STRB     R4,[R2, #+11]
    768            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   0000003C   0x689C             LDR      R4,[R3, #+8]
   \   0000003E   0x0A24             LSRS     R4,R4,#+8
   \   00000040   0x7314             STRB     R4,[R2, #+12]
    769            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   00000042   0x689C             LDR      R4,[R3, #+8]
   \   00000044   0x0C24             LSRS     R4,R4,#+16
   \   00000046   0x7354             STRB     R4,[R2, #+13]
    770            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   00000048   0x689C             LDR      R4,[R3, #+8]
   \   0000004A   0x0E24             LSRS     R4,R4,#+24
   \   0000004C   0x7394             STRB     R4,[R2, #+14]
    771            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   0000004E   0x68DC             LDR      R4,[R3, #+12]
   \   00000050   0x73D4             STRB     R4,[R2, #+15]
    772            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   00000052   0x68DC             LDR      R4,[R3, #+12]
   \   00000054   0x0A24             LSRS     R4,R4,#+8
   \   00000056   0x7414             STRB     R4,[R2, #+16]
    773            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   00000058   0x68DC             LDR      R4,[R3, #+12]
   \   0000005A   0x0C24             LSRS     R4,R4,#+16
   \   0000005C   0x7454             STRB     R4,[R2, #+17]
    774            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   0000005E   0x68DB             LDR      R3,[R3, #+12]
   \   00000060   0x0E1B             LSRS     R3,R3,#+24
   \   00000062   0x7493             STRB     R3,[R2, #+18]
    775            /* Release the FIFO */
    776            /* Release FIFO0 */
    777            if (FIFONumber == CAN_FIFO0)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD104             BNE.N    ??CAN_Receive_2
    778            {
    779              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000068   0x68C1             LDR      R1,[R0, #+12]
   \   0000006A   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000006E   0x60C1             STR      R1,[R0, #+12]
   \   00000070   0xE003             B.N      ??CAN_Receive_3
    780            }
    781            /* Release FIFO1 */
    782            else /* FIFONumber == CAN_FIFO1 */
    783            {
    784              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_2: (+1)
   \   00000072   0x6901             LDR      R1,[R0, #+16]
   \   00000074   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000078   0x6101             STR      R1,[R0, #+16]
    785            }
    786          }
   \                     ??CAN_Receive_3: (+1)
   \   0000007A   0xBC10             POP      {R4}
   \   0000007C   0x4770             BX       LR               ;; return
    787          
    788          /**
    789            * @brief  Releases the specified receive FIFO.
    790            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    791            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    792            * @retval None
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_CAN_ALL_PERIPH(CANx));
    798            assert_param(IS_CAN_FIFO(FIFONumber));
    799            /* Release FIFO0 */
    800            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD104             BNE.N    ??CAN_FIFORelease_0
    801            {
    802              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
   \   0000000C   0x4770             BX       LR
    803            }
    804            /* Release FIFO1 */
    805            else /* FIFONumber == CAN_FIFO1 */
    806            {
    807              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0: (+1)
   \   0000000E   0x6901             LDR      R1,[R0, #+16]
   \   00000010   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000014   0x6101             STR      R1,[R0, #+16]
    808            }
    809          }
   \   00000016   0x4770             BX       LR               ;; return
    810          
    811          /**
    812            * @brief  Returns the number of pending received messages.
    813            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    814            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    815            * @retval NbMessage : which is the number of pending message.
    816            */

   \                                 In section .text, align 2, keep-with-next
    817          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    818          {
    819            uint8_t message_pending=0;
   \                     CAN_MessagePending: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    820            /* Check the parameters */
    821            assert_param(IS_CAN_ALL_PERIPH(CANx));
    822            assert_param(IS_CAN_FIFO(FIFONumber));
    823            if (FIFONumber == CAN_FIFO0)
   \   00000002   0x000B             MOVS     R3,R1
   \   00000004   0xD103             BNE.N    ??CAN_MessagePending_0
    824            {
    825              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF000 0x0203      AND      R2,R0,#0x3
   \   0000000C   0xE004             B.N      ??CAN_MessagePending_1
    826            }
    827            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0: (+1)
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD102             BNE.N    ??CAN_MessagePending_1
    828            {
    829              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \   00000014   0xF000 0x0203      AND      R2,R0,#0x3
    830            }
    831            else
    832            {
    833              message_pending = 0;
    834            }
    835            return message_pending;
   \                     ??CAN_MessagePending_1: (+1)
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
    836          }
    837          /**
    838            * @}
    839            */
    840          
    841          
    842          /** @defgroup CAN_Group4 CAN Operation modes functions
    843           *  @brief    CAN Operation modes functions 
    844           *
    845          @verbatim    
    846           ===============================================================================
    847                                CAN Operation modes functions
    848           ===============================================================================  
    849            This section provides functions allowing to select the CAN Operation modes
    850            - sleep mode
    851            - normal mode 
    852            - initialization mode
    853             
    854          @endverbatim
    855            * @{
    856            */
    857            
    858            
    859          /**
    860            * @brief  Selects the CAN Operation mode.
    861            * @param  CAN_OperatingMode: CAN Operating Mode.
    862            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    863            * @retval status of the requested mode which can be 
    864            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    865            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    866            */

   \                                 In section .text, align 2, keep-with-next
    867          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    868          {
   \                     CAN_OperatingModeRequest: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x460A             MOV      R2,R1
    869            uint8_t status = CAN_ModeStatus_Failed;
   \   00000004   0x2100             MOVS     R1,#+0
    870            
    871            /* Timeout for INAK or also for SLAK bits*/
    872            uint32_t timeout = INAK_TIMEOUT; 
   \   00000006   0xF64F 0x73FF      MOVW     R3,#+65535
    873          
    874            /* Check the parameters */
    875            assert_param(IS_CAN_ALL_PERIPH(CANx));
    876            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    877          
    878            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0xD116             BNE.N    ??CAN_OperatingModeRequest_0
    879            {
    880              /* Request initialisation */
    881              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0xF06F 0x0402      MVN      R4,#+2
   \   00000014   0x4022             ANDS     R2,R4,R2
   \   00000016   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000001A   0x6002             STR      R2,[R0, #+0]
   \   0000001C   0xE000             B.N      ??CAN_OperatingModeRequest_1
    882          
    883              /* Wait the acknowledge */
    884              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    885              {
    886                timeout--;
   \                     ??CAN_OperatingModeRequest_2: (+1)
   \   0000001E   0x1E5B             SUBS     R3,R3,#+1
    887              }
   \                     ??CAN_OperatingModeRequest_1: (+1)
   \   00000020   0x6842             LDR      R2,[R0, #+4]
   \   00000022   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000026   0x2A01             CMP      R2,#+1
   \   00000028   0xD001             BEQ.N    ??CAN_OperatingModeRequest_3
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD1F7             BNE.N    ??CAN_OperatingModeRequest_2
    888              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
   \                     ??CAN_OperatingModeRequest_3: (+1)
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD12C             BNE.N    ??CAN_OperatingModeRequest_4
    889              {
    890                status = CAN_ModeStatus_Failed;
    891              }
    892              else
    893              {
    894                status = CAN_ModeStatus_Success;
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xE02A             B.N      ??CAN_OperatingModeRequest_4
    895              }
    896            }
    897            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
   \                     ??CAN_OperatingModeRequest_0: (+1)
   \   0000003C   0x2A01             CMP      R2,#+1
   \   0000003E   0xD111             BNE.N    ??CAN_OperatingModeRequest_5
    898            {
    899              /* Request leave initialisation and sleep mode  and enter Normal mode */
    900              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x0892             LSRS     R2,R2,#+2
   \   00000044   0x0092             LSLS     R2,R2,#+2
   \   00000046   0x6002             STR      R2,[R0, #+0]
   \   00000048   0xE000             B.N      ??CAN_OperatingModeRequest_6
    901          
    902              /* Wait the acknowledge */
    903              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    904              {
    905                timeout--;
   \                     ??CAN_OperatingModeRequest_7: (+1)
   \   0000004A   0x1E5B             SUBS     R3,R3,#+1
    906              }
   \                     ??CAN_OperatingModeRequest_6: (+1)
   \   0000004C   0x6842             LDR      R2,[R0, #+4]
   \   0000004E   0xF012 0x0F03      TST      R2,#0x3
   \   00000052   0xD001             BEQ.N    ??CAN_OperatingModeRequest_8
   \   00000054   0x2B00             CMP      R3,#+0
   \   00000056   0xD1F8             BNE.N    ??CAN_OperatingModeRequest_7
    907              if ((CANx->MSR & CAN_MODE_MASK) != 0)
   \                     ??CAN_OperatingModeRequest_8: (+1)
   \   00000058   0x6840             LDR      R0,[R0, #+4]
   \   0000005A   0xF010 0x0F03      TST      R0,#0x3
   \   0000005E   0xD118             BNE.N    ??CAN_OperatingModeRequest_4
    908              {
    909                status = CAN_ModeStatus_Failed;
    910              }
    911              else
    912              {
    913                status = CAN_ModeStatus_Success;
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0xE016             B.N      ??CAN_OperatingModeRequest_4
    914              }
    915            }
    916            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
   \                     ??CAN_OperatingModeRequest_5: (+1)
   \   00000064   0x2A02             CMP      R2,#+2
   \   00000066   0xD114             BNE.N    ??CAN_OperatingModeRequest_4
    917            {
    918              /* Request Sleep mode */
    919              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0x0852             LSRS     R2,R2,#+1
   \   0000006C   0x0052             LSLS     R2,R2,#+1
   \   0000006E   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000072   0x6002             STR      R2,[R0, #+0]
   \   00000074   0xE000             B.N      ??CAN_OperatingModeRequest_9
    920          
    921              /* Wait the acknowledge */
    922              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    923              {
    924                timeout--;
   \                     ??CAN_OperatingModeRequest_10: (+1)
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
    925              }
   \                     ??CAN_OperatingModeRequest_9: (+1)
   \   00000078   0x6842             LDR      R2,[R0, #+4]
   \   0000007A   0xF002 0x0203      AND      R2,R2,#0x3
   \   0000007E   0x2A02             CMP      R2,#+2
   \   00000080   0xD001             BEQ.N    ??CAN_OperatingModeRequest_11
   \   00000082   0x2B00             CMP      R3,#+0
   \   00000084   0xD1F7             BNE.N    ??CAN_OperatingModeRequest_10
    926              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
   \                     ??CAN_OperatingModeRequest_11: (+1)
   \   00000086   0x6840             LDR      R0,[R0, #+4]
   \   00000088   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000008C   0x2802             CMP      R0,#+2
   \   0000008E   0xD100             BNE.N    ??CAN_OperatingModeRequest_4
    927              {
    928                status = CAN_ModeStatus_Failed;
    929              }
    930              else
    931              {
    932                status = CAN_ModeStatus_Success;
   \   00000090   0x2101             MOVS     R1,#+1
    933              }
    934            }
    935            else
    936            {
    937              status = CAN_ModeStatus_Failed;
    938            }
    939          
    940            return  (uint8_t) status;
   \                     ??CAN_OperatingModeRequest_4: (+1)
   \   00000092   0x4608             MOV      R0,R1
   \   00000094   0xBC10             POP      {R4}
   \   00000096   0x4770             BX       LR               ;; return
    941          }
    942          
    943          /**
    944            * @brief  Enters the Sleep (low power) mode.
    945            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    946            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    949          {
    950            uint8_t sleepstatus = CAN_Sleep_Failed;
   \                     CAN_Sleep: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    951            
    952            /* Check the parameters */
    953            assert_param(IS_CAN_ALL_PERIPH(CANx));
    954              
    955            /* Request Sleep mode */
    956             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    957             
    958            /* Sleep mode status */
    959            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD100             BNE.N    ??CAN_Sleep_0
    960            {
    961              /* Sleep mode not entered */
    962              sleepstatus =  CAN_Sleep_Ok;
   \   00000018   0x2101             MOVS     R1,#+1
    963            }
    964            /* return sleep mode status */
    965             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_0: (+1)
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    966          }
    967          
    968          /**
    969            * @brief  Wakes up the CAN peripheral from sleep mode .
    970            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    971            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    972            */

   \                                 In section .text, align 2, keep-with-next
    973          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    974          {
   \                     CAN_WakeUp: (+1)
   \   00000000   0xB410             PUSH     {R4}
    975            uint32_t wait_slak = SLAK_TIMEOUT;
   \   00000002   0xF64F 0x72FF      MOVW     R2,#+65535
    976            uint8_t wakeupstatus = CAN_WakeUp_Failed;
   \   00000006   0x2100             MOVS     R1,#+0
    977            
    978            /* Check the parameters */
    979            assert_param(IS_CAN_ALL_PERIPH(CANx));
    980              
    981            /* Wake up request */
    982            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
   \   00000008   0x6803             LDR      R3,[R0, #+0]
   \   0000000A   0xF06F 0x0402      MVN      R4,#+2
   \   0000000E   0x4023             ANDS     R3,R4,R3
   \   00000010   0x6003             STR      R3,[R0, #+0]
   \   00000012   0xE000             B.N      ??CAN_WakeUp_0
    983              
    984            /* Sleep mode status */
    985            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    986            {
    987             wait_slak--;
   \                     ??CAN_WakeUp_1: (+1)
   \   00000014   0x1E52             SUBS     R2,R2,#+1
    988            }
   \                     ??CAN_WakeUp_0: (+1)
   \   00000016   0x6843             LDR      R3,[R0, #+4]
   \   00000018   0x079B             LSLS     R3,R3,#+30
   \   0000001A   0xD501             BPL.N    ??CAN_WakeUp_2
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD1F9             BNE.N    ??CAN_WakeUp_1
    989            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2: (+1)
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xD400             BMI.N    ??CAN_WakeUp_3
    990            {
    991             /* wake up done : Sleep mode exited */
    992              wakeupstatus = CAN_WakeUp_Ok;
   \   00000026   0x2101             MOVS     R1,#+1
    993            }
    994            /* return wakeup status */
    995            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_3: (+1)
   \   00000028   0x4608             MOV      R0,R1
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    996          }
    997          /**
    998            * @}
    999            */
   1000          
   1001          
   1002          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1003           *  @brief    CAN Bus Error management functions 
   1004           *
   1005          @verbatim    
   1006           ===============================================================================
   1007                                CAN Bus Error management functions
   1008           ===============================================================================  
   1009            This section provides functions allowing to 
   1010             -  Return the CANx's last error code (LEC)
   1011             -  Return the CANx Receive Error Counter (REC)
   1012             -  Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1013             
   1014             @note If TEC is greater than 255, The CAN is in bus-off state.
   1015             @note if REC or TEC are greater than 96, an Error warning flag occurs.
   1016             @note if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1017                                  
   1018          @endverbatim
   1019            * @{
   1020            */
   1021            
   1022          /**
   1023            * @brief  Returns the CANx's last error code (LEC).
   1024            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1025            * @retval Error code: 
   1026            *          - CAN_ERRORCODE_NoErr: No Error  
   1027            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1028            *          - CAN_ERRORCODE_FormErr: Form Error
   1029            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1030            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1031            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1032            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1033            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1036          {
   1037            uint8_t errorcode=0;
   1038            
   1039            /* Check the parameters */
   1040            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1041            
   1042            /* Get the error code*/
   1043            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   \                     CAN_GetLastErrorCode: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0xF000 0x0070      AND      R0,R0,#0x70
   1044            
   1045            /* Return the error code*/
   1046            return errorcode;
   \   00000006   0x4770             BX       LR               ;; return
   1047          }
   1048          
   1049          /**
   1050            * @brief  Returns the CANx Receive Error Counter (REC).
   1051            * @note   In case of an error during reception, this counter is incremented 
   1052            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1053            *         standard. After every successful reception, the counter is 
   1054            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1055            *         When the counter value exceeds 127, the CAN controller enters the 
   1056            *         error passive state.  
   1057            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1058            * @retval CAN Receive Error Counter. 
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1061          {
   1062            uint8_t counter=0;
   1063            
   1064            /* Check the parameters */
   1065            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1066            
   1067            /* Get the Receive Error Counter*/
   1068            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   \                     CAN_GetReceiveErrorCounter: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x0E00             LSRS     R0,R0,#+24
   1069            
   1070            /* Return the Receive Error Counter*/
   1071            return counter;
   \   00000004   0x4770             BX       LR               ;; return
   1072          }
   1073          
   1074          
   1075          /**
   1076            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1077            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1078            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1079            */

   \                                 In section .text, align 2, keep-with-next
   1080          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1081          {
   1082            uint8_t counter=0;
   1083            
   1084            /* Check the parameters */
   1085            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1086            
   1087            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1088            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   \                     CAN_GetLSBTransmitErrorCounter: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x0C00             LSRS     R0,R0,#+16
   1089            
   1090            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1091            return counter;
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
   1092          }
   1093          /**
   1094            * @}
   1095            */
   1096          
   1097          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1098           *  @brief   Interrupts and flags management functions
   1099           *
   1100          @verbatim   
   1101           ===============================================================================
   1102                             Interrupts and flags management functions
   1103           ===============================================================================  
   1104          
   1105            This section provides functions allowing to configure the CAN Interrupts and 
   1106            to get the status and clear flags and Interrupts pending bits.
   1107            
   1108            The CAN provides 14 Interrupts sources and 15 Flags:
   1109          
   1110            ===============  
   1111                Flags :
   1112            ===============
   1113            The 15 flags can be divided on 4 groups: 
   1114          
   1115             A. Transmit Flags
   1116            -----------------------
   1117                  CAN_FLAG_RQCP0, 
   1118                  CAN_FLAG_RQCP1, 
   1119                  CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1120                                    Set when when the last request (transmit or abort) has 
   1121                                    been performed. 
   1122          
   1123            B. Receive Flags
   1124            -----------------------
   1125          
   1126                  CAN_FLAG_FMP0,
   1127                  CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1128                                    set to signal that messages are pending in the receive 
   1129                                    FIFO.
   1130                                    These Flags are cleared only by hardware. 
   1131          
   1132                  CAN_FLAG_FF0,
   1133                  CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1134                                    set when three messages are stored in the selected 
   1135                                    FIFO.                        
   1136          
   1137                  CAN_FLAG_FOV0              
   1138                  CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1139                                    set when a new message has been received and passed 
   1140                                    the filter while the FIFO was full.         
   1141          
   1142            C. Operating Mode Flags
   1143            ----------------------- 
   1144                  CAN_FLAG_WKU    : Wake up Flag
   1145                                    set to signal that a SOF bit has been detected while 
   1146                                    the CAN hardware was in Sleep mode. 
   1147                  
   1148                  CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1149                                    Set to signal that the CAN has entered Sleep Mode. 
   1150              
   1151            D. Error Flags
   1152            ----------------------- 
   1153                  CAN_FLAG_EWG    : Error Warning Flag
   1154                                    Set when the warning limit has been reached (Receive 
   1155                                    Error Counter or Transmit Error Counter greater than 96). 
   1156                                    This Flag is cleared only by hardware.
   1157                                      
   1158                  CAN_FLAG_EPV    : Error Passive Flag
   1159                                    Set when the Error Passive limit has been reached 
   1160                                    (Receive Error Counter or Transmit Error Counter 
   1161                                    greater than 127).
   1162                                    This Flag is cleared only by hardware.
   1163                                       
   1164                  CAN_FLAG_BOF    : Bus-Off Flag
   1165                                    set when CAN enters the bus-off state. The bus-off 
   1166                                    state is entered on TEC overflow, greater than 255.
   1167                                    This Flag is cleared only by hardware.
   1168                                             
   1169                  CAN_FLAG_LEC    : Last error code Flag
   1170                                    set If a message has been transferred (reception or
   1171                                    transmission) with error, and the error code is hold.              
   1172                                    
   1173            ===============  
   1174             Interrupts :
   1175            ===============
   1176            The 14 interrupts can be divided on 4 groups: 
   1177            
   1178             A. Transmit interrupt
   1179            -----------------------   
   1180                    CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1181                                    if enabled, this interrupt source is pending when 
   1182                                    no transmit request are pending for Tx mailboxes.      
   1183          
   1184             B. Receive Interrupts
   1185            -----------------------          
   1186                  CAN_IT_FMP0,
   1187                  CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1188                                    if enabled, these interrupt sources are pending when 
   1189                                    messages are pending in the receive FIFO.
   1190                                    The corresponding interrupt pending bits are cleared 
   1191                                    only by hardware.
   1192                          
   1193                  CAN_IT_FF0,              
   1194                  CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1195                                    if enabled, these interrupt sources are pending when
   1196                                    three messages are stored in the selected FIFO.
   1197                  
   1198                  CAN_IT_FOV0,        
   1199                  CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1200                                    if enabled, these interrupt sources are pending when
   1201                                    a new message has been received and passed the filter
   1202                                    while the FIFO was full.
   1203          
   1204             C. Operating Mode Interrupts
   1205            -------------------------------          
   1206                  CAN_IT_WKU     :  Wake-up Interrupt
   1207                                    if enabled, this interrupt source is pending when 
   1208                                    a SOF bit has been detected while the CAN hardware was 
   1209                                    in Sleep mode.
   1210                                            
   1211                  CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1212                                    if enabled, this interrupt source is pending when 
   1213                                    the CAN has entered Sleep Mode.       
   1214          
   1215             D. Error Interrupts 
   1216            -----------------------         
   1217                  CAN_IT_EWG     :  Error warning Interrupt 
   1218                                    if enabled, this interrupt source is pending when
   1219                                    the warning limit has been reached (Receive Error 
   1220                                    Counter or Transmit Error Counter=96). 
   1221                                         
   1222                  CAN_IT_EPV     :  Error passive Interrupt        
   1223                                    if enabled, this interrupt source is pending when
   1224                                    the Error Passive limit has been reached (Receive 
   1225                                    Error Counter or Transmit Error Counter>127).
   1226                                    
   1227                  CAN_IT_BOF     :  Bus-off Interrupt
   1228                                    if enabled, this interrupt source is pending when
   1229                                    CAN enters the bus-off state. The bus-off state is 
   1230                                    entered on TEC overflow, greater than 255.
   1231                                    This Flag is cleared only by hardware.
   1232                                            
   1233                  CAN_IT_LEC     :  Last error code Interrupt        
   1234                                    if enabled, this interrupt source is pending  when
   1235                                    a message has been transferred (reception or
   1236                                    transmission) with error, and the error code is hold.
   1237                                    
   1238                  CAN_IT_ERR     :  Error Interrupt
   1239                                    if enabled, this interrupt source is pending when 
   1240                                    an error condition is pending.      
   1241                                
   1242          
   1243            Managing the CAN controller events :
   1244            ------------------------------------ 
   1245            The user should identify which mode will be used in his application to manage 
   1246            the CAN controller events: Polling mode or Interrupt mode.
   1247            
   1248            1.  In the Polling Mode it is advised to use the following functions:
   1249                - CAN_GetFlagStatus() : to check if flags events occur. 
   1250                - CAN_ClearFlag()     : to clear the flags events.
   1251            
   1252          
   1253            
   1254            2.  In the Interrupt Mode it is advised to use the following functions:
   1255                - CAN_ITConfig()       : to enable or disable the interrupt source.
   1256                - CAN_GetITStatus()    : to check if Interrupt occurs.
   1257                - CAN_ClearITPendingBit() : to clear the Interrupt pending Bit (corresponding Flag).
   1258                @note  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1259                       pending bits since there are cleared only by hardware. 
   1260            
   1261          @endverbatim
   1262            * @{
   1263            */ 
   1264          /**
   1265            * @brief  Enables or disables the specified CANx interrupts.
   1266            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1267            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1268            *          This parameter can be: 
   1269            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1270            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1271            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1272            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1273            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1274            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1275            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1276            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1277            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1278            *            @arg CAN_IT_EWG: Error warning Interrupt
   1279            *            @arg CAN_IT_EPV: Error passive Interrupt
   1280            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1281            *            @arg CAN_IT_LEC: Last error code Interrupt
   1282            *            @arg CAN_IT_ERR: Error Interrupt
   1283            * @param  NewState: new state of the CAN interrupts.
   1284            *          This parameter can be: ENABLE or DISABLE.
   1285            * @retval None
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1288          {
   1289            /* Check the parameters */
   1290            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1291            assert_param(IS_CAN_IT(CAN_IT));
   1292            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1293          
   1294            if (NewState != DISABLE)
   \                     CAN_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6942             LDR      R2,[R0, #+20]
   \   00000004   0xD002             BEQ.N    ??CAN_ITConfig_0
   1295            {
   1296              /* Enable the selected CANx interrupt */
   1297              CANx->IER |= CAN_IT;
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6141             STR      R1,[R0, #+20]
   \   0000000A   0x4770             BX       LR
   1298            }
   1299            else
   1300            {
   1301              /* Disable the selected CANx interrupt */
   1302              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0: (+1)
   \   0000000C   0xEA22 0x0101      BIC      R1,R2,R1
   \   00000010   0x6141             STR      R1,[R0, #+20]
   1303            }
   1304          }
   \   00000012   0x4770             BX       LR               ;; return
   1305          /**
   1306            * @brief  Checks whether the specified CAN flag is set or not.
   1307            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1308            * @param  CAN_FLAG: specifies the flag to check.
   1309            *          This parameter can be one of the following values:
   1310            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1311            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1312            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1313            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1314            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1315            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1316            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1317            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1318            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1319            *            @arg CAN_FLAG_WKU: Wake up Flag
   1320            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1321            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1322            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1323            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1324            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1325            * @retval The new state of CAN_FLAG (SET or RESET).
   1326            */

   \                                 In section .text, align 2, keep-with-next
   1327          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1328          {
   \                     CAN_GetFlagStatus: (+1)
   \   00000000   0x4602             MOV      R2,R0
   1329            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1330            
   1331            /* Check the parameters */
   1332            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1333            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1334            
   1335          
   1336            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \   00000004   0xF411 0x0F70      TST      R1,#0xF00000
   \   00000008   0xD005             BEQ.N    ??CAN_GetFlagStatus_0
   1337            { 
   1338              /* Check the status of the specified CAN flag */
   1339              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000000A   0x6992             LDR      R2,[R2, #+24]
   \   0000000C   0x4011             ANDS     R1,R1,R2
   \   0000000E   0x0309             LSLS     R1,R1,#+12
   \   00000010   0xD01E             BEQ.N    ??CAN_GetFlagStatus_1
   1340              { 
   1341                /* CAN_FLAG is set */
   1342                bitstatus = SET;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR
   1343              }
   1344              else
   1345              { 
   1346                /* CAN_FLAG is reset */
   1347                bitstatus = RESET;
   1348              }
   1349            }
   1350            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_0: (+1)
   \   00000016   0x01CB             LSLS     R3,R1,#+7
   \   00000018   0xD505             BPL.N    ??CAN_GetFlagStatus_2
   1351            { 
   1352              /* Check the status of the specified CAN flag */
   1353              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000001A   0x6852             LDR      R2,[R2, #+4]
   \   0000001C   0x4011             ANDS     R1,R1,R2
   \   0000001E   0x0309             LSLS     R1,R1,#+12
   \   00000020   0xD016             BEQ.N    ??CAN_GetFlagStatus_1
   1354              { 
   1355                /* CAN_FLAG is set */
   1356                bitstatus = SET;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x4770             BX       LR
   1357              }
   1358              else
   1359              { 
   1360                /* CAN_FLAG is reset */
   1361                bitstatus = RESET;
   1362              }
   1363            }
   1364            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_2: (+1)
   \   00000026   0x010B             LSLS     R3,R1,#+4
   \   00000028   0xD505             BPL.N    ??CAN_GetFlagStatus_3
   1365            { 
   1366              /* Check the status of the specified CAN flag */
   1367              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000002A   0x6892             LDR      R2,[R2, #+8]
   \   0000002C   0x4011             ANDS     R1,R1,R2
   \   0000002E   0x0309             LSLS     R1,R1,#+12
   \   00000030   0xD00E             BEQ.N    ??CAN_GetFlagStatus_1
   1368              { 
   1369                /* CAN_FLAG is set */
   1370                bitstatus = SET;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x4770             BX       LR
   1371              }
   1372              else
   1373              { 
   1374                /* CAN_FLAG is reset */
   1375                bitstatus = RESET;
   1376              }
   1377            }
   1378            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_3: (+1)
   \   00000036   0x018B             LSLS     R3,R1,#+6
   \   00000038   0xD505             BPL.N    ??CAN_GetFlagStatus_4
   1379            { 
   1380              /* Check the status of the specified CAN flag */
   1381              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000003A   0x68D2             LDR      R2,[R2, #+12]
   \   0000003C   0x4011             ANDS     R1,R1,R2
   \   0000003E   0x0309             LSLS     R1,R1,#+12
   \   00000040   0xD006             BEQ.N    ??CAN_GetFlagStatus_1
   1382              { 
   1383                /* CAN_FLAG is set */
   1384                bitstatus = SET;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x4770             BX       LR
   1385              }
   1386              else
   1387              { 
   1388                /* CAN_FLAG is reset */
   1389                bitstatus = RESET;
   1390              }
   1391            }
   1392            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1393            { 
   1394              /* Check the status of the specified CAN flag */
   1395              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_4: (+1)
   \   00000046   0x6912             LDR      R2,[R2, #+16]
   \   00000048   0x4011             ANDS     R1,R1,R2
   \   0000004A   0x0309             LSLS     R1,R1,#+12
   \   0000004C   0xD000             BEQ.N    ??CAN_GetFlagStatus_1
   1396              { 
   1397                /* CAN_FLAG is set */
   1398                bitstatus = SET;
   \   0000004E   0x2001             MOVS     R0,#+1
   1399              }
   1400              else
   1401              { 
   1402                /* CAN_FLAG is reset */
   1403                bitstatus = RESET;
   1404              }
   1405            }
   1406            /* Return the CAN_FLAG status */
   1407            return  bitstatus;
   \                     ??CAN_GetFlagStatus_1: (+1)
   \   00000050   0x4770             BX       LR               ;; return
   1408          }
   1409          
   1410          /**
   1411            * @brief  Clears the CAN's pending flags.
   1412            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1413            * @param  CAN_FLAG: specifies the flag to clear.
   1414            *          This parameter can be one of the following values:
   1415            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1416            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1417            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1418            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1419            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1420            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1421            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1422            *            @arg CAN_FLAG_WKU: Wake up Flag
   1423            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1424            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1425            * @retval None
   1426            */

   \                                 In section .text, align 2, keep-with-next
   1427          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1428          {
   1429            uint32_t flagtmp=0;
   1430            /* Check the parameters */
   1431            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1432            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1433            
   1434            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \                     CAN_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable6_7  ;; 0x30f00070
   \   00000002   0x4291             CMP      R1,R2
   \   00000004   0xD102             BNE.N    ??CAN_ClearFlag_0
   1435            {
   1436              /* Clear the selected CAN flags */
   1437              CANx->ESR = (uint32_t)RESET;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6181             STR      R1,[R0, #+24]
   \   0000000A   0x4770             BX       LR
   1438            }
   1439            else /* MSR or TSR or RF0R or RF1R */
   1440            {
   1441              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_0: (+1)
   \   0000000C   0xF3C1 0x0213      UBFX     R2,R1,#+0,#+20
   1442          
   1443              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \   00000010   0x018B             LSLS     R3,R1,#+6
   \   00000012   0xD501             BPL.N    ??CAN_ClearFlag_1
   1444              {
   1445                /* Receive Flags */
   1446                CANx->RF0R = (uint32_t)(flagtmp);
   \   00000014   0x60C2             STR      R2,[R0, #+12]
   \   00000016   0x4770             BX       LR
   1447              }
   1448              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_1: (+1)
   \   00000018   0x014B             LSLS     R3,R1,#+5
   \   0000001A   0xD501             BPL.N    ??CAN_ClearFlag_2
   1449              {
   1450                /* Receive Flags */
   1451                CANx->RF1R = (uint32_t)(flagtmp);
   \   0000001C   0x6102             STR      R2,[R0, #+16]
   \   0000001E   0x4770             BX       LR
   1452              }
   1453              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_2: (+1)
   \   00000020   0x0109             LSLS     R1,R1,#+4
   \   00000022   0xD501             BPL.N    ??CAN_ClearFlag_3
   1454              {
   1455                /* Transmit Flags */
   1456                CANx->TSR = (uint32_t)(flagtmp);
   \   00000024   0x6082             STR      R2,[R0, #+8]
   \   00000026   0x4770             BX       LR
   1457              }
   1458              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1459              {
   1460                /* Operating mode Flags */
   1461                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_3: (+1)
   \   00000028   0x6042             STR      R2,[R0, #+4]
   1462              }
   1463            }
   1464          }
   \   0000002A   0x4770             BX       LR               ;; return
   1465          
   1466          /**
   1467            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1468            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1469            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1470            *          This parameter can be one of the following values:
   1471            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1472            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1473            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1474            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1475            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1476            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1477            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1478            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1479            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1480            *            @arg CAN_IT_EWG: Error warning Interrupt
   1481            *            @arg CAN_IT_EPV: Error passive Interrupt
   1482            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1483            *            @arg CAN_IT_LEC: Last error code Interrupt
   1484            *            @arg CAN_IT_ERR: Error Interrupt
   1485            * @retval The current state of CAN_IT (SET or RESET).
   1486            */

   \                                 In section .text, align 2, keep-with-next
   1487          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1488          {
   \                     CAN_GetITStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1489            ITStatus itstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
   1490            /* Check the parameters */
   1491            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1492            assert_param(IS_CAN_IT(CAN_IT));
   1493            
   1494            /* check the interrupt enable bit */
   1495           if((CANx->IER & CAN_IT) != RESET)
   \   00000004   0x6943             LDR      R3,[R0, #+20]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD076             BEQ.N    ??CAN_GetITStatus_0
   1496           {
   1497             /* in case the Interrupt is enabled, .... */
   1498              switch (CAN_IT)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD021             BEQ.N    ??CAN_GetITStatus_1
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD025             BEQ.N    ??CAN_GetITStatus_2
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD029             BEQ.N    ??CAN_GetITStatus_3
   \   00000016   0x2908             CMP      R1,#+8
   \   00000018   0xD02D             BEQ.N    ??CAN_GetITStatus_4
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xD031             BEQ.N    ??CAN_GetITStatus_5
   \   0000001E   0x2920             CMP      R1,#+32
   \   00000020   0xD035             BEQ.N    ??CAN_GetITStatus_6
   \   00000022   0x2940             CMP      R1,#+64
   \   00000024   0xD039             BEQ.N    ??CAN_GetITStatus_7
   \   00000026   0xF5B1 0x7F80      CMP      R1,#+256
   \   0000002A   0xD048             BEQ.N    ??CAN_GetITStatus_8
   \   0000002C   0xF5B1 0x7F00      CMP      R1,#+512
   \   00000030   0xD04B             BEQ.N    ??CAN_GetITStatus_9
   \   00000032   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000036   0xD04E             BEQ.N    ??CAN_GetITStatus_10
   \   00000038   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000003C   0xD051             BEQ.N    ??CAN_GetITStatus_11
   \   0000003E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000042   0xD054             BEQ.N    ??CAN_GetITStatus_12
   \   00000044   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000048   0xD02D             BEQ.N    ??CAN_GetITStatus_13
   \   0000004A   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000004E   0xD030             BEQ.N    ??CAN_GetITStatus_14
   \   00000050   0xE052             B.N      ??CAN_GetITStatus_0
   1499              {
   1500                case CAN_IT_TME:
   1501                  /* Check CAN_TSR_RQCPx bits */
   1502                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_1: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10101
   \   00000054   0x6880             LDR      R0,[R0, #+8]
   \   00000056   0x.... 0x....      BL       CheckITStatus
   \   0000005A   0x4602             MOV      R2,R0
   1503                  break;
   \   0000005C   0xE04C             B.N      ??CAN_GetITStatus_0
   1504                case CAN_IT_FMP0:
   1505                  /* Check CAN_RF0R_FMP0 bit */
   1506                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_2: (+1)
   \   0000005E   0x2103             MOVS     R1,#+3
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0x.... 0x....      BL       CheckITStatus
   \   00000066   0x4602             MOV      R2,R0
   1507                  break;
   \   00000068   0xE046             B.N      ??CAN_GetITStatus_0
   1508                case CAN_IT_FF0:
   1509                  /* Check CAN_RF0R_FULL0 bit */
   1510                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_3: (+1)
   \   0000006A   0x2108             MOVS     R1,#+8
   \   0000006C   0x68C0             LDR      R0,[R0, #+12]
   \   0000006E   0x.... 0x....      BL       CheckITStatus
   \   00000072   0x4602             MOV      R2,R0
   1511                  break;
   \   00000074   0xE040             B.N      ??CAN_GetITStatus_0
   1512                case CAN_IT_FOV0:
   1513                  /* Check CAN_RF0R_FOVR0 bit */
   1514                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_4: (+1)
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0x.... 0x....      BL       CheckITStatus
   \   0000007E   0x4602             MOV      R2,R0
   1515                  break;
   \   00000080   0xE03A             B.N      ??CAN_GetITStatus_0
   1516                case CAN_IT_FMP1:
   1517                  /* Check CAN_RF1R_FMP1 bit */
   1518                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_5: (+1)
   \   00000082   0x2103             MOVS     R1,#+3
   \   00000084   0x6900             LDR      R0,[R0, #+16]
   \   00000086   0x.... 0x....      BL       CheckITStatus
   \   0000008A   0x4602             MOV      R2,R0
   1519                  break;
   \   0000008C   0xE034             B.N      ??CAN_GetITStatus_0
   1520                case CAN_IT_FF1:
   1521                  /* Check CAN_RF1R_FULL1 bit */
   1522                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_6: (+1)
   \   0000008E   0x2108             MOVS     R1,#+8
   \   00000090   0x6900             LDR      R0,[R0, #+16]
   \   00000092   0x.... 0x....      BL       CheckITStatus
   \   00000096   0x4602             MOV      R2,R0
   1523                  break;
   \   00000098   0xE02E             B.N      ??CAN_GetITStatus_0
   1524                case CAN_IT_FOV1:
   1525                  /* Check CAN_RF1R_FOVR1 bit */
   1526                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_7: (+1)
   \   0000009A   0x2110             MOVS     R1,#+16
   \   0000009C   0x6900             LDR      R0,[R0, #+16]
   \   0000009E   0x.... 0x....      BL       CheckITStatus
   \   000000A2   0x4602             MOV      R2,R0
   1527                  break;
   \   000000A4   0xE028             B.N      ??CAN_GetITStatus_0
   1528                case CAN_IT_WKU:
   1529                  /* Check CAN_MSR_WKUI bit */
   1530                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_13: (+1)
   \   000000A6   0x2108             MOVS     R1,#+8
   \   000000A8   0x6840             LDR      R0,[R0, #+4]
   \   000000AA   0x.... 0x....      BL       CheckITStatus
   \   000000AE   0x4602             MOV      R2,R0
   1531                  break;
   \   000000B0   0xE022             B.N      ??CAN_GetITStatus_0
   1532                case CAN_IT_SLK:
   1533                  /* Check CAN_MSR_SLAKI bit */
   1534                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_14: (+1)
   \   000000B2   0x2110             MOVS     R1,#+16
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0x.... 0x....      BL       CheckITStatus
   \   000000BA   0x4602             MOV      R2,R0
   1535                  break;
   \   000000BC   0xE01C             B.N      ??CAN_GetITStatus_0
   1536                case CAN_IT_EWG:
   1537                  /* Check CAN_ESR_EWGF bit */
   1538                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_8: (+1)
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x6980             LDR      R0,[R0, #+24]
   \   000000C2   0x.... 0x....      BL       CheckITStatus
   \   000000C6   0x4602             MOV      R2,R0
   1539                  break;
   \   000000C8   0xE016             B.N      ??CAN_GetITStatus_0
   1540                case CAN_IT_EPV:
   1541                  /* Check CAN_ESR_EPVF bit */
   1542                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_9: (+1)
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0x6980             LDR      R0,[R0, #+24]
   \   000000CE   0x.... 0x....      BL       CheckITStatus
   \   000000D2   0x4602             MOV      R2,R0
   1543                  break;
   \   000000D4   0xE010             B.N      ??CAN_GetITStatus_0
   1544                case CAN_IT_BOF:
   1545                  /* Check CAN_ESR_BOFF bit */
   1546                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_10: (+1)
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x6980             LDR      R0,[R0, #+24]
   \   000000DA   0x.... 0x....      BL       CheckITStatus
   \   000000DE   0x4602             MOV      R2,R0
   1547                  break;
   \   000000E0   0xE00A             B.N      ??CAN_GetITStatus_0
   1548                case CAN_IT_LEC:
   1549                  /* Check CAN_ESR_LEC bit */
   1550                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_11: (+1)
   \   000000E2   0x2170             MOVS     R1,#+112
   \   000000E4   0x6980             LDR      R0,[R0, #+24]
   \   000000E6   0x.... 0x....      BL       CheckITStatus
   \   000000EA   0x4602             MOV      R2,R0
   1551                  break;
   \   000000EC   0xE004             B.N      ??CAN_GetITStatus_0
   1552                case CAN_IT_ERR:
   1553                  /* Check CAN_MSR_ERRI bit */ 
   1554                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \                     ??CAN_GetITStatus_12: (+1)
   \   000000EE   0x2104             MOVS     R1,#+4
   \   000000F0   0x6840             LDR      R0,[R0, #+4]
   \   000000F2   0x.... 0x....      BL       CheckITStatus
   \   000000F6   0x4602             MOV      R2,R0
   1555                  break;
   1556                default:
   1557                  /* in case of error, return RESET */
   1558                  itstatus = RESET;
   1559                  break;
   1560              }
   1561            }
   1562            else
   1563            {
   1564             /* in case the Interrupt is not enabled, return RESET */
   1565              itstatus  = RESET;
   1566            }
   1567            
   1568            /* Return the CAN_IT status */
   1569            return  itstatus;
   \                     ??CAN_GetITStatus_0: (+1)
   \   000000F8   0x4610             MOV      R0,R2
   \   000000FA   0xBD02             POP      {R1,PC}          ;; return
   1570          }
   1571          
   1572          /**
   1573            * @brief  Clears the CANx's interrupt pending bits.
   1574            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1575            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1576            *          This parameter can be one of the following values:
   1577            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1578            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1579            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1580            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1581            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1582            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1583            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1584            *            @arg CAN_IT_EWG: Error warning Interrupt
   1585            *            @arg CAN_IT_EPV: Error passive Interrupt
   1586            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1587            *            @arg CAN_IT_LEC: Last error code Interrupt
   1588            *            @arg CAN_IT_ERR: Error Interrupt 
   1589            * @retval None
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1592          {
   1593            /* Check the parameters */
   1594            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1595            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1596          
   1597            switch (CAN_IT)
   \                     CAN_ClearITPendingBit: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD01D             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000008   0x2908             CMP      R1,#+8
   \   0000000A   0xD01F             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000C   0x2920             CMP      R1,#+32
   \   0000000E   0xD020             BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000010   0x2940             CMP      R1,#+64
   \   00000012   0xD021             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000014   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000018   0xD027             BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001A   0xF5B1 0x7F00      CMP      R1,#+512
   \   0000001E   0xD024             BEQ.N    ??CAN_ClearITPendingBit_5
   \   00000020   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000024   0xD021             BEQ.N    ??CAN_ClearITPendingBit_5
   \   00000026   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000002A   0xD021             BEQ.N    ??CAN_ClearITPendingBit_6
   \   0000002C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000030   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_6
   \   00000032   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000036   0xD012             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000038   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000003C   0xD012             BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000003E   0x4770             BX       LR
   1598            {
   1599              case CAN_IT_TME:
   1600                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1601                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \   00000040   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10101
   \   00000042   0x6081             STR      R1,[R0, #+8]
   1602                break;
   \   00000044   0x4770             BX       LR
   1603              case CAN_IT_FF0:
   1604                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1605                CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \   00000046   0x2108             MOVS     R1,#+8
   \   00000048   0x60C1             STR      R1,[R0, #+12]
   1606                break;
   \   0000004A   0x4770             BX       LR
   1607              case CAN_IT_FOV0:
   1608                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1609                CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0x60C1             STR      R1,[R0, #+12]
   1610                break;
   \   00000050   0x4770             BX       LR
   1611              case CAN_IT_FF1:
   1612                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1613                CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \   00000052   0x2108             MOVS     R1,#+8
   \   00000054   0x6101             STR      R1,[R0, #+16]
   1614                break;
   \   00000056   0x4770             BX       LR
   1615              case CAN_IT_FOV1:
   1616                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1617                CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x6101             STR      R1,[R0, #+16]
   1618                break;
   \   0000005C   0x4770             BX       LR
   1619              case CAN_IT_WKU:
   1620                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1621                CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \   0000005E   0x2108             MOVS     R1,#+8
   \   00000060   0x6041             STR      R1,[R0, #+4]
   1622                break;
   \   00000062   0x4770             BX       LR
   1623              case CAN_IT_SLK:
   1624                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1625                CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \   00000064   0x2110             MOVS     R1,#+16
   \   00000066   0x6041             STR      R1,[R0, #+4]
   1626                break;
   \   00000068   0x4770             BX       LR
   1627              case CAN_IT_EWG:
   1628                /* Clear CAN_MSR_ERRI (rc_w1) */
   1629                CANx->MSR = CAN_MSR_ERRI;
   1630                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1631                break;
   1632              case CAN_IT_EPV:
   1633                /* Clear CAN_MSR_ERRI (rc_w1) */
   1634                CANx->MSR = CAN_MSR_ERRI; 
   1635                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1636                break;
   1637              case CAN_IT_BOF:
   1638                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1639                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \   0000006A   0x2104             MOVS     R1,#+4
   \   0000006C   0x6041             STR      R1,[R0, #+4]
   1640                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1641                 break;
   \   0000006E   0x4770             BX       LR
   1642              case CAN_IT_LEC:
   1643                /*  Clear LEC bits */
   1644                CANx->ESR = RESET; 
   1645                /* Clear CAN_MSR_ERRI (rc_w1) */
   1646                CANx->MSR = CAN_MSR_ERRI; 
   1647                break;
   1648              case CAN_IT_ERR:
   1649                /*Clear LEC bits */
   1650                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x6181             STR      R1,[R0, #+24]
   1651                /* Clear CAN_MSR_ERRI (rc_w1) */
   1652                CANx->MSR = CAN_MSR_ERRI; 
   \   00000074   0x2104             MOVS     R1,#+4
   \   00000076   0x6041             STR      R1,[R0, #+4]
   1653                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1654                 break;
   1655              default:
   1656                 break;
   1657             }
   1658          }
   \   00000078   0x4770             BX       LR               ;; return
   1659           /**
   1660            * @}
   1661            */
   1662          
   1663          /**
   1664            * @brief  Checks whether the CAN interrupt has occurred or not.
   1665            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1666            * @param  It_Bit: specifies the interrupt source bit to check.
   1667            * @retval The new state of the CAN Interrupt (SET or RESET).
   1668            */

   \                                 In section .text, align 2, keep-with-next
   1669          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1670          {
   1671            ITStatus pendingbitstatus = RESET;
   \                     CheckITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1672            
   1673            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD000             BEQ.N    ??CheckITStatus_0
   1674            {
   1675              /* CAN_IT is set */
   1676              pendingbitstatus = SET;
   \   00000006   0x2201             MOVS     R2,#+1
   1677            }
   1678            else
   1679            {
   1680              /* CAN_IT is reset */
   1681              pendingbitstatus = RESET;
   1682            }
   1683            return pendingbitstatus;
   \                     ??CheckITStatus_0: (+1)
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x4770             BX       LR               ;; return
   1684          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x04000003         DC32     0x4000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x08000300         DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x10030000         DC32     0x10030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x30F00070         DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x00010101         DC32     0x10101
   1685          
   1686          /**
   1687            * @}
   1688            */
   1689          
   1690          /**
   1691            * @}
   1692            */
   1693          
   1694          /**
   1695            * @}
   1696            */
   1697          
   1698          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
      12   CAN_FilterInit
       0   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       8   CAN_Init
       0   CAN_MessagePending
       4   CAN_OperatingModeRequest
       4   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
      12   CAN_Transmit
       0   CAN_TransmitStatus
       4   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      42  CAN_CancelTransmit
      44  CAN_ClearFlag
     122  CAN_ClearITPendingBit
      22  CAN_DBGFreeze
      58  CAN_DeInit
      24  CAN_FIFORelease
     186  CAN_FilterInit
      82  CAN_GetFlagStatus
     252  CAN_GetITStatus
       8  CAN_GetLSBTransmitErrorCounter
       8  CAN_GetLastErrorCode
       6  CAN_GetReceiveErrorCounter
      20  CAN_ITConfig
     266  CAN_Init
      28  CAN_MessagePending
     152  CAN_OperatingModeRequest
     126  CAN_Receive
      40  CAN_SlaveStartBank
      30  CAN_Sleep
      32  CAN_StructInit
      78  CAN_TTComModeCmd
     174  CAN_Transmit
      90  CAN_TransmitStatus
      46  CAN_WakeUp
      12  CheckITStatus

 
 1 984 bytes in section .text
 
 1 984 bytes of CODE memory

Errors: none
Warnings: none
