###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:05
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\nmeap.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\nmeap.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\nmeap.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\nmeap.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\nmeap.c
      1          /*
      2          Copyright (c) 2005, David M Howard (daveh at dmh2000.com)
      3          All rights reserved.
      4          
      5          This product is licensed for use and distribution under the BSD Open Source License.
      6          see the file COPYING for more details.
      7          
      8          THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
      9          AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
     10          IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
     11          ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
     12          LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
     13          OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
     14          OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
     15          OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
     16          WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
     17          OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
     18          EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
     19          
     20          */
     21          #define GPS_GLOBALS
     22          #include "includes.h"

   \                                 In section .bss, align 1
   \   __absolute INT8U GPS_Fault
   \                     GPS_Fault:
   \   00000000                      DS8 1
   \   __absolute INT8U GPS_Reset_Cnt
   \                     GPS_Reset_Cnt:
   \   00000001                      DS8 1
   \   __absolute INT8U GPS_Reset_Flag
   \                     GPS_Reset_Flag:
   \   00000002                      DS8 1
   \   __absolute INT8U GPS_SigWait_Cnt
   \                     GPS_SigWait_Cnt:
   \   00000003                      DS8 1
   \   __absolute INT8U GPS_Valid
   \                     GPS_Valid:
   \   00000004                      DS8 1
   \   __absolute INT8U GPS_Valid_Char
   \                     GPS_Valid_Char:
   \   00000005                      DS8 1
   \   __absolute INT8U GPS_Not_Valid_Cnt
   \                     GPS_Not_Valid_Cnt:
   \   00000006                      DS8 1
   \   __absolute char gps_on
   \                     gps_on:
   \   00000007                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT8U GPS_RxBuf[512]
   \                     GPS_RxBuf:
   \   00000000                      DS8 512

   \                                 In section .bss, align 8
   \   __absolute nmeap_rmc_t rmc
   \                     rmc:
   \   00000000                      DS8 56
   \   __absolute INT16U GPS_RxHead
   \                     GPS_RxHead:
   \   00000038                      DS8 2
   \   __absolute INT16U GPS_RxTail
   \                     GPS_RxTail:
   \   0000003A                      DS8 2
   \   0000003C                      DS8 856
   \   00000394                      DS8 4
   \   __absolute nmeap_gga_t gga
   \                     gga:
   \   00000398                      DS8 56
   \   __absolute nmeap_gsa_t gsa
   \                     gsa:
   \   000003D0                      DS8 24

   \                                 In section .bss, align 4
   \   __absolute int gps_status
   \                     gps_status:
   \   00000000                      DS8 4
     23          
     24          
     25          //INT16U checktime = 0;
     26          static nmeap_context_t nmea;	    /* parser context */
     27          
     28          /* this only works if you are sure you have an upper case hex digit */
     29          //#define HEXTOBIN(ch) ((ch <= '9') ? ch - '0' : ch - ('A' - 10))
     30          
     31          /* forward references */
     32          int nmeap_init(nmeap_context_t *context,void *user_data);
     33          int nmeap_addParser(nmeap_context_t        *context,
     34                              const char             *sentence_name,
     35                              nmeap_sentence_parser_t sentence_parser,
     36                              nmeap_callout_t         sentence_callout,
     37                              void                   *sentence_data
     38                             );
     39          int nmeap_tokenize(nmeap_context_t *context);
     40          int nmeap_process(nmeap_context_t *context);
     41          int nmeap_parse(nmeap_context_t *context,char ch);
     42          int nmeap_parseBuffer(nmeap_context_t *context,const char *buffer,int *length);
     43          
     44          
     45          /*
     46          ********************************************************************************
     47          * Description : nmeap_latitude
     48          * Arguments   : const char *plat,const char *phem
     49          * Return      : 
     50          * Note        : get a latitude out of a pair of nmea tokens 
     51          ******************************************************************************** 
     52          */

   \                                 In section .text, align 2, keep-with-next
     53          double nmeap_latitude(const char *plat,const char *phem)
     54          {
   \                     nmeap_latitude: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
     55              double lat;
     56              int    deg;
     57              double min;
     58              int    ns;
     59              
     60              assert(plat != 0);
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD108             BNE.N    ??nmeap_latitude_0
   \   0000000C   0x223C             MOVS     R2,#+60
   \   0000000E   0x.... 0x....      ADR.W    R1,?_1
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       __aeabi_assert
   \   0000001A   0x.... 0x....      BL       __iar_EmptyStepPoint
     61              assert(phem != 0);
   \                     ??nmeap_latitude_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD108             BNE.N    ??nmeap_latitude_1
   \   00000022   0x223D             MOVS     R2,#+61
   \   00000024   0x.... 0x....      ADR.W    R1,?_1
   \   00000028   0x.... 0x....      ADR.W    R0,?_2
   \   0000002C   0x.... 0x....      BL       __aeabi_assert
   \   00000030   0x.... 0x....      BL       __iar_EmptyStepPoint
     62              
     63              if (*plat == 0) {
   \                     ??nmeap_latitude_1: (+1)
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??nmeap_latitude_2
     64                  return 0.0;
     65              }
     66              if (*phem == 0) {
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0x0001             MOVS     R1,R0
   \   0000003E   0xD102             BNE.N    ??nmeap_latitude_3
     67                  return 0.0;
   \                     ??nmeap_latitude_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4601             MOV      R1,R0
   \   00000044   0xE039             B.N      ??nmeap_latitude_4
     68              }
     69              
     70              /* north lat is +, south lat is - */
     71              if (*phem == 'N') {
   \                     ??nmeap_latitude_3: (+1)
   \   00000046   0x284E             CMP      R0,#+78
   \   00000048   0xD101             BNE.N    ??nmeap_latitude_5
     72                  ns = 1;
   \   0000004A   0x2601             MOVS     R6,#+1
   \   0000004C   0xE001             B.N      ??nmeap_latitude_6
     73              }
     74              else {
     75                  ns = -1;
   \                     ??nmeap_latitude_5: (+1)
   \   0000004E   0xF04F 0x36FF      MOV      R6,#-1
     76              }
     77              
     78              /* latitude is degrees, minutes, fractional minutes */
     79              /* no validation is performed on the token. it better be good.*/
     80              /* if it comes back 0.0 then probably the token was bad */
     81              lat = atof(plat);
   \                     ??nmeap_latitude_6: (+1)
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       atof
   \   00000058   0x4604             MOV      R4,R0
   \   0000005A   0x460D             MOV      R5,R1
     82              
     83              /* extract the degree part */
     84              deg = (int)(lat / 100.0);
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable30  ;; 0x40590000
   \   00000062   0x.... 0x....      BL       __aeabi_ddiv
   \   00000066   0x.... 0x....      BL       __aeabi_d2iz
   \   0000006A   0x4607             MOV      R7,R0
     85              
     86              /* mask out the degrees */
     87              min = lat - (deg * 100.0);
     88              
     89              /* compute the actual latitude in degrees.decimal-degrees */
     90              lat = (deg + (min / 60.0)) * ns;
     91              
     92              return lat;
   \   0000006C   0x.... 0x....      BL       __aeabi_i2d
   \   00000070   0x4680             MOV      R8,R0
   \   00000072   0x4689             MOV      R9,R1
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x.... 0x....      BL       __aeabi_i2d
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable30  ;; 0x40590000
   \   00000080   0x.... 0x....      BL       __aeabi_dmul
   \   00000084   0x4602             MOV      R2,R0
   \   00000086   0x460B             MOV      R3,R1
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x4629             MOV      R1,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_dsub
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x.... 0x....      LDR.W    R3,??DataTable30_1  ;; 0x404e0000
   \   00000096   0x.... 0x....      BL       __aeabi_ddiv
   \   0000009A   0x4642             MOV      R2,R8
   \   0000009C   0x464B             MOV      R3,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_dadd
   \   000000A2   0x4604             MOV      R4,R0
   \   000000A4   0x460D             MOV      R5,R1
   \   000000A6   0x4630             MOV      R0,R6
   \   000000A8   0x.... 0x....      BL       __aeabi_i2d
   \   000000AC   0x4622             MOV      R2,R4
   \   000000AE   0x462B             MOV      R3,R5
   \   000000B0   0xB001             ADD      SP,SP,#+4
   \   000000B2   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   000000B6   0x.... 0x....      B.W      __aeabi_dmul
   \                     ??nmeap_latitude_4: (+1)
   \   000000BA   0xE8BD 0x83F4      POP      {R2,R4-R9,PC}    ;; return
     93          }
     94          
     95          
     96          /*
     97          ********************************************************************************
     98          * Description : nmeap_longitude
     99          * Arguments   : const char *plon,const char *phem
    100          * Return      : 
    101          * Note        :  get a longitude out of a pair of nmea tokens
    102          ******************************************************************************** 
    103          */

   \                                 In section .text, align 2, keep-with-next
    104          double nmeap_longitude(const char *plon,const char *phem)
    105          {
   \                     nmeap_longitude: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    106              double lon;
    107              int    deg;
    108              double min;
    109              int    ew;
    110              
    111              assert(plon != 0);
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD108             BNE.N    ??nmeap_longitude_0
   \   0000000C   0x226F             MOVS     R2,#+111
   \   0000000E   0x.... 0x....      ADR.W    R1,?_1
   \   00000012   0x.... 0x....      ADR.W    R0,?_3
   \   00000016   0x.... 0x....      BL       __aeabi_assert
   \   0000001A   0x.... 0x....      BL       __iar_EmptyStepPoint
    112              assert(phem != 0);
   \                     ??nmeap_longitude_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD108             BNE.N    ??nmeap_longitude_1
   \   00000022   0x2270             MOVS     R2,#+112
   \   00000024   0x.... 0x....      ADR.W    R1,?_1
   \   00000028   0x.... 0x....      ADR.W    R0,?_2
   \   0000002C   0x.... 0x....      BL       __aeabi_assert
   \   00000030   0x.... 0x....      BL       __iar_EmptyStepPoint
    113              
    114              if (*plon == 0) {
   \                     ??nmeap_longitude_1: (+1)
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??nmeap_longitude_2
    115                  return 0.0;
    116              }
    117              if (*phem == 0) {
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0x0001             MOVS     R1,R0
   \   0000003E   0xD102             BNE.N    ??nmeap_longitude_3
    118                  return 0.0;
   \                     ??nmeap_longitude_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4601             MOV      R1,R0
   \   00000044   0xE039             B.N      ??nmeap_longitude_4
    119              }
    120              
    121              /* west long is negative, east long is positive */
    122              if (*phem == 'E') {
   \                     ??nmeap_longitude_3: (+1)
   \   00000046   0x2845             CMP      R0,#+69
   \   00000048   0xD101             BNE.N    ??nmeap_longitude_5
    123                  ew = 1;
   \   0000004A   0x2601             MOVS     R6,#+1
   \   0000004C   0xE001             B.N      ??nmeap_longitude_6
    124              }
    125              else {
    126                  ew = -1;
   \                     ??nmeap_longitude_5: (+1)
   \   0000004E   0xF04F 0x36FF      MOV      R6,#-1
    127              }
    128              
    129              /* longitude is degrees, minutes, fractional minutes */
    130              /* no validation is performed on the token. it better be good.*/
    131              /* if it comes back 0.0 then probably the token was bad */
    132              lon = atof(plon);
   \                     ??nmeap_longitude_6: (+1)
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       atof
   \   00000058   0x4604             MOV      R4,R0
   \   0000005A   0x460D             MOV      R5,R1
    133              
    134              /* extract the degree part */
    135              deg = (int)(lon / 100.0);
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable30  ;; 0x40590000
   \   00000062   0x.... 0x....      BL       __aeabi_ddiv
   \   00000066   0x.... 0x....      BL       __aeabi_d2iz
   \   0000006A   0x4607             MOV      R7,R0
    136              
    137              /* mask out the degrees */
    138              min = lon - (deg * 100.0);
    139              
    140              /* compute the actual lonitude in degrees.decimal-degrees */
    141              lon = (deg + (min / 60.0)) * ew;
    142          
    143              
    144              return lon;
   \   0000006C   0x.... 0x....      BL       __aeabi_i2d
   \   00000070   0x4680             MOV      R8,R0
   \   00000072   0x4689             MOV      R9,R1
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x.... 0x....      BL       __aeabi_i2d
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable30  ;; 0x40590000
   \   00000080   0x.... 0x....      BL       __aeabi_dmul
   \   00000084   0x4602             MOV      R2,R0
   \   00000086   0x460B             MOV      R3,R1
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x4629             MOV      R1,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_dsub
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x.... 0x....      LDR.W    R3,??DataTable30_1  ;; 0x404e0000
   \   00000096   0x.... 0x....      BL       __aeabi_ddiv
   \   0000009A   0x4642             MOV      R2,R8
   \   0000009C   0x464B             MOV      R3,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_dadd
   \   000000A2   0x4604             MOV      R4,R0
   \   000000A4   0x460D             MOV      R5,R1
   \   000000A6   0x4630             MOV      R0,R6
   \   000000A8   0x.... 0x....      BL       __aeabi_i2d
   \   000000AC   0x4622             MOV      R2,R4
   \   000000AE   0x462B             MOV      R3,R5
   \   000000B0   0xB001             ADD      SP,SP,#+4
   \   000000B2   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   000000B6   0x.... 0x....      B.W      __aeabi_dmul
   \                     ??nmeap_longitude_4: (+1)
   \   000000BA   0xE8BD 0x83F4      POP      {R2,R4-R9,PC}    ;; return
    145          }
    146          
    147          
    148          /*
    149          ********************************************************************************
    150          * Description : nmeap_altitude
    151          * Arguments   : const char *palt,const char *punits
    152          * Return      : 
    153          * Note        :  get an altitude longitude out of a pair of nmea tokens
    154          *                ALTITUDE is returned in METERS 
    155          ******************************************************************************** 
    156          */

   \                                 In section .text, align 2, keep-with-next
    157          double nmeap_altitude(const char *palt,const char *punits)
    158          {
   \                     nmeap_altitude: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    159              double alt;
    160              
    161              if (*palt == 0) {
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD102             BNE.N    ??nmeap_altitude_0
    162                  return 0.0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0xBD10             POP      {R4,PC}
    163              }
    164              
    165              /* convert with no error checking */
    166              alt = atof(palt);
   \                     ??nmeap_altitude_0: (+1)
   \   00000010   0x.... 0x....      BL       atof
    167              
    168              if (*punits == 'M') {
   \   00000014   0x7822             LDRB     R2,[R4, #+0]
   \   00000016   0x2A4D             CMP      R2,#+77
   \   00000018   0xD009             BEQ.N    ??nmeap_altitude_1
    169                  /* already in meters */ 
    170              }
    171              else if (*punits == 'F') {
   \   0000001A   0x2A46             CMP      R2,#+70
   \   0000001C   0xD107             BNE.N    ??nmeap_altitude_1
    172                  /* convert to feet */
    173                  alt = alt * 3.2808399;
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable30_2  ;; 0xfd4f4b98
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable30_3  ;; 0x400a3f28
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x.... 0x....      B.W      __aeabi_dmul
    174              }
    175              
    176              return alt;
   \                     ??nmeap_altitude_1: (+1)
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    177          }
    178          
    179          
    180          /*
    181          ********************************************************************************
    182          * Description : nmeap_init
    183          * Arguments   : nmeap_context_t *context,void *user_data
    184          * Return      : 
    185          * Note        : initialize an NMEA parser
    186          ******************************************************************************** 
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          int nmeap_init(nmeap_context_t *context,void *user_data)
    189          {
   \                     nmeap_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    190              assert(context != 0);
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD108             BNE.N    ??nmeap_init_0
   \   0000000A   0x22BE             MOVS     R2,#+190
   \   0000000C   0x.... 0x....      ADR.W    R1,?_1
   \   00000010   0x.... 0x....      ADR.W    R0,?_4
   \   00000014   0x.... 0x....      BL       __aeabi_assert
   \   00000018   0x.... 0x....      BL       __iar_EmptyStepPoint
    191          
    192              memset(context,0,sizeof(*context));
   \                     ??nmeap_init_0: (+1)
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xF44F 0x7156      MOV      R1,#+856
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       __aeabi_memset4
    193          
    194              context->user_data = user_data;
   \   00000028   0xF8C4 0x5354      STR      R5,[R4, #+852]
    195          
    196              return 0;    
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    197          }
    198          
    199          
    200          /*
    201          ********************************************************************************
    202          * Description : nmeap_addParser
    203          * Arguments   : ...
    204          * Return      : 
    205          * Note        : register an NMEA sentence parser
    206          ******************************************************************************** 
    207          */

   \                                 In section .text, align 2, keep-with-next
    208          int nmeap_addParser(nmeap_context_t        *context,
    209          					          const char             *sentence_name,
    210          					          nmeap_sentence_parser_t sentence_parser,
    211          					          nmeap_callout_t         sentence_callout,
    212                              void                   *sentence_data
    213          					         )
    214          {
   \                     nmeap_addParser: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    215              nmeap_sentence_t *s = 0;
    216              
    217              /* runtime error */
    218              assert(context != 0);
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD108             BNE.N    ??nmeap_addParser_0
   \   00000010   0x22DA             MOVS     R2,#+218
   \   00000012   0x.... 0x....      ADR.W    R1,?_1
   \   00000016   0x.... 0x....      ADR.W    R0,?_4
   \   0000001A   0x.... 0x....      BL       __aeabi_assert
   \   0000001E   0x.... 0x....      BL       __iar_EmptyStepPoint
    219              
    220              /* sentence capacity overflow */
    221              if (context->sentence_count >= NMEAP_MAX_SENTENCES) {
   \                     ??nmeap_addParser_0: (+1)
   \   00000022   0xF8D4 0x00C0      LDR      R0,[R4, #+192]
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xDB02             BLT.N    ??nmeap_addParser_1
    222                  return -1;
   \   0000002A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000002E   0xE018             B.N      ??nmeap_addParser_2
    223              }
    224              
    225              /* point at next empty sentence buffer */
    226              s = &context->sentence[context->sentence_count];
   \                     ??nmeap_addParser_1: (+1)
   \   00000030   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000034   0xEB04 0x08C1      ADD      R8,R4,R1, LSL #+3
    227              
    228              /* advance sentence data count */
    229              context->sentence_count++;
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0xF8C4 0x00C0      STR      R0,[R4, #+192]
    230              
    231              /* clear the sentence data */
    232              memset(s,0,sizeof(*s));
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2118             MOVS     R1,#+24
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x.... 0x....      BL       __aeabi_memset4
    233              
    234              /* name */
    235              strncpy(s->name,sentence_name,NMEAP_MAX_SENTENCE_NAME_LENGTH);
   \   00000048   0x2205             MOVS     R2,#+5
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       strncpy
    236              
    237              /* parser */
    238              s->parser = sentence_parser;
   \   00000052   0xF8C8 0x600C      STR      R6,[R8, #+12]
    239              
    240              /* callout */
    241              s->callout = sentence_callout;
   \   00000056   0xF8C8 0x7010      STR      R7,[R8, #+16]
    242              
    243              /* data */
    244              s->data    = sentence_data;
   \   0000005A   0x9806             LDR      R0,[SP, #+24]
   \   0000005C   0xF8C8 0x0014      STR      R0,[R8, #+20]
    245          
    246              return 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??nmeap_addParser_2: (+1)
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    247          }
    248          
    249          
    250          /*
    251          ********************************************************************************
    252          * Description : nmeap_tokenize
    253          * Arguments   : nmeap_context_t *context
    254          * Return      : 
    255          * Note        : tokenize a buffer
    256          ******************************************************************************** 
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          int nmeap_tokenize(nmeap_context_t *context)
    259          {
   \                     nmeap_tokenize: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    260              char *s;
    261              int   tokens;
    262              int   state;
    263              
    264              /* first token is header. assume it is there */
    265              tokens = 0;
    266              s = context->input;
   \   00000002   0xF100 0x02C4      ADD      R2,R0,#+196
    267              context->token[tokens] = s;
   \   00000006   0xF8C0 0x21D4      STR      R2,[R0, #+468]
    268              
    269              /* get rest of tokens */
    270              tokens = 1;
   \   0000000A   0x2101             MOVS     R1,#+1
    271              state = 0;
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0xE001             B.N      ??nmeap_tokenize_0
    272              while((*s != 0)&&(tokens < NMEAP_MAX_TOKENS)) {
    273                  switch(state) {
    274                  case 0:
    275                      /* looking for end of a token */
    276                      if (*s == ',') {
    277                          /* delimit at the comma */
    278                          *s    = 0;
    279                          /* new token */
    280                          state = 1;
    281                      }
    282                      break;
    283                  case 1:
    284                      /* start of next token, might be another comma */
    285                      context->token[tokens++] = s;
    286                      if (*s == ',') {
    287                          /* delimit at the comma */
    288                          *s    = 0;
    289                      }
    290                      else {   
    291                          /* not a comma */
    292                          state = 0;
    293                      }
    294                      break;
    295                  default:
    296                      state = 0;
   \                     ??nmeap_tokenize_1: (+1)
   \   00000010   0x2300             MOVS     R3,#+0
    297                      break;
    298                  }
    299                  
    300                  // next character
    301                  s++;
   \                     ??nmeap_tokenize_2: (+1)
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \                     ??nmeap_tokenize_0: (+1)
   \   00000014   0x7814             LDRB     R4,[R2, #+0]
   \   00000016   0x0025             MOVS     R5,R4
   \   00000018   0xD019             BEQ.N    ??nmeap_tokenize_3
   \   0000001A   0x2918             CMP      R1,#+24
   \   0000001C   0xDA17             BGE.N    ??nmeap_tokenize_3
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD002             BEQ.N    ??nmeap_tokenize_4
   \   00000022   0x2B01             CMP      R3,#+1
   \   00000024   0xD006             BEQ.N    ??nmeap_tokenize_5
   \   00000026   0xE7F3             B.N      ??nmeap_tokenize_1
   \                     ??nmeap_tokenize_4: (+1)
   \   00000028   0x2C2C             CMP      R4,#+44
   \   0000002A   0xD1F2             BNE.N    ??nmeap_tokenize_2
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x7013             STRB     R3,[R2, #+0]
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0xE7EE             B.N      ??nmeap_tokenize_2
   \                     ??nmeap_tokenize_5: (+1)
   \   00000034   0xEB00 0x0481      ADD      R4,R0,R1, LSL #+2
   \   00000038   0xF8C4 0x21D4      STR      R2,[R4, #+468]
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0x7814             LDRB     R4,[R2, #+0]
   \   00000040   0x2C2C             CMP      R4,#+44
   \   00000042   0xD102             BNE.N    ??nmeap_tokenize_6
   \   00000044   0x2400             MOVS     R4,#+0
   \   00000046   0x7014             STRB     R4,[R2, #+0]
   \   00000048   0xE7E3             B.N      ??nmeap_tokenize_2
   \                     ??nmeap_tokenize_6: (+1)
   \   0000004A   0x2300             MOVS     R3,#+0
   \   0000004C   0xE7E1             B.N      ??nmeap_tokenize_2
    302              }
    303              return tokens;
   \                     ??nmeap_tokenize_3: (+1)
   \   0000004E   0x4608             MOV      R0,R1
   \   00000050   0xBC30             POP      {R4,R5}
   \   00000052   0x4770             BX       LR               ;; return
    304          }
    305          
    306          
    307          /*
    308          ********************************************************************************
    309          * Description : nmeap_process
    310          * Arguments   : nmeap_context_t *context
    311          * Return      : 
    312          * Note        : process a sentence
    313          ******************************************************************************** 
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          int nmeap_process(nmeap_context_t *context)
    316          {
   \                     nmeap_process: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    317              int id;
    318              int i;
    319              nmeap_sentence_t *s;
    320          	
    321              /* copy the input to a debug buffer */
    322              /* remove debug_input when everything is working. */
    323              strncpy(context->debug_input,context->input,sizeof(context->debug_input));
   \   00000004   0xF44F 0x7280      MOV      R2,#+256
   \   00000008   0xF104 0x01C4      ADD      R1,R4,#+196
   \   0000000C   0xF44F 0x7015      MOV      R0,#+596
   \   00000010   0x4420             ADD      R0,R4,R0
   \   00000012   0x.... 0x....      BL       strncpy
    324              
    325              /* tokenize the input */
    326              context->tokens = nmeap_tokenize(context);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       nmeap_tokenize
   \   0000001C   0xF8C4 0x0234      STR      R0,[R4, #+564]
    327              
    328              /* try to find a matching sentence parser */
    329              /* this search is O(n). it has a lot of potential for optimization, */
    330              /* at the expense of complexity, if you have a lot of sentences */
    331              /* binary search instead of linear (have to keep sentences in sorted order) O(NlogN) */
    332              /* OR, when sentences are added, create a TRIE structure to find the names with */
    333              /* a constant time search O(5) */
    334              for(i=0;i<context->sentence_count;i++) {
   \   00000020   0x2600             MOVS     R6,#+0
   \   00000022   0xE000             B.N      ??nmeap_process_0
   \                     ??nmeap_process_1: (+1)
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \                     ??nmeap_process_0: (+1)
   \   00000026   0xF8D4 0x00C0      LDR      R0,[R4, #+192]
   \   0000002A   0x4286             CMP      R6,R0
   \   0000002C   0xDA1F             BGE.N    ??nmeap_process_2
    335                  s = &context->sentence[i];
    336                  assert(s != 0);
   \   0000002E   0xEB06 0x0046      ADD      R0,R6,R6, LSL #+1
   \   00000032   0xEB14 0x07C0      ADDS     R7,R4,R0, LSL #+3
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD109             BNE.N    ??nmeap_process_3
   \   0000003A   0xF44F 0x72A8      MOV      R2,#+336
   \   0000003E   0x.... 0x....      ADR.W    R1,?_1
   \   00000042   0x.... 0x....      ADR.W    R0,?_5
   \   00000046   0x.... 0x....      BL       __aeabi_assert
   \   0000004A   0x.... 0x....      BL       __iar_EmptyStepPoint
    337                  if (strncmp(context->input_name,s->name,5) == 0) {
   \                     ??nmeap_process_3: (+1)
   \   0000004E   0x2205             MOVS     R2,#+5
   \   00000050   0x4639             MOV      R1,R7
   \   00000052   0xF44F 0x70E6      MOV      R0,#+460
   \   00000056   0x4420             ADD      R0,R4,R0
   \   00000058   0x.... 0x....      BL       strncmp
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD1E1             BNE.N    ??nmeap_process_1
    338                      /* found a match, call its parser */
    339                      id = (*context->sentence[i].parser)(context,s);
   \   00000060   0x4639             MOV      R1,R7
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x68FA             LDR      R2,[R7, #+12]
   \   00000066   0x4790             BLX      R2
   \   00000068   0x4605             MOV      R5,R0
    340                      if (id > 0) {
   \   0000006A   0x2D01             CMP      R5,#+1
   \   0000006C   0xDBDA             BLT.N    ??nmeap_process_1
    341                          break;
    342                      }
    343                  }
    344              }
    345                  
    346              return id;
   \                     ??nmeap_process_2: (+1)
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    347          }
    348          
    349          /*
    350          ********************************************************************************
    351          * Description : nmeap_parse
    352          * Arguments   : nmeap_context_t *context,char ch
    353          * Return      : 
    354          * Note        : 
    355                           +-5-+              +---+
    356                           v   |              v   |
    357           +------+       +------+           +------+         +------+         +------+
    358           |   0  |--$--> |1-hdr |--alnum--> |2-data|----\r-->| 6-LF |---\n--->| done |--> 0
    359           +------+       +------+           +------+         +------+         +------+
    360                                              |                 ^
    361                                              *                 +--------\r-------+
    362                                              V                                   |
    363                                           +------+           +------+         +------+
    364                                           |3-cks |--xdigit-->|4-cks |-xdigit->| 5-CR |
    365                                           +------+           +------+         +------+
    366                                           
    367          return to start conditions:
    368          1. buffer overflow
    369          2. invalid character for state
    370          
    371          checksum calculation
    372          two hex digits represent the XOR of all characters between, but not
    373          including, the "$" and "*".  A checksum is required on some
    374          sentences.
    375          ******************************************************************************** 
    376          */

   \                                 In section .text, align 4, keep-with-next
    377          int nmeap_parse(nmeap_context_t *context,char ch)
    378          {
   \                     nmeap_parse: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
    379            int status = 0;
   \   00000008   0x2400             MOVS     R4,#+0
    380            
    381            /* check for input buffer overrun first to avoid duplicating code in the
    382            individual states
    383            */
    384            if (context->input_count >= (sizeof(context->input)-1)) {
   \   0000000A   0xF44F 0x70E2      MOV      R0,#+452
   \   0000000E   0x1835             ADDS     R5,R6,R0
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xD302             BCC.N    ??nmeap_parse_1
    385              /* input buffer overrun, restart state machine */
    386              context->input_state = 0;
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x6068             STR      R0,[R5, #+4]
    387              /* reset input count */
    388              context->input_count = 0;
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    389            }
    390            
    391            /* store the byte */
    392            context->input[context->input_count] = ch;
   \                     ??nmeap_parse_1: (+1)
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x4430             ADD      R0,R6,R0
   \   00000020   0xF880 0x70C4      STRB     R7,[R0, #+196]
    393            
    394            /* next buffer position */
    395            context->input_count++;
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x6028             STR      R0,[R5, #+0]
    396            
    397            /* run it through the lexical scanner */
    398            switch(context->input_state) {
   \   0000002A   0x6869             LDR      R1,[R5, #+4]
   \   0000002C   0x2906             CMP      R1,#+6
   \   0000002E   0xF200 0x80A8      BHI.W    ??nmeap_parse_2
   \   00000032   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??nmeap_parse_0:
   \   00000036   0x04 0x13          DC8      0x4,0x13,0x30,0x44
   \              0x30 0x44    
   \   0000003A   0x5A 0x7B          DC8      0x5A,0x7B,0x80,0x0
   \              0x80 0x00    
    399            /* LOOKING FOR $ */
    400            case 0:
    401              if (ch == '$') {
   \                     ??nmeap_parse_3: (+1)
   \   0000003E   0x2F24             CMP      R7,#+36
   \   00000040   0xD105             BNE.N    ??nmeap_parse_4
    402                  /*look for id */
    403                  context->input_state = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x6068             STR      R0,[R5, #+4]
    404                  context->ccks        = 0;
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x73E8             STRB     R0,[R5, #+15]
    405                  context->icks        = 0;
   \   0000004A   0x73A8             STRB     R0,[R5, #+14]
   \   0000004C   0xE0A1             B.N      ??nmeap_parse_5
    406              }
    407              else {
    408                  /* header error, start over */
    409                  context->err_hdr++;
   \                     ??nmeap_parse_4: (+1)
   \   0000004E   0x6FA8             LDR      R0,[R5, #+120]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x67A8             STR      R0,[R5, #+120]
    410                  context->input_state = 0;
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x6068             STR      R0,[R5, #+4]
    411                  context->input_count = 0;
   \   00000058   0x6028             STR      R0,[R5, #+0]
   \   0000005A   0xE09A             B.N      ??nmeap_parse_5
    412              }
    413              break;
    414            /* LOOKING FOR 5 CHARACTER SENTENCE ID */
    415            case 1:
    416              /* allow numbers even though it isn't usually done */
    417              /* a proprietary id might have a numeral */
    418              if (isalnum(ch)) {
   \                     ??nmeap_parse_6: (+1)
   \   0000005C   0x4638             MOV      R0,R7
   \   0000005E   0x.... 0x....      BL       isalnum
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD00D             BEQ.N    ??nmeap_parse_7
    419                  /* store name separately */
    420                  context->input_name[context->input_count - 2] = ch;
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0x4430             ADD      R0,R6,R0
   \   0000006A   0xF880 0x71CA      STRB     R7,[R0, #+458]
    421                  /* checksum */
    422                  context->ccks ^= ch;
   \   0000006E   0x7BE8             LDRB     R0,[R5, #+15]
   \   00000070   0x4078             EORS     R0,R7,R0
   \   00000072   0x73E8             STRB     R0,[R5, #+15]
    423                  /* end of header? */
    424                  if (context->input_count >= 6) {
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x2806             CMP      R0,#+6
   \   00000078   0xF2C0 0x808B      BLT.W    ??nmeap_parse_5
    425                      /* yes, get body */
    426                      context->input_state = 2;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x6068             STR      R0,[R5, #+4]
   \   00000080   0xE087             B.N      ??nmeap_parse_5
    427                  }
    428              }
    429              else {
    430                  /* bad character, start over */
    431                  context->err_id++;
   \                     ??nmeap_parse_7: (+1)
   \   00000082   0xF44F 0x7011      MOV      R0,#+580
   \   00000086   0x4430             ADD      R0,R6,R0
   \   00000088   0x6841             LDR      R1,[R0, #+4]
   \   0000008A   0x1C49             ADDS     R1,R1,#+1
   \   0000008C   0x6041             STR      R1,[R0, #+4]
    432                  context->input_state = 0;
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x6068             STR      R0,[R5, #+4]
    433                  context->input_count = 0;
   \   00000092   0x6028             STR      R0,[R5, #+0]
   \   00000094   0xE07D             B.N      ??nmeap_parse_5
    434              }
    435              break;
    436            /* LOOKING FOR CR OR CHECKSUM INDICATOR */
    437            case 2:
    438              if (ch == '*') {
   \                     ??nmeap_parse_8: (+1)
   \   00000096   0x46B8             MOV      R8,R7
   \   00000098   0xF1B8 0x0F2A      CMP      R8,#+42
   \   0000009C   0xD102             BNE.N    ??nmeap_parse_9
    439                  /* this sentence has a checksum */
    440                  context->input_state = 3;
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0x6068             STR      R0,[R5, #+4]
   \   000000A2   0xE076             B.N      ??nmeap_parse_5
    441              }
    442              else if (ch == '\r') {
   \                     ??nmeap_parse_9: (+1)
   \   000000A4   0xF1B8 0x0F0D      CMP      R8,#+13
   \   000000A8   0xD105             BNE.N    ??nmeap_parse_10
    443                  /* carriage return, no checksum, force a match */
    444                context->icks = 0;
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x73A8             STRB     R0,[R5, #+14]
    445                context->ccks = 0;
   \   000000AE   0x73E8             STRB     R0,[R5, #+15]
    446                context->input_state = 6;
   \   000000B0   0x2006             MOVS     R0,#+6
   \   000000B2   0x6068             STR      R0,[R5, #+4]
   \   000000B4   0xE06D             B.N      ??nmeap_parse_5
    447              }
    448              else {
    449                  /* continue accumulating data */
    450                  /* checksum */
    451                  context->ccks ^= ch;
   \                     ??nmeap_parse_10: (+1)
   \   000000B6   0x7BE8             LDRB     R0,[R5, #+15]
   \   000000B8   0x4078             EORS     R0,R7,R0
   \   000000BA   0x73E8             STRB     R0,[R5, #+15]
   \   000000BC   0xE069             B.N      ??nmeap_parse_5
    452              }
    453              break;
    454            /* LOOKING FOR FIRST CHECKSUM CHARACTER */
    455            case 3:
    456              /* must be upper case hex digit */
    457              if (isxdigit(ch) && (ch <= 'F')) {
   \                     ??nmeap_parse_11: (+1)
   \   000000BE   0x46B8             MOV      R8,R7
   \   000000C0   0x4640             MOV      R0,R8
   \   000000C2   0x.... 0x....      BL       isxdigit
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD026             BEQ.N    ??nmeap_parse_12
   \   000000CA   0xF1B8 0x0F47      CMP      R8,#+71
   \   000000CE   0xDA23             BGE.N    ??nmeap_parse_12
    458                /* got first checksum byte */
    459                context->input_state = 4;
   \   000000D0   0x2004             MOVS     R0,#+4
   \   000000D2   0x6068             STR      R0,[R5, #+4]
    460                context->icks = HEXTOBIN(ch) << 4;
   \   000000D4   0xF1B8 0x0F3A      CMP      R8,#+58
   \   000000D8   0xDA02             BGE.N    ??nmeap_parse_13
   \   000000DA   0xF1A8 0x0030      SUB      R0,R8,#+48
   \   000000DE   0xE001             B.N      ??nmeap_parse_14
   \                     ??nmeap_parse_13: (+1)
   \   000000E0   0xF1A8 0x0037      SUB      R0,R8,#+55
   \                     ??nmeap_parse_14: (+1)
   \   000000E4   0x0100             LSLS     R0,R0,#+4
   \   000000E6   0x73A8             STRB     R0,[R5, #+14]
   \   000000E8   0xE053             B.N      ??nmeap_parse_5
    461              }
    462              else {
    463                /* input error, restart */
    464                context->err_cks++;
    465                context->input_state = 0;
    466                context->input_count = 0;
    467              }
    468              break;
    469              /* LOOKING FOR SECOND CHECKSUM CHARACTER */
    470            case 4:
    471              /* must be upper case hex digit */
    472              if (isxdigit(ch) && (ch <= 'F')) {
   \                     ??nmeap_parse_15: (+1)
   \   000000EA   0x46B8             MOV      R8,R7
   \   000000EC   0x4640             MOV      R0,R8
   \   000000EE   0x.... 0x....      BL       isxdigit
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD010             BEQ.N    ??nmeap_parse_12
   \   000000F6   0xF1B8 0x0F47      CMP      R8,#+71
   \   000000FA   0xDA0D             BGE.N    ??nmeap_parse_12
    473                  /* got second checksum byte */
    474                  context->input_state = 5;
   \   000000FC   0x2005             MOVS     R0,#+5
   \   000000FE   0x6068             STR      R0,[R5, #+4]
    475                  context->icks += HEXTOBIN(ch);
   \   00000100   0xF1B8 0x0F3A      CMP      R8,#+58
   \   00000104   0xDA02             BGE.N    ??nmeap_parse_16
   \   00000106   0xF1A8 0x0030      SUB      R0,R8,#+48
   \   0000010A   0xE001             B.N      ??nmeap_parse_17
   \                     ??nmeap_parse_16: (+1)
   \   0000010C   0xF1A8 0x0037      SUB      R0,R8,#+55
   \                     ??nmeap_parse_17: (+1)
   \   00000110   0x7BA9             LDRB     R1,[R5, #+14]
   \   00000112   0x1840             ADDS     R0,R0,R1
   \   00000114   0x73A8             STRB     R0,[R5, #+14]
   \   00000116   0xE03C             B.N      ??nmeap_parse_5
    476              }
    477              else {
    478                  /* input error, restart */
    479                  context->err_cks++;
   \                     ??nmeap_parse_12: (+1)
   \   00000118   0xF44F 0x7011      MOV      R0,#+580
   \   0000011C   0x4430             ADD      R0,R6,R0
   \   0000011E   0x6881             LDR      R1,[R0, #+8]
   \   00000120   0x1C49             ADDS     R1,R1,#+1
   \   00000122   0x6081             STR      R1,[R0, #+8]
    480                  context->input_state = 0;
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x6068             STR      R0,[R5, #+4]
    481                  context->input_count = 0;
   \   00000128   0x6028             STR      R0,[R5, #+0]
   \   0000012A   0xE032             B.N      ??nmeap_parse_5
    482              }
    483              break;
    484            /* LOOKING FOR CR */
    485            case 5:
    486              if (ch == '\r') {
   \                     ??nmeap_parse_18: (+1)
   \   0000012C   0x2F0D             CMP      R7,#+13
   \   0000012E   0xD11E             BNE.N    ??nmeap_parse_19
    487                  /* carriage return */
    488                  context->input_state = 6;
   \   00000130   0x2006             MOVS     R0,#+6
   \   00000132   0x6068             STR      R0,[R5, #+4]
   \   00000134   0xE02D             B.N      ??nmeap_parse_5
    489              }
    490              else {
    491                  /* input error, restart */
    492                  context->err_crl++;
    493                  context->input_state = 0;
    494                  context->input_count = 0;
    495              }
    496              break;
    497            /* LOOKING FOR LINE FEED */
    498            case 6:
    499              if (ch == '\n') {
   \                     ??nmeap_parse_20: (+1)
   \   00000136   0x2F0A             CMP      R7,#+10
   \   00000138   0xD119             BNE.N    ??nmeap_parse_19
    500                /* linefeed, line complete */
    501                
    502                /* delimit buffer */
    503                context->input[context->input_count] = 0;
   \   0000013A   0x4621             MOV      R1,R4
   \   0000013C   0x4430             ADD      R0,R6,R0
   \   0000013E   0xF880 0x10C4      STRB     R1,[R0, #+196]
    504                    
    505                /* if the checksums match, process the sentence */
    506                if (context->ccks == context->icks) {
   \   00000142   0x7BE8             LDRB     R0,[R5, #+15]
   \   00000144   0x7BA9             LDRB     R1,[R5, #+14]
   \   00000146   0x4288             CMP      R0,R1
   \   00000148   0xD107             BNE.N    ??nmeap_parse_21
    507                  /* process */
    508                  status = nmeap_process(context);
   \   0000014A   0x4630             MOV      R0,R6
   \   0000014C   0x.... 0x....      BL       nmeap_process
   \   00000150   0x4604             MOV      R4,R0
    509                  //gps_status = status;
    510                  /* count good messages */
    511                  context->msgs++;
   \   00000152   0x6F68             LDR      R0,[R5, #+116]
   \   00000154   0x1C40             ADDS     R0,R0,#+1
   \   00000156   0x6768             STR      R0,[R5, #+116]
   \   00000158   0xE005             B.N      ??nmeap_parse_22
    512                }
    513                else {
    514                  /* count checksum errors */
    515                  context->err_cks++;
   \                     ??nmeap_parse_21: (+1)
   \   0000015A   0xF44F 0x7011      MOV      R0,#+580
   \   0000015E   0x4430             ADD      R0,R6,R0
   \   00000160   0x6881             LDR      R1,[R0, #+8]
   \   00000162   0x1C49             ADDS     R1,R1,#+1
   \   00000164   0x6081             STR      R1,[R0, #+8]
    516                }
    517                    
    518                /* restart next time */
    519                context->input_state = 0;
   \                     ??nmeap_parse_22: (+1)
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x6068             STR      R0,[R5, #+4]
    520                context->input_count = 0;
   \   0000016A   0x6028             STR      R0,[R5, #+0]
   \   0000016C   0xE011             B.N      ??nmeap_parse_5
    521              }
    522              else {
    523                  /* input error, restart */
    524                  context->err_crl++;
   \                     ??nmeap_parse_19: (+1)
   \   0000016E   0xF44F 0x7011      MOV      R0,#+580
   \   00000172   0x4430             ADD      R0,R6,R0
   \   00000174   0x68C1             LDR      R1,[R0, #+12]
   \   00000176   0x1C49             ADDS     R1,R1,#+1
   \   00000178   0x60C1             STR      R1,[R0, #+12]
    525                  context->input_state = 0;
   \   0000017A   0x4620             MOV      R0,R4
   \   0000017C   0x6068             STR      R0,[R5, #+4]
    526                  context->input_count = 0;
   \   0000017E   0x6028             STR      R0,[R5, #+0]
   \   00000180   0xE007             B.N      ??nmeap_parse_5
    527              }
    528              break;
    529            default:
    530              context->err_unk++;
   \                     ??nmeap_parse_2: (+1)
   \   00000182   0xF44F 0x7011      MOV      R0,#+580
   \   00000186   0x4430             ADD      R0,R6,R0
   \   00000188   0x6801             LDR      R1,[R0, #+0]
   \   0000018A   0x1C49             ADDS     R1,R1,#+1
   \   0000018C   0x6001             STR      R1,[R0, #+0]
    531              context->input_state = 0;
   \   0000018E   0x4620             MOV      R0,R4
   \   00000190   0x6068             STR      R0,[R5, #+4]
    532              break;
    533            }
    534                      
    535          	return status;
   \                     ??nmeap_parse_5: (+1)
   \   00000192   0x4620             MOV      R0,R4
   \   00000194   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    536          }
    537          
    538          
    539          /*
    540          ********************************************************************************
    541          * Description : nmeap_gpgga
    542          * Arguments   : nmeap_context_t *context,const char *buffer,int *length
    543          * Return      : 
    544          * Note        : parse a buffer of nmea data
    545          ******************************************************************************** 
    546          */

   \                                 In section .text, align 2, keep-with-next
    547          int nmeap_parseBuffer(nmeap_context_t *context,const char *buffer,int *length)
    548          {
   \                     nmeap_parseBuffer: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    549            int  i;
    550            int  status;
    551            int  rem;
    552            int  tlen;
    553            
    554            tlen   = *length;
   \   0000000A   0x6837             LDR      R7,[R6, #+0]
    555            rem    = *length;
   \   0000000C   0x46B8             MOV      R8,R7
    556            status = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
    557            /* for each byte in the buffer */
    558            for(i=0;i<tlen;i++) {
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0xE001             B.N      ??nmeap_parseBuffer_0
   \                     ??nmeap_parseBuffer_1: (+1)
   \   00000014   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??nmeap_parseBuffer_0: (+1)
   \   00000018   0x45B9             CMP      R9,R7
   \   0000001A   0xDA08             BGE.N    ??nmeap_parseBuffer_2
    559              /* decrement remaining byte count */
    560              rem--;
   \   0000001C   0xF1A8 0x0801      SUB      R8,R8,#+1
    561              /* parse the byte */
    562              status = nmeap_parse(context,buffer[i]);
   \   00000020   0xF815 0x1009      LDRB     R1,[R5, R9]
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       nmeap_parse
    563              if (status != 0) {
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD0F2             BEQ.N    ??nmeap_parseBuffer_1
    564                /* message found or error */
    565                break;
    566              }
    567            }
    568          
    569            /* return remaining byte count */
    570            *length = rem;
   \                     ??nmeap_parseBuffer_2: (+1)
   \   0000002E   0xF8C6 0x8000      STR      R8,[R6, #+0]
    571          
    572            return status;
   \   00000032   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    573          }
    574          
    575          
    576          /*
    577          ********************************************************************************
    578          * Description : nmeap_gpgga
    579          * Arguments   : nmeap_context_t *context,nmeap_sentence_t *sentence
    580          * Return      : 
    581          * Note        : standard GPGGA sentence parser 
    582          ******************************************************************************** 
    583          */

   \                                 In section .text, align 2, keep-with-next
    584          int nmeap_gpgga(nmeap_context_t *context,nmeap_sentence_t *sentence)
    585          {
   \                     nmeap_gpgga: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    586            int i;
    587          
    588            
    589            /* get pointer to sentence data */
    590            nmeap_gga_t *gga = (nmeap_gga_t *)sentence->data;
   \   00000006   0x6975             LDR      R5,[R6, #+20]
    591            
    592            /* if there is a data element, extract data from the tokens */
    593          	if (gga != 0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD02B             BEQ.N    ??nmeap_gpgga_0
    594          		gga->latitude  = nmeap_latitude(context->token[2],context->token[3]);
   \   0000000C   0xF44F 0x70EC      MOV      R0,#+472
   \   00000010   0x1827             ADDS     R7,R4,R0
   \   00000012   0x68B9             LDR      R1,[R7, #+8]
   \   00000014   0x6878             LDR      R0,[R7, #+4]
   \   00000016   0x.... 0x....      BL       nmeap_latitude
   \   0000001A   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
    595          		gga->longitude = nmeap_longitude(context->token[4],context->token[5]);
   \   0000001E   0x6939             LDR      R1,[R7, #+16]
   \   00000020   0x68F8             LDR      R0,[R7, #+12]
   \   00000022   0x.... 0x....      BL       nmeap_longitude
   \   00000026   0xE9C5 0x0102      STRD     R0,R1,[R5, #+8]
    596          		gga->altitude  = nmeap_altitude(context->token[9],context->token[10]);
   \   0000002A   0x6A79             LDR      R1,[R7, #+36]
   \   0000002C   0x6A38             LDR      R0,[R7, #+32]
   \   0000002E   0x.... 0x....      BL       nmeap_altitude
   \   00000032   0xE9C5 0x0104      STRD     R0,R1,[R5, #+16]
    597          		gga->time       = atoi(context->token[1]);
   \   00000036   0x6838             LDR      R0,[R7, #+0]
   \   00000038   0x.... 0x....      BL       atoi
   \   0000003C   0x61A8             STR      R0,[R5, #+24]
    598          		gga->satellites = atoi(context->token[7]);
   \   0000003E   0x69B8             LDR      R0,[R7, #+24]
   \   00000040   0x.... 0x....      BL       atoi
   \   00000044   0x61E8             STR      R0,[R5, #+28]
    599          		gga->quality    = atoi(context->token[6]);
   \   00000046   0x6978             LDR      R0,[R7, #+20]
   \   00000048   0x.... 0x....      BL       atoi
   \   0000004C   0x6228             STR      R0,[R5, #+32]
    600          		gga->hdop       = atof(context->token[8]);
   \   0000004E   0x69F8             LDR      R0,[R7, #+28]
   \   00000050   0x.... 0x....      BL       atof
   \   00000054   0xE9C5 0x010A      STRD     R0,R1,[R5, #+40]
    601          		gga->geoid      = nmeap_altitude(context->token[11],context->token[12]);
   \   00000058   0x6AF9             LDR      R1,[R7, #+44]
   \   0000005A   0x6AB8             LDR      R0,[R7, #+40]
   \   0000005C   0x.... 0x....      BL       nmeap_altitude
   \   00000060   0xE9C5 0x010C      STRD     R0,R1,[R5, #+48]
    602          	}
    603          
    604            if(gps_on) { 
   \                     ??nmeap_gpgga_0: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable30_4
   \   00000068   0x79C0             LDRB     R0,[R0, #+7]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD025             BEQ.N    ??nmeap_gpgga_1
    605              /* print raw input string */
    606              printk("%s",context->debug_input);
   \   0000006E   0xF44F 0x7015      MOV      R0,#+596
   \   00000072   0x1821             ADDS     R1,R4,R0
   \   00000074   0x....             ADR.N    R0,??DataTable28  ;; 0x25, 0x73, 0x00, 0x00
   \   00000076   0x.... 0x....      BL       printk
    607              
    608              /* print some validation data */
    609              printk("%s==%s %02x==%02x\n",context->input_name,sentence->name,context->icks,context->ccks);
   \   0000007A   0xF44F 0x70E9      MOV      R0,#+466
   \   0000007E   0x4420             ADD      R0,R4,R0
   \   00000080   0x7841             LDRB     R1,[R0, #+1]
   \   00000082   0x9100             STR      R1,[SP, #+0]
   \   00000084   0x7803             LDRB     R3,[R0, #+0]
   \   00000086   0x4632             MOV      R2,R6
   \   00000088   0xF44F 0x70E6      MOV      R0,#+460
   \   0000008C   0x1821             ADDS     R1,R4,R0
   \   0000008E   0x.... 0x....      ADR.W    R0,?_7
   \   00000092   0x.... 0x....      BL       printk
    610              
    611              /* print the tokens */
    612              for(i=0;i<context->tokens;i++) {
   \   00000096   0x2700             MOVS     R7,#+0
   \   00000098   0xE009             B.N      ??nmeap_gpgga_2
    613                  printk("%d:%s\n",i,context->token[i]);
   \                     ??nmeap_gpgga_3: (+1)
   \   0000009A   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   0000009E   0xF8D0 0x21D4      LDR      R2,[R0, #+468]
   \   000000A2   0x4639             MOV      R1,R7
   \   000000A4   0x.... 0x....      ADR.W    R0,?_8
   \   000000A8   0x.... 0x....      BL       printk
    614              }
   \   000000AC   0x1C7F             ADDS     R7,R7,#+1
   \                     ??nmeap_gpgga_2: (+1)
   \   000000AE   0xF44F 0x70EC      MOV      R0,#+472
   \   000000B2   0x4420             ADD      R0,R4,R0
   \   000000B4   0x6DC0             LDR      R0,[R0, #+92]
   \   000000B6   0x4287             CMP      R7,R0
   \   000000B8   0xDBEF             BLT.N    ??nmeap_gpgga_3
    615            } 
    616          
    617            /* if the sentence has a callout, call it */
    618            if (sentence->callout != 0) {
   \                     ??nmeap_gpgga_1: (+1)
   \   000000BA   0x6933             LDR      R3,[R6, #+16]
   \   000000BC   0x0018             MOVS     R0,R3
   \   000000BE   0xD004             BEQ.N    ??nmeap_gpgga_4
    619                (*sentence->callout)(context,gga,context->user_data);
   \   000000C0   0xF8D4 0x2354      LDR      R2,[R4, #+852]
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x4798             BLX      R3
    620            }
    621            
    622            return NMEAP_GPGGA;
   \                     ??nmeap_gpgga_4: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    623          }
    624          
    625          
    626          /*
    627          ********************************************************************************
    628          * Description : nmeap_gprmc
    629          * Arguments   : nmeap_context_t *context,nmeap_sentence_t *sentence
    630          * Return      : 
    631          * Note        : standard GPRMCntence parser 
    632          ******************************************************************************** 
    633          */

   \                                 In section .text, align 2, keep-with-next
    634          int nmeap_gprmc(nmeap_context_t *context,nmeap_sentence_t *sentence)
    635          {
   \                     nmeap_gprmc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    636            int i;
    637          
    638          
    639            /* get pointer to sentence data */
    640            nmeap_rmc_t *rmc = (nmeap_rmc_t *)sentence->data;
   \   0000000A   0x696E             LDR      R6,[R5, #+20]
    641              
    642          	/* if there is a data element, use it */
    643          	if (rmc != 0) {
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable30_4
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD035             BEQ.N    ??nmeap_gprmc_0
    644          		/* extract data from the tokens */
    645          		rmc->time       = atoi(context->token[1]);
   \   00000014   0xF44F 0x70EC      MOV      R0,#+472
   \   00000018   0xEB04 0x0800      ADD      R8,R4,R0
   \   0000001C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000020   0x.... 0x....      BL       atoi
   \   00000024   0x6030             STR      R0,[R6, #+0]
    646          		rmc->warn       = *context->token[2];
   \   00000026   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x7130             STRB     R0,[R6, #+4]
    647          		rmc->latitude  = nmeap_latitude(context->token[3],context->token[4]);
   \   0000002E   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \   00000032   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000036   0x.... 0x....      BL       nmeap_latitude
   \   0000003A   0xE9C6 0x0102      STRD     R0,R1,[R6, #+8]
    648          		rmc->longitude = nmeap_longitude(context->token[5],context->token[6]);
   \   0000003E   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \   00000042   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000046   0x.... 0x....      BL       nmeap_longitude
   \   0000004A   0xE9C6 0x0104      STRD     R0,R1,[R6, #+16]
    649          		rmc->speed      = atof(context->token[7]);
   \   0000004E   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000052   0x.... 0x....      BL       atof
   \   00000056   0xE9C6 0x0106      STRD     R0,R1,[R6, #+24]
    650          		rmc->course     = atof(context->token[8]);
   \   0000005A   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   0000005E   0x.... 0x....      BL       atof
   \   00000062   0xE9C6 0x0108      STRD     R0,R1,[R6, #+32]
    651          		rmc->date       = atoi(context->token[9]);
   \   00000066   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   0000006A   0x.... 0x....      BL       atoi
   \   0000006E   0x62B0             STR      R0,[R6, #+40]
    652          		rmc->magvar     = atof(context->token[10]);
   \   00000070   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \   00000074   0x.... 0x....      BL       atof
   \   00000078   0xE9C6 0x010C      STRD     R0,R1,[R6, #+48]
    653              GPS_SigWait_Cnt = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x70F8             STRB     R0,[R7, #+3]
    654          	}
    655          
    656            if(gps_on) {   
   \                     ??nmeap_gprmc_0: (+1)
   \   00000080   0x79F8             LDRB     R0,[R7, #+7]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD025             BEQ.N    ??nmeap_gprmc_1
    657              /* print raw input string */
    658              printk("%s",context->debug_input);
   \   00000086   0xF44F 0x7015      MOV      R0,#+596
   \   0000008A   0x1821             ADDS     R1,R4,R0
   \   0000008C   0x....             ADR.N    R0,??DataTable28  ;; 0x25, 0x73, 0x00, 0x00
   \   0000008E   0x.... 0x....      BL       printk
    659              
    660              /* print some validation data */
    661              printk("%s==%s %02x==%02x\n",context->input_name,sentence->name,context->icks,context->ccks);
   \   00000092   0xF44F 0x70E9      MOV      R0,#+466
   \   00000096   0x4420             ADD      R0,R4,R0
   \   00000098   0x7841             LDRB     R1,[R0, #+1]
   \   0000009A   0x9100             STR      R1,[SP, #+0]
   \   0000009C   0x7803             LDRB     R3,[R0, #+0]
   \   0000009E   0x462A             MOV      R2,R5
   \   000000A0   0xF44F 0x70E6      MOV      R0,#+460
   \   000000A4   0x1821             ADDS     R1,R4,R0
   \   000000A6   0x.... 0x....      ADR.W    R0,?_7
   \   000000AA   0x.... 0x....      BL       printk
    662              
    663              /* print the tokens */
    664              for(i=0;i<context->tokens;i++) {
   \   000000AE   0x2700             MOVS     R7,#+0
   \   000000B0   0xE009             B.N      ??nmeap_gprmc_2
    665                  printk("%d:%s\n",i,context->token[i]);
   \                     ??nmeap_gprmc_3: (+1)
   \   000000B2   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   000000B6   0xF8D0 0x21D4      LDR      R2,[R0, #+468]
   \   000000BA   0x4639             MOV      R1,R7
   \   000000BC   0x.... 0x....      ADR.W    R0,?_8
   \   000000C0   0x.... 0x....      BL       printk
    666              }
   \   000000C4   0x1C7F             ADDS     R7,R7,#+1
   \                     ??nmeap_gprmc_2: (+1)
   \   000000C6   0xF44F 0x70EC      MOV      R0,#+472
   \   000000CA   0x4420             ADD      R0,R4,R0
   \   000000CC   0x6DC0             LDR      R0,[R0, #+92]
   \   000000CE   0x4287             CMP      R7,R0
   \   000000D0   0xDBEF             BLT.N    ??nmeap_gprmc_3
    667            }   
    668          
    669            /* if the sentence has a callout, call it */
    670            if (sentence->callout != 0) {
   \                     ??nmeap_gprmc_1: (+1)
   \   000000D2   0x692B             LDR      R3,[R5, #+16]
   \   000000D4   0x0018             MOVS     R0,R3
   \   000000D6   0xD004             BEQ.N    ??nmeap_gprmc_4
    671                (*sentence->callout)(context,rmc,context->user_data);
   \   000000D8   0xF8D4 0x2354      LDR      R2,[R4, #+852]
   \   000000DC   0x4631             MOV      R1,R6
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x4798             BLX      R3
    672            }
    673            
    674            return NMEAP_GPRMC;
   \                     ??nmeap_gprmc_4: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \   000000E4   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    675          }
    676          
    677          /*
    678          ********************************************************************************
    679          * Description : nmeap_gprmc
    680          * Arguments   : nmeap_context_t *context,nmeap_sentence_t *sentence
    681          * Return      : 
    682          * Note        : standard GPRMCntence parser 
    683          ******************************************************************************** 
    684          */

   \                                 In section .text, align 2, keep-with-next
    685          int nmeap_gpgsa(nmeap_context_t *context,nmeap_sentence_t *sentence)
    686          {
   \                     nmeap_gpgsa: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    687            int i;
    688          
    689          
    690            /* get pointer to sentence data */
    691            nmeap_gsa_t *gsa = (nmeap_gsa_t *)sentence->data;
   \   00000006   0x6975             LDR      R5,[R6, #+20]
    692              
    693          	/* if there is a data element, use it */
    694          	if (gsa != 0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD011             BEQ.N    ??nmeap_gpgsa_0
    695          		/* extract data from the tokens */
    696          		gsa->pdop       = atof(context->token[15]);
   \   0000000C   0xF44F 0x7004      MOV      R0,#+528
   \   00000010   0x1827             ADDS     R7,R4,R0
   \   00000012   0x6838             LDR      R0,[R7, #+0]
   \   00000014   0x.... 0x....      BL       atof
   \   00000018   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
    697          		gsa->hdop       = atof(context->token[16]);
   \   0000001C   0x6878             LDR      R0,[R7, #+4]
   \   0000001E   0x.... 0x....      BL       atof
   \   00000022   0xE9C5 0x0102      STRD     R0,R1,[R5, #+8]
    698          		gsa->vdop       = atof(context->token[17]);
   \   00000026   0x68B8             LDR      R0,[R7, #+8]
   \   00000028   0x.... 0x....      BL       atof
   \   0000002C   0xE9C5 0x0104      STRD     R0,R1,[R5, #+16]
    699          	}
    700          
    701            if(gps_on) {   
   \                     ??nmeap_gpgsa_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable30_4
   \   00000032   0x79C0             LDRB     R0,[R0, #+7]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD025             BEQ.N    ??nmeap_gpgsa_1
    702              /* print raw input string */
    703              printk("%s",context->debug_input);
   \   00000038   0xF44F 0x7015      MOV      R0,#+596
   \   0000003C   0x1821             ADDS     R1,R4,R0
   \   0000003E   0x....             ADR.N    R0,??DataTable28  ;; 0x25, 0x73, 0x00, 0x00
   \   00000040   0x.... 0x....      BL       printk
    704              
    705              /* print some validation data */
    706              printk("%s==%s %02x==%02x\n",context->input_name,sentence->name,context->icks,context->ccks);
   \   00000044   0xF44F 0x70E9      MOV      R0,#+466
   \   00000048   0x4420             ADD      R0,R4,R0
   \   0000004A   0x7841             LDRB     R1,[R0, #+1]
   \   0000004C   0x9100             STR      R1,[SP, #+0]
   \   0000004E   0x7803             LDRB     R3,[R0, #+0]
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0xF44F 0x70E6      MOV      R0,#+460
   \   00000056   0x1821             ADDS     R1,R4,R0
   \   00000058   0x.... 0x....      ADR.W    R0,?_7
   \   0000005C   0x.... 0x....      BL       printk
    707              
    708              /* print the tokens */
    709              for(i=0;i<context->tokens;i++) {
   \   00000060   0x2700             MOVS     R7,#+0
   \   00000062   0xE009             B.N      ??nmeap_gpgsa_2
    710                  printk("%d:%s\n",i,context->token[i]);
   \                     ??nmeap_gpgsa_3: (+1)
   \   00000064   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   00000068   0xF8D0 0x21D4      LDR      R2,[R0, #+468]
   \   0000006C   0x4639             MOV      R1,R7
   \   0000006E   0x.... 0x....      ADR.W    R0,?_8
   \   00000072   0x.... 0x....      BL       printk
    711              }
   \   00000076   0x1C7F             ADDS     R7,R7,#+1
   \                     ??nmeap_gpgsa_2: (+1)
   \   00000078   0xF44F 0x7004      MOV      R0,#+528
   \   0000007C   0x4420             ADD      R0,R4,R0
   \   0000007E   0x6A40             LDR      R0,[R0, #+36]
   \   00000080   0x4287             CMP      R7,R0
   \   00000082   0xDBEF             BLT.N    ??nmeap_gpgsa_3
    712            }   
    713          
    714            /* if the sentence has a callout, call it */
    715            if (sentence->callout != 0) {
   \                     ??nmeap_gpgsa_1: (+1)
   \   00000084   0x6933             LDR      R3,[R6, #+16]
   \   00000086   0x0018             MOVS     R0,R3
   \   00000088   0xD004             BEQ.N    ??nmeap_gpgsa_4
    716                (*sentence->callout)(context,gsa,context->user_data);
   \   0000008A   0xF8D4 0x2354      LDR      R2,[R4, #+852]
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x4798             BLX      R3
    717            }
    718            
    719            return NMEAP_GPGSA;
   \                     ??nmeap_gpgsa_4: (+1)
   \   00000094   0x2003             MOVS     R0,#+3
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    720          }
    721                              
    722          
    723          /*
    724          ********************************************************************************
    725          * Description : print_gga
    726          * Arguments   : nmeap_rmc_t *rmc
    727          * Return      : 
    728          * Note        : do something with the GGA data
    729          ******************************************************************************** 
    730          */

   \                                 In section .text, align 2, keep-with-next
    731          static void print_gga(nmeap_gga_t *gga)
    732          {
   \                     print_gga: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
    733              printk("found GPGGA message %.6f %.6f %.0f %lu %d %d %f %f\n",
    734                      gga->latitude  ,
    735                      gga->longitude, 
    736                      gga->altitude , 
    737                      gga->time     , 
    738                      gga->satellites,
    739                      gga->quality   ,
    740                      gga->hdop      ,
    741                      gga->geoid     
    742                      );
   \   00000004   0xE9D0 0x230C      LDRD     R2,R3,[R0, #+48]
   \   00000008   0xE9CD 0x230A      STRD     R2,R3,[SP, #+40]
   \   0000000C   0xE9D0 0x230A      LDRD     R2,R3,[R0, #+40]
   \   00000010   0xE9CD 0x2308      STRD     R2,R3,[SP, #+32]
   \   00000014   0x6A01             LDR      R1,[R0, #+32]
   \   00000016   0x9106             STR      R1,[SP, #+24]
   \   00000018   0x69C1             LDR      R1,[R0, #+28]
   \   0000001A   0x9105             STR      R1,[SP, #+20]
   \   0000001C   0x6981             LDR      R1,[R0, #+24]
   \   0000001E   0x9104             STR      R1,[SP, #+16]
   \   00000020   0xE9D0 0x2304      LDRD     R2,R3,[R0, #+16]
   \   00000024   0xE9CD 0x2302      STRD     R2,R3,[SP, #+8]
   \   00000028   0xE9D0 0x2302      LDRD     R2,R3,[R0, #+8]
   \   0000002C   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \   00000030   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000034   0x.... 0x....      ADR.W    R0,?_9
   \   00000038   0x.... 0x....      BL       printk
    743          }
   \   0000003C   0xB00D             ADD      SP,SP,#+52
   \   0000003E   0xBD00             POP      {PC}             ;; return
    744          
    745          /** 
    746          ********************************************************************************
    747          * Description : gpgga_callout
    748          * Arguments   : nmeap_context_t *context,void *data,void *user_data
    749          * Return      : 
    750          * Note        : called when a gpgga message is received and parsed
    751          ******************************************************************************** 
    752          */

   \                                 In section .text, align 2, keep-with-next
    753          static void gpgga_callout(nmeap_context_t *context,void *data,void *user_data)
    754          {
    755              nmeap_gga_t *gga = (nmeap_gga_t *)data;
    756          
    757              if(gps_on) print_gga(gga);
   \                     gpgga_callout: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_4
   \   00000002   0x79C0             LDRB     R0,[R0, #+7]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??gpgga_callout_0
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x....             B.N      print_gga
    758          }
   \                     ??gpgga_callout_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    759          
    760          
    761          /*
    762          ********************************************************************************
    763          * Description : print_rmc
    764          * Arguments   : nmeap_rmc_t *rmc
    765          * Return      : 
    766          * Note        : do something with the RMC data
    767          ******************************************************************************** 
    768          */

   \                                 In section .text, align 2, keep-with-next
    769          static void print_rmc(nmeap_rmc_t *rmc)
    770          {
   \                     print_rmc: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
    771              printk("found GPRMC Message %lu %c %.6f %.6f %f %f %lu %f\n",
    772                      rmc->time,
    773                      rmc->warn,
    774                      rmc->latitude,
    775                      rmc->longitude,
    776                      rmc->speed,
    777                      rmc->course,
    778                      rmc->date,
    779                      rmc->magvar
    780                      );
   \   00000004   0xE9D0 0x230C      LDRD     R2,R3,[R0, #+48]
   \   00000008   0xE9CD 0x230A      STRD     R2,R3,[SP, #+40]
   \   0000000C   0x6A81             LDR      R1,[R0, #+40]
   \   0000000E   0x9108             STR      R1,[SP, #+32]
   \   00000010   0xE9D0 0x2308      LDRD     R2,R3,[R0, #+32]
   \   00000014   0xE9CD 0x2306      STRD     R2,R3,[SP, #+24]
   \   00000018   0xE9D0 0x2306      LDRD     R2,R3,[R0, #+24]
   \   0000001C   0xE9CD 0x2304      STRD     R2,R3,[SP, #+16]
   \   00000020   0xE9D0 0x2304      LDRD     R2,R3,[R0, #+16]
   \   00000024   0xE9CD 0x2302      STRD     R2,R3,[SP, #+8]
   \   00000028   0xE9D0 0x2302      LDRD     R2,R3,[R0, #+8]
   \   0000002C   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \   00000030   0x7902             LDRB     R2,[R0, #+4]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x.... 0x....      ADR.W    R0,?_10
   \   00000038   0x.... 0x....      BL       printk
    781          }
   \   0000003C   0xB00D             ADD      SP,SP,#+52
   \   0000003E   0xBD00             POP      {PC}             ;; return
    782          
    783          /*
    784          ********************************************************************************
    785          * Description : gprmc_callout
    786          * Arguments   : nmeap_context_t *context,void *data,void *user_data
    787          * Return      : 
    788          * Note        : called when a gprmc message is received and parsed 
    789          ******************************************************************************** 
    790          */

   \                                 In section .text, align 2, keep-with-next
    791          static void gprmc_callout(nmeap_context_t *context,void *data,void *user_data)
    792          {
    793              nmeap_rmc_t *rmc = (nmeap_rmc_t *)data;
    794          
    795              if(gps_on) print_rmc(rmc);
   \                     gprmc_callout: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_4
   \   00000002   0x79C0             LDRB     R0,[R0, #+7]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??gprmc_callout_0
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x....             B.N      print_rmc
    796          }
   \                     ??gprmc_callout_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    797          
    798          /*
    799          ********************************************************************************
    800          * Description : print_gsa
    801          * Arguments   : nmeap_gsa_t *gsa
    802          * Return      : 
    803          * Note        : do something with the GGA data
    804          ******************************************************************************** 
    805          */

   \                                 In section .text, align 2, keep-with-next
    806          static void print_gsa(nmeap_gsa_t *gsa)
    807          {
   \                     print_gsa: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    808              printk("found GPGSA message %f %f %f\n",
    809                      gsa->pdop      ,
    810                      gsa->hdop      ,
    811                      gsa->vdop     
    812                      );
   \   00000004   0xE9D0 0x2304      LDRD     R2,R3,[R0, #+16]
   \   00000008   0xE9CD 0x2302      STRD     R2,R3,[SP, #+8]
   \   0000000C   0xE9D0 0x2302      LDRD     R2,R3,[R0, #+8]
   \   00000010   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \   00000014   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000018   0x.... 0x....      ADR.W    R0,?_11
   \   0000001C   0x.... 0x....      BL       printk
    813          }
   \   00000020   0xB005             ADD      SP,SP,#+20
   \   00000022   0xBD00             POP      {PC}             ;; return
    814          
    815          /** 
    816          ********************************************************************************
    817          * Description : gpgsa_callout
    818          * Arguments   : nmeap_context_t *context,void *data,void *user_data
    819          * Return      : 
    820          * Note        : called when a gpgga message is received and parsed
    821          ******************************************************************************** 
    822          */

   \                                 In section .text, align 2, keep-with-next
    823          static void gpgsa_callout(nmeap_context_t *context,void *data,void *user_data)
    824          {
    825              nmeap_gsa_t *gsa = (nmeap_gsa_t *)data;
    826          
    827              if(gps_on) print_gsa(gsa);
   \                     gpgsa_callout: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_4
   \   00000002   0x79C0             LDRB     R0,[R0, #+7]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??gpgsa_callout_0
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x....             B.N      print_gsa
    828          }
   \                     ??gpgsa_callout_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    829          
    830          /*
    831          ********************************************************************************
    832          * Description : GPS_parse_proc
    833          * Arguments   : none
    834          * Return      : 
    835          * Note        : GPS Data parsing process
    836          ******************************************************************************** 
    837          */

   \                                 In section .text, align 2, keep-with-next
    838          void GPS_parse_proc(void)	
    839          {
   \                     GPS_parse_proc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    840          	INT16U tmptail;  
    841          	char data=0;
    842            int  status = 0; 
   \   00000002   0x....             LDR.N    R4,??DataTable30_5
   \   00000004   0xE00C             B.N      ??GPS_parse_proc_0
    843               
    844          	while (GPS_RxHead != GPS_RxTail ) { 
    845              tmptail = (GPS_RxTail + 1) & GPS_RX_BUFFER_MASK; /* Calculate buffer index */
    846              
    847              GPS_RxTail = tmptail;                /* Store new index */
    848              
    849              data = GPS_RxBuf[tmptail];           /* Return data */   
    850              
    851              status = nmeap_parse(&nmea, data);
    852              GPS_Reset_Cnt = 0;
    853              if(gps_on) {
    854                switch(status) {
    855                case NMEAP_GPGGA:
    856                    /* GPGGA MESSAGE */
    857                    printk("-------------switch\n");
   \                     ??GPS_parse_proc_1: (+1)
   \   00000006   0x.... 0x....      ADR.W    R0,?_12
   \   0000000A   0x.... 0x....      BL       printk
    858                    print_gga(&gga);
   \   0000000E   0xF44F 0x7066      MOV      R0,#+920
   \   00000012   0x4420             ADD      R0,R4,R0
   \   00000014   0x.... 0x....      BL       print_gga
    859                    printk("-------------\n");
   \   00000018   0x.... 0x....      ADR.W    R0,?_13
   \   0000001C   0x.... 0x....      BL       printk
    860                    break;
   \                     ??GPS_parse_proc_0: (+1)
   \   00000020   0x8F60             LDRH     R0,[R4, #+58]
   \   00000022   0x8F21             LDRH     R1,[R4, #+56]
   \   00000024   0x4602             MOV      R2,R0
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD02F             BEQ.N    ??GPS_parse_proc_2
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   00000030   0x8760             STRH     R0,[R4, #+58]
   \   00000032   0x....             LDR.N    R1,??DataTable30_6
   \   00000034   0x5C09             LDRB     R1,[R1, R0]
   \   00000036   0xF104 0x003C      ADD      R0,R4,#+60
   \   0000003A   0x.... 0x....      BL       nmeap_parse
   \   0000003E   0x....             LDR.N    R1,??DataTable30_4
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x704A             STRB     R2,[R1, #+1]
   \   00000044   0x79C9             LDRB     R1,[R1, #+7]
   \   00000046   0x2900             CMP      R1,#+0
   \   00000048   0xD0EA             BEQ.N    ??GPS_parse_proc_0
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD0DB             BEQ.N    ??GPS_parse_proc_1
   \   0000004E   0xD3E7             BCC.N    ??GPS_parse_proc_0
   \   00000050   0x2803             CMP      R0,#+3
   \   00000052   0xD00C             BEQ.N    ??GPS_parse_proc_3
   \   00000054   0xD2E4             BCS.N    ??GPS_parse_proc_0
    861                case NMEAP_GPRMC:
    862                    /* GPRMC MESSAGE */
    863                    printk("-------------switch\n");
   \   00000056   0x.... 0x....      ADR.W    R0,?_12
   \   0000005A   0x.... 0x....      BL       printk
    864                    print_rmc(&rmc);
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       print_rmc
    865                    printk("-------------\n");
   \   00000064   0x.... 0x....      ADR.W    R0,?_13
   \   00000068   0x.... 0x....      BL       printk
    866                    break;
   \   0000006C   0xE7D8             B.N      ??GPS_parse_proc_0
    867                case NMEAP_GPGSA:
    868                    /* GPGSA MESSAGE */
    869                    printk("-------------switch\n");
   \                     ??GPS_parse_proc_3: (+1)
   \   0000006E   0x.... 0x....      ADR.W    R0,?_12
   \   00000072   0x.... 0x....      BL       printk
    870                    print_gsa(&gsa);
   \   00000076   0xF44F 0x7074      MOV      R0,#+976
   \   0000007A   0x4420             ADD      R0,R4,R0
   \   0000007C   0x.... 0x....      BL       print_gsa
    871                    printk("-------------\n");
   \   00000080   0x.... 0x....      ADR.W    R0,?_13
   \   00000084   0x.... 0x....      BL       printk
    872                    break;
   \   00000088   0xE7CA             B.N      ??GPS_parse_proc_0
    873                default:
    874                    break;
    875                }      
    876              }
    877            }
    878          }
   \                     ??GPS_parse_proc_2: (+1)
   \   0000008A   0xBD10             POP      {R4,PC}          ;; return
    879          
    880          /*
    881          ********************************************************************************
    882          * Description : GPS_SecTimerProcess
    883          * Arguments   : none
    884          * Return      : 
    885          * Note        : GPS 1Sec Timer Process
    886          ******************************************************************************** 
    887          */
    888          #define GPS_RESET_ENABLE
    889          #define GPS_RESET_INTERVAL 30
    890          #define GPS_RESET_TIME 2
    891          

   \                                 In section .text, align 2, keep-with-next
    892          void GPS_ResetProcess(void) 
    893          {
    894          #ifdef GPS_RESET_ENABLE  
    895          //  if(Power_Off_Flag) return;
    896            GPS_Reset_Cnt++;    
   \                     GPS_ResetProcess: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_4
   \   00000002   0x7841             LDRB     R1,[R0, #+1]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    897            if(GPS_Reset_Cnt == GPS_RESET_INTERVAL) {
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x291E             CMP      R1,#+30
   \   0000000C   0xD102             BNE.N    ??GPS_ResetProcess_0
    898              GPS_Reset_Flag = 1;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x7081             STRB     R1,[R0, #+2]
   \   00000012   0x4770             BX       LR
    899          //    GPS_POWER_OFF();  
    900            }    
    901            else if(GPS_Reset_Cnt == (GPS_RESET_INTERVAL+GPS_RESET_TIME)) {
   \                     ??GPS_ResetProcess_0: (+1)
   \   00000014   0x2920             CMP      R1,#+32
   \   00000016   0xD102             BNE.N    ??GPS_ResetProcess_1
    902              GPS_Reset_Cnt = 0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7041             STRB     R1,[R0, #+1]
    903          //    GPS_POWER_ON();
    904              GPS_Reset_Flag = 0;
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
    905            }
    906          #endif  
    907          }
   \                     ??GPS_ResetProcess_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    908          
    909          /*
    910          ********************************************************************************
    911          * Description : dbg_gps_view
    912          * Arguments   : None
    913          * Return      : 
    914          * Note        :
    915          ******************************************************************************** 
    916          */

   \                                 In section .text, align 2, keep-with-next
    917          INT16U dbg_gps_view(void)
    918          {
    919          	if ( gps_on )
   \                     dbg_gps_view: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_4
   \   00000002   0x79C1             LDRB     R1,[R0, #+7]
   \   00000004   0x1E4A             SUBS     R2,R1,#+1
   \   00000006   0x4192             SBCS     R2,R2,R2
   \   00000008   0x0FD2             LSRS     R2,R2,#+31
   \   0000000A   0x71C2             STRB     R2,[R0, #+7]
    920          		gps_on = 0;
    921          	else
    922          		gps_on = 1;
    923          
    924          	return NO_DISPLAY;
   \   0000000C   0x20C9             MOVS     R0,#+201
   \   0000000E   0x4770             BX       LR               ;; return
    925          }
    926          
    927                              
    928          /*
    929          ********************************************************************************
    930          * Description : Task_GPS
    931          * Arguments   : none
    932          * Return      : 
    933          * Note        : task for gps
    934          ******************************************************************************** 
    935          */
    936                              
    937          /* Task_GPS function */

   \                                 In section .text, align 2, keep-with-next
    938          void Task_GPS(void *p_arg)
    939          {
   \                     Task_GPS: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    940            int  status;
    941            int  task_count = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    942            
    943          	sysinfo_t *s = (sysinfo_t *)p_arg;
    944          
    945            BSP_UART1RX_IntEnable(ENABLE);  
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       BSP_UART1RX_IntEnable
    946            GPS_RxHead = 0;
   \   0000000C   0x....             LDR.N    R6,??DataTable30_5
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x63B0             STR      R0,[R6, #+56]
    947            GPS_RxTail = 0;
    948          
    949            status = nmeap_addParser(&nmea,"GPGGA",nmeap_gpgga,gpgga_callout,&gga);
   \   00000012   0xF44F 0x7066      MOV      R0,#+920
   \   00000016   0x4430             ADD      R0,R6,R0
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x....             LDR.N    R3,??DataTable30_7
   \   0000001C   0x....             LDR.N    R2,??DataTable30_8
   \   0000001E   0x.... 0x....      ADR.W    R1,?_14
   \   00000022   0xF106 0x003C      ADD      R0,R6,#+60
   \   00000026   0x.... 0x....      BL       nmeap_addParser
    950            if (status != 0) {
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD004             BEQ.N    ??Task_GPS_0
    951                printd("nmeap_add %d\n",status);
   \   0000002E   0x4601             MOV      R1,R0
   \   00000030   0x.... 0x....      ADR.W    R0,?_15
   \   00000034   0x.... 0x....      BL       printd
    952            }
    953          
    954            status = nmeap_addParser(&nmea,"GPRMC",nmeap_gprmc,gprmc_callout,&rmc);
   \                     ??Task_GPS_0: (+1)
   \   00000038   0x9600             STR      R6,[SP, #+0]
   \   0000003A   0x....             LDR.N    R3,??DataTable30_9
   \   0000003C   0x....             LDR.N    R2,??DataTable30_10
   \   0000003E   0x.... 0x....      ADR.W    R1,?_16
   \   00000042   0xF106 0x003C      ADD      R0,R6,#+60
   \   00000046   0x.... 0x....      BL       nmeap_addParser
   \   0000004A   0x0001             MOVS     R1,R0
    955            if (status != 0) {
   \   0000004C   0xD003             BEQ.N    ??Task_GPS_1
    956                printd("nmeap_add %d\n",status);
   \   0000004E   0x.... 0x....      ADR.W    R0,?_15
   \   00000052   0x.... 0x....      BL       printd
    957            }
    958          
    959            status = nmeap_addParser(&nmea,"GPGSA",nmeap_gpgsa,gpgsa_callout,&gsa);
   \                     ??Task_GPS_1: (+1)
   \   00000056   0xF44F 0x7074      MOV      R0,#+976
   \   0000005A   0x4430             ADD      R0,R6,R0
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x....             LDR.N    R3,??DataTable30_11
   \   00000060   0x....             LDR.N    R2,??DataTable30_12
   \   00000062   0x.... 0x....      ADR.W    R1,?_17
   \   00000066   0xF106 0x003C      ADD      R0,R6,#+60
   \   0000006A   0x.... 0x....      BL       nmeap_addParser
    960            if (status != 0) {
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD004             BEQ.N    ??Task_GPS_2
    961                printd("nmeap_add %d\n",status);
   \   00000072   0x4601             MOV      R1,R0
   \   00000074   0x.... 0x....      ADR.W    R0,?_15
   \   00000078   0x.... 0x....      BL       printd
    962            }
    963            GPS_Valid_Char = 'N';
   \                     ??Task_GPS_2: (+1)
   \   0000007C   0x....             LDR.N    R7,??DataTable30_4
   \   0000007E   0x204E             MOVS     R0,#+78
   \   00000080   0x7178             STRB     R0,[R7, #+5]
   \   00000082   0xE01D             B.N      ??Task_GPS_3
    964          //  GPS_POWER_ON();     // GPS Power On
    965            
    966            /* USER CODE BEGIN Task_GPS */
    967            /* Infinite loop */
    968            for(;;)
    969          	{
    970          		s->twatchGpsFlag = 1;    
    971              GPS_parse_proc();
    972              if((task_count%500) == 0) {
    973                if(rmc.warn =='A'&& GPS_SigWait_Cnt < 3) {  
    974                  GPS_Valid = 1;
    975                  GPS_Valid_Char = 'G';  
    976                  GPS_Not_Valid_Cnt = 0;
    977                  GPS_Fault = 0;   
    978                }
    979                else {
    980                  GPS_Valid = 0;
    981                  if(GPS_SigWait_Cnt < 3)
    982                    GPS_Valid_Char = rmc.warn;
    983                  else
    984                    GPS_Valid_Char = 'N';
   \                     ??Task_GPS_4: (+1)
   \   00000084   0x204E             MOVS     R0,#+78
   \   00000086   0x7178             STRB     R0,[R7, #+5]
    985          //        if(GPS_Not_Valid_Cnt > 5) 
    986                  GPS_Fault = 1;
   \                     ??Task_GPS_5: (+1)
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x7038             STRB     R0,[R7, #+0]
    987                }
    988              }
    989              task_count++;
   \                     ??Task_GPS_6: (+1)
   \   0000008C   0x1C6D             ADDS     R5,R5,#+1
    990              if(task_count > 999) {
   \   0000008E   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   00000092   0xDB10             BLT.N    ??Task_GPS_7
    991                task_count = 0;
   \   00000094   0x2500             MOVS     R5,#+0
    992                if(!GPS_Reset_Flag) {
   \   00000096   0x78B8             LDRB     R0,[R7, #+2]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD10A             BNE.N    ??Task_GPS_8
    993                  if(!GPS_Valid) GPS_Not_Valid_Cnt++;
   \   0000009C   0x7938             LDRB     R0,[R7, #+4]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD102             BNE.N    ??Task_GPS_9
   \   000000A2   0x79B8             LDRB     R0,[R7, #+6]
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0x71B8             STRB     R0,[R7, #+6]
    994                  if(GPS_SigWait_Cnt < 0xFF) GPS_SigWait_Cnt++;
   \                     ??Task_GPS_9: (+1)
   \   000000A8   0x78F8             LDRB     R0,[R7, #+3]
   \   000000AA   0x28FF             CMP      R0,#+255
   \   000000AC   0xD001             BEQ.N    ??Task_GPS_8
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x70F8             STRB     R0,[R7, #+3]
    995                }
    996                GPS_ResetProcess();
   \                     ??Task_GPS_8: (+1)
   \   000000B2   0x.... 0x....      BL       GPS_ResetProcess
    997              }
    998          		s->twatchGpsFlag = 0;  
   \                     ??Task_GPS_7: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7460             STRB     R0,[R4, #+17]
    999              vTaskDelay(1);
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x.... 0x....      BL       vTaskDelay
   \                     ??Task_GPS_3: (+1)
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x7460             STRB     R0,[R4, #+17]
   \   000000C4   0x.... 0x....      BL       GPS_parse_proc
   \   000000C8   0xF44F 0x70FA      MOV      R0,#+500
   \   000000CC   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   000000D0   0xF44F 0x71FA      MOV      R1,#+500
   \   000000D4   0xFB01 0x5010      MLS      R0,R1,R0,R5
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD1D7             BNE.N    ??Task_GPS_6
   \   000000DC   0x78F8             LDRB     R0,[R7, #+3]
   \   000000DE   0x7931             LDRB     R1,[R6, #+4]
   \   000000E0   0x2941             CMP      R1,#+65
   \   000000E2   0xD109             BNE.N    ??Task_GPS_10
   \   000000E4   0x2803             CMP      R0,#+3
   \   000000E6   0xDA07             BGE.N    ??Task_GPS_10
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x7138             STRB     R0,[R7, #+4]
   \   000000EC   0x2047             MOVS     R0,#+71
   \   000000EE   0x7178             STRB     R0,[R7, #+5]
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x71B8             STRB     R0,[R7, #+6]
   \   000000F4   0x7038             STRB     R0,[R7, #+0]
   \   000000F6   0xE7C9             B.N      ??Task_GPS_6
   \                     ??Task_GPS_10: (+1)
   \   000000F8   0x2200             MOVS     R2,#+0
   \   000000FA   0x713A             STRB     R2,[R7, #+4]
   \   000000FC   0x2803             CMP      R0,#+3
   \   000000FE   0xDAC1             BGE.N    ??Task_GPS_4
   \   00000100   0x7179             STRB     R1,[R7, #+5]
   \   00000102   0xE7C1             B.N      ??Task_GPS_5
   1000          	}
   1001            /* USER CODE END Task_GPS */  
   1002          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x40590000         DC32     0x40590000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x404E0000         DC32     0x404e0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0xFD4F4B98         DC32     0xfd4f4b98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x400A3F28         DC32     0x400a3f28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x........         DC32     GPS_Fault

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x........         DC32     rmc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x........         DC32     GPS_RxBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x........         DC32     gpgga_callout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x........         DC32     nmeap_gpgga

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x........         DC32     gprmc_callout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x........         DC32     nmeap_gprmc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x........         DC32     gpgsa_callout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x........         DC32     nmeap_gpgsa

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x25 0x73          DC8 "%s"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x70 0x6C          DC8 "plat != 0"
   \              0x61 0x74    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x30 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 4CH, 4FH, 4FH, 50H, 5CH
   \              0x5C 0x4C    
   \              0x4F 0x4F    
   \              0x50 0x5C    
   \   00000008   0x53 0x43          DC8 53H, 43H, 52H, 44H, 50H, 46H, 5CH, 4FH
   \              0x52 0x44    
   \              0x50 0x46    
   \              0x5C 0x4F    
   \   00000010   0x42 0x44          DC8 42H, 44H, 5CH, 66H, 72H, 65H, 65H, 52H
   \              0x5C 0x66    
   \              0x72 0x65    
   \              0x65 0x52    
   \   00000018   0x54 0x4F          DC8 54H, 4FH, 53H, 5FH, 53H, 54H, 4DH, 33H
   \              0x53 0x5F    
   \              0x53 0x54    
   \              0x4D 0x33    
   \   00000020   0x32 0x46          DC8 32H, 46H, 32H, 78H, 78H, 5FH, 4DH, 6FH
   \              0x32 0x78    
   \              0x78 0x5F    
   \              0x4D 0x6F    
   \   00000028   0x64 0x65          DC8 64H, 65H, 6DH, 5FH, 43H, 43H, 5FH, 4CH
   \              0x6D 0x5F    
   \              0x43 0x43    
   \              0x5F 0x4C    
   \   00000030   0x61 0x72          DC8 61H, 72H, 67H, 65H, 5CH, 41H, 70H, 70H
   \              0x67 0x65    
   \              0x5C 0x41    
   \              0x70 0x70    
   \   00000038   0x5C 0x6E          DC8 5CH, 6EH, 6DH, 65H, 61H, 70H, 2EH, 63H
   \              0x6D 0x65    
   \              0x61 0x70    
   \              0x2E 0x63    
   \   00000040   0x00               DC8 0
   \   00000041   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x70 0x68          DC8 "phem != 0"
   \              0x65 0x6D    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x30 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x70 0x6C          DC8 "plon != 0"
   \              0x6F 0x6E    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x30 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x63 0x6F          DC8 "context != 0"
   \              0x6E 0x74    
   \              0x65 0x78    
   \              0x74 0x20    
   \              0x21 0x3D    
   \              0x20 0x30    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x73 0x20          DC8 "s != 0"
   \              0x21 0x3D    
   \              0x20 0x30    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x25 0x73          DC8 "%s==%s %02x==%02x\012"
   \              0x3D 0x3D    
   \              0x25 0x73    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x78 0x3D    
   \              0x3D 0x25    
   \              0x30 0x32    
   \              0x78 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x25 0x64          DC8 "%d:%s\012"
   \              0x3A 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x66 0x6F          DC8 66H, 6FH, 75H, 6EH, 64H, 20H, 47H, 50H
   \              0x75 0x6E    
   \              0x64 0x20    
   \              0x47 0x50    
   \   00000008   0x47 0x47          DC8 47H, 47H, 41H, 20H, 6DH, 65H, 73H, 73H
   \              0x41 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \   00000010   0x61 0x67          DC8 61H, 67H, 65H, 20H, 25H, 2EH, 36H, 66H
   \              0x65 0x20    
   \              0x25 0x2E    
   \              0x36 0x66    
   \   00000018   0x20 0x25          DC8 20H, 25H, 2EH, 36H, 66H, 20H, 25H, 2EH
   \              0x2E 0x36    
   \              0x66 0x20    
   \              0x25 0x2E    
   \   00000020   0x30 0x66          DC8 30H, 66H, 20H, 25H, 6CH, 75H, 20H, 25H
   \              0x20 0x25    
   \              0x6C 0x75    
   \              0x20 0x25    
   \   00000028   0x64 0x20          DC8 64H, 20H, 25H, 64H, 20H, 25H, 66H, 20H
   \              0x25 0x64    
   \              0x20 0x25    
   \              0x66 0x20    
   \   00000030   0x25 0x66          DC8 25H, 66H, 0AH, 0
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x66 0x6F          DC8 66H, 6FH, 75H, 6EH, 64H, 20H, 47H, 50H
   \              0x75 0x6E    
   \              0x64 0x20    
   \              0x47 0x50    
   \   00000008   0x52 0x4D          DC8 52H, 4DH, 43H, 20H, 4DH, 65H, 73H, 73H
   \              0x43 0x20    
   \              0x4D 0x65    
   \              0x73 0x73    
   \   00000010   0x61 0x67          DC8 61H, 67H, 65H, 20H, 25H, 6CH, 75H, 20H
   \              0x65 0x20    
   \              0x25 0x6C    
   \              0x75 0x20    
   \   00000018   0x25 0x63          DC8 25H, 63H, 20H, 25H, 2EH, 36H, 66H, 20H
   \              0x20 0x25    
   \              0x2E 0x36    
   \              0x66 0x20    
   \   00000020   0x25 0x2E          DC8 25H, 2EH, 36H, 66H, 20H, 25H, 66H, 20H
   \              0x36 0x66    
   \              0x20 0x25    
   \              0x66 0x20    
   \   00000028   0x25 0x66          DC8 25H, 66H, 20H, 25H, 6CH, 75H, 20H, 25H
   \              0x20 0x25    
   \              0x6C 0x75    
   \              0x20 0x25    
   \   00000030   0x66 0x0A          DC8 66H, 0AH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x66 0x6F          DC8 "found GPGSA message %f %f %f\012"
   \              0x75 0x6E    
   \              0x64 0x20    
   \              0x47 0x50    
   \              0x47 0x53    
   \              0x41 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x25 0x66    
   \              0x20 0x25    
   \              0x66 0x20    
   \              0x25 0x66    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x2D 0x2D          DC8 "-------------switch\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x73    
   \              0x77 0x69    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x2D 0x2D          DC8 "-------------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x47 0x50          DC8 "GPGGA"
   \              0x47 0x47    
   \              0x41 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x6E 0x6D          DC8 "nmeap_add %d\012"
   \              0x65 0x61    
   \              0x70 0x5F    
   \              0x61 0x64    
   \              0x64 0x20    
   \              0x25 0x64    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x47 0x50          DC8 "GPRMC"
   \              0x52 0x4D    
   \              0x43 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x47 0x50          DC8 "GPGSA"
   \              0x47 0x53    
   \              0x41 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
   1003          
   1004          
   1005          /*
   1006          ********************* (C) COPYRIGHT 2015 LOOP ***************END OF FILE*****************************
   1007          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GPS_ResetProcess
       8   GPS_parse_proc
         8   -> nmeap_parse
         8   -> print_gga
         8   -> print_gsa
         8   -> print_rmc
         8   -> printk
      24   Task_GPS
        24   -> BSP_UART1RX_IntEnable
        24   -> GPS_ResetProcess
        24   -> GPS_parse_proc
        24   -> nmeap_addParser
        24   -> printd
        24   -> vTaskDelay
       0   dbg_gps_view
       0   gpgga_callout
         0   -> print_gga
       0   gpgsa_callout
         0   -> print_gsa
       0   gprmc_callout
         0   -> print_rmc
      24   nmeap_addParser
        24   -> __aeabi_assert
        24   -> __aeabi_memset4
        24   -> __iar_EmptyStepPoint
        24   -> strncpy
       8   nmeap_altitude
         0   -> __aeabi_dmul
         8   -> atof
      24   nmeap_gpgga
        24   -- Indirect call
        24   -> atof
        24   -> atoi
        24   -> nmeap_altitude
        24   -> nmeap_latitude
        24   -> nmeap_longitude
        24   -> printk
      24   nmeap_gpgsa
        24   -- Indirect call
        24   -> atof
        24   -> printk
      32   nmeap_gprmc
        32   -- Indirect call
        32   -> atof
        32   -> atoi
        32   -> nmeap_latitude
        32   -> nmeap_longitude
        32   -> printk
      16   nmeap_init
        16   -> __aeabi_assert
        16   -> __aeabi_memset4
        16   -> __iar_EmptyStepPoint
      32   nmeap_latitude
        32   -> __aeabi_assert
        32   -> __aeabi_d2iz
        32   -> __aeabi_dadd
        32   -> __aeabi_ddiv
         0   -> __aeabi_dmul
        32   -> __aeabi_dmul
        32   -> __aeabi_dsub
        32   -> __aeabi_i2d
        32   -> __iar_EmptyStepPoint
        32   -> atof
      32   nmeap_longitude
        32   -> __aeabi_assert
        32   -> __aeabi_d2iz
        32   -> __aeabi_dadd
        32   -> __aeabi_ddiv
         0   -> __aeabi_dmul
        32   -> __aeabi_dmul
        32   -> __aeabi_dsub
        32   -> __aeabi_i2d
        32   -> __iar_EmptyStepPoint
        32   -> atof
      24   nmeap_parse
        24   -> isalnum
        24   -> isxdigit
        24   -> nmeap_process
      32   nmeap_parseBuffer
        32   -> nmeap_parse
      24   nmeap_process
        24   -- Indirect call
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> nmeap_tokenize
        24   -> strncmp
        24   -> strncpy
       8   nmeap_tokenize
      56   print_gga
        56   -> printk
      24   print_gsa
        24   -> printk
      56   print_rmc
        56   -> printk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      12  ?_0
      68  ?_1
      52  ?_10
      32  ?_11
      24  ?_12
      16  ?_13
       8  ?_14
      16  ?_15
       8  ?_16
       8  ?_17
      12  ?_2
      12  ?_3
      16  ?_4
       8  ?_5
       4  ?_6
      20  ?_7
       8  ?_8
      52  ?_9
       8  GPS_Fault
          GPS_Reset_Cnt
          GPS_Reset_Flag
          GPS_SigWait_Cnt
          GPS_Valid
          GPS_Valid_Char
          GPS_Not_Valid_Cnt
          gps_on
      32  GPS_ResetProcess
     512  GPS_RxBuf
     140  GPS_parse_proc
     260  Task_GPS
      16  dbg_gps_view
      14  gpgga_callout
      14  gpgsa_callout
      14  gprmc_callout
       4  gps_status
     102  nmeap_addParser
      48  nmeap_altitude
     206  nmeap_gpgga
     152  nmeap_gpgsa
     232  nmeap_gprmc
      48  nmeap_init
     190  nmeap_latitude
     190  nmeap_longitude
     408  nmeap_parse
      54  nmeap_parseBuffer
     114  nmeap_process
      84  nmeap_tokenize
      64  print_gga
      36  print_gsa
      64  print_rmc
    1000  rmc
          GPS_RxHead
          GPS_RxTail
          nmea
          gga
          gsa

 
 1 524 bytes in section .bss
     4 bytes in section .rodata
 2 910 bytes in section .text
 
 2 910 bytes of CODE  memory
     4 bytes of CONST memory
 1 524 bytes of DATA  memory

Errors: none
Warnings: none
