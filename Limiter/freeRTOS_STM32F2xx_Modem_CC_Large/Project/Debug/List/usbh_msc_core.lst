###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_core.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_core.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_msc_core.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_msc_core.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_core.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file implements the MSC class driver functions
      8            *          ===================================================================      
      9            *                                MSC Class  Description
     10            *          =================================================================== 
     11            *           This module manages the MSC class V1.0 following the "Universal 
     12            *           Serial Bus Mass Storage Class (MSC) Bulk-Only Transport (BOT) Version 1.0
     13            *           Sep. 31, 1999".
     14            *           This driver implements the following aspects of the specification:
     15            *             - Bulk-Only Transport protocol
     16            *             - Subclass : SCSI transparent command set (ref. SCSI Primary Commands - 3 (SPC-3))
     17            *      
     18            *  @endverbatim
     19            *
     20            ******************************************************************************
     21            * @attention
     22            *
     23            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     24            *
     25            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     26            * You may not use this file except in compliance with the License.
     27            * You may obtain a copy of the License at:
     28            *
     29            *        http://www.st.com/software_license_agreement_liberty_v2
     30            *
     31            * Unless required by applicable law or agreed to in writing, software 
     32            * distributed under the License is distributed on an "AS IS" BASIS, 
     33            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     34            * See the License for the specific language governing permissions and
     35            * limitations under the License.
     36            *
     37            ******************************************************************************
     38            */
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          
     42          #include "usbh_msc_core.h"
     43          #include "usbh_msc_scsi.h"
     44          #include "usbh_msc_bot.h"
     45          #include "usbh_core.h"
     46          
     47          
     48          /** @addtogroup USBH_LIB
     49            * @{
     50            */
     51          
     52          /** @addtogroup USBH_CLASS
     53            * @{
     54            */
     55          
     56          /** @addtogroup USBH_MSC_CLASS
     57            * @{
     58            */
     59            
     60          /** @defgroup USBH_MSC_CORE 
     61            * @brief    This file includes the mass storage related functions
     62            * @{
     63            */ 
     64          
     65          
     66          /** @defgroup USBH_MSC_CORE_Private_TypesDefinitions
     67            * @{
     68            */ 
     69          /**
     70            * @}
     71            */ 
     72          
     73          /** @defgroup USBH_MSC_CORE_Private_Defines
     74            * @{
     75            */ 
     76          #define USBH_MSC_ERROR_RETRY_LIMIT 10
     77          /**
     78            * @}
     79            */ 
     80          
     81          /** @defgroup USBH_MSC_CORE_Private_Macros
     82            * @{
     83            */ 
     84          /**
     85            * @}
     86            */ 
     87          
     88          
     89          /** @defgroup USBH_MSC_CORE_Private_Variables
     90            * @{
     91            */ 
     92          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     93            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
     94              #pragma data_alignment=4   
     95            #endif
     96          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */

   \                                 In section .bss, align 4
     97          __ALIGN_BEGIN MSC_Machine_TypeDef         MSC_Machine __ALIGN_END ;
   \                     MSC_Machine:
   \   00000000                      DS8 76
     98          
     99          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    100            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    101              #pragma data_alignment=4   
    102            #endif
    103          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */

   \                                 In section .bss, align 4
    104          __ALIGN_BEGIN USB_Setup_TypeDef           MSC_Setup __ALIGN_END ;
   \                     MSC_Setup:
   \   00000000                      DS8 8
    105          uint8_t MSCErrorCount = 0;
    106          
    107          
    108          /**
    109            * @}
    110            */ 
    111          
    112          
    113          /** @defgroup USBH_MSC_CORE_Private_FunctionPrototypes
    114            * @{
    115            */ 
    116          
    117          static USBH_Status USBH_MSC_InterfaceInit  (USB_OTG_CORE_HANDLE *pdev , 
    118                                                      void *phost);
    119          
    120          static void USBH_MSC_InterfaceDeInit  (USB_OTG_CORE_HANDLE *pdev , 
    121                                                 void *phost);
    122          
    123          static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
    124                                      void *phost);
    125          
    126          static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
    127                                                   void *phost);
    128          
    129          static USBH_Status USBH_MSC_BOTReset(USB_OTG_CORE_HANDLE *pdev,
    130                                        USBH_HOST *phost);
    131          static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev,
    132                                         USBH_HOST *phost);
    133          
    134          

   \                                 In section .data, align 4
    135          USBH_Class_cb_TypeDef  USBH_MSC_cb = 
   \                     USBH_MSC_cb:
   \   00000000   0x........         DC32 USBH_MSC_InterfaceInit, USBH_MSC_InterfaceDeInit
   \              0x........   
   \   00000008   0x........         DC32 USBH_MSC_ClassRequest, USBH_MSC_Handle
   \              0x........   
    136          {
    137            USBH_MSC_InterfaceInit,
    138            USBH_MSC_InterfaceDeInit,
    139            USBH_MSC_ClassRequest,
    140            USBH_MSC_Handle,
    141          };
    142          
    143          void USBH_MSC_ErrorHandle(uint8_t status);
    144          
    145          /**
    146            * @}
    147            */ 
    148          
    149          
    150          /** @defgroup USBH_MSC_CORE_Exported_Variables
    151            * @{
    152            */ 
    153          
    154          /**
    155            * @}
    156            */ 
    157          
    158          
    159          /** @defgroup USBH_MSC_CORE_Private_Functions
    160            * @{
    161            */ 
    162          
    163          
    164          /**
    165            * @brief  USBH_MSC_InterfaceInit 
    166            *         Interface initialization for MSC class.
    167            * @param  pdev: Selected device
    168            * @param  hdev: Selected device property
    169            * @retval USBH_Status : Status of class request handled.
    170            */

   \                                 In section .text, align 2, keep-with-next
    171          static USBH_Status USBH_MSC_InterfaceInit ( USB_OTG_CORE_HANDLE *pdev, 
    172                                                  void *phost)
    173          {	 
   \                     USBH_MSC_InterfaceInit: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    174            USBH_HOST *pphost = phost;
    175            
    176            if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
    177               (pphost->device_prop.Itf_Desc[0].bInterfaceProtocol == MSC_PROTOCOL))
   \   00000006   0xF105 0x0043      ADD      R0,R5,#+67
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD139             BNE.N    ??USBH_MSC_InterfaceInit_0
   \   00000010   0x7881             LDRB     R1,[R0, #+2]
   \   00000012   0x2950             CMP      R1,#+80
   \   00000014   0xD136             BNE.N    ??USBH_MSC_InterfaceInit_0
    178            {
    179              if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
   \   00000016   0x7BC0             LDRB     R0,[R0, #+15]
   \   00000018   0xF105 0x0154      ADD      R1,R5,#+84
   \   0000001C   0x....             LDR.N    R6,??DataTable5
   \   0000001E   0x0602             LSLS     R2,R0,#+24
   \   00000020   0xD503             BPL.N    ??USBH_MSC_InterfaceInit_1
    180              {
    181                MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
   \   00000022   0x70F0             STRB     R0,[R6, #+3]
    182                MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
   \   00000024   0x8808             LDRH     R0,[R1, #+0]
   \   00000026   0x80B0             STRH     R0,[R6, #+4]
   \   00000028   0xE002             B.N      ??USBH_MSC_InterfaceInit_2
    183              }
    184              else
    185              {
    186                MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
   \                     ??USBH_MSC_InterfaceInit_1: (+1)
   \   0000002A   0x70B0             STRB     R0,[R6, #+2]
    187                MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0] [0].wMaxPacketSize;      
   \   0000002C   0x8808             LDRH     R0,[R1, #+0]
   \   0000002E   0x80F0             STRH     R0,[R6, #+6]
    188              }
    189              
    190              if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
   \                     ??USBH_MSC_InterfaceInit_2: (+1)
   \   00000030   0x7988             LDRB     R0,[R1, #+6]
   \   00000032   0x0602             LSLS     R2,R0,#+24
   \   00000034   0xD503             BPL.N    ??USBH_MSC_InterfaceInit_3
    191              {
    192                MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
   \   00000036   0x70F0             STRB     R0,[R6, #+3]
    193                MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
   \   00000038   0x8908             LDRH     R0,[R1, #+8]
   \   0000003A   0x80B0             STRH     R0,[R6, #+4]
   \   0000003C   0xE002             B.N      ??USBH_MSC_InterfaceInit_4
    194              }
    195              else
    196              {
    197                MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
   \                     ??USBH_MSC_InterfaceInit_3: (+1)
   \   0000003E   0x70B0             STRB     R0,[R6, #+2]
    198                MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
   \   00000040   0x8908             LDRH     R0,[R1, #+8]
   \   00000042   0x80F0             STRH     R0,[R6, #+6]
    199              }
    200              
    201              MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
    202                                                          MSC_Machine.MSBulkOutEp);
   \                     ??USBH_MSC_InterfaceInit_4: (+1)
   \   00000044   0x78B1             LDRB     R1,[R6, #+2]
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       USBH_Alloc_Channel
   \   0000004C   0x7070             STRB     R0,[R6, #+1]
    203              MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
    204                                                          MSC_Machine.MSBulkInEp);  
   \   0000004E   0x78F1             LDRB     R1,[R6, #+3]
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       USBH_Alloc_Channel
   \   00000056   0x7030             STRB     R0,[R6, #+0]
    205              
    206              /* Open the new channels */
    207              USBH_Open_Channel  (pdev,
    208                                  MSC_Machine.hc_num_out,
    209                                  pphost->device_prop.address,
    210                                  pphost->device_prop.speed,
    211                                  EP_TYPE_BULK,
    212                                  MSC_Machine.MSBulkOutEpSize);  
   \   00000058   0x3520             ADDS     R5,R5,#+32
   \   0000005A   0x88F0             LDRH     R0,[R6, #+6]
   \   0000005C   0x9001             STR      R0,[SP, #+4]
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0x786B             LDRB     R3,[R5, #+1]
   \   00000064   0x782A             LDRB     R2,[R5, #+0]
   \   00000066   0x7871             LDRB     R1,[R6, #+1]
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       USBH_Open_Channel
    213              
    214              USBH_Open_Channel  (pdev,
    215                                  MSC_Machine.hc_num_in,
    216                                  pphost->device_prop.address,
    217                                  pphost->device_prop.speed,
    218                                  EP_TYPE_BULK,
    219                                  MSC_Machine.MSBulkInEpSize);    
   \   0000006E   0x88B0             LDRH     R0,[R6, #+4]
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x786B             LDRB     R3,[R5, #+1]
   \   00000078   0x782A             LDRB     R2,[R5, #+0]
   \   0000007A   0x7831             LDRB     R1,[R6, #+0]
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       USBH_Open_Channel
   \   00000082   0xE004             B.N      ??USBH_MSC_InterfaceInit_5
    220              
    221            }
    222            
    223            else
    224            {
    225              pphost->usr_cb->DeviceNotSupported(); 
   \                     ??USBH_MSC_InterfaceInit_0: (+1)
   \   00000084   0xF105 0x0054      ADD      R0,R5,#+84
   \   00000088   0x6AC0             LDR      R0,[R0, #+44]
   \   0000008A   0x6C00             LDR      R0,[R0, #+64]
   \   0000008C   0x4780             BLX      R0
    226            }
    227            
    228            return USBH_OK ;
   \                     ??USBH_MSC_InterfaceInit_5: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    229           
    230          }
    231          
    232          
    233          /**
    234            * @brief  USBH_MSC_InterfaceDeInit 
    235            *         De-Initialize interface by freeing host channels allocated to interface
    236            * @param  pdev: Selected device
    237            * @param  hdev: Selected device property
    238            * @retval None
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          void USBH_MSC_InterfaceDeInit ( USB_OTG_CORE_HANDLE *pdev,
    241                                          void *phost)
    242          {	
   \                     USBH_MSC_InterfaceDeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    243            if ( MSC_Machine.hc_num_out)
   \   00000004   0x....             LDR.N    R5,??DataTable5
   \   00000006   0x7869             LDRB     R1,[R5, #+1]
   \   00000008   0x0008             MOVS     R0,R1
   \   0000000A   0xD008             BEQ.N    ??USBH_MSC_InterfaceDeInit_0
    244            {
    245              USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_out);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       USB_OTG_HC_Halt
    246              USBH_Free_Channel  (pdev, MSC_Machine.hc_num_out);
   \   00000012   0x7869             LDRB     R1,[R5, #+1]
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       USBH_Free_Channel
    247              MSC_Machine.hc_num_out = 0;     /* Reset the Channel as Free */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7068             STRB     R0,[R5, #+1]
    248            }
    249             
    250            if ( MSC_Machine.hc_num_in)
   \                     ??USBH_MSC_InterfaceDeInit_0: (+1)
   \   0000001E   0x7829             LDRB     R1,[R5, #+0]
   \   00000020   0x0008             MOVS     R0,R1
   \   00000022   0xD008             BEQ.N    ??USBH_MSC_InterfaceDeInit_1
    251            {
    252              USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_in);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USB_OTG_HC_Halt
    253              USBH_Free_Channel  (pdev, MSC_Machine.hc_num_in);
   \   0000002A   0x7829             LDRB     R1,[R5, #+0]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       USBH_Free_Channel
    254              MSC_Machine.hc_num_in = 0;     /* Reset the Channel as Free */
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7028             STRB     R0,[R5, #+0]
    255            } 
    256          }
   \                     ??USBH_MSC_InterfaceDeInit_1: (+1)
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    257          
    258          /**
    259            * @brief  USBH_MSC_ClassRequest 
    260            *         This function will only initialize the MSC state machine
    261            * @param  pdev: Selected device
    262            * @param  hdev: Selected device property
    263            * @retval USBH_Status : Status of class request handled.
    264            */
    265          

   \                                 In section .text, align 2, keep-with-next
    266          static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
    267                                                  void *phost)
    268          {   
    269            
    270            USBH_Status status = USBH_OK ;
    271            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_INIT_STATE;
   \                     USBH_MSC_ClassRequest: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable5_1
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    272            
    273            return status; 
   \   00000006   0x4770             BX       LR               ;; return
    274          }
    275          
    276          
    277          /**
    278            * @brief  USBH_MSC_Handle 
    279            *         MSC state machine handler 
    280            * @param  pdev: Selected device
    281            * @param  hdev: Selected device property
    282            * @retval USBH_Status
    283            */
    284          

   \                                 In section .text, align 4, keep-with-next
    285          static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
    286                                             void   *phost)
    287          {
   \                     USBH_MSC_Handle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4607             MOV      R7,R0
   \   00000004   0x460E             MOV      R6,R1
    288            USBH_HOST *pphost = phost;
    289              
    290            USBH_Status status = USBH_BUSY;
   \   00000006   0x2501             MOVS     R5,#+1
    291            uint8_t mscStatus = USBH_MSC_BUSY;
    292            uint8_t appliStatus = 0;
    293            
    294            static uint8_t maxLunExceed = FALSE;
    295            
    296              
    297            if(HCD_IsDeviceConnected(pdev))
   \   00000008   0x.... 0x....      BL       HCD_IsDeviceConnected
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x8097      BEQ.W    ??USBH_MSC_Handle_1
    298            {   
    299              switch(USBH_MSC_BOTXferParam.MSCState)
   \   00000012   0x....             LDR.N    R4,??DataTable5_1
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x280A             CMP      R0,#+10
   \   00000018   0xF200 0x8092      BHI.W    ??USBH_MSC_Handle_1
   \   0000001C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_MSC_Handle_0:
   \   00000020   0x06 0x0C          DC8      0x6,0xC,0x1B,0x4A
   \              0x1B 0x4A    
   \   00000024   0x59 0x61          DC8      0x59,0x61,0x70,0x7C
   \              0x70 0x7C    
   \   00000028   0x81 0x3B          DC8      0x81,0x3B,0x8F,0x0
   \              0x8F 0x00    
    300              {
    301              case USBH_MSC_BOT_INIT_STATE:
    302                USBH_MSC_Init(pdev);
   \                     ??USBH_MSC_Handle_2: (+1)
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x.... 0x....      BL       USBH_MSC_Init
    303                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_RESET;  
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x7020             STRB     R0,[R4, #+0]
    304                break;
   \   00000036   0xE083             B.N      ??USBH_MSC_Handle_1
    305                
    306              case USBH_MSC_BOT_RESET:   
    307                /* Issue BOT RESET request */
    308                status = USBH_MSC_BOTReset(pdev, phost);
   \                     ??USBH_MSC_Handle_3: (+1)
   \   00000038   0x4631             MOV      R1,R6
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       USBH_MSC_BOTReset
   \   00000040   0x0005             MOVS     R5,R0
    309                if(status == USBH_OK )
   \   00000042   0xD101             BNE.N    ??USBH_MSC_Handle_4
    310                {
    311                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_GET_MAX_LUN;
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x7020             STRB     R0,[R4, #+0]
    312                }
    313                
    314                if(status == USBH_NOT_SUPPORTED )
   \                     ??USBH_MSC_Handle_4: (+1)
   \   00000048   0x2D03             CMP      R5,#+3
   \   0000004A   0xD179             BNE.N    ??USBH_MSC_Handle_1
    315                {
    316                 /* If the Command has failed, then we need to move to Next State, after
    317                  STALL condition is cleared by Control-Transfer */
    318                  USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x7060             STRB     R0,[R4, #+1]
    319          
    320                  /* a Clear Feature should be issued here */
    321                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
   \   00000050   0x2009             MOVS     R0,#+9
   \   00000052   0x7020             STRB     R0,[R4, #+0]
   \   00000054   0xE074             B.N      ??USBH_MSC_Handle_1
    322                }  
    323                break;
    324                
    325              case USBH_MSC_GET_MAX_LUN:
    326                /* Issue GetMaxLUN request */
    327                status = USBH_MSC_GETMaxLUN(pdev, phost);
   \                     ??USBH_MSC_Handle_5: (+1)
   \   00000056   0x4631             MOV      R1,R6
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       USBH_MSC_GETMaxLUN
   \   0000005E   0x0005             MOVS     R5,R0
    328                
    329                if(status == USBH_OK )
   \   00000060   0xD112             BNE.N    ??USBH_MSC_Handle_6
    330                {
    331                  MSC_Machine.maxLun = *(MSC_Machine.buff) ;
   \   00000062   0x....             LDR.N    R0,??DataTable5
   \   00000064   0x7A01             LDRB     R1,[R0, #+8]
   \   00000066   0xF880 0x1048      STRB     R1,[R0, #+72]
    332                  
    333                  /* If device has more that one logical unit then it is not supported */
    334                  if((MSC_Machine.maxLun > 0) && (maxLunExceed == FALSE))
   \   0000006A   0x2900             CMP      R1,#+0
   \   0000006C   0xD00A             BEQ.N    ??USBH_MSC_Handle_7
   \   0000006E   0x....             LDR.N    R0,??DataTable5_2
   \   00000070   0x7841             LDRB     R1,[R0, #+1]
   \   00000072   0x2900             CMP      R1,#+0
   \   00000074   0xD106             BNE.N    ??USBH_MSC_Handle_7
    335                  {
    336                    maxLunExceed = TRUE;
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x7041             STRB     R1,[R0, #+1]
    337                    pphost->usr_cb->DeviceNotSupported();
   \   0000007A   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \   0000007E   0x6C00             LDR      R0,[R0, #+64]
   \   00000080   0x4780             BLX      R0
    338                    
    339                    break;
   \   00000082   0xE05D             B.N      ??USBH_MSC_Handle_1
    340                  }
    341                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_TEST_UNIT_READY;
   \                     ??USBH_MSC_Handle_7: (+1)
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x7020             STRB     R0,[R4, #+0]
    342                }
    343                
    344                if(status == USBH_NOT_SUPPORTED )
   \                     ??USBH_MSC_Handle_6: (+1)
   \   00000088   0x2D03             CMP      R5,#+3
   \   0000008A   0xD159             BNE.N    ??USBH_MSC_Handle_1
    345                {
    346                         /* If the Command has failed, then we need to move to Next State, after
    347                  STALL condition is cleared by Control-Transfer */
    348                  USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY; 
   \   0000008C   0x2003             MOVS     R0,#+3
   \   0000008E   0x7060             STRB     R0,[R4, #+1]
    349                  
    350                  /* a Clear Feature should be issued here */
    351                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
   \   00000090   0x2009             MOVS     R0,#+9
   \   00000092   0x7020             STRB     R0,[R4, #+0]
   \   00000094   0xE054             B.N      ??USBH_MSC_Handle_1
    352                }    
    353                break;
    354                
    355              case USBH_MSC_CTRL_ERROR_STATE:
    356                /* Issue Clearfeature request */
    357                status = USBH_ClrFeature(pdev,
    358                                         phost,
    359                                         0x00,
    360                                         pphost->Control.hc_num_out);
   \                     ??USBH_MSC_Handle_8: (+1)
   \   00000096   0x7973             LDRB     R3,[R6, #+5]
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x4631             MOV      R1,R6
   \   0000009C   0x4638             MOV      R0,R7
   \   0000009E   0x.... 0x....      BL       USBH_ClrFeature
   \   000000A2   0x0005             MOVS     R5,R0
    361                if(status == USBH_OK )
   \   000000A4   0xD14C             BNE.N    ??USBH_MSC_Handle_1
    362                {
    363                  /* If GetMaxLun Request not support, assume Single LUN configuration */
    364                  MSC_Machine.maxLun = 0;  
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x....             LDR.N    R1,??DataTable5
   \   000000AA   0xF881 0x0048      STRB     R0,[R1, #+72]
    365                  
    366                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
   \   000000AE   0x7860             LDRB     R0,[R4, #+1]
   \   000000B0   0x7020             STRB     R0,[R4, #+0]
   \   000000B2   0xE045             B.N      ??USBH_MSC_Handle_1
    367                }
    368                break;  
    369                
    370              case USBH_MSC_TEST_UNIT_READY:
    371                /* Issue SCSI command TestUnitReady */ 
    372                mscStatus = USBH_MSC_TestUnitReady(pdev);
   \                     ??USBH_MSC_Handle_9: (+1)
   \   000000B4   0x4638             MOV      R0,R7
   \   000000B6   0x.... 0x....      BL       USBH_MSC_TestUnitReady
    373                
    374                if(mscStatus == USBH_MSC_OK )
   \   000000BA   0x0001             MOVS     R1,R0
   \   000000BC   0xD106             BNE.N    ??USBH_MSC_Handle_10
    375                {
    376                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
   \   000000BE   0x2004             MOVS     R0,#+4
   \   000000C0   0x7020             STRB     R0,[R4, #+0]
    377                  MSCErrorCount = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x....             LDR.N    R1,??DataTable5_2
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    378                  status = USBH_OK;
   \   000000C8   0x4605             MOV      R5,R0
   \   000000CA   0xE039             B.N      ??USBH_MSC_Handle_1
    379                }
    380                else
    381                {
    382                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_10: (+1)
   \   000000CC   0x.... 0x....      BL       USBH_MSC_ErrorHandle
   \   000000D0   0xE036             B.N      ??USBH_MSC_Handle_1
    383                } 
    384                break;
    385                
    386              case USBH_MSC_READ_CAPACITY10:
    387                /* Issue READ_CAPACITY10 SCSI command */
    388                mscStatus = USBH_MSC_ReadCapacity10(pdev);
   \                     ??USBH_MSC_Handle_11: (+1)
   \   000000D2   0x4638             MOV      R0,R7
   \   000000D4   0x.... 0x....      BL       USBH_MSC_ReadCapacity10
    389                if(mscStatus == USBH_MSC_OK )
   \   000000D8   0x0001             MOVS     R1,R0
   \   000000DA   0xD007             BEQ.N    ??USBH_MSC_Handle_12
    390                {
    391                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;//USBH_MSC_MODE_SENSE6;
    392                  MSCErrorCount = 0;
    393                  status = USBH_OK;
    394                }
    395                else
    396                {
    397                  USBH_MSC_ErrorHandle(mscStatus);
   \   000000DC   0x.... 0x....      BL       USBH_MSC_ErrorHandle
   \   000000E0   0xE02E             B.N      ??USBH_MSC_Handle_1
    398                }
    399                break;
    400          
    401              case USBH_MSC_MODE_SENSE6:
    402                /* Issue ModeSense6 SCSI command for detecting if device is write-protected */
    403                mscStatus = USBH_MSC_ModeSense6(pdev);
   \                     ??USBH_MSC_Handle_13: (+1)
   \   000000E2   0x4638             MOV      R0,R7
   \   000000E4   0x.... 0x....      BL       USBH_MSC_ModeSense6
    404                if(mscStatus == USBH_MSC_OK )
   \   000000E8   0x0001             MOVS     R1,R0
   \   000000EA   0xD106             BNE.N    ??USBH_MSC_Handle_14
    405                {
    406                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
   \                     ??USBH_MSC_Handle_12: (+1)
   \   000000EC   0x2008             MOVS     R0,#+8
   \   000000EE   0x7020             STRB     R0,[R4, #+0]
    407                  MSCErrorCount = 0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x....             LDR.N    R1,??DataTable5_2
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
    408                  status = USBH_OK;
   \   000000F6   0x4605             MOV      R5,R0
   \   000000F8   0xE022             B.N      ??USBH_MSC_Handle_1
    409                }
    410                else
    411                {
    412                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_14: (+1)
   \   000000FA   0x.... 0x....      BL       USBH_MSC_ErrorHandle
   \   000000FE   0xE01F             B.N      ??USBH_MSC_Handle_1
    413                }
    414                break;
    415                
    416              case USBH_MSC_REQUEST_SENSE:
    417                /* Issue RequestSense SCSI command for retreiving error code */
    418                mscStatus = USBH_MSC_RequestSense(pdev);
   \                     ??USBH_MSC_Handle_15: (+1)
   \   00000100   0x4638             MOV      R0,R7
   \   00000102   0x.... 0x....      BL       USBH_MSC_RequestSense
    419                if(mscStatus == USBH_MSC_OK )
   \   00000106   0x0001             MOVS     R1,R0
   \   00000108   0xD103             BNE.N    ??USBH_MSC_Handle_16
    420                {
    421                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
   \   0000010A   0x7860             LDRB     R0,[R4, #+1]
   \   0000010C   0x7020             STRB     R0,[R4, #+0]
    422                  status = USBH_OK;
   \   0000010E   0x2500             MOVS     R5,#+0
   \   00000110   0xE016             B.N      ??USBH_MSC_Handle_1
    423                }
    424                else
    425                {
    426                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_16: (+1)
   \   00000112   0x.... 0x....      BL       USBH_MSC_ErrorHandle
   \   00000116   0xE013             B.N      ??USBH_MSC_Handle_1
    427                }  
    428                break;
    429                
    430              case USBH_MSC_BOT_USB_TRANSFERS:
    431                /* Process the BOT state machine */
    432                USBH_MSC_HandleBOTXfer(pdev , phost);
   \                     ??USBH_MSC_Handle_17: (+1)
   \   00000118   0x4631             MOV      R1,R6
   \   0000011A   0x4638             MOV      R0,R7
   \   0000011C   0x.... 0x....      BL       USBH_MSC_HandleBOTXfer
    433                break;
   \   00000120   0xE00E             B.N      ??USBH_MSC_Handle_1
    434              
    435              case USBH_MSC_DEFAULT_APPLI_STATE:
    436                /* Process Application callback for MSC */
    437                appliStatus = pphost->usr_cb->UserApplication();
   \                     ??USBH_MSC_Handle_18: (+1)
   \   00000122   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \   00000126   0x6BC0             LDR      R0,[R0, #+60]
   \   00000128   0x4780             BLX      R0
   \   0000012A   0xB2C0             UXTB     R0,R0
    438                if(appliStatus == 0)
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD102             BNE.N    ??USBH_MSC_Handle_19
    439                {
    440                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
   \   00000130   0x2008             MOVS     R0,#+8
   \   00000132   0x7020             STRB     R0,[R4, #+0]
   \   00000134   0xE004             B.N      ??USBH_MSC_Handle_1
    441                }
    442                else if (appliStatus == 1) 
   \                     ??USBH_MSC_Handle_19: (+1)
   \   00000136   0x2801             CMP      R0,#+1
   \   00000138   0xD102             BNE.N    ??USBH_MSC_Handle_1
    443                {
    444                  /* De-init requested from application layer */
    445                  status =  USBH_APPLY_DEINIT;
   \   0000013A   0x2506             MOVS     R5,#+6
   \   0000013C   0xE000             B.N      ??USBH_MSC_Handle_1
    446                }
    447                break;
    448                
    449              case USBH_MSC_UNRECOVERED_STATE:
    450                
    451                status = USBH_UNRECOVERED_ERROR;
   \                     ??USBH_MSC_Handle_20: (+1)
   \   0000013E   0x2504             MOVS     R5,#+4
    452                
    453                break;
    454                
    455              default:
    456                break; 
    457                
    458              }
    459            }
    460             return status;
   \                     ??USBH_MSC_Handle_1: (+1)
   \   00000140   0x4628             MOV      R0,R5
   \   00000142   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    461          }

   \                                 In section .bss, align 1
   \                     MSCErrorCount:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
    462          
    463          
    464          
    465          /**
    466            * @brief  USBH_MSC_BOTReset
    467            *         This request is used to reset the mass storage device and its 
    468            *         associated interface. This class-specific request shall ready the 
    469            *         device for the next CBW from the host.
    470            * @param  pdev: Selected device
    471            * @retval USBH_Status : Status of class request handled.
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          static USBH_Status USBH_MSC_BOTReset(USB_OTG_CORE_HANDLE *pdev,
    474                                        USBH_HOST *phost)
    475          {
    476            
    477            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
    478                                        USB_REQ_RECIPIENT_INTERFACE;
   \                     USBH_MSC_BOTReset: (+1)
   \   00000000   0x2221             MOVS     R2,#+33
   \   00000002   0x750A             STRB     R2,[R1, #+20]
    479            
    480            phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x754A             STRB     R2,[R1, #+21]
    481            phost->Control.setup.b.wValue.w = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x82CA             STRH     R2,[R1, #+22]
    482            phost->Control.setup.b.wIndex.w = 0;
   \   0000000C   0x830A             STRH     R2,[R1, #+24]
    483            phost->Control.setup.b.wLength.w = 0;           
   \   0000000E   0x834A             STRH     R2,[R1, #+26]
    484            
    485            return USBH_CtlReq(pdev, phost, 0 , 0 ); 
   \   00000010   0x4613             MOV      R3,R2
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    486          }
    487          
    488          
    489          /**
    490            * @brief  USBH_MSC_GETMaxLUN
    491            *         This request is used to reset the mass storage device and its 
    492            *         associated interface. This class-specific request shall ready the 
    493            *         device for the next CBW from the host.
    494            * @param  pdev: Selected device
    495            * @retval USBH_Status : USB ctl xfer status
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
    498          {
    499            phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
    500                                        USB_REQ_RECIPIENT_INTERFACE;
   \                     USBH_MSC_GETMaxLUN: (+1)
   \   00000000   0x22A1             MOVS     R2,#+161
   \   00000002   0x750A             STRB     R2,[R1, #+20]
    501            
    502            phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
   \   00000004   0x22FE             MOVS     R2,#+254
   \   00000006   0x754A             STRB     R2,[R1, #+21]
    503            phost->Control.setup.b.wValue.w = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x82CA             STRH     R2,[R1, #+22]
    504            phost->Control.setup.b.wIndex.w = 0;
   \   0000000C   0x830A             STRH     R2,[R1, #+24]
    505            phost->Control.setup.b.wLength.w = 1;           
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x834A             STRH     R2,[R1, #+26]
    506            
    507            return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
   \   00000012   0x4613             MOV      R3,R2
   \   00000014   0x....             LDR.N    R2,??DataTable5_3
   \   00000016   0x.... 0x....      B.W      USBH_CtlReq
    508          }
    509          
    510          /**
    511            * @brief  USBH_MSC_ErrorHandle 
    512            *         The function is for handling errors occuring during the MSC
    513            *         state machine   
    514            * @param  status
    515            * @retval None
    516            */
    517          

   \                                 In section .text, align 2, keep-with-next
    518          void USBH_MSC_ErrorHandle(uint8_t status)
    519          {  
    520              if(status == USBH_MSC_FAIL)
   \                     USBH_MSC_ErrorHandle: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD10F             BNE.N    ??USBH_MSC_ErrorHandle_0
    521              { 
    522                MSCErrorCount++;
   \   00000004   0x....             LDR.N    R0,??DataTable5_2
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    523                if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x290A             CMP      R1,#+10
   \   00000012   0xDA04             BGE.N    ??USBH_MSC_ErrorHandle_1
    524                { /* Try MSC level error recovery, Issue the request Sense to get 
    525                  Drive error reason  */
    526                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
   \   00000014   0x2106             MOVS     R1,#+6
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    527                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x70C1             STRB     R1,[R0, #+3]
   \   0000001C   0x4770             BX       LR
    528                }
    529                else
    530                {
    531                  /* Error trials exceeded the limit, go to unrecovered state */
    532                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
   \                     ??USBH_MSC_ErrorHandle_1: (+1)
   \   0000001E   0x210A             MOVS     R1,#+10
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   \   00000022   0x4770             BX       LR
    533                }
    534              } 
    535              else if(status == USBH_MSC_PHASE_ERROR)
   \                     ??USBH_MSC_ErrorHandle_0: (+1)
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD102             BNE.N    ??USBH_MSC_ErrorHandle_2
    536              {
    537                /* Phase error, Go to Unrecoovered state */
    538                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0x....             LDR.N    R1,??DataTable5_1
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    539              }
    540              else if(status == USBH_MSC_BUSY)
    541              {
    542                /*No change in state*/
    543              }
    544          }
   \                     ??USBH_MSC_ErrorHandle_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     MSC_Machine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     USBH_MSC_BOTXferParam

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     MSCErrorCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     MSC_Machine+0x8
    545          
    546          /**
    547            * @}
    548            */ 
    549          
    550          /**
    551            * @}
    552            */ 
    553          
    554          /**
    555            * @}
    556            */
    557          
    558          /**
    559            * @}
    560            */ 
    561          
    562          /**
    563            * @}
    564            */
    565          
    566          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBH_MSC_BOTReset
         0   -> USBH_CtlReq
       0   USBH_MSC_ClassRequest
       0   USBH_MSC_ErrorHandle
       0   USBH_MSC_GETMaxLUN
         0   -> USBH_CtlReq
      24   USBH_MSC_Handle
        24   -- Indirect call
        24   -> HCD_IsDeviceConnected
        24   -> USBH_ClrFeature
        24   -> USBH_MSC_BOTReset
        24   -> USBH_MSC_ErrorHandle
        24   -> USBH_MSC_GETMaxLUN
        24   -> USBH_MSC_HandleBOTXfer
        24   -> USBH_MSC_Init
        24   -> USBH_MSC_ModeSense6
        24   -> USBH_MSC_ReadCapacity10
        24   -> USBH_MSC_RequestSense
        24   -> USBH_MSC_TestUnitReady
      16   USBH_MSC_InterfaceDeInit
        16   -> USBH_Free_Channel
        16   -> USB_OTG_HC_Halt
      24   USBH_MSC_InterfaceInit
        24   -- Indirect call
        24   -> USBH_Alloc_Channel
        24   -> USBH_Open_Channel


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       2  MSCErrorCount
          maxLunExceed
      76  MSC_Machine
       8  MSC_Setup
      22  USBH_MSC_BOTReset
       8  USBH_MSC_ClassRequest
      48  USBH_MSC_ErrorHandle
      26  USBH_MSC_GETMaxLUN
     324  USBH_MSC_Handle
      56  USBH_MSC_InterfaceDeInit
     146  USBH_MSC_InterfaceInit
      16  USBH_MSC_cb

 
  86 bytes in section .bss
  16 bytes in section .data
 646 bytes in section .text
 
 646 bytes of CODE memory
 102 bytes of DATA memory

Errors: none
Warnings: none
