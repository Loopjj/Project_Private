###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\avg.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\avg.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\avg.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\avg.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\avg.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2015 LOOP *************************************
      3          *
      4          * File Name          : avg.c
      5          *
      6          * Author             : Reserch & Developing 1 Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 07/29/2015
     11          *
     12          * Description        : ADC average
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          
     18          
     19          /*
     20          *********************************************************************************************************
     21          *                                             INCLUDE FILES
     22          *********************************************************************************************************
     23          */
     24          
     25          
     26          #define AVR_GLOBALS
     27          #include "includes.h"

   \                                 In section .bss, align 4
   \   __absolute int flagsampling
   \                     flagsampling:
   \   00000000                      DS8 4
     28          
     29          typedef struct {
     30          	INT16U	buffer[100];
     31          	INT16U	headIndex;
     32          	INT16U	rearIndex;
     33          	INT16U	Max;// 멕스값은 최소값으로 초기화하고 
     34          	INT16U	Min;// 민 값은 최대값으로 초기화하면 다음측정시에 바로 업데이트 될텐데 초기화 할 곳이 마땅치 않다. 일단보류.
     35          	INT32U	sum;
     36          }runavr_t;
     37          

   \                                 In section .bss, align 4
     38          static runavr_t runavr[AVR_BUFF_MAX]={0};
   \                     runavr:
   \   00000000                      DS8 424
     39          
     40          
     41          /*
     42          ********************************************************************************
     43          * Description : init_runavr_buff
     44          * Arguments   : none
     45          * Return      : 
     46          * Note        : digital output test
     47          ******************************************************************************** 
     48          */
     49          

   \                                 In section .text, align 2, keep-with-next
     50          void init_runavr_buff(void)
     51          {
   \                     init_runavr_buff: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     52          	int i=0;
   \   00000002   0x2400             MOVS     R4,#+0
     53          	for(i=0;i<AVR_BUFF_MAX;i++)
   \   00000004   0xE014             B.N      ??init_runavr_buff_0
     54          	{
     55          		memset((char *)runavr[i].buffer,0x00,sizeof(runavr[i].buffer));
   \                     ??init_runavr_buff_1: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable3
   \   00000008   0x21D4             MOVS     R1,#+212
   \   0000000A   0x4361             MULS     R1,R1,R4
   \   0000000C   0x1845             ADDS     R5,R0,R1
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x21C8             MOVS     R1,#+200
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       __aeabi_memset
     56          		runavr[i].headIndex = 0;
   \   00000018   0xF105 0x00C8      ADD      R0,R5,#+200
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x8001             STRH     R1,[R0, #+0]
     57          		runavr[i].rearIndex = 0;
   \   00000020   0x8041             STRH     R1,[R0, #+2]
     58          		runavr[i].Max		= 0;
   \   00000022   0x8081             STRH     R1,[R0, #+4]
     59          		runavr[i].Min		= 0xffff;
   \   00000024   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000028   0x80C1             STRH     R1,[R0, #+6]
     60          		runavr[i].sum		= 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6081             STR      R1,[R0, #+8]
     61          
     62          	}
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
   \                     ??init_runavr_buff_0: (+1)
   \   00000030   0x2C02             CMP      R4,#+2
   \   00000032   0xDBE8             BLT.N    ??init_runavr_buff_1
     63          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     64          
     65          /*
     66          ********************************************************************************
     67          * Description : insert_sort
     68          * Arguments   : *buff, length, channel
     69          * Return      : 
     70          * Note        : 
     71          ******************************************************************************** 
     72          */
     73          
     74          __INLINE void insert_sort(INT16U *buff, INT16U len,int ch)
     75          {
     76          	INT16U i,j,t;
     77          	runavr_t *pAVR;
     78          	pAVR = &runavr[ch];
     79          
     80          	for(i=0;i<len-1;i++)
     81          	{
     82          		for(j=1;j < len-i;j++){
     83          			if(pAVR->buffer[j-1] > pAVR->buffer[j])
     84          			{
     85          				t = pAVR->buffer[j-1];
     86          				pAVR->buffer[j-1] = pAVR->buffer[j];
     87          				pAVR->buffer[j] = t;
     88          			}
     89          		}
     90          	}
     91          }
     92          
     93          
     94          /*
     95          ********************************************************************************
     96          * Description : runningAverageADC
     97          * Arguments   : channel, val
     98          * Return      : 
     99          * Note        : 
    100          ******************************************************************************** 
    101          */
    102          

   \                                 In section .text, align 2, keep-with-next
    103          INT16U runningAverageADC(int ch,INT16U val)
    104          {
   \                     runningAverageADC: (+1)
   \   00000000   0xB410             PUSH     {R4}
    105          	INT8U	AverageCount= 0;
    106          	runavr_t *pAVR;
    107          	pAVR = &runavr[ch];
    108          
    109          	AverageCount = ADC_MAXAVERAGE_IN;
    110          
    111          	if ( pAVR->headIndex == AverageCount )
   \   00000002   0x....             LDR.N    R2,??DataTable3
   \   00000004   0x23D4             MOVS     R3,#+212
   \   00000006   0x4358             MULS     R0,R3,R0
   \   00000008   0x4402             ADD      R2,R2,R0
   \   0000000A   0xF102 0x00C8      ADD      R0,R2,#+200
   \   0000000E   0x8803             LDRH     R3,[R0, #+0]
   \   00000010   0x2B14             CMP      R3,#+20
   \   00000012   0xD103             BNE.N    ??runningAverageADC_0
    112          	{
    113          		pAVR->headIndex = 0;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x8003             STRH     R3,[R0, #+0]
    114          		pAVR->rearIndex = AverageCount-1;
   \   00000018   0x2313             MOVS     R3,#+19
   \   0000001A   0x8043             STRH     R3,[R0, #+2]
    115          	}
    116          	pAVR->sum -= pAVR->buffer[pAVR->headIndex];
   \                     ??runningAverageADC_0: (+1)
   \   0000001C   0x6883             LDR      R3,[R0, #+8]
   \   0000001E   0x8804             LDRH     R4,[R0, #+0]
   \   00000020   0xF832 0x4014      LDRH     R4,[R2, R4, LSL #+1]
   \   00000024   0x1B1B             SUBS     R3,R3,R4
   \   00000026   0x6083             STR      R3,[R0, #+8]
    117          	pAVR->buffer[pAVR->headIndex] = val;
   \   00000028   0x8803             LDRH     R3,[R0, #+0]
   \   0000002A   0xF822 0x1013      STRH     R1,[R2, R3, LSL #+1]
    118          	pAVR->sum += pAVR->buffer[pAVR->headIndex];
   \   0000002E   0x6881             LDR      R1,[R0, #+8]
   \   00000030   0x8803             LDRH     R3,[R0, #+0]
   \   00000032   0xF832 0x2013      LDRH     R2,[R2, R3, LSL #+1]
   \   00000036   0x1851             ADDS     R1,R2,R1
   \   00000038   0x6081             STR      R1,[R0, #+8]
    119          	pAVR->headIndex++;
   \   0000003A   0x8801             LDRH     R1,[R0, #+0]
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0x8001             STRH     R1,[R0, #+0]
    120          	return (INT16U) (pAVR->sum/AverageCount);
   \   00000040   0x6880             LDR      R0,[R0, #+8]
   \   00000042   0x2114             MOVS     R1,#+20
   \   00000044   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000048   0xB280             UXTH     R0,R0
   \   0000004A   0xBC10             POP      {R4}
   \   0000004C   0x4770             BX       LR               ;; return
    121          	
    122          }
    123          
    124          
    125          /*
    126          ********************************************************************************
    127          * Description : ext_insert_sort
    128          * Arguments   : *buff, length, channel
    129          * Return      : 
    130          * Note        : 
    131          ******************************************************************************** 
    132          */
    133          

   \                                 In section .text, align 4
    134          __INLINE void ext_insert_sort(INT16U *buff, INT16U len,int ch)
    135          {
   \                     ext_insert_sort: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    136          	INT16U i,j,t;
    137          	runavr_t *pAVR;
    138          	pAVR = &runavr[ch];
    139          
    140          	for(i=0;i<len-1;i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0xE017             B.N      ??ext_insert_sort_0
    141          	{
    142          		for(j=1;j < len-i;j++){
    143          			if(pAVR->buffer[j-1] > pAVR->buffer[j])
   \                     ??ext_insert_sort_1: (+1)
   \   00000008   0x4D0E             LDR.N    R5,??ext_insert_sort_2
   \   0000000A   0x26D4             MOVS     R6,#+212
   \   0000000C   0x4356             MULS     R6,R6,R2
   \   0000000E   0x4435             ADD      R5,R5,R6
   \   00000010   0xEB05 0x0644      ADD      R6,R5,R4, LSL #+1
   \   00000014   0xF836 0x7C02      LDRH     R7,[R6, #-2]
   \   00000018   0xF835 0xC014      LDRH     R12,[R5, R4, LSL #+1]
   \   0000001C   0x46BE             MOV      LR,R7
   \   0000001E   0x45F4             CMP      R12,LR
   \   00000020   0xD203             BCS.N    ??ext_insert_sort_3
    144          			{
    145          				t = pAVR->buffer[j-1];
    146          				pAVR->buffer[j-1] = pAVR->buffer[j];
   \   00000022   0xF826 0xCC02      STRH     R12,[R6, #-2]
    147          				pAVR->buffer[j] = t;
   \   00000026   0xF825 0x7014      STRH     R7,[R5, R4, LSL #+1]
    148          			}
    149          		}
   \                     ??ext_insert_sort_3: (+1)
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \   0000002C   0xB2A4             UXTH     R4,R4
   \                     ??ext_insert_sort_4: (+1)
   \   0000002E   0x1A1D             SUBS     R5,R3,R0
   \   00000030   0x42AC             CMP      R4,R5
   \   00000032   0xDBE9             BLT.N    ??ext_insert_sort_1
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0xB280             UXTH     R0,R0
   \                     ??ext_insert_sort_0: (+1)
   \   00000038   0x1E5C             SUBS     R4,R3,#+1
   \   0000003A   0x42A0             CMP      R0,R4
   \   0000003C   0xDA01             BGE.N    ??ext_insert_sort_5
   \   0000003E   0x2401             MOVS     R4,#+1
   \   00000040   0xE7F5             B.N      ??ext_insert_sort_4
    150          	}
    151          }
   \                     ??ext_insert_sort_5: (+1)
   \   00000042   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??ext_insert_sort_2:
   \   00000044   0x........         DC32     runavr
    152          
    153          
    154          /*
    155          ********************************************************************************
    156          * Description : ext_runningAverageADC
    157          * Arguments   : channel
    158          * Return      : 
    159          * Note        : 
    160          ******************************************************************************** 
    161          */
    162          

   \                                 In section .text, align 2, keep-with-next
    163          INT16U ext_runningAverageADC(int ch,INT16U val)
    164          {
   \                     ext_runningAverageADC: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    165          	INT8U	i=0,N=0;
   \   00000002   0x2400             MOVS     R4,#+0
    166          	INT16U	retunad=0;
    167          	runavr_t *pAVR;
    168          	pAVR = &runavr[ch];										          // 원하는 adc체널의 포인터를 얻어온다.
    169          	
    170          	N = ADC_MAXAVERAGE/2;
    171          	pAVR->buffer[pAVR->headIndex] = val;
   \   00000004   0x....             LDR.N    R2,??DataTable3
   \   00000006   0x23D4             MOVS     R3,#+212
   \   00000008   0x4343             MULS     R3,R3,R0
   \   0000000A   0x18D5             ADDS     R5,R2,R3
   \   0000000C   0xF105 0x06C8      ADD      R6,R5,#+200
   \   00000010   0x8832             LDRH     R2,[R6, #+0]
   \   00000012   0xF825 0x1012      STRH     R1,[R5, R2, LSL #+1]
    172          
    173          	if ( pAVR->headIndex == ADC_MAXAVERAGE ){				// 버퍼 경계 처리 
   \   00000016   0x8831             LDRH     R1,[R6, #+0]
   \   00000018   0x2914             CMP      R1,#+20
   \   0000001A   0xD11B             BNE.N    ??ext_runningAverageADC_0
    174          		pAVR->headIndex = 0;								          // 다시 0
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x8031             STRH     R1,[R6, #+0]
    175          		pAVR->sum = 0;
   \   00000020   0x60B1             STR      R1,[R6, #+8]
    176          		pAVR->rearIndex = ADC_MAXAVERAGE-1;					  // 이전번호 인덱스 
   \   00000022   0x2113             MOVS     R1,#+19
   \   00000024   0x8071             STRH     R1,[R6, #+2]
    177          		ext_insert_sort(pAVR->buffer,ADC_MAXAVERAGE,ch);
   \   00000026   0x4602             MOV      R2,R0
   \   00000028   0x2114             MOVS     R1,#+20
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       ext_insert_sort
    178          		for(i=0;i < N;i++)
   \   00000030   0xE006             B.N      ??ext_runningAverageADC_1
    179          		{
    180          			if(ADC_MAXAVERAGE == 20)
    181          				pAVR->sum += pAVR->buffer[5 + i];         // 큰 값을 sum한다.
   \                     ??ext_runningAverageADC_2: (+1)
   \   00000032   0x68B1             LDR      R1,[R6, #+8]
   \   00000034   0xEB05 0x0040      ADD      R0,R5,R0, LSL #+1
   \   00000038   0x8940             LDRH     R0,[R0, #+10]
   \   0000003A   0x1840             ADDS     R0,R0,R1
   \   0000003C   0x60B0             STR      R0,[R6, #+8]
    182          			else if(ADC_MAXAVERAGE == 30)
    183          				pAVR->sum += pAVR->buffer[7 + i];         // 큰 값을 sum한다.
    184          			else if(ADC_MAXAVERAGE == 40)
    185          				pAVR->sum += pAVR->buffer[9 + i];         // 큰 값을 sum한다.
    186          			else if(ADC_MAXAVERAGE == 10)
    187          				pAVR->sum += pAVR->buffer[3 + i];         // 큰 값을 sum한다.
    188          		}
   \   0000003E   0x1C64             ADDS     R4,R4,#+1
   \                     ??ext_runningAverageADC_1: (+1)
   \   00000040   0xB2E4             UXTB     R4,R4
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x280A             CMP      R0,#+10
   \   00000046   0xDBF4             BLT.N    ??ext_runningAverageADC_2
    189          		retunad = (INT16U)(pAVR->sum / N);
    190          		pAVR->sum = retunad;
   \   00000048   0x68B0             LDR      R0,[R6, #+8]
   \   0000004A   0x210A             MOVS     R1,#+10
   \   0000004C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000050   0xB280             UXTH     R0,R0
   \   00000052   0x60B0             STR      R0,[R6, #+8]
    191          	}
    192          	pAVR->headIndex++;										          // 인덱스 증가 
   \                     ??ext_runningAverageADC_0: (+1)
   \   00000054   0x8830             LDRH     R0,[R6, #+0]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x8030             STRH     R0,[R6, #+0]
    193          	return (INT16U)pAVR->sum;
   \   0000005A   0x68B0             LDR      R0,[R6, #+8]
   \   0000005C   0xB280             UXTH     R0,R0
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
    194          }
    195          
    196          
    197          /*
    198          ********************************************************************************
    199          * Description : Pressure_Process
    200          * Arguments   : channel
    201          * Return      : 
    202          * Note        : 0.5V의 Reference, 4.5V의 Reference의 측정후 아래 함수에 적용,
    203          *             : Reference의 초기값은 SYS_Control_Factory_Init() Define.
    204          ******************************************************************************** 
    205          */
    206          

   \                                 In section .text, align 2, keep-with-next
    207          INT16U Pressure_Process(void)
    208          {
   \                     Pressure_Process: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    209            double bar = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x4625             MOV      R5,R4
    210          	double gain = 0;
    211          
    212            adcdata[ADC_AVR_P0] = runningAverageADC(ADC_P0, adcdata[ADC_P0]);
   \   00000008   0x....             LDR.N    R7,??DataTable3_1
   \   0000000A   0x8839             LDRH     R1,[R7, #+0]
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       runningAverageADC
   \   00000012   0x4606             MOV      R6,R0
   \   00000014   0x807E             STRH     R6,[R7, #+2]
    213            if( adcdata[ADC_AVR_P0] < Setting.P1CalLow) bar = 0;
   \   00000016   0x....             LDR.N    R0,??DataTable3_2
   \   00000018   0x88C7             LDRH     R7,[R0, #+6]
   \   0000001A   0x4631             MOV      R1,R6
   \   0000001C   0x463A             MOV      R2,R7
   \   0000001E   0x4291             CMP      R1,R2
   \   00000020   0xD330             BCC.N    ??Pressure_Process_0
    214            else if( adcdata[ADC_AVR_P0] > Setting.P1CalHigh) bar = Setting.Prangehigh;
   \   00000022   0xF8B0 0xA004      LDRH     R10,[R0, #+4]
   \   00000026   0x8805             LDRH     R5,[R0, #+0]
   \   00000028   0x4651             MOV      R1,R10
   \   0000002A   0x4632             MOV      R2,R6
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD205             BCS.N    ??Pressure_Process_1
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       __aeabi_ui2d
   \   00000036   0x4604             MOV      R4,R0
   \   00000038   0x460D             MOV      R5,R1
   \   0000003A   0xE023             B.N      ??Pressure_Process_0
    215            else {
    216              gain =(double)(Setting.Prangehigh - Setting.Prangelow )/(double)(Setting.P1CalHigh - Setting.P1CalLow); 
    217              bar = (double)(Setting.Prangelow + gain*(double)(adcdata[ADC_AVR_P0] - Setting.P1CalLow));
   \                     ??Pressure_Process_1: (+1)
   \   0000003C   0x8844             LDRH     R4,[R0, #+2]
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       __aeabi_ui2d
   \   00000044   0x4680             MOV      R8,R0
   \   00000046   0x4689             MOV      R9,R1
   \   00000048   0x1B28             SUBS     R0,R5,R4
   \   0000004A   0x.... 0x....      BL       __aeabi_i2d
   \   0000004E   0x4604             MOV      R4,R0
   \   00000050   0x460D             MOV      R5,R1
   \   00000052   0xEBAA 0x0007      SUB      R0,R10,R7
   \   00000056   0x.... 0x....      BL       __aeabi_i2d
   \   0000005A   0x4602             MOV      R2,R0
   \   0000005C   0x460B             MOV      R3,R1
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x.... 0x....      BL       __aeabi_ddiv
   \   00000066   0x4604             MOV      R4,R0
   \   00000068   0x460D             MOV      R5,R1
   \   0000006A   0x1BF0             SUBS     R0,R6,R7
   \   0000006C   0x.... 0x....      BL       __aeabi_i2d
   \   00000070   0x4622             MOV      R2,R4
   \   00000072   0x462B             MOV      R3,R5
   \   00000074   0x.... 0x....      BL       __aeabi_dmul
   \   00000078   0x4642             MOV      R2,R8
   \   0000007A   0x464B             MOV      R3,R9
   \   0000007C   0x.... 0x....      BL       __aeabi_dadd
   \   00000080   0x4604             MOV      R4,R0
   \   00000082   0x460D             MOV      R5,R1
    218            }
    219          	return (INT16U)bar;
   \                     ??Pressure_Process_0: (+1)
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x4629             MOV      R1,R5
   \   00000088   0x.... 0x....      BL       __aeabi_d2iz
   \   0000008C   0xB280             UXTH     R0,R0
   \   0000008E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    220          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     runavr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     adcdata

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     Setting+0x9F
    221          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   Pressure_Process
        32   -> __aeabi_d2iz
        32   -> __aeabi_dadd
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_i2d
        32   -> __aeabi_ui2d
        32   -> runningAverageADC
      20   ext_insert_sort
      16   ext_runningAverageADC
        16   -> ext_insert_sort
      16   init_runavr_buff
        16   -> __aeabi_memset
       4   runningAverageADC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
     146  Pressure_Process
      72  ext_insert_sort
      96  ext_runningAverageADC
       4  flagsampling
      54  init_runavr_buff
     424  runavr
      78  runningAverageADC

 
 428 bytes in section .bss
 458 bytes in section .text
 
 386 bytes of CODE memory (+ 72 bytes shared)
 428 bytes of DATA memory

Errors: none
Warnings: none
