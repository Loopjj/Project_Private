###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       09/Jan/2023  17:31:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_ioreq.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_ioreq.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\usbh_ioreq.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\usbh_ioreq.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\USB\STM32_USB_HOST_Library\Core\src\usbh_ioreq.c
      1          /** 
      2            ******************************************************************************
      3            * @file    usbh_ioreq.c 
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file handles the issuing of the USB transactions
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          /* Includes ------------------------------------------------------------------*/
     28          
     29          #include "usbh_ioreq.h"
     30          
     31          /** @addtogroup USBH_LIB
     32            * @{
     33            */
     34          
     35          /** @addtogroup USBH_LIB_CORE
     36          * @{
     37          */
     38            
     39          /** @defgroup USBH_IOREQ 
     40            * @brief This file handles the standard protocol processing (USB v2.0)
     41            * @{
     42            */
     43          
     44          
     45          /** @defgroup USBH_IOREQ_Private_Defines
     46            * @{
     47            */ 
     48          /**
     49            * @}
     50            */ 
     51           
     52          
     53          /** @defgroup USBH_IOREQ_Private_TypesDefinitions
     54            * @{
     55            */ 
     56          /**
     57            * @}
     58            */ 
     59          
     60          
     61          
     62          /** @defgroup USBH_IOREQ_Private_Macros
     63            * @{
     64            */ 
     65          /**
     66            * @}
     67            */ 
     68          
     69          
     70          /** @defgroup USBH_IOREQ_Private_Variables
     71            * @{
     72            */ 
     73          /**
     74            * @}
     75            */ 
     76          
     77          
     78          /** @defgroup USBH_IOREQ_Private_FunctionPrototypes
     79            * @{
     80            */ 
     81          static USBH_Status USBH_SubmitSetupRequest(USBH_HOST *phost,
     82                                                     uint8_t* buff, 
     83                                                     uint16_t length);
     84          
     85          /**
     86            * @}
     87            */ 
     88          
     89          
     90          /** @defgroup USBH_IOREQ_Private_Functions
     91            * @{
     92            */ 
     93          
     94          
     95          /**
     96            * @brief  USBH_CtlReq
     97            *         USBH_CtlReq sends a control request and provide the status after 
     98            *            completion of the request
     99            * @param  pdev: Selected device
    100            * @param  req: Setup Request Structure
    101            * @param  buff: data buffer address to store the response
    102            * @param  length: length of the response
    103            * @retval Status
    104            */

   \                                 In section .text, align 2, keep-with-next
    105          USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
    106                                       USBH_HOST           *phost, 
    107                                       uint8_t             *buff,
    108                                       uint16_t            length)
    109          {
   \                     USBH_CtlReq: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4611             MOV      R1,R2
   \   00000006   0x461A             MOV      R2,R3
    110            USBH_Status status;
    111            status = USBH_BUSY;
   \   00000008   0x2501             MOVS     R5,#+1
    112            
    113            switch (phost->RequestState)
   \   0000000A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD002             BEQ.N    ??USBH_CtlReq_0
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD006             BEQ.N    ??USBH_CtlReq_1
   \   00000014   0xE019             B.N      ??USBH_CtlReq_2
    114            {
    115            case CMD_SEND:
    116              /* Start a SETUP transfer */
    117              USBH_SubmitSetupRequest(phost, buff, length);
   \                     ??USBH_CtlReq_0: (+1)
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       USBH_SubmitSetupRequest
    118              phost->RequestState = CMD_WAIT;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x70E0             STRB     R0,[R4, #+3]
    119              status = USBH_BUSY;
    120              break;
   \   00000020   0xE013             B.N      ??USBH_CtlReq_2
    121              
    122            case CMD_WAIT:
    123               if (phost->Control.state == CTRL_COMPLETE ) 
   \                     ??USBH_CtlReq_1: (+1)
   \   00000022   0x7F20             LDRB     R0,[R4, #+28]
   \   00000024   0x280D             CMP      R0,#+13
   \   00000026   0xD105             BNE.N    ??USBH_CtlReq_3
    124              {
    125                /* Commands successfully sent and Response Received  */       
    126                phost->RequestState = CMD_SEND;
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x70E0             STRB     R0,[R4, #+3]
    127                phost->Control.state =CTRL_IDLE;  
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7720             STRB     R0,[R4, #+28]
    128                status = USBH_OK;      
   \   00000030   0x4605             MOV      R5,R0
   \   00000032   0xE00A             B.N      ??USBH_CtlReq_2
    129              }
    130              else if  (phost->Control.state == CTRL_ERROR)
   \                     ??USBH_CtlReq_3: (+1)
   \   00000034   0x280B             CMP      R0,#+11
   \   00000036   0xD103             BNE.N    ??USBH_CtlReq_4
    131              {
    132                /* Failure Mode */
    133                phost->RequestState = CMD_SEND;
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x70E0             STRB     R0,[R4, #+3]
    134                status = USBH_FAIL;
   \   0000003C   0x2502             MOVS     R5,#+2
   \   0000003E   0xE004             B.N      ??USBH_CtlReq_2
    135              }   
    136               else if  (phost->Control.state == CTRL_STALLED )
   \                     ??USBH_CtlReq_4: (+1)
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD102             BNE.N    ??USBH_CtlReq_2
    137              {
    138                /* Commands successfully sent and Response Received  */       
    139                phost->RequestState = CMD_SEND;
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x70E0             STRB     R0,[R4, #+3]
    140                status = USBH_NOT_SUPPORTED;
   \   00000048   0x2503             MOVS     R5,#+3
    141              }
    142              break;
    143              
    144            default:
    145              break; 
    146            }
    147            return status;
   \                     ??USBH_CtlReq_2: (+1)
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    148          }
    149          
    150          /**
    151            * @brief  USBH_CtlSendSetup
    152            *         Sends the Setup Packet to the Device
    153            * @param  pdev: Selected device
    154            * @param  buff: Buffer pointer from which the Data will be send to Device
    155            * @param  hc_num: Host channel Number
    156            * @retval Status
    157            */

   \                                 In section .text, align 2, keep-with-next
    158          USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
    159                                          uint8_t *buff, 
    160                                          uint8_t hc_num){
   \                     USBH_CtlSendSetup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    161            pdev->host.hc[hc_num].ep_is_in = 0;
   \   00000002   0xEB00 0x1342      ADD      R3,R0,R2, LSL #+5
   \   00000006   0xF203 0x34AE      ADDW     R4,R3,#+942
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x7025             STRB     R5,[R4, #+0]
    162            pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
   \   0000000E   0x2503             MOVS     R5,#+3
   \   00000010   0x71A5             STRB     R5,[R4, #+6]
    163            pdev->host.hc[hc_num].xfer_buff = buff;
   \   00000012   0xF44F 0x746E      MOV      R4,#+952
   \   00000016   0x4423             ADD      R3,R3,R4
   \   00000018   0x6019             STR      R1,[R3, #+0]
    164            pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
   \   0000001A   0x2108             MOVS     R1,#+8
   \   0000001C   0x6059             STR      R1,[R3, #+4]
    165          
    166            return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
   \   0000001E   0x4611             MOV      R1,R2
   \   00000020   0x.... 0x....      BL       HCD_SubmitRequest
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    167          }
    168          
    169          
    170          /**
    171            * @brief  USBH_CtlSendData
    172            *         Sends a data Packet to the Device
    173            * @param  pdev: Selected device
    174            * @param  buff: Buffer pointer from which the Data will be sent to Device
    175            * @param  length: Length of the data to be sent
    176            * @param  hc_num: Host channel Number
    177            * @retval Status
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          USBH_Status USBH_CtlSendData ( USB_OTG_CORE_HANDLE *pdev, 
    180                                          uint8_t *buff, 
    181                                          uint16_t length,
    182                                          uint8_t hc_num)
    183          {
   \                     USBH_CtlSendData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    184            pdev->host.hc[hc_num].ep_is_in = 0;
   \   00000002   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000006   0xF204 0x35AE      ADDW     R5,R4,#+942
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x702E             STRB     R6,[R5, #+0]
    185            pdev->host.hc[hc_num].xfer_buff = buff;
   \   0000000E   0xF44F 0x766E      MOV      R6,#+952
   \   00000012   0x4434             ADD      R4,R4,R6
   \   00000014   0x6021             STR      R1,[R4, #+0]
    186            pdev->host.hc[hc_num].xfer_len = length;
   \   00000016   0x6062             STR      R2,[R4, #+4]
    187           
    188            if ( length == 0 )
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD101             BNE.N    ??USBH_CtlSendData_0
    189            { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    190              pdev->host.hc[hc_num].toggle_out = 1;   
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7361             STRB     R1,[R4, #+13]
    191            }
    192           
    193           /* Set the Data Toggle bit as per the Flag */
    194            if ( pdev->host.hc[hc_num].toggle_out == 0)
   \                     ??USBH_CtlSendData_0: (+1)
   \   00000020   0x7B61             LDRB     R1,[R4, #+13]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD102             BNE.N    ??USBH_CtlSendData_1
    195            { /* Put the PID 0 */
    196                pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x71A9             STRB     R1,[R5, #+6]
   \   0000002A   0xE001             B.N      ??USBH_CtlSendData_2
    197            }
    198           else
    199           { /* Put the PID 1 */
    200                pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
   \                     ??USBH_CtlSendData_1: (+1)
   \   0000002C   0x2102             MOVS     R1,#+2
   \   0000002E   0x71A9             STRB     R1,[R5, #+6]
    201           }
    202          
    203            HCD_SubmitRequest (pdev , hc_num);   
   \                     ??USBH_CtlSendData_2: (+1)
   \   00000030   0x4619             MOV      R1,R3
   \   00000032   0x.... 0x....      BL       HCD_SubmitRequest
    204             
    205            return USBH_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    206          }
    207          
    208          
    209          /**
    210            * @brief  USBH_CtlReceiveData
    211            *         Receives the Device Response to the Setup Packet
    212            * @param  pdev: Selected device
    213            * @param  buff: Buffer pointer in which the response needs to be copied
    214            * @param  length: Length of the data to be received
    215            * @param  hc_num: Host channel Number
    216            * @retval Status. 
    217            */

   \                                 In section .text, align 2, keep-with-next
    218          USBH_Status USBH_CtlReceiveData(USB_OTG_CORE_HANDLE *pdev, 
    219                                          uint8_t* buff, 
    220                                          uint16_t length,
    221                                          uint8_t hc_num)
    222          {
   \                     USBH_CtlReceiveData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    223          
    224            pdev->host.hc[hc_num].ep_is_in = 1;
   \   00000002   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000006   0xF204 0x35AE      ADDW     R5,R4,#+942
   \   0000000A   0x2601             MOVS     R6,#+1
   \   0000000C   0x702E             STRB     R6,[R5, #+0]
    225            pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
   \   0000000E   0x2602             MOVS     R6,#+2
   \   00000010   0x71AE             STRB     R6,[R5, #+6]
    226            pdev->host.hc[hc_num].xfer_buff = buff;
   \   00000012   0xF44F 0x756E      MOV      R5,#+952
   \   00000016   0x442C             ADD      R4,R4,R5
   \   00000018   0x6021             STR      R1,[R4, #+0]
    227            pdev->host.hc[hc_num].xfer_len = length;  
   \   0000001A   0x6062             STR      R2,[R4, #+4]
    228          
    229            HCD_SubmitRequest (pdev , hc_num);   
   \   0000001C   0x4619             MOV      R1,R3
   \   0000001E   0x.... 0x....      BL       HCD_SubmitRequest
    230            
    231            return USBH_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    232            
    233          }
    234          
    235          
    236          /**
    237            * @brief  USBH_BulkSendData
    238            *         Sends the Bulk Packet to the device
    239            * @param  pdev: Selected device
    240            * @param  buff: Buffer pointer from which the Data will be sent to Device
    241            * @param  length: Length of the data to be sent
    242            * @param  hc_num: Host channel Number
    243            * @retval Status
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
    246                                          uint8_t *buff, 
    247                                          uint16_t length,
    248                                          uint8_t hc_num)
    249          { 
   \                     USBH_BulkSendData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    250            pdev->host.hc[hc_num].ep_is_in = 0;
   \   00000002   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000006   0xF204 0x35AE      ADDW     R5,R4,#+942
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x702E             STRB     R6,[R5, #+0]
    251            pdev->host.hc[hc_num].xfer_buff = buff;
   \   0000000E   0xF44F 0x766E      MOV      R6,#+952
   \   00000012   0x4434             ADD      R4,R4,R6
   \   00000014   0x6021             STR      R1,[R4, #+0]
    252            pdev->host.hc[hc_num].xfer_len = length;  
   \   00000016   0x6062             STR      R2,[R4, #+4]
    253          
    254           /* Set the Data Toggle bit as per the Flag */
    255            if ( pdev->host.hc[hc_num].toggle_out == 0)
   \   00000018   0x7B61             LDRB     R1,[R4, #+13]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD102             BNE.N    ??USBH_BulkSendData_0
    256            { /* Put the PID 0 */
    257                pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x71A9             STRB     R1,[R5, #+6]
   \   00000022   0xE001             B.N      ??USBH_BulkSendData_1
    258            }
    259           else
    260           { /* Put the PID 1 */
    261                pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
   \                     ??USBH_BulkSendData_0: (+1)
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x71A9             STRB     R1,[R5, #+6]
    262           }
    263          
    264            HCD_SubmitRequest (pdev , hc_num);   
   \                     ??USBH_BulkSendData_1: (+1)
   \   00000028   0x4619             MOV      R1,R3
   \   0000002A   0x.... 0x....      BL       HCD_SubmitRequest
    265            return USBH_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    266          }
    267          
    268          
    269          /**
    270            * @brief  USBH_BulkReceiveData
    271            *         Receives IN bulk packet from device
    272            * @param  pdev: Selected device
    273            * @param  buff: Buffer pointer in which the received data packet to be copied
    274            * @param  length: Length of the data to be received
    275            * @param  hc_num: Host channel Number
    276            * @retval Status. 
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
    279                                          uint8_t *buff, 
    280                                          uint16_t length,
    281                                          uint8_t hc_num)
    282          {
   \                     USBH_BulkReceiveData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    283            pdev->host.hc[hc_num].ep_is_in = 1;   
   \   00000002   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000006   0xF204 0x35AE      ADDW     R5,R4,#+942
   \   0000000A   0x2601             MOVS     R6,#+1
   \   0000000C   0x702E             STRB     R6,[R5, #+0]
    284            pdev->host.hc[hc_num].xfer_buff = buff;
   \   0000000E   0xF44F 0x766E      MOV      R6,#+952
   \   00000012   0x4434             ADD      R4,R4,R6
   \   00000014   0x6021             STR      R1,[R4, #+0]
    285            pdev->host.hc[hc_num].xfer_len = length;
   \   00000016   0x6062             STR      R2,[R4, #+4]
    286            
    287          
    288            if( pdev->host.hc[hc_num].toggle_in == 0)
   \   00000018   0x7B21             LDRB     R1,[R4, #+12]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD102             BNE.N    ??USBH_BulkReceiveData_0
    289            {
    290              pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x71A9             STRB     R1,[R5, #+6]
   \   00000022   0xE001             B.N      ??USBH_BulkReceiveData_1
    291            }
    292            else
    293            {
    294              pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
   \                     ??USBH_BulkReceiveData_0: (+1)
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x71A9             STRB     R1,[R5, #+6]
    295            }
    296          
    297            HCD_SubmitRequest (pdev , hc_num);  
   \                     ??USBH_BulkReceiveData_1: (+1)
   \   00000028   0x4619             MOV      R1,R3
   \   0000002A   0x.... 0x....      BL       HCD_SubmitRequest
    298            return USBH_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    299          }
    300          
    301          
    302          /**
    303            * @brief  USBH_InterruptReceiveData
    304            *         Receives the Device Response to the Interrupt IN token
    305            * @param  pdev: Selected device
    306            * @param  buff: Buffer pointer in which the response needs to be copied
    307            * @param  length: Length of the data to be received
    308            * @param  hc_num: Host channel Number
    309            * @retval Status. 
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          USBH_Status USBH_InterruptReceiveData( USB_OTG_CORE_HANDLE *pdev, 
    312                                          uint8_t *buff, 
    313                                          uint8_t length,
    314                                          uint8_t hc_num)
    315          {
   \                     USBH_InterruptReceiveData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4619             MOV      R1,R3
    316          
    317            pdev->host.hc[hc_num].ep_is_in = 1;  
   \   00000006   0xEB00 0x1341      ADD      R3,R0,R1, LSL #+5
   \   0000000A   0xF203 0x35AE      ADDW     R5,R3,#+942
   \   0000000E   0x2601             MOVS     R6,#+1
   \   00000010   0x702E             STRB     R6,[R5, #+0]
    318            pdev->host.hc[hc_num].xfer_buff = buff;
   \   00000012   0xF44F 0x766E      MOV      R6,#+952
   \   00000016   0x4433             ADD      R3,R3,R6
   \   00000018   0x601C             STR      R4,[R3, #+0]
    319            pdev->host.hc[hc_num].xfer_len = length;
   \   0000001A   0x605A             STR      R2,[R3, #+4]
    320            
    321          
    322            
    323            if(pdev->host.hc[hc_num].toggle_in == 0)
   \   0000001C   0x7B1A             LDRB     R2,[R3, #+12]
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD102             BNE.N    ??USBH_InterruptReceiveData_0
    324            {
    325              pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x71AA             STRB     R2,[R5, #+6]
   \   00000026   0xE001             B.N      ??USBH_InterruptReceiveData_1
    326            }
    327            else
    328            {
    329              pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
   \                     ??USBH_InterruptReceiveData_0: (+1)
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0x71AA             STRB     R2,[R5, #+6]
    330            }
    331          
    332            /* toggle DATA PID */
    333            pdev->host.hc[hc_num].toggle_in ^= 1;  
   \                     ??USBH_InterruptReceiveData_1: (+1)
   \   0000002C   0x7B1A             LDRB     R2,[R3, #+12]
   \   0000002E   0xF082 0x0201      EOR      R2,R2,#0x1
   \   00000032   0x731A             STRB     R2,[R3, #+12]
    334            
    335            HCD_SubmitRequest (pdev , hc_num);  
   \   00000034   0x.... 0x....      BL       HCD_SubmitRequest
    336            
    337            return USBH_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    338          }
    339          
    340          /**
    341            * @brief  USBH_InterruptSendData
    342            *         Sends the data on Interrupt OUT Endpoint
    343            * @param  pdev: Selected device
    344            * @param  buff: Buffer pointer from where the data needs to be copied
    345            * @param  length: Length of the data to be sent
    346            * @param  hc_num: Host channel Number
    347            * @retval Status. 
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          USBH_Status USBH_InterruptSendData( USB_OTG_CORE_HANDLE *pdev, 
    350                                          uint8_t *buff, 
    351                                          uint8_t length,
    352                                          uint8_t hc_num)
    353          {
   \                     USBH_InterruptSendData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4619             MOV      R1,R3
    354          
    355            pdev->host.hc[hc_num].ep_is_in = 0;  
   \   00000006   0xEB00 0x1341      ADD      R3,R0,R1, LSL #+5
   \   0000000A   0xF203 0x35AE      ADDW     R5,R3,#+942
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0x702E             STRB     R6,[R5, #+0]
    356            pdev->host.hc[hc_num].xfer_buff = buff;
   \   00000012   0xF44F 0x766E      MOV      R6,#+952
   \   00000016   0x4433             ADD      R3,R3,R6
   \   00000018   0x601C             STR      R4,[R3, #+0]
    357            pdev->host.hc[hc_num].xfer_len = length;
   \   0000001A   0x605A             STR      R2,[R3, #+4]
    358            
    359            if(pdev->host.hc[hc_num].toggle_in == 0)
   \   0000001C   0x7B1A             LDRB     R2,[R3, #+12]
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD102             BNE.N    ??USBH_InterruptSendData_0
    360            {
    361              pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x71AA             STRB     R2,[R5, #+6]
   \   00000026   0xE001             B.N      ??USBH_InterruptSendData_1
    362            }
    363            else
    364            {
    365              pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
   \                     ??USBH_InterruptSendData_0: (+1)
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0x71AA             STRB     R2,[R5, #+6]
    366            }
    367          
    368            pdev->host.hc[hc_num].toggle_in ^= 1;  
   \                     ??USBH_InterruptSendData_1: (+1)
   \   0000002C   0x7B1A             LDRB     R2,[R3, #+12]
   \   0000002E   0xF082 0x0201      EOR      R2,R2,#0x1
   \   00000032   0x731A             STRB     R2,[R3, #+12]
    369            
    370            HCD_SubmitRequest (pdev , hc_num);  
   \   00000034   0x.... 0x....      BL       HCD_SubmitRequest
    371            
    372            return USBH_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    373          }
    374          
    375          
    376          /**
    377            * @brief  USBH_SubmitSetupRequest
    378            *         Start a setup transfer by changing the state-machine and 
    379            *         initializing  the required variables needed for the Control Transfer
    380            * @param  pdev: Selected device
    381            * @param  setup: Setup Request Structure
    382            * @param  buff: Buffer used for setup request
    383            * @param  length: Length of the data
    384            * @retval Status. 
    385          */

   \                                 In section .text, align 2, keep-with-next
    386          static USBH_Status USBH_SubmitSetupRequest(USBH_HOST *phost,
    387                                                     uint8_t* buff, 
    388                                                     uint16_t length)
    389          {
    390            
    391            /* Save Global State */
    392            phost->gStateBkp =   phost->gState; 
   \                     USBH_SubmitSetupRequest: (+1)
   \   00000000   0x7803             LDRB     R3,[R0, #+0]
   \   00000002   0x7043             STRB     R3,[R0, #+1]
    393            
    394            /* Prepare the Transactions */
    395            phost->gState = HOST_CTRL_XFER;
   \   00000004   0x2307             MOVS     R3,#+7
   \   00000006   0x7003             STRB     R3,[R0, #+0]
    396            phost->Control.buff = buff; 
   \   00000008   0x6081             STR      R1,[R0, #+8]
    397            phost->Control.length = length;
   \   0000000A   0x8182             STRH     R2,[R0, #+12]
    398            phost->Control.state = CTRL_SETUP;  
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7701             STRB     R1,[R0, #+28]
    399          
    400            return USBH_OK;  
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    401          }
    402          
    403          
    404          /**
    405            * @brief  USBH_IsocReceiveData
    406            *         Receives the Device Response to the Isochronous IN token
    407            * @param  pdev: Selected device
    408            * @param  buff: Buffer pointer in which the response needs to be copied
    409            * @param  length: Length of the data to be received
    410            * @param  hc_num: Host channel Number
    411            * @retval Status. 
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          USBH_Status USBH_IsocReceiveData( USB_OTG_CORE_HANDLE *pdev, 
    414                                          uint8_t *buff, 
    415                                          uint32_t length,
    416                                          uint8_t hc_num)
    417          {    
   \                     USBH_IsocReceiveData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    418            
    419            pdev->host.hc[hc_num].ep_is_in = 1;  
   \   00000002   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000006   0xF204 0x35AE      ADDW     R5,R4,#+942
   \   0000000A   0x2601             MOVS     R6,#+1
   \   0000000C   0x702E             STRB     R6,[R5, #+0]
    420            pdev->host.hc[hc_num].xfer_buff = buff;
   \   0000000E   0xF44F 0x766E      MOV      R6,#+952
   \   00000012   0x4434             ADD      R4,R4,R6
   \   00000014   0x6021             STR      R1,[R4, #+0]
    421            pdev->host.hc[hc_num].xfer_len = length;
   \   00000016   0x6062             STR      R2,[R4, #+4]
    422            pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x71A9             STRB     R1,[R5, #+6]
    423            
    424          
    425            HCD_SubmitRequest (pdev , hc_num);  
   \   0000001C   0x4619             MOV      R1,R3
   \   0000001E   0x.... 0x....      BL       HCD_SubmitRequest
    426            
    427            return USBH_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    428          }
    429          
    430          /**
    431            * @brief  USBH_IsocSendData
    432            *         Sends the data on Isochronous OUT Endpoint
    433            * @param  pdev: Selected device
    434            * @param  buff: Buffer pointer from where the data needs to be copied
    435            * @param  length: Length of the data to be sent
    436            * @param  hc_num: Host channel Number
    437            * @retval Status. 
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          USBH_Status USBH_IsocSendData( USB_OTG_CORE_HANDLE *pdev, 
    440                                          uint8_t *buff, 
    441                                          uint32_t length,
    442                                          uint8_t hc_num)
    443          {
   \                     USBH_IsocSendData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    444            
    445            pdev->host.hc[hc_num].ep_is_in = 0;  
   \   00000002   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000006   0xF204 0x35AE      ADDW     R5,R4,#+942
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x702E             STRB     R6,[R5, #+0]
    446            pdev->host.hc[hc_num].xfer_buff = buff;
   \   0000000E   0xF44F 0x766E      MOV      R6,#+952
   \   00000012   0x4434             ADD      R4,R4,R6
   \   00000014   0x6021             STR      R1,[R4, #+0]
    447            pdev->host.hc[hc_num].xfer_len = length;
   \   00000016   0x6062             STR      R2,[R4, #+4]
    448            pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x71A9             STRB     R1,[R5, #+6]
    449            
    450            HCD_SubmitRequest (pdev , hc_num);  
   \   0000001C   0x4619             MOV      R1,R3
   \   0000001E   0x.... 0x....      BL       HCD_SubmitRequest
    451            
    452            return USBH_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    453          }
    454          
    455          /**
    456          * @}
    457          */ 
    458          
    459          /**
    460          * @}
    461          */ 
    462          
    463          /**
    464          * @}
    465          */
    466          
    467          /**
    468          * @}
    469          */ 
    470          
    471          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    472          
    473          
    474          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USBH_BulkReceiveData
        16   -> HCD_SubmitRequest
      16   USBH_BulkSendData
        16   -> HCD_SubmitRequest
      16   USBH_CtlReceiveData
        16   -> HCD_SubmitRequest
      16   USBH_CtlReq
        16   -> USBH_SubmitSetupRequest
      16   USBH_CtlSendData
        16   -> HCD_SubmitRequest
      16   USBH_CtlSendSetup
        16   -> HCD_SubmitRequest
      16   USBH_InterruptReceiveData
        16   -> HCD_SubmitRequest
      16   USBH_InterruptSendData
        16   -> HCD_SubmitRequest
      16   USBH_IsocReceiveData
        16   -> HCD_SubmitRequest
      16   USBH_IsocSendData
        16   -> HCD_SubmitRequest
       0   USBH_SubmitSetupRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      50  USBH_BulkReceiveData
      50  USBH_BulkSendData
      38  USBH_CtlReceiveData
      78  USBH_CtlReq
      58  USBH_CtlSendData
      40  USBH_CtlSendSetup
      60  USBH_InterruptReceiveData
      60  USBH_InterruptSendData
      38  USBH_IsocReceiveData
      38  USBH_IsocSendData
      20  USBH_SubmitSetupRequest

 
 530 bytes in section .text
 
 530 bytes of CODE memory

Errors: none
Warnings: none
