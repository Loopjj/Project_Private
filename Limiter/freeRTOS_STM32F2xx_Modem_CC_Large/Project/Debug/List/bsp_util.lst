###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\bsp_util.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\bsp_util.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\bsp_util.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\bsp_util.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\bsp\bsp_util.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2014 Loop *************************************
      3          *
      4          * File Name          : bsp_util.c
      5          *
      6          * Author             : Digital Development Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 09/25/2014
     11          *
     12          * Description        : SCR board configuration 
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          #define BUTIL_GLOBALS
     18          #include "includes.h"

   \                                 In section .bss, align 4
   \   __absolute INT32U volatile systick_uptime_millis
   \                     systick_uptime_millis:
   \   00000000                      DS8 4
     19          
     20          

   \                                 In section .text, align 2, keep-with-next
     21          void BSRAMSemaphore_Init(void)
     22          {
   \                     BSRAMSemaphore_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     23          	BSP_BKSramSem = xSemaphoreCreateMutex();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable32_4
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       xQueueCreateMutex
   \   0000000C   0x6020             STR      R0,[R4, #+0]
     24          	BSP_BKRtcSem  = xSemaphoreCreateMutex();
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable32_5
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       xQueueCreateMutex
   \   00000018   0x6028             STR      R0,[R5, #+0]
     25          	vSemaphoreCreateBinary(BSP_BKSramSem);
   \   0000001A   0x2203             MOVS     R2,#+3
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       xQueueGenericCreate
   \   00000024   0x6020             STR      R0,[R4, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD004             BEQ.N    ??BSRAMSemaphore_Init_0
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x461A             MOV      R2,R3
   \   0000002E   0x4611             MOV      R1,R2
   \   00000030   0x.... 0x....      BL       xQueueGenericSend
     26          	vSemaphoreCreateBinary(BSP_BKRtcSem );
   \                     ??BSRAMSemaphore_Init_0: (+1)
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x.... 0x....      BL       xQueueGenericCreate
   \   0000003E   0x6028             STR      R0,[R5, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD007             BEQ.N    ??BSRAMSemaphore_Init_1
   \   00000044   0x2300             MOVS     R3,#+0
   \   00000046   0x461A             MOV      R2,R3
   \   00000048   0x4611             MOV      R1,R2
   \   0000004A   0xB001             ADD      SP,SP,#+4
   \   0000004C   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000050   0x.... 0x....      B.W      xQueueGenericSend
     27          }
   \                     ??BSRAMSemaphore_Init_1: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     28          
     29          /** 
     30          * Returns the system uptime, in milliseconds. 
     31          */ 

   \                                 In section .text, align 2, keep-with-next
     32          INT32U systick_uptime(void) { 
     33            return systick_uptime_millis; 
   \                     systick_uptime: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
     34          } 
     35          
     36          

   \                                 In section .text, align 2, keep-with-next
     37          INT8U write_to_backup_sram( INT8U *data, INT16U size, INT16U offset )
     38          {
   \                     write_to_backup_sram: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
     39          	const INT16U backup_size = 0x1000;
     40          	INT8U* base_addr = (INT8U *) BKPSRAM_BASE;
     41          	INT16U i;
     42          
     43          	if(BSP_BKSramSem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable32_4
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??write_to_backup_sram_0
     44          	{
     45          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`write_to_backup_sram::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
     46          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
     47          	}
     48          	if(xSemaphoreTake(BSP_BKSramSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??write_to_backup_sram_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD131             BNE.N    ??write_to_backup_sram_1
     49          	{
     50          
     51          		if( size + offset >= backup_size ) 
   \   00000030   0x19B8             ADDS     R0,R7,R6
   \   00000032   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000036   0xDB07             BLT.N    ??write_to_backup_sram_2
     52          		{
     53          			/* ERROR : the last byte is outside the backup SRAM region */
     54          			xSemaphoreGive(BSP_BKSramSem);
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x461A             MOV      R2,R3
   \   0000003C   0x4611             MOV      R1,R2
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x.... 0x....      BL       xQueueGenericSend
     55          			return FALSE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}
     56          		}
     57          		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
   \                     ??write_to_backup_sram_2: (+1)
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF44F 0x2080      MOV      R0,#+262144
   \   0000004E   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     58          			/* disable backup domain write protection */
     59          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);   // set RCC->APB1ENR.pwren
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0xF04F 0x5080      MOV      R0,#+268435456
   \   00000058   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     60          		PWR_BackupAccessCmd(ENABLE);                          // set PWR->CR.dbp = 1;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       PWR_BackupAccessCmd
     61          		/** enable the backup regulator (used to maintain the backup SRAM content in
     62          		* standby and Vbat modes).  NOTE : this bit is not reset when the device
     63          		* wakes up from standby, system reset or power reset. You can check that
     64          		* the backup regulator is ready on PWR->CSR.brr, see rm p144 */
     65          		PWR_BackupRegulatorCmd(ENABLE);     // set PWR->CSR.bre = 1;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       PWR_BackupRegulatorCmd
     66          		for( i = 0; i < size; i++ )
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE006             B.N      ??write_to_backup_sram_3
     67          		{
     68          			*(base_addr + offset + i) = *(data + i);
   \                     ??write_to_backup_sram_4: (+1)
   \   0000006C   0x5C21             LDRB     R1,[R4, R0]
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable32_7  ;; 0x40024000
   \   00000072   0x443A             ADD      R2,R2,R7
   \   00000074   0x5411             STRB     R1,[R2, R0]
     69          		}
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0xB280             UXTH     R0,R0
   \                     ??write_to_backup_sram_3: (+1)
   \   0000007A   0x42B0             CMP      R0,R6
   \   0000007C   0xDBF6             BLT.N    ??write_to_backup_sram_4
     70          		PWR_BackupAccessCmd(DISABLE);                     // reset PWR->CR.dbp = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      BL       PWR_BackupAccessCmd
     71          		xSemaphoreGive(BSP_BKSramSem);
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x461A             MOV      R2,R3
   \   00000088   0x4611             MOV      R1,R2
   \   0000008A   0x6828             LDR      R0,[R5, #+0]
   \   0000008C   0x.... 0x....      BL       xQueueGenericSend
     72          		return TRUE;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}
     73          	
     74          	}
     75          	return FALSE;
   \                     ??write_to_backup_sram_1: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     76          }
     77          

   \                                 In section .text, align 2, keep-with-next
     78          INT8U read_from_backup_sram( INT8U *data, INT16U size, INT16U offset )
     79          {
   \                     read_from_backup_sram: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
     80          	const INT16U backup_size = 0x1000;
     81          	INT8U* base_addr = (INT8U *) BKPSRAM_BASE;
     82          	INT16U i;
     83          
     84          	if(BSP_BKSramSem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable32_4
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??read_from_backup_sram_0
     85          	{
     86          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`read_from_backup_sram::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
     87          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
     88          	}
     89          	if(xSemaphoreTake(BSP_BKSramSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??read_from_backup_sram_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD123             BNE.N    ??read_from_backup_sram_1
     90          	{
     91          		if( size + offset >= backup_size ) 
   \   00000030   0x19B8             ADDS     R0,R7,R6
   \   00000032   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000036   0xDB07             BLT.N    ??read_from_backup_sram_2
     92          		{
     93          			/* ERROR : the last byte is outside the backup SRAM region */
     94          			xSemaphoreGive(BSP_BKSramSem);
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x461A             MOV      R2,R3
   \   0000003C   0x4611             MOV      R1,R2
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x.... 0x....      BL       xQueueGenericSend
     95          			return FALSE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}
     96          		}
     97          		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
   \                     ??read_from_backup_sram_2: (+1)
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF44F 0x2080      MOV      R0,#+262144
   \   0000004E   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     98          		for( i = 0; i < size; i++ )
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE006             B.N      ??read_from_backup_sram_3
     99          		{
    100          			*(data + i) = *(base_addr + offset + i);
   \                     ??read_from_backup_sram_4: (+1)
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable32_7  ;; 0x40024000
   \   0000005A   0x4439             ADD      R1,R1,R7
   \   0000005C   0x5C09             LDRB     R1,[R1, R0]
   \   0000005E   0x5421             STRB     R1,[R4, R0]
    101          		}
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0xB280             UXTH     R0,R0
   \                     ??read_from_backup_sram_3: (+1)
   \   00000064   0x42B0             CMP      R0,R6
   \   00000066   0xDBF6             BLT.N    ??read_from_backup_sram_4
    102          		xSemaphoreGive(BSP_BKSramSem);
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x461A             MOV      R2,R3
   \   0000006C   0x4611             MOV      R1,R2
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0x.... 0x....      BL       xQueueGenericSend
    103          		return TRUE;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}
    104          	}
    105          	return FALSE;
   \                     ??read_from_backup_sram_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    106          }
    107          

   \                                 In section .text, align 2, keep-with-next
    108          INT8U write_to_backup_rtc( INT32U *data, INT16U size, INT16U offset ) 
    109          {
   \                     write_to_backup_rtc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4617             MOV      R7,R2
    110          	const INT16U backup_size = 80;
    111          	volatile INT32U* base_addr = &(RTC->BKP0R);
    112          	INT16U i;
    113          
    114          	if(BSP_BKRtcSem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable32_5
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??write_to_backup_rtc_0
    115          	{
    116          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`write_to_backup_rtc::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
    117          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    118          	}
    119          	if(xSemaphoreTake(BSP_BKRtcSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??write_to_backup_rtc_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD13B             BNE.N    ??write_to_backup_rtc_1
    120          	{
    121          
    122          		if( size + offset >= backup_size ) {
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x1839             ADDS     R1,R7,R0
   \   00000034   0x2950             CMP      R1,#+80
   \   00000036   0xDA0D             BGE.N    ??write_to_backup_rtc_2
    123          			/* ERROR : the last byte is outside the backup SRAM region */
    124          			xSemaphoreGive(BSP_BKRtcSem);
    125          			return FALSE;
    126          		} 
    127          		else if( offset % 4 || size % 4 )
   \   00000038   0x1079             ASRS     R1,R7,#+1
   \   0000003A   0xEB07 0x7191      ADD      R1,R7,R1, LSR #+30
   \   0000003E   0x1089             ASRS     R1,R1,#+2
   \   00000040   0xEBB7 0x0181      SUBS     R1,R7,R1, LSL #+2
   \   00000044   0xD106             BNE.N    ??write_to_backup_rtc_2
   \   00000046   0x1041             ASRS     R1,R0,#+1
   \   00000048   0xEB00 0x7191      ADD      R1,R0,R1, LSR #+30
   \   0000004C   0x1089             ASRS     R1,R1,#+2
   \   0000004E   0xEBB0 0x0081      SUBS     R0,R0,R1, LSL #+2
   \   00000052   0xD007             BEQ.N    ??write_to_backup_rtc_3
    128          		{
    129          			/* ERROR: data start or num bytes are not word aligned */
    130          			xSemaphoreGive(BSP_BKRtcSem);
   \                     ??write_to_backup_rtc_2: (+1)
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x461A             MOV      R2,R3
   \   00000058   0x4611             MOV      R1,R2
   \   0000005A   0x6830             LDR      R0,[R6, #+0]
   \   0000005C   0x.... 0x....      BL       xQueueGenericSend
    131          			return FALSE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
    132          		} 
    133          		else 
    134          		{
    135          			size >>= 2;      /* divide by 4 because writing words */
    136          		}
    137          		/* disable backup domain write protection */
    138          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);   // set RCC->APB1ENR.pwren
   \                     ??write_to_backup_rtc_3: (+1)
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0xF04F 0x5080      MOV      R0,#+268435456
   \   0000006A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    139          		PWR_BackupAccessCmd(ENABLE);                          // set PWR->CR.dbp = 1;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      BL       PWR_BackupAccessCmd
    140          		for( i = 0; i < size; i++ ) 
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE009             B.N      ??write_to_backup_rtc_4
    141          		{
    142          			*(base_addr + offset + i) = *(data + i);
   \                     ??write_to_backup_rtc_5: (+1)
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable32_8  ;; 0x40002850
   \   0000007C   0xEB01 0x0187      ADD      R1,R1,R7, LSL #+2
   \   00000080   0xF854 0x2020      LDR      R2,[R4, R0, LSL #+2]
   \   00000084   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    143          		}
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0xB280             UXTH     R0,R0
   \                     ??write_to_backup_rtc_4: (+1)
   \   0000008C   0xEBB0 0x0F95      CMP      R0,R5, LSR #+2
   \   00000090   0xDBF2             BLT.N    ??write_to_backup_rtc_5
    144          		PWR_BackupAccessCmd(DISABLE);                     // reset PWR->CR.dbp = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      BL       PWR_BackupAccessCmd
    145          		// consider also disabling the power peripherial?
    146          		xSemaphoreGive(BSP_BKRtcSem);
   \   00000098   0x2300             MOVS     R3,#+0
   \   0000009A   0x461A             MOV      R2,R3
   \   0000009C   0x4611             MOV      R1,R2
   \   0000009E   0x6830             LDR      R0,[R6, #+0]
   \   000000A0   0x.... 0x....      BL       xQueueGenericSend
    147          		return TRUE;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}
    148          	}
    149          	return FALSE;
   \                     ??write_to_backup_rtc_1: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    150          }
    151          

   \                                 In section .text, align 2, keep-with-next
    152          INT8U read_from_backup_rtc( INT32U *data, INT16U size, INT16U offset )
    153          {
   \                     read_from_backup_rtc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4617             MOV      R7,R2
    154          	const uint16_t backup_size = 80;
    155          	volatile INT32U* base_addr = &(RTC->BKP0R);
    156          	INT16U i;
    157          
    158          	if(BSP_BKRtcSem == NULL)
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable32_5
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??read_from_backup_rtc_0
    159          	{
    160          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`read_from_backup_rtc::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       printk
    161          		return ERROR;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    162          	}
    163          	if(xSemaphoreTake(BSP_BKRtcSem, ( portTickType ) 0 )  == pdTRUE)
   \                     ??read_from_backup_rtc_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x461A             MOV      R2,R3
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD130             BNE.N    ??read_from_backup_rtc_1
    164          	{
    165          
    166          		if( size + offset >= backup_size )
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x1839             ADDS     R1,R7,R0
   \   00000034   0x2950             CMP      R1,#+80
   \   00000036   0xDA0D             BGE.N    ??read_from_backup_rtc_2
    167          		{
    168          			/* ERROR : the last byte is outside the backup SRAM region */
    169          			xSemaphoreGive(BSP_BKRtcSem);
    170          			return FALSE;
    171          		} 
    172          		else if( offset % 4 || size % 4 )
   \   00000038   0x1079             ASRS     R1,R7,#+1
   \   0000003A   0xEB07 0x7191      ADD      R1,R7,R1, LSR #+30
   \   0000003E   0x1089             ASRS     R1,R1,#+2
   \   00000040   0xEBB7 0x0181      SUBS     R1,R7,R1, LSL #+2
   \   00000044   0xD106             BNE.N    ??read_from_backup_rtc_2
   \   00000046   0x1041             ASRS     R1,R0,#+1
   \   00000048   0xEB00 0x7191      ADD      R1,R0,R1, LSR #+30
   \   0000004C   0x1089             ASRS     R1,R1,#+2
   \   0000004E   0xEBB0 0x0081      SUBS     R0,R0,R1, LSL #+2
   \   00000052   0xD007             BEQ.N    ??read_from_backup_rtc_3
    173          		{
    174          			/* ERROR: data start or num bytes are not word aligned */
    175          			xSemaphoreGive(BSP_BKRtcSem);
   \                     ??read_from_backup_rtc_2: (+1)
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x461A             MOV      R2,R3
   \   00000058   0x4611             MOV      R1,R2
   \   0000005A   0x6830             LDR      R0,[R6, #+0]
   \   0000005C   0x.... 0x....      BL       xQueueGenericSend
    176          			return FALSE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
    177          		} 
    178          		else 
    179          		{
    180          			size >>= 2;      /* divide by 4 because writing words */
    181          		}
    182          		/* read should be 32 bit aligned */
    183          		for( i = 0; i < size; i++ ) {
   \                     ??read_from_backup_rtc_3: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE009             B.N      ??read_from_backup_rtc_4
    184          			*(data + i) = *(base_addr + offset + i);
   \                     ??read_from_backup_rtc_5: (+1)
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable32_8  ;; 0x40002850
   \   0000006C   0xEB01 0x0187      ADD      R1,R1,R7, LSL #+2
   \   00000070   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000074   0xF844 0x1020      STR      R1,[R4, R0, LSL #+2]
    185          		}
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0xB280             UXTH     R0,R0
   \                     ??read_from_backup_rtc_4: (+1)
   \   0000007C   0xEBB0 0x0F95      CMP      R0,R5, LSR #+2
   \   00000080   0xDBF2             BLT.N    ??read_from_backup_rtc_5
    186          		xSemaphoreGive(BSP_BKRtcSem);
   \   00000082   0x2300             MOVS     R3,#+0
   \   00000084   0x461A             MOV      R2,R3
   \   00000086   0x4611             MOV      R1,R2
   \   00000088   0x6830             LDR      R0,[R6, #+0]
   \   0000008A   0x.... 0x....      BL       xQueueGenericSend
    187          		return TRUE;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}
    188          	}
    189          	return FALSE;
   \                     ??read_from_backup_rtc_1: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    190          }
    191          
    192          /**
    193            * @brief  Display the current time on the Hyperterminal.
    194            * @param  None
    195            * @retval None
    196            */

   \                                 In section .text, align 2, keep-with-next
    197          void RTC_TimeShow(void)
    198          {
   \                     RTC_TimeShow: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    199          	RTC_TimeTypeDef RTC_TimeStructure;
    200          	/* Get the current Time */
    201          	RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
   \   00000002   0x4669             MOV      R1,SP
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       RTC_GetTime
    202          	if(RTC_TimeStructure.RTC_Hours > 24) RTC_TimeStructure.RTC_Hours -= 24;
   \   0000000A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000E   0x2819             CMP      R0,#+25
   \   00000010   0xDB02             BLT.N    ??RTC_TimeShow_0
   \   00000012   0x3818             SUBS     R0,R0,#+24
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    203          	printk(" :  %0.2d:%0.2d:%0.2d \n\r", RTC_TimeStructure.RTC_Hours, RTC_TimeStructure.RTC_Minutes, RTC_TimeStructure.RTC_Seconds);
   \                     ??RTC_TimeShow_0: (+1)
   \   00000018   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   0000001C   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000020   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000024   0x.... 0x....      ADR.W    R0,?_1
   \   00000028   0x.... 0x....      BL       printk
    204          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
    205          
    206          /**
    207            * @brief  Display the current time on the Hyperterminal.
    208            * @param  None
    209            * @retval None
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          void RTC_AlarmShow(void)
    212          {
   \                     RTC_AlarmShow: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    213          	RTC_AlarmTypeDef  RTC_AlarmStructure;
    214          	/* Get the current Alarm */
    215          	RTC_GetAlarm(RTC_Format_BIN, RTC_Alarm_A, &RTC_AlarmStructure);
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0xF44F 0x7180      MOV      R1,#+256
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       RTC_GetAlarm
    216          	printk("\n\r  The current alarm is :  %0.2d:%0.2d:%0.2d \n\r", RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours, RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes, RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds);
   \   00000010   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   00000014   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000018   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000001C   0x.... 0x....      ADR.W    R0,?_2
   \   00000020   0x.... 0x....      BL       printk
    217          }
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
    218          void RTC_DateShow(void)
    219          {
   \                     RTC_DateShow: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    220          	RTC_DateTypeDef RTC_DateStructure;
    221          	/* Get the current Date */
    222          	RTC_GetDate(RTC_Format_BIN, &RTC_DateStructure);
   \   00000002   0x4669             MOV      R1,SP
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       RTC_GetDate
    223          	printk("\n\r  The current date:  %0.2d-%0.2d-%0.2d", RTC_DateStructure.RTC_Year, RTC_DateStructure.RTC_Month, RTC_DateStructure.RTC_Date);
   \   0000000A   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   0000000E   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000012   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000016   0x.... 0x....      ADR.W    R0,?_3
   \   0000001A   0x.... 0x....      BL       printk
    224          
    225          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    226          
    227          /**
    228            * @brief  Returns the time entered by user, using Hyperterminal.
    229            * @param  None
    230            * @retval None
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          void RTC_TimeSet(INT8U hours, INT8U Min, INT8U sec)
    233          {
   \                     RTC_TimeSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4614             MOV      R4,R2
    234          	RTC_TimeTypeDef RTC_TimeStructure;
    235          
    236          	printk("\n\r==============Time Settings=====================================\n\r");
   \   0000000A   0x.... 0x....      ADR.W    R0,?_4
   \   0000000E   0x.... 0x....      BL       printk
    237          	if( hours > 12)
   \   00000012   0x2E0D             CMP      R6,#+13
   \   00000014   0xDB03             BLT.N    ??RTC_TimeSet_0
    238          		RTC_TimeStructure.RTC_H12     = RTC_H12_PM;//RTC_H12_PM
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000001C   0xE002             B.N      ??RTC_TimeSet_1
    239          	else
    240          		RTC_TimeStructure.RTC_H12     = RTC_H12_AM;//RTC_H12_PM
   \                     ??RTC_TimeSet_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF88D 0x0003      STRB     R0,[SP, #+3]
    241          
    242              RTC_TimeStructure.RTC_Hours = (uint8_t)(hours);
   \                     ??RTC_TimeSet_1: (+1)
   \   00000024   0xF88D 0x6000      STRB     R6,[SP, #+0]
    243          
    244              RTC_TimeStructure.RTC_Minutes = (uint8_t)Min;
   \   00000028   0xF88D 0x5001      STRB     R5,[SP, #+1]
    245            
    246              RTC_TimeStructure.RTC_Seconds = (uint8_t)sec;
   \   0000002C   0xF88D 0x4002      STRB     R4,[SP, #+2]
    247          
    248          	/* Configure the RTC time register */
    249          	if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      BL       RTC_SetTime
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD104             BNE.N    ??RTC_TimeSet_2
    250          	{
    251          		printk("\n\r>> !! RTC Set Time failed. !! <<\n\r");
   \   0000003C   0x.... 0x....      ADR.W    R0,?_5
   \   00000040   0x.... 0x....      BL       printk
   \   00000044   0xBD73             POP      {R0,R1,R4-R6,PC}
    252          	} 
    253          	else
    254          	{
    255          		/* Indicator for the RTC configuration */
    256          		RTC_TimeShow();
   \                     ??RTC_TimeSet_2: (+1)
   \   00000046   0x.... 0x....      BL       RTC_TimeShow
    257          		RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
   \   0000004A   0xF243 0x21F2      MOVW     R1,#+13042
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      BL       RTC_WriteBackupRegister
    258          	}
    259          }
   \   00000054   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    260          void RTC_TimeRegulate(struct tm *tm_ptr)
    261          {
   \                     RTC_TimeRegulate: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    262          	INT8U ret=0;
    263          	RTC_TimeTypeDef RTC_TimeStructure;
    264          	RTC_DateTypeDef RTC_DateStructure;
    265          
    266          	//printk("\n\r==============Time Settings=====================================\n\r");
    267          	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;//RTC_H12_PM
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0007      STRB     R0,[SP, #+7]
    268          
    269              RTC_TimeStructure.RTC_Hours = (uint8_t)(tm_ptr->tm_hour);
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    270          
    271              RTC_TimeStructure.RTC_Minutes = (uint8_t)tm_ptr->tm_min;
   \   00000010   0x6860             LDR      R0,[R4, #+4]
   \   00000012   0xF88D 0x0005      STRB     R0,[SP, #+5]
    272            
    273              RTC_TimeStructure.RTC_Seconds = (uint8_t)tm_ptr->tm_sec;
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0xF88D 0x0006      STRB     R0,[SP, #+6]
    274          
    275          	/* Configure the RTC time register */
    276          	if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
   \   0000001C   0xA901             ADD      R1,SP,#+4
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       RTC_SetTime
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD104             BNE.N    ??RTC_TimeRegulate_0
    277          	{
    278          		printk("\n\r>> !! RTC Set Time failed. !! <<\n\r");
   \   00000028   0x.... 0x....      ADR.W    R0,?_5
   \   0000002C   0x.... 0x....      BL       printk
   \   00000030   0xE004             B.N      ??RTC_TimeRegulate_1
    279          	} 
    280          	else
    281          	{
    282          		/* Indicator for the RTC configuration */
    283          		RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
   \                     ??RTC_TimeRegulate_0: (+1)
   \   00000032   0xF243 0x21F2      MOVW     R1,#+13042
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      BL       RTC_WriteBackupRegister
    284          	}
    285          	tm_ptr->tm_wday = 0;
   \                     ??RTC_TimeRegulate_1: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x61A0             STR      R0,[R4, #+24]
    286          	RTC_DateStructure.RTC_WeekDay = (uint8_t) tm_ptr->tm_wday;
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
    287          
    288          	RTC_DateStructure.RTC_Month   = (uint8_t) tm_ptr->tm_mon;
   \   00000044   0x6920             LDR      R0,[R4, #+16]
   \   00000046   0xF88D 0x0001      STRB     R0,[SP, #+1]
    289          
    290          	RTC_DateStructure.RTC_Date    = (uint8_t) tm_ptr->tm_mday;
   \   0000004A   0x68E0             LDR      R0,[R4, #+12]
   \   0000004C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    291          
    292          	RTC_DateStructure.RTC_Year    = (uint8_t) tm_ptr->tm_year;// - 1900;
   \   00000050   0x6960             LDR      R0,[R4, #+20]
   \   00000052   0xF88D 0x0003      STRB     R0,[SP, #+3]
    293          
    294          	ret =RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure);
    295          	//if( RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure) == ERROR)
    296          	if(ret == ERROR)
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       RTC_SetDate
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD104             BNE.N    ??RTC_TimeRegulate_2
    297          	{
    298          		printk("\n>> !! RTC Set Date failed. !! <<\n");
   \   00000062   0x.... 0x....      ADR.W    R0,?_6
   \   00000066   0x.... 0x....      BL       printk
   \   0000006A   0xBD13             POP      {R0,R1,R4,PC}
    299          	}
    300          	else
    301          	{
    302          		//printk("\n>> !! RTC Set Date success. !! <<\n");
    303          		//RTC_DateShow();
    304          		//RTC_TimeShow();
    305          		RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
   \                     ??RTC_TimeRegulate_2: (+1)
   \   0000006C   0xF243 0x21F2      MOVW     R1,#+13042
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      BL       RTC_WriteBackupRegister
    306          	}
    307          }
   \   00000076   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    308          

   \                                 In section .bss, align 4
    309          	RTC_DateTypeDef RTC_DateStructure;
   \                     RTC_DateStructure:
   \   00000000                      DS8 4
    310          	RTC_TimeTypeDef RTC_TimeStructure;
   \                     RTC_TimeStructure:
   \   00000004                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    311          void GetRTCTime(struct tm *tm_ptr)
    312          {
   \                     GetRTCTime: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
    313          
    314          
    315          	RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable32_9
   \   0000000A   0x1D29             ADDS     R1,R5,#+4
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       RTC_GetTime
    316          	RTC_GetDate(RTC_Format_BIN, &RTC_DateStructure);
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       RTC_GetDate
    317          
    318          	tm_ptr->tm_year = RTC_DateStructure.RTC_Year;// + 1900   ;
   \   0000001A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000001C   0x6160             STR      R0,[R4, #+20]
    319          	tm_ptr->tm_mon  = RTC_DateStructure.RTC_Month  ;
   \   0000001E   0x7868             LDRB     R0,[R5, #+1]
   \   00000020   0x6120             STR      R0,[R4, #+16]
    320          	tm_ptr->tm_mday = RTC_DateStructure.RTC_Date   ;
   \   00000022   0x78A8             LDRB     R0,[R5, #+2]
   \   00000024   0x60E0             STR      R0,[R4, #+12]
    321          	tm_ptr->tm_hour = RTC_TimeStructure.RTC_Hours  ;
   \   00000026   0x7928             LDRB     R0,[R5, #+4]
   \   00000028   0x60A0             STR      R0,[R4, #+8]
    322          	tm_ptr->tm_min  = RTC_TimeStructure.RTC_Minutes;
   \   0000002A   0x7968             LDRB     R0,[R5, #+5]
   \   0000002C   0x6060             STR      R0,[R4, #+4]
    323          	tm_ptr->tm_sec  = RTC_TimeStructure.RTC_Seconds;
   \   0000002E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000030   0x6020             STR      R0,[R4, #+0]
    324            
    325            RTC_Time.tm_sec  = tm_ptr->tm_sec;
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable32_10
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    326            RTC_Time.tm_min  = tm_ptr->tm_min;
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x7048             STRB     R0,[R1, #+1]
    327            RTC_Time.tm_hour = tm_ptr->tm_hour;
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x7088             STRB     R0,[R1, #+2]
    328            RTC_Time.tm_mday = tm_ptr->tm_mday;
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0x70C8             STRB     R0,[R1, #+3]
    329            RTC_Time.tm_mon  = tm_ptr->tm_mon;
   \   00000044   0x6920             LDR      R0,[R4, #+16]
   \   00000046   0x7108             STRB     R0,[R1, #+4]
    330            RTC_Time.tm_year = tm_ptr->tm_year;
   \   00000048   0x6960             LDR      R0,[R4, #+20]
   \   0000004A   0x7148             STRB     R0,[R1, #+5]
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x2208             MOVS     R2,#+8
   \   00000050   0x.... 0x....      BL       __aeabi_memcpy
    331            RTC_LVal    = mktime_conv(RTC_Time);  
   \   00000054   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000058   0x.... 0x....      BL       mktime_conv
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable32_11
   \   00000060   0x6008             STR      R0,[R1, #+0]
    332          }
   \   00000062   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    333          void MakeTimePtr(struct tm *tm_ptr,INT32U year, INT8U mon, INT8U mday, INT8U hours, INT8U mins, INT8U sec, INT8U wday)
    334          {
    335          	tm_ptr->tm_year = year ;
   \                     MakeTimePtr: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
    336          	tm_ptr->tm_mon  = mon  ;
   \   00000002   0x6102             STR      R2,[R0, #+16]
    337          	tm_ptr->tm_mday = mday ;
   \   00000004   0x60C3             STR      R3,[R0, #+12]
    338          	tm_ptr->tm_hour = hours;
   \   00000006   0x9900             LDR      R1,[SP, #+0]
   \   00000008   0x6081             STR      R1,[R0, #+8]
    339          	tm_ptr->tm_min  = mins ;
   \   0000000A   0x9901             LDR      R1,[SP, #+4]
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    340          	tm_ptr->tm_sec  = sec  ;
   \   0000000E   0x9902             LDR      R1,[SP, #+8]
   \   00000010   0x6001             STR      R1,[R0, #+0]
    341          	tm_ptr->tm_wday = wday;
   \   00000012   0x9903             LDR      R1,[SP, #+12]
   \   00000014   0x6181             STR      R1,[R0, #+24]
    342          
    343          }
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    344          void SetRTCTime(struct tm *tm_ptr)
    345          {
    346          	RTC_TimeRegulate(tm_ptr);
   \                     SetRTCTime: (+1)
   \   00000000   0x....             B.N      RTC_TimeRegulate
    347          }
    348          

   \                                 In section .text, align 2, keep-with-next
    349          INT8U TimeParsorSet(char *data)
    350          {
   \                     TimeParsorSet: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    351          	struct tm tm_ptr;
    352          	if(data[0] != 0) 	tm_ptr.tm_year = data[0];// + 2000 ;
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xD005             BEQ.N    ??TimeParsorSet_0
   \   0000000A   0x9105             STR      R1,[SP, #+20]
    353          	else				return 0;
    354          	if(data[1] != 0 && data[1] <= 12)	tm_ptr.tm_mon  = data[1]  ;
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0x000A             MOVS     R2,R1
   \   00000010   0xD103             BNE.N    ??TimeParsorSet_1
    355          	else				return 0;
   \                     ??TimeParsorSet_2: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE022             B.N      ??TimeParsorSet_3
   \                     ??TimeParsorSet_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE020             B.N      ??TimeParsorSet_3
   \                     ??TimeParsorSet_1: (+1)
   \   0000001A   0x290D             CMP      R1,#+13
   \   0000001C   0xDAF9             BGE.N    ??TimeParsorSet_2
   \   0000001E   0x9104             STR      R1,[SP, #+16]
    356          	if(data[2] != 0 && data[2] <= 31)	tm_ptr.tm_mday = data[2] ;
   \   00000020   0x7881             LDRB     R1,[R0, #+2]
   \   00000022   0x000A             MOVS     R2,R1
   \   00000024   0xD013             BEQ.N    ??TimeParsorSet_4
   \   00000026   0x2920             CMP      R1,#+32
   \   00000028   0xDA11             BGE.N    ??TimeParsorSet_4
   \   0000002A   0x9103             STR      R1,[SP, #+12]
    357          	else				return 0;
    358          	if(data[3] <= 24)	tm_ptr.tm_hour = data[3];
   \   0000002C   0x78C1             LDRB     R1,[R0, #+3]
   \   0000002E   0x2919             CMP      R1,#+25
   \   00000030   0xDA0F             BGE.N    ??TimeParsorSet_5
   \   00000032   0x9102             STR      R1,[SP, #+8]
    359          	else				return 0;
    360          	if(data[4] <= 60)	tm_ptr.tm_min  = data[4] ;
   \   00000034   0x7901             LDRB     R1,[R0, #+4]
   \   00000036   0x293D             CMP      R1,#+61
   \   00000038   0xDA0D             BGE.N    ??TimeParsorSet_6
   \   0000003A   0x9101             STR      R1,[SP, #+4]
    361          	else				return 0;
    362          	if(data[5] <= 60)	tm_ptr.tm_sec  = data[5]  ;
   \   0000003C   0x7940             LDRB     R0,[R0, #+5]
   \   0000003E   0x283D             CMP      R0,#+61
   \   00000040   0xDA0B             BGE.N    ??TimeParsorSet_7
   \   00000042   0x9000             STR      R0,[SP, #+0]
    363          	else				return 0;
    364          	SetRTCTime(&tm_ptr);
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       SetRTCTime
    365          	return 1;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE006             B.N      ??TimeParsorSet_3
   \                     ??TimeParsorSet_4: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE004             B.N      ??TimeParsorSet_3
   \                     ??TimeParsorSet_5: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE002             B.N      ??TimeParsorSet_3
   \                     ??TimeParsorSet_6: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE000             B.N      ??TimeParsorSet_3
   \                     ??TimeParsorSet_7: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??TimeParsorSet_3: (+1)
   \   0000005C   0xB00B             ADD      SP,SP,#+44
   \   0000005E   0xBD00             POP      {PC}             ;; return
    366          }

   \                                 In section .text, align 2, keep-with-next
    367          void ResponseTime(char *data)
    368          {
   \                     ResponseTime: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x4604             MOV      R4,R0
    369          	struct tm tm_ptr;
    370          
    371          	GetRTCTime(&tm_ptr);
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      BL       GetRTCTime
    372          
    373          	data[0] = (INT8U)(tm_ptr.tm_year);//-2000);
   \   0000000C   0x9805             LDR      R0,[SP, #+20]
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    374          	data[1] = (INT8U)tm_ptr.tm_mon  ;
   \   00000010   0x9804             LDR      R0,[SP, #+16]
   \   00000012   0x7060             STRB     R0,[R4, #+1]
    375          	data[2] = (INT8U)tm_ptr.tm_mday ;
   \   00000014   0x9803             LDR      R0,[SP, #+12]
   \   00000016   0x70A0             STRB     R0,[R4, #+2]
    376          	data[3] = (INT8U)tm_ptr.tm_hour ;
   \   00000018   0x9802             LDR      R0,[SP, #+8]
   \   0000001A   0x70E0             STRB     R0,[R4, #+3]
    377          	data[4] = (INT8U)tm_ptr.tm_min  ;
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x7120             STRB     R0,[R4, #+4]
    378          	data[5] = (INT8U)tm_ptr.tm_sec  ;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x7160             STRB     R0,[R4, #+5]
    379          }
   \   00000024   0xB00C             ADD      SP,SP,#+48
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    380          
    381          #define	DAY_STRING_MAX	60

   \                                 In section .data, align 4
    382          static char dday[ DAY_STRING_MAX ] 	;
   \                     dday:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000003C   0x53 0x75          DC8 "Sun"
   \              0x6E 0x00    
   \   00000040   0x4D 0x6F          DC8 "Mon"
   \              0x6E 0x00    
   \   00000044   0x54 0x75          DC8 "Tue"
   \              0x65 0x00    
   \   00000048   0x57 0x65          DC8 "Wed"
   \              0x64 0x00    
   \   0000004C   0x54 0x68          DC8 "Thu"
   \              0x75 0x00    
   \   00000050   0x46 0x72          DC8 "Fri"
   \              0x69 0x00    
   \   00000054   0x53 0x61          DC8 "Sat"
   \              0x74 0x00    
    383          static char wday[7][4] = {"Sun","Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
    384          
    385          

   \                                 In section .text, align 2, keep-with-next
    386          char * btime2str(struct tm *tm_ptr, char *format)  // like strftime/*{{{*/
    387          { 
   \                     btime2str: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    388          	int    index = 0  ; 
   \   00000008   0x2700             MOVS     R7,#+0
    389          	int    i          ; 
    390          
    391          	memset(dday, 0x00, DAY_STRING_MAX ) ;
   \   0000000A   0x....             LDR.N    R6,??DataTable32_12
   \   0000000C   0x463A             MOV      R2,R7
   \   0000000E   0x213C             MOVS     R1,#+60
   \   00000010   0x4630             MOV      R0,R6
   \   00000012   0x.... 0x....      BL       __aeabi_memset4
    392          
    393          	for (i = 0; i < strlen(format); i++) 
   \   00000016   0x46B8             MOV      R8,R7
   \   00000018   0xE003             B.N      ??btime2str_0
    394          	{ 
    395          		switch(format[i]) 
    396          		{ 
    397          			case 'Y': // ??
    398          				sprintf(dday+index, "%04d", tm_ptr->tm_year); 
    399          				index += 4; 
    400          				break; 
    401          			case 'y': // ??
    402          				sprintf(dday+index, "%02d", (tm_ptr->tm_year % 100)); 
    403          				index += 2; 
    404          				break; 
    405          			case 'm': // ??1-12), ?0-59)  
    406          				if (format[i+1] == 'i') 
    407          				{ 
    408          					sprintf(dday+index, "%02d", tm_ptr->tm_min); 
    409          					index += 2; 
    410          					i++; 
    411          					break; 
    412          				} 
    413          				else 
    414          				{ 
    415          					sprintf(dday+index, "%02d", tm_ptr->tm_mon); 
    416          					index += 2; 
    417          					break; 
    418          				} 
    419          			case 'd': // ??(1-31) 
    420          				sprintf(dday+index, "%02d", tm_ptr->tm_mday); 
    421          				index += 2; 
    422          				break; 
    423          			case 'D': // ?(??~ ?? 
    424          				sprintf(dday+index, "%s", wday[tm_ptr->tm_wday]); 
    425          				index += 3; 
    426          				break; 
    427          			case 'h': // ??00-23) 
    428          				sprintf(dday+index, "%02d", tm_ptr->tm_hour ); 
    429          				index += 2; 
    430          				break; 
    431          			case 's': // ?00-59) 
    432          				sprintf(dday+index, "%02d", tm_ptr->tm_sec); 
    433          				index += 2; 
    434          				break; 
    435          
    436          			default: 
    437          				dday[index] = format[i]; 
   \                     ??btime2str_1: (+1)
   \   0000001A   0x55F0             STRB     R0,[R6, R7]
    438          				index++; 
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??btime2str_2: (+1)
   \   0000001E   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??btime2str_0: (+1)
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       strlen
   \   00000028   0x4580             CMP      R8,R0
   \   0000002A   0xD261             BCS.N    ??btime2str_3
   \   0000002C   0xF815 0x0008      LDRB     R0,[R5, R8]
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x2944             CMP      R1,#+68
   \   00000034   0xD041             BEQ.N    ??btime2str_4
   \   00000036   0x2959             CMP      R1,#+89
   \   00000038   0xD00A             BEQ.N    ??btime2str_5
   \   0000003A   0x2964             CMP      R1,#+100
   \   0000003C   0xD035             BEQ.N    ??btime2str_6
   \   0000003E   0x2968             CMP      R1,#+104
   \   00000040   0xD046             BEQ.N    ??btime2str_7
   \   00000042   0x296D             CMP      R1,#+109
   \   00000044   0xD01A             BEQ.N    ??btime2str_8
   \   00000046   0x2973             CMP      R1,#+115
   \   00000048   0xD04A             BEQ.N    ??btime2str_9
   \   0000004A   0x2979             CMP      R1,#+121
   \   0000004C   0xD008             BEQ.N    ??btime2str_10
   \   0000004E   0xE7E4             B.N      ??btime2str_1
   \                     ??btime2str_5: (+1)
   \   00000050   0x6962             LDR      R2,[R4, #+20]
   \   00000052   0x.... 0x....      ADR.W    R1,?_7
   \   00000056   0x19F0             ADDS     R0,R6,R7
   \   00000058   0x.... 0x....      BL       sprintf
   \   0000005C   0x1D3F             ADDS     R7,R7,#+4
   \   0000005E   0xE7DE             B.N      ??btime2str_2
   \                     ??btime2str_10: (+1)
   \   00000060   0x6960             LDR      R0,[R4, #+20]
   \   00000062   0x2164             MOVS     R1,#+100
   \   00000064   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000068   0x2264             MOVS     R2,#+100
   \   0000006A   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000006E   0x.... 0x....      ADR.W    R1,?_8
   \   00000072   0x19F0             ADDS     R0,R6,R7
   \   00000074   0x.... 0x....      BL       sprintf
   \   00000078   0x1CBF             ADDS     R7,R7,#+2
   \   0000007A   0xE7D0             B.N      ??btime2str_2
   \                     ??btime2str_8: (+1)
   \   0000007C   0xF107 0x0902      ADD      R9,R7,#+2
   \   00000080   0x.... 0x....      ADR.W    R1,?_8
   \   00000084   0xEB05 0x0008      ADD      R0,R5,R8
   \   00000088   0x7840             LDRB     R0,[R0, #+1]
   \   0000008A   0x2869             CMP      R0,#+105
   \   0000008C   0xD107             BNE.N    ??btime2str_11
   \   0000008E   0x6862             LDR      R2,[R4, #+4]
   \   00000090   0x19F0             ADDS     R0,R6,R7
   \   00000092   0x.... 0x....      BL       sprintf
   \   00000096   0x464F             MOV      R7,R9
   \   00000098   0xF108 0x0801      ADD      R8,R8,#+1
   \   0000009C   0xE7BF             B.N      ??btime2str_2
   \                     ??btime2str_11: (+1)
   \   0000009E   0x6922             LDR      R2,[R4, #+16]
   \   000000A0   0x19F0             ADDS     R0,R6,R7
   \   000000A2   0x.... 0x....      BL       sprintf
   \   000000A6   0x464F             MOV      R7,R9
   \   000000A8   0xE7B9             B.N      ??btime2str_2
   \                     ??btime2str_6: (+1)
   \   000000AA   0x68E2             LDR      R2,[R4, #+12]
   \   000000AC   0x.... 0x....      ADR.W    R1,?_8
   \   000000B0   0x19F0             ADDS     R0,R6,R7
   \   000000B2   0x.... 0x....      BL       sprintf
   \   000000B6   0x1CBF             ADDS     R7,R7,#+2
   \   000000B8   0xE7B1             B.N      ??btime2str_2
   \                     ??btime2str_4: (+1)
   \   000000BA   0x69A0             LDR      R0,[R4, #+24]
   \   000000BC   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \   000000C0   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000C4   0x....             ADR.N    R1,??DataTable32  ;; 0x25, 0x73, 0x00, 0x00
   \   000000C6   0x19F0             ADDS     R0,R6,R7
   \   000000C8   0x.... 0x....      BL       sprintf
   \   000000CC   0x1CFF             ADDS     R7,R7,#+3
   \   000000CE   0xE7A6             B.N      ??btime2str_2
   \                     ??btime2str_7: (+1)
   \   000000D0   0x68A2             LDR      R2,[R4, #+8]
   \   000000D2   0x.... 0x....      ADR.W    R1,?_8
   \   000000D6   0x19F0             ADDS     R0,R6,R7
   \   000000D8   0x.... 0x....      BL       sprintf
   \   000000DC   0x1CBF             ADDS     R7,R7,#+2
   \   000000DE   0xE79E             B.N      ??btime2str_2
   \                     ??btime2str_9: (+1)
   \   000000E0   0x6822             LDR      R2,[R4, #+0]
   \   000000E2   0x.... 0x....      ADR.W    R1,?_8
   \   000000E6   0x19F0             ADDS     R0,R6,R7
   \   000000E8   0x.... 0x....      BL       sprintf
   \   000000EC   0x1CBF             ADDS     R7,R7,#+2
   \   000000EE   0xE796             B.N      ??btime2str_2
    439          		} 
    440          	} 
    441          	return dday; 
   \                     ??btime2str_3: (+1)
   \   000000F0   0x4630             MOV      R0,R6
   \   000000F2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    442          } /*}}}*/
    443          
    444          

   \                                 In section .text, align 2, keep-with-next
    445          void MemoryDisplay(INT32U offset,INT32U size)
    446          {
   \                     MemoryDisplay: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460F             MOV      R7,R1
    447          	INT32U i,j;
    448          	INT8U temp,buf[0x10];
    449          	INT8U *pMem = (INT8U *)offset;
   \   00000008   0x462E             MOV      R6,R5
   \   0000000A   0xE000             B.N      ??MemoryDisplay_0
    450          
    451          	while(size%16)size++;
   \                     ??MemoryDisplay_1: (+1)
   \   0000000C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??MemoryDisplay_0: (+1)
   \   0000000E   0xF017 0x0F0F      TST      R7,#0xF
   \   00000012   0xD1FB             BNE.N    ??MemoryDisplay_1
    452          
    453          	printk("\n");
   \   00000014   0x....             ADR.N    R4,??DataTable32_1  ;; "\n"
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       printk
    454          
    455          	for(i=0; i<size; i++)
   \   0000001C   0xF04F 0x0800      MOV      R8,#+0
   \   00000020   0xE011             B.N      ??MemoryDisplay_2
    456          	{
    457          		temp = pMem[i];
    458          		
    459          		if((i&0xF) == 0){
    460          			if(i){
    461          				for(j=0; j<0x10; j++){
    462          					if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
    463          						printk("%c",buf[j]);
    464          					}
    465          					else{
    466          						printk(".");
    467          					}
    468          				}
    469          			}
    470          			printk("\n%05X : ",offset+i);
   \                     ??MemoryDisplay_3: (+1)
   \   00000022   0xEB08 0x0105      ADD      R1,R8,R5
   \   00000026   0x.... 0x....      ADR.W    R0,?_13
   \   0000002A   0x.... 0x....      BL       printk
    471          		}
    472          		
    473          		buf[i&0xF] = temp;
   \                     ??MemoryDisplay_4: (+1)
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0xF008 0x010F      AND      R1,R8,#0xF
   \   00000034   0xF800 0x9001      STRB     R9,[R0, R1]
    474          		
    475          		printk("%02X ",temp);
   \   00000038   0x4649             MOV      R1,R9
   \   0000003A   0x.... 0x....      ADR.W    R0,?_14
   \   0000003E   0x.... 0x....      BL       printk
   \   00000042   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??MemoryDisplay_2: (+1)
   \   00000046   0x45B8             CMP      R8,R7
   \   00000048   0xD21D             BCS.N    ??MemoryDisplay_5
   \   0000004A   0xF816 0x9008      LDRB     R9,[R6, R8]
   \   0000004E   0xF018 0x0F0F      TST      R8,#0xF
   \   00000052   0xD1EC             BNE.N    ??MemoryDisplay_4
   \   00000054   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000058   0xD0E3             BEQ.N    ??MemoryDisplay_3
   \   0000005A   0xF04F 0x0A00      MOV      R10,#+0
   \   0000005E   0xE004             B.N      ??MemoryDisplay_6
   \                     ??MemoryDisplay_7: (+1)
   \   00000060   0x....             ADR.N    R0,??DataTable32_2  ;; "."
   \   00000062   0x.... 0x....      BL       printk
   \                     ??MemoryDisplay_8: (+1)
   \   00000066   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??MemoryDisplay_6: (+1)
   \   0000006A   0xF1BA 0x0F10      CMP      R10,#+16
   \   0000006E   0xD2D8             BCS.N    ??MemoryDisplay_3
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0xF810 0x100A      LDRB     R1,[R0, R10]
   \   00000076   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   0000007A   0x285F             CMP      R0,#+95
   \   0000007C   0xD2F0             BCS.N    ??MemoryDisplay_7
   \   0000007E   0x....             ADR.N    R0,??DataTable32_3  ;; 0x25, 0x63, 0x00, 0x00
   \   00000080   0x.... 0x....      BL       printk
   \   00000084   0xE7EF             B.N      ??MemoryDisplay_8
    476          	}
    477          
    478          	for(j=0; j<0x10; j++){
   \                     ??MemoryDisplay_5: (+1)
   \   00000086   0x2500             MOVS     R5,#+0
   \   00000088   0xE003             B.N      ??MemoryDisplay_9
    479          		if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
    480          			printk("%c",buf[j]);
    481          		}
    482          		else{
    483          			printk(".");
   \                     ??MemoryDisplay_10: (+1)
   \   0000008A   0x....             ADR.N    R0,??DataTable32_2  ;; "."
   \   0000008C   0x.... 0x....      BL       printk
    484          		}
   \                     ??MemoryDisplay_11: (+1)
   \   00000090   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MemoryDisplay_9: (+1)
   \   00000092   0x2D10             CMP      R5,#+16
   \   00000094   0xD209             BCS.N    ??MemoryDisplay_12
   \   00000096   0x4668             MOV      R0,SP
   \   00000098   0x5D41             LDRB     R1,[R0, R5]
   \   0000009A   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   0000009E   0x285F             CMP      R0,#+95
   \   000000A0   0xD2F3             BCS.N    ??MemoryDisplay_10
   \   000000A2   0x....             ADR.N    R0,??DataTable32_3  ;; 0x25, 0x63, 0x00, 0x00
   \   000000A4   0x.... 0x....      BL       printk
   \   000000A8   0xE7F2             B.N      ??MemoryDisplay_11
    485          	}
    486          	
    487          	printk("\n");	
   \                     ??MemoryDisplay_12: (+1)
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       printk
    488          }
   \   000000B0   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
    489          
    490          

   \                                 In section .text, align 2, keep-with-next
    491          INT16U dbg_rtc_set(void)
    492          {
   \                     dbg_rtc_set: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08F             SUB      SP,SP,#+60
    493          	INT32U yy,mon,day,hh,mm,ss,wday;
    494          	struct tm tm_ptr;
    495            
    496          	if(CLI_GetArgCnt() < 7) return INV_PRM;
   \   00000006   0x.... 0x....      BL       CLI_GetArgCnt
   \   0000000A   0x2807             CMP      R0,#+7
   \   0000000C   0xD201             BCS.N    ??dbg_rtc_set_0
   \   0000000E   0x20CA             MOVS     R0,#+202
   \   00000010   0xE040             B.N      ??dbg_rtc_set_1
    497          	
    498          	yy  = comparison_num((char *)P_ARG(1));
   \                     ??dbg_rtc_set_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       Argument
   \   00000018   0x.... 0x....      BL       comparison_num
   \   0000001C   0x4604             MOV      R4,R0
    499          	mon = comparison_num((char *)P_ARG(2));
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       Argument
   \   00000024   0x.... 0x....      BL       comparison_num
   \   00000028   0x4605             MOV      R5,R0
    500          	day= comparison_num((char *)P_ARG(3));
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x.... 0x....      BL       Argument
   \   00000030   0x.... 0x....      BL       comparison_num
   \   00000034   0x4606             MOV      R6,R0
    501          	hh  = comparison_num((char *)P_ARG(4));
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x.... 0x....      BL       Argument
   \   0000003C   0x.... 0x....      BL       comparison_num
   \   00000040   0x4607             MOV      R7,R0
    502          	mm  = comparison_num((char *)P_ARG(5));
   \   00000042   0x2005             MOVS     R0,#+5
   \   00000044   0x.... 0x....      BL       Argument
   \   00000048   0x.... 0x....      BL       comparison_num
   \   0000004C   0x4680             MOV      R8,R0
    503          	ss  = comparison_num((char *)P_ARG(6));
   \   0000004E   0x2006             MOVS     R0,#+6
   \   00000050   0x.... 0x....      BL       Argument
   \   00000054   0x.... 0x....      BL       comparison_num
   \   00000058   0x4681             MOV      R9,R0
    504          	wday= comparison_num((char *)P_ARG(7));
   \   0000005A   0x2007             MOVS     R0,#+7
   \   0000005C   0x.... 0x....      BL       Argument
   \   00000060   0x.... 0x....      BL       comparison_num
    505          
    506          	MakeTimePtr(&tm_ptr,yy, mon, day, hh, mm, ss,wday);
   \   00000064   0xB2C0             UXTB     R0,R0
   \   00000066   0x9003             STR      R0,[SP, #+12]
   \   00000068   0xFA5F 0xF989      UXTB     R9,R9
   \   0000006C   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000070   0xFA5F 0xF888      UXTB     R8,R8
   \   00000074   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000078   0xB2FF             UXTB     R7,R7
   \   0000007A   0x9700             STR      R7,[SP, #+0]
   \   0000007C   0x4633             MOV      R3,R6
   \   0000007E   0xB2DB             UXTB     R3,R3
   \   00000080   0x462A             MOV      R2,R5
   \   00000082   0xB2D2             UXTB     R2,R2
   \   00000084   0x4621             MOV      R1,R4
   \   00000086   0xA804             ADD      R0,SP,#+16
   \   00000088   0x.... 0x....      BL       MakeTimePtr
    507          	SetRTCTime(&tm_ptr);
   \   0000008C   0xA804             ADD      R0,SP,#+16
   \   0000008E   0x.... 0x....      BL       SetRTCTime
    508          
    509          	return NO_DISPLAY;
   \   00000092   0x20C9             MOVS     R0,#+201
   \                     ??dbg_rtc_set_1: (+1)
   \   00000094   0xB00F             ADD      SP,SP,#+60
   \   00000096   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    510          }
    511          
    512          

   \                                 In section .text, align 2, keep-with-next
    513          INT16U dbg_rtc_gettime(void)
    514          {
   \                     dbg_rtc_gettime: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    515          
    516          	sysinfo_t *s = &_sysinfo 	;
    517          
    518          	printk("Read RTC Sec = %s\n",btime2str(&s->tm_ptr, "y-m-d h:mi:s"));
   \   00000002   0x.... 0x....      ADR.W    R1,?_16
   \   00000006   0x....             LDR.N    R0,??DataTable32_13
   \   00000008   0x.... 0x....      BL       btime2str
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x.... 0x....      ADR.W    R0,?_15
   \   00000012   0x.... 0x....      BL       printk
    519          
    520              return NO_DISPLAY;
   \   00000016   0x20C9             MOVS     R0,#+201
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    521          
    522          }
    523          
    524          

   \                                 In section .text, align 2, keep-with-next
    525          INT16U dbg_backupsramwr_test(void)
    526          {
   \                     dbg_backupsramwr_test: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    527          	INT16U size, addr;
    528            static INT8U BS_RxB[100];
    529            
    530          	if(CLI_GetArgCnt() < 2) return INV_PRM;
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD201             BCS.N    ??dbg_backupsramwr_test_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    531          	
    532          	addr = comparison_num((char *)P_ARG(1));
   \                     ??dbg_backupsramwr_test_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
   \   00000018   0x4604             MOV      R4,R0
    533          	size = comparison_num((char *)P_ARG(2));
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       Argument
   \   00000020   0x.... 0x....      BL       comparison_num
   \   00000024   0x4605             MOV      R5,R0
    534          
    535            if(size > 100) size = 100;
   \   00000026   0xB2AD             UXTH     R5,R5
   \   00000028   0x2D65             CMP      R5,#+101
   \   0000002A   0xDB00             BLT.N    ??dbg_backupsramwr_test_1
   \   0000002C   0x2564             MOVS     R5,#+100
    536          	read_from_backup_sram( BS_RxB, size, addr);
   \                     ??dbg_backupsramwr_test_1: (+1)
   \   0000002E   0x....             LDR.N    R6,??DataTable32_14
   \   00000030   0x4622             MOV      R2,R4
   \   00000032   0xB292             UXTH     R2,R2
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       read_from_backup_sram
    537          	MemoryDisplay((INT32U)BS_RxB, size);
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       MemoryDisplay
    538          
    539          	return NO_DISPLAY;
   \   00000044   0x20C9             MOVS     R0,#+201
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    540          }

   \                                 In section .bss, align 4
   \                     `dbg_backupsramwr_test::BS_RxB`:
   \   00000000                      DS8 100
    541          

   \                                 In section .text, align 2, keep-with-next
    542          INT16U dbg_backupsramrd_test(void)
    543          {
   \                     dbg_backupsramrd_test: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    544          	INT8U BS_RxB[16];
    545          	INT8U i;
    546          
    547          	for(i=0;i<sizeof(BS_RxB);i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x466A             MOV      R2,SP
   \   0000000A   0xE001             B.N      ??dbg_backupsramrd_test_0
    548          	{
    549          		BS_RxB[i] = 0x00;
   \                     ??dbg_backupsramrd_test_1: (+1)
   \   0000000C   0x5411             STRB     R1,[R2, R0]
    550          	}
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??dbg_backupsramrd_test_0: (+1)
   \   00000010   0x2810             CMP      R0,#+16
   \   00000012   0xD3FB             BCC.N    ??dbg_backupsramrd_test_1
    551          	read_from_backup_sram( BS_RxB, 16, 0);
   \   00000014   0x460A             MOV      R2,R1
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x.... 0x....      BL       read_from_backup_sram
    552          	MemoryDisplay((INT32U)BS_RxB, 16);
   \   0000001E   0x2110             MOVS     R1,#+16
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       MemoryDisplay
    553          
    554          	return NO_DISPLAY;
   \   00000026   0x20C9             MOVS     R0,#+201
   \   00000028   0xB005             ADD      SP,SP,#+20
   \   0000002A   0xBD00             POP      {PC}             ;; return
    555          }
    556          
    557          

   \                                 In section .bss, align 4
    558          struct tm tm_time;
   \                     tm_time:
   \   00000000                      DS8 44
    559          /*
    560          ********************************************************************************
    561          * Description :   mktime conversion
    562          ******************************************************************************** 
    563          */

   \                                 In section .text, align 2, keep-with-next
    564          time_t mktime_conv(Time_t t) 
    565          {
   \                     mktime_conv: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0xB403             PUSH     {R0,R1}
   \   00000004   0xB081             SUB      SP,SP,#+4
    566            tm_time.tm_sec = t.tm_sec;
   \   00000006   0x....             LDR.N    R0,??DataTable32_15
   \   00000008   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    567            tm_time.tm_min = t.tm_min;
   \   0000000E   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000012   0x6041             STR      R1,[R0, #+4]
    568            tm_time.tm_hour = t.tm_hour;
   \   00000014   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   00000018   0x6081             STR      R1,[R0, #+8]
    569            tm_time.tm_mday = t.tm_mday;
   \   0000001A   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   0000001E   0x60C1             STR      R1,[R0, #+12]
    570            tm_time.tm_mon = t.tm_mon-1;
   \   00000020   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000024   0x1E49             SUBS     R1,R1,#+1
   \   00000026   0x6101             STR      R1,[R0, #+16]
    571            tm_time.tm_year = 2000+t.tm_year-1900;
   \   00000028   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   0000002C   0x3164             ADDS     R1,R1,#+100
   \   0000002E   0x6141             STR      R1,[R0, #+20]
    572            tm_time.tm_isdst = 0;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6201             STR      R1,[R0, #+32]
    573            return  mktime(&tm_time);
   \   00000034   0xB004             ADD      SP,SP,#+16
   \   00000036   0x.... 0x....      B.W      __mktime32
    574          }  
    575            
    576          /*
    577          ********************************************************************************
    578          * Description :   gmtime conversion
    579          ******************************************************************************** 
    580          */

   \                                 In section .text, align 2, keep-with-next
    581          Time_t gmtime_conv(INT32U rtime)
    582          {  
   \                     gmtime_conv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
    583            Time_t local;
    584            struct tm *t;
    585            INT32U ltime;  
    586            
    587            ltime =  rtime;
   \   00000006   0x9102             STR      R1,[SP, #+8]
    588            t = gmtime((time_t*)&ltime);
   \   00000008   0xA802             ADD      R0,SP,#+8
   \   0000000A   0x.... 0x....      BL       __gmtime32
    589            local.tm_wday = (u8)(t->tm_wday);
   \   0000000E   0x6981             LDR      R1,[R0, #+24]
   \   00000010   0xF88D 0x1006      STRB     R1,[SP, #+6]
    590            if(t->tm_year+1900 > 2000)
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0xF201 0x726C      ADDW     R2,R1,#+1900
   \   0000001A   0xF5B2 0x6FFA      CMP      R2,#+2000
   \   0000001E   0xDD03             BLE.N    ??gmtime_conv_0
    591              local.tm_year = (u8)(t->tm_year+1900-2000);
   \   00000020   0x3964             SUBS     R1,R1,#+100
   \   00000022   0xF88D 0x1005      STRB     R1,[SP, #+5]
   \   00000026   0xE002             B.N      ??gmtime_conv_1
    592            else local.tm_year = 0;
   \                     ??gmtime_conv_0: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF88D 0x1005      STRB     R1,[SP, #+5]
    593            local.tm_mon = (INT8U)(t->tm_mon+1);
   \                     ??gmtime_conv_1: (+1)
   \   0000002E   0x6901             LDR      R1,[R0, #+16]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0xF88D 0x1004      STRB     R1,[SP, #+4]
    594            local.tm_mday = (INT8U)(t->tm_mday);
   \   00000036   0x68C1             LDR      R1,[R0, #+12]
   \   00000038   0xF88D 0x1003      STRB     R1,[SP, #+3]
    595            local.tm_hour = (INT8U)(t->tm_hour);
   \   0000003C   0x6881             LDR      R1,[R0, #+8]
   \   0000003E   0xF88D 0x1002      STRB     R1,[SP, #+2]
    596            local.tm_min = (INT8U)(t->tm_min);
   \   00000042   0x6841             LDR      R1,[R0, #+4]
   \   00000044   0xF88D 0x1001      STRB     R1,[SP, #+1]
    597            local.tm_sec = (INT8U)(t->tm_sec);
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    598            return local;
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x2208             MOVS     R2,#+8
   \   00000054   0x.... 0x....      BL       __aeabi_memcpy
   \   00000058   0xB004             ADD      SP,SP,#+16
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    599          }
    600          
    601          /*
    602          ********************************************************************************
    603          * Description :   IsSameDate
    604          ******************************************************************************** 
    605          */

   \                                 In section .text, align 2, keep-with-next
    606          u8 IsSameDate(long time1, long time2) //   1  0    [JCH.2014.03.14]
    607          {
    608            long daycnt1, daycnt2;
    609            
    610            daycnt1 = time1/3600/24;
    611            daycnt2 = time2/3600/24;
    612            if(daycnt1 == daycnt2) return 1;
   \                     IsSameDate: (+1)
   \   00000000   0xF44F 0x6261      MOV      R2,#+3600
   \   00000004   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   00000008   0x2218             MOVS     R2,#+24
   \   0000000A   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   0000000E   0xF44F 0x6261      MOV      R2,#+3600
   \   00000012   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000016   0x2218             MOVS     R2,#+24
   \   00000018   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??IsSameDate_0
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4770             BX       LR
    613            else return 0;
   \                     ??IsSameDate_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
    614          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x25 0x63          DC8      0x25, 0x63, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x........         DC32     BSP_BKSramSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0x........         DC32     BSP_BKRtcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \   00000000   0x........         DC32     systick_uptime_millis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \   00000000   0x40024000         DC32     0x40024000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_8:
   \   00000000   0x40002850         DC32     0x40002850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_9:
   \   00000000   0x........         DC32     RTC_DateStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_10:
   \   00000000   0x........         DC32     RTC_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_11:
   \   00000000   0x........         DC32     RTC_LVal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_12:
   \   00000000   0x........         DC32     dday

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_13:
   \   00000000   0x........         DC32     _sysinfo+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_14:
   \   00000000   0x........         DC32     `dbg_backupsramwr_test::BS_RxB`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_15:
   \   00000000   0x........         DC32     tm_time

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x25 0x73          DC8 "%s"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_10:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x25 0x63          DC8 "%c"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_12:
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x20 0x3A          DC8 " :  %0.2d:%0.2d:%0.2d \012\015"
   \              0x20 0x20    
   \              0x25 0x30    
   \              0x2E 0x32    
   \              0x64 0x3A    
   \              0x25 0x30    
   \              0x2E 0x32    
   \              0x64 0x3A    
   \              0x25 0x30    
   \              0x2E 0x32    
   \              0x64 0x20    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0A 0x0D          DC8 "\012\015  The current alarm is :  %0.2d:%0.2d:%0.2d \012\015"
   \              0x20 0x20    
   \              0x54 0x68    
   \              0x65 0x20    
   \              0x63 0x75    
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x61 0x6C    
   \              0x61 0x72    
   \              0x6D 0x20    
   \              0x69 0x73    
   \              0x20 0x3A    
   \              0x20 0x20    
   \              0x25 0x30    
   \              0x2E 0x32    
   \              0x64 0x3A    
   \              0x25 0x30    
   \              0x2E 0x32    
   \              0x64 0x3A    
   \              0x25 0x30    
   \              0x2E 0x32    
   \              0x64 0x20    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x0A 0x0D          DC8 "\012\015  The current date:  %0.2d-%0.2d-%0.2d"
   \              0x20 0x20    
   \              0x54 0x68    
   \              0x65 0x20    
   \              0x63 0x75    
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x64 0x61    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x20 0x25    
   \              0x30 0x2E    
   \              0x32 0x64    
   \              0x2D 0x25    
   \              0x30 0x2E    
   \              0x32 0x64    
   \              0x2D 0x25    
   \              0x30 0x2E    
   \              0x32 0x64    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000008   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000010   0x54 0x69          DC8 54H, 69H, 6DH, 65H, 20H, 53H, 65H, 74H
   \              0x6D 0x65    
   \              0x20 0x53    
   \              0x65 0x74    
   \   00000018   0x74 0x69          DC8 74H, 69H, 6EH, 67H, 73H, 3DH, 3DH, 3DH
   \              0x6E 0x67    
   \              0x73 0x3D    
   \              0x3D 0x3D    
   \   00000020   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000028   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000030   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000038   0x3D 0x3D          DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \              0x3D 0x3D    
   \   00000040   0x3D 0x3D          DC8 3DH, 3DH, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x0A 0x0D          DC8 "\012\015>> !! RTC Set Time failed. !! <<\012\015"
   \              0x3E 0x3E    
   \              0x20 0x21    
   \              0x21 0x20    
   \              0x52 0x54    
   \              0x43 0x20    
   \              0x53 0x65    
   \              0x74 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2E    
   \              0x20 0x21    
   \              0x21 0x20    
   \              0x3C 0x3C    
   \              0x0A 0x0D    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x0A 0x3E          DC8 "\012>> !! RTC Set Date failed. !! <<\012"
   \              0x3E 0x20    
   \              0x21 0x21    
   \              0x20 0x52    
   \              0x54 0x43    
   \              0x20 0x53    
   \              0x65 0x74    
   \              0x20 0x44    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x21 0x21    
   \              0x20 0x3C    
   \              0x3C 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x25 0x30          DC8 "%04d"
   \              0x34 0x64    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x25 0x30          DC8 "%02d"
   \              0x32 0x64    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x0A 0x25          DC8 "\012%05X : "
   \              0x30 0x35    
   \              0x58 0x20    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x52 0x65          DC8 "Read RTC Sec = %s\012"
   \              0x61 0x64    
   \              0x20 0x52    
   \              0x54 0x43    
   \              0x20 0x53    
   \              0x65 0x63    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x79 0x2D          DC8 "y-m-d h:mi:s"
   \              0x6D 0x2D    
   \              0x64 0x20    
   \              0x68 0x3A    
   \              0x6D 0x69    
   \              0x3A 0x73    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    615          
    616          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BSRAMSemaphore_Init
        16   -> xQueueCreateMutex
        16   -> xQueueGenericCreate
         0   -> xQueueGenericSend
        16   -> xQueueGenericSend
      24   GetRTCTime
        24   -> RTC_GetDate
        24   -> RTC_GetTime
        24   -> __aeabi_memcpy
        24   -> mktime_conv
       0   IsSameDate
       0   MakeTimePtr
      48   MemoryDisplay
        48   -> printk
      24   RTC_AlarmShow
        24   -> RTC_GetAlarm
        24   -> printk
       8   RTC_DateShow
         8   -> RTC_GetDate
         8   -> printk
      16   RTC_TimeRegulate
        16   -> RTC_SetDate
        16   -> RTC_SetTime
        16   -> RTC_WriteBackupRegister
        16   -> printk
      24   RTC_TimeSet
        24   -> RTC_SetTime
        24   -> RTC_TimeShow
        24   -> RTC_WriteBackupRegister
        24   -> printk
       8   RTC_TimeShow
         8   -> RTC_GetTime
         8   -> printk
      56   ResponseTime
        56   -> GetRTCTime
       0   SetRTCTime
         0   -> RTC_TimeRegulate
      48   TimeParsorSet
        48   -> SetRTCTime
      32   btime2str
        32   -> __aeabi_memset4
        32   -> sprintf
        32   -> strlen
      24   dbg_backupsramrd_test
        24   -> MemoryDisplay
        24   -> read_from_backup_sram
      16   dbg_backupsramwr_test
        16   -> Argument
        16   -> CLI_GetArgCnt
        16   -> MemoryDisplay
        16   -> comparison_num
        16   -> read_from_backup_sram
       8   dbg_rtc_gettime
         8   -> btime2str
         8   -> printk
      88   dbg_rtc_set
        88   -> Argument
        88   -> CLI_GetArgCnt
        88   -> MakeTimePtr
        88   -> SetRTCTime
        88   -> comparison_num
      24   gmtime_conv
        24   -> __aeabi_memcpy
        24   -> __gmtime32
      16   mktime_conv
         0   -> __mktime32
      24   read_from_backup_rtc
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
      24   read_from_backup_sram
        24   -> RCC_AHB1PeriphClockCmd
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
       0   systick_uptime
      24   write_to_backup_rtc
        24   -> PWR_BackupAccessCmd
        24   -> RCC_APB1PeriphClockCmd
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend
      24   write_to_backup_sram
        24   -> PWR_BackupAccessCmd
        24   -> PWR_BackupRegulatorCmd
        24   -> RCC_AHB1PeriphClockCmd
        24   -> RCC_APB1PeriphClockCmd
        24   -> printk
        24   -> xQueueGenericReceive
        24   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_12
       4  ??DataTable32_13
       4  ??DataTable32_14
       4  ??DataTable32_15
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
       8  ?_0
      28  ?_1
       2  ?_10
       4  ?_11
       2  ?_12
      12  ?_13
       8  ?_14
      20  ?_15
      16  ?_16
      52  ?_2
      44  ?_3
      72  ?_4
      40  ?_5
      36  ?_6
       8  ?_7
       8  ?_8
       4  ?_9
      86  BSRAMSemaphore_Init
     100  BS_RxB
     100  GetRTCTime
      40  IsSameDate
      24  MakeTimePtr
     180  MemoryDisplay
      40  RTC_AlarmShow
      32  RTC_DateShow
       8  RTC_DateStructure
          RTC_TimeStructure
     120  RTC_TimeRegulate
      86  RTC_TimeSet
      46  RTC_TimeShow
      40  ResponseTime
       2  SetRTCTime
      96  TimeParsorSet
     246  btime2str
      44  dbg_backupsramrd_test
      72  dbg_backupsramwr_test
      26  dbg_rtc_gettime
     154  dbg_rtc_set
      88  dday
          wday
      92  gmtime_conv
      58  mktime_conv
     150  read_from_backup_rtc
     124  read_from_backup_sram
       8  systick_uptime
       4  systick_uptime_millis
      44  tm_time
     172  write_to_backup_rtc
     152  write_to_backup_sram
      92  -- Other

 
   156 bytes in section .bss
    88 bytes in section .data
    12 bytes in section .rodata
 2 698 bytes in section .text
 
 2 698 bytes of CODE  memory
    12 bytes of CONST memory
   244 bytes of DATA  memory

Errors: none
Warnings: none
