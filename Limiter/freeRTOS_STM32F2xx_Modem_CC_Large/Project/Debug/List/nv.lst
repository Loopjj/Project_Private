###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:05
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\nv.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\nv.c -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\nv.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\nv.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\App\nv.c
      1          /*
      2          *************************************** (C) COPYRIGHT 2013 XNIL *************************************
      3          *
      4          * File Name          : nv.c
      5          *
      6          * Author             : Digital Development Team
      7          *
      8          * Version            : V1.0.0
      9          *
     10          * Date               : 01/28/2013
     11          *
     12          * Description        :  
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          
     18          /*
     19          *********************************************************************************************************
     20          *                                             INCLUDE FILES
     21          *********************************************************************************************************
     22          */
     23          
     24          #define NV_GLOBALS
     25          #include "includes.h"
     26          
     27          
     28          
     29          #define DUMMY_BYTE	0x55
     30          
     31          //xSemaphoreHandle BSP_SaveSem = NULL;
     32          

   \                                 In section .text, align 2, keep-with-next
     33          void nvxSemaphore_init(void)
     34          {
   \                     nvxSemaphore_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     35          	BSP_SaveSem = xSemaphoreCreateMutex();
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       xQueueCreateMutex
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     36          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                                FUNCTIONS
     42          *********************************************************************************************************
     43          */
     44          
     45          // 특정 데이터 변경 
     46          //static INT8U pNv[SPI_FLASH_PAGE];

   \                                 In section .text, align 2, keep-with-next
     47          static void nv_modify(int addr, INT8U data)
     48          {
   \                     nv_modify: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     49          	INT8U old_base;
     50          
     51          	SPI_FLASH_BufferRead( &old_base, addr, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x4621             MOV      R1,R4
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_BufferRead
     52          
     53          	printk("\n\n[%05X]ORG:%02X ==> %02X\n", addr, old_base, data);
   \   0000000E   0xF89D 0x3004      LDRB     R3,[SP, #+4]
   \   00000012   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       printk
     54          	
     55          	SPI_FLASH_Member_Write(&data, addr, 1);
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4621             MOV      R1,R4
   \   00000024   0xA801             ADD      R0,SP,#+4
   \   00000026   0x.... 0x....      BL       SPI_FLASH_Member_Write
     56          
     57          }
   \   0000002A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     58          
     59          
     60          // SFlash의 sector 사이즈 만큼 Display해준다 

   \                                 In section .text, align 2, keep-with-next
     61          static void nv_sflash_md(int addr)
     62          {
   \                     nv_sflash_md: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4605             MOV      R5,R0
     63          	int i,j;
     64          	INT8U temp,buf[0x10];
     65          
     66          	printk("\n");
   \   00000008   0x....             ADR.N    R4,??DataTable35  ;; "\n"
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       printk
     67          
     68          	for(i=0; i<SPI_FLASH_PAGE; i++)
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0xE011             B.N      ??nv_sflash_md_0
     69          	{
     70          		SPI_FLASH_BufferRead((INT8U *)&temp, addr+i, 1);
     71          
     72          		if((i&0xF) == 0){
     73          			if(i){
     74          				for(j=0; j<0x10; j++){
     75          					if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
     76          						printk("%c",buf[j]);
     77          					}
     78          					else{
     79          						printk(".");
     80          					}
     81          				}
     82          			}
     83          			printk("\n%05X : ",addr+i);
   \                     ??nv_sflash_md_1: (+1)
   \   00000014   0x4639             MOV      R1,R7
   \   00000016   0x.... 0x....      ADR.W    R0,?_4
   \   0000001A   0x.... 0x....      BL       printk
     84          		}
     85          		
     86          		buf[i&0xF] = temp;
   \                     ??nv_sflash_md_2: (+1)
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0xF006 0x020F      AND      R2,R6,#0xF
   \   00000028   0x5488             STRB     R0,[R1, R2]
     87          		
     88          		printk("%02X ",temp);
   \   0000002A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000002E   0x.... 0x....      ADR.W    R0,?_5
   \   00000032   0x.... 0x....      BL       printk
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \                     ??nv_sflash_md_0: (+1)
   \   00000038   0xF5B6 0x5F80      CMP      R6,#+4096
   \   0000003C   0xDA20             BGE.N    ??nv_sflash_md_3
   \   0000003E   0x1977             ADDS     R7,R6,R5
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x4639             MOV      R1,R7
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       SPI_FLASH_BufferRead
   \   0000004A   0xF016 0x0F0F      TST      R6,#0xF
   \   0000004E   0xD1E6             BNE.N    ??nv_sflash_md_2
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD0DF             BEQ.N    ??nv_sflash_md_1
   \   00000054   0xF04F 0x0800      MOV      R8,#+0
   \   00000058   0xE004             B.N      ??nv_sflash_md_4
   \                     ??nv_sflash_md_5: (+1)
   \   0000005A   0x....             ADR.N    R0,??DataTable35_1  ;; "."
   \   0000005C   0x.... 0x....      BL       printk
   \                     ??nv_sflash_md_6: (+1)
   \   00000060   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??nv_sflash_md_4: (+1)
   \   00000064   0xF1B8 0x0F10      CMP      R8,#+16
   \   00000068   0xDAD4             BGE.N    ??nv_sflash_md_1
   \   0000006A   0xA801             ADD      R0,SP,#+4
   \   0000006C   0xF810 0x1008      LDRB     R1,[R0, R8]
   \   00000070   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   00000074   0x285F             CMP      R0,#+95
   \   00000076   0xD2F0             BCS.N    ??nv_sflash_md_5
   \   00000078   0x....             ADR.N    R0,??DataTable36  ;; 0x25, 0x63, 0x00, 0x00
   \   0000007A   0x.... 0x....      BL       printk
   \   0000007E   0xE7EF             B.N      ??nv_sflash_md_6
     89          	}
     90          
     91          	for(j=0; j<0x10; j++){
   \                     ??nv_sflash_md_3: (+1)
   \   00000080   0x2500             MOVS     R5,#+0
   \   00000082   0xE003             B.N      ??nv_sflash_md_7
     92          		if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
     93          			printk("%c",buf[j]);
     94          		}
     95          		else{
     96          			printk(".");
   \                     ??nv_sflash_md_8: (+1)
   \   00000084   0x....             ADR.N    R0,??DataTable35_1  ;; "."
   \   00000086   0x.... 0x....      BL       printk
     97          		}
   \                     ??nv_sflash_md_9: (+1)
   \   0000008A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??nv_sflash_md_7: (+1)
   \   0000008C   0x2D10             CMP      R5,#+16
   \   0000008E   0xDA09             BGE.N    ??nv_sflash_md_10
   \   00000090   0xA801             ADD      R0,SP,#+4
   \   00000092   0x5D41             LDRB     R1,[R0, R5]
   \   00000094   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   00000098   0x285F             CMP      R0,#+95
   \   0000009A   0xD2F3             BCS.N    ??nv_sflash_md_8
   \   0000009C   0x....             ADR.N    R0,??DataTable36  ;; 0x25, 0x63, 0x00, 0x00
   \   0000009E   0x.... 0x....      BL       printk
   \   000000A2   0xE7F2             B.N      ??nv_sflash_md_9
     98          	}
     99          	
    100          	printk("\n");	
   \                     ??nv_sflash_md_10: (+1)
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       printk
    101          }
   \   000000AA   0xB006             ADD      SP,SP,#+24
   \   000000AC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    102          
    103          // SFlash의 leng*16 사이즈 만큼 Display해준다 

   \                                 In section .text, align 2, keep-with-next
    104          static void nv_sflash_md_1(int addr, int leng)
    105          {
   \                     nv_sflash_md_1: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460E             MOV      R6,R1
    106          	int i,j;
    107          	INT8U temp,buf[0x10];
    108          
    109          	printk("\n");
   \   0000000A   0x....             ADR.N    R4,??DataTable35  ;; "\n"
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       printk
    110          
    111          	for(i=0; i<(0x10*leng); i++)
   \   00000012   0x2700             MOVS     R7,#+0
   \   00000014   0xE011             B.N      ??nv_sflash_md_1_0
    112          	{
    113          		SPI_FLASH_BufferRead((INT8U *)&temp, addr+i, 1);
    114          
    115          		if((i&0xF) == 0){
    116          			if(i){
    117          				for(j=0; j<0x10; j++){
    118          					if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
    119          						printk("%c",buf[j]);
    120          					}
    121          					else{
    122          						printk(".");
    123          					}
    124          				}
    125          			}
    126          			printk("\n%05X : ",addr+i);
   \                     ??nv_sflash_md_1_1: (+1)
   \   00000016   0x4641             MOV      R1,R8
   \   00000018   0x.... 0x....      ADR.W    R0,?_4
   \   0000001C   0x.... 0x....      BL       printk
    127          		}
    128          		
    129          		buf[i&0xF] = temp;
   \                     ??nv_sflash_md_1_2: (+1)
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xF007 0x020F      AND      R2,R7,#0xF
   \   0000002A   0x5488             STRB     R0,[R1, R2]
    130          		
    131          		printk("%02X ",temp);
   \   0000002C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000030   0x.... 0x....      ADR.W    R0,?_5
   \   00000034   0x.... 0x....      BL       printk
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \                     ??nv_sflash_md_1_0: (+1)
   \   0000003A   0xEBB7 0x1F06      CMP      R7,R6, LSL #+4
   \   0000003E   0xDA21             BGE.N    ??nv_sflash_md_1_3
   \   00000040   0xEB07 0x0805      ADD      R8,R7,R5
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x.... 0x....      BL       SPI_FLASH_BufferRead
   \   0000004E   0xF017 0x0F0F      TST      R7,#0xF
   \   00000052   0xD1E5             BNE.N    ??nv_sflash_md_1_2
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD0DE             BEQ.N    ??nv_sflash_md_1_1
   \   00000058   0xF04F 0x0900      MOV      R9,#+0
   \   0000005C   0xE004             B.N      ??nv_sflash_md_1_4
   \                     ??nv_sflash_md_1_5: (+1)
   \   0000005E   0x....             ADR.N    R0,??DataTable35_1  ;; "."
   \   00000060   0x.... 0x....      BL       printk
   \                     ??nv_sflash_md_1_6: (+1)
   \   00000064   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??nv_sflash_md_1_4: (+1)
   \   00000068   0xF1B9 0x0F10      CMP      R9,#+16
   \   0000006C   0xDAD3             BGE.N    ??nv_sflash_md_1_1
   \   0000006E   0xA801             ADD      R0,SP,#+4
   \   00000070   0xF810 0x1009      LDRB     R1,[R0, R9]
   \   00000074   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   00000078   0x285F             CMP      R0,#+95
   \   0000007A   0xD2F0             BCS.N    ??nv_sflash_md_1_5
   \   0000007C   0x....             ADR.N    R0,??DataTable36  ;; 0x25, 0x63, 0x00, 0x00
   \   0000007E   0x.... 0x....      BL       printk
   \   00000082   0xE7EF             B.N      ??nv_sflash_md_1_6
    132          	}
    133          
    134          	for(j=0; j<0x10; j++){
   \                     ??nv_sflash_md_1_3: (+1)
   \   00000084   0x2500             MOVS     R5,#+0
   \   00000086   0xE003             B.N      ??nv_sflash_md_1_7
    135          		if( buf[j] >= 0x20 && buf[j] <= 0x7E ){
    136          			printk("%c",buf[j]);
    137          		}
    138          		else{
    139          			printk(".");
   \                     ??nv_sflash_md_1_8: (+1)
   \   00000088   0x....             ADR.N    R0,??DataTable35_1  ;; "."
   \   0000008A   0x.... 0x....      BL       printk
    140          		}
   \                     ??nv_sflash_md_1_9: (+1)
   \   0000008E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??nv_sflash_md_1_7: (+1)
   \   00000090   0x2D10             CMP      R5,#+16
   \   00000092   0xDA09             BGE.N    ??nv_sflash_md_1_10
   \   00000094   0xA801             ADD      R0,SP,#+4
   \   00000096   0x5D41             LDRB     R1,[R0, R5]
   \   00000098   0xF1A1 0x0020      SUB      R0,R1,#+32
   \   0000009C   0x285F             CMP      R0,#+95
   \   0000009E   0xD2F3             BCS.N    ??nv_sflash_md_1_8
   \   000000A0   0x....             ADR.N    R0,??DataTable36  ;; 0x25, 0x63, 0x00, 0x00
   \   000000A2   0x.... 0x....      BL       printk
   \   000000A6   0xE7F2             B.N      ??nv_sflash_md_1_9
    141          	}
    142          	
    143          	printk("\n");	
   \                     ??nv_sflash_md_1_10: (+1)
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       printk
    144          }
   \   000000AE   0xB005             ADD      SP,SP,#+20
   \   000000B0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    145          
    146          
    147          /*
    148          *********************************************************************************************************
    149          *                                              DEBUG FUNCTIONS
    150          *********************************************************************************************************
    151          */
    152          
    153          

   \                                 In section .text, align 2, keep-with-next
    154          INT16U dbg_sflash_read_id(void)
    155          {
   \                     dbg_sflash_read_id: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    156          	INT32U ret = 0;
    157          
    158          	ret = SPI_FLASH_ReadID();
   \   00000002   0x.... 0x....      BL       SPI_FLASH_ReadID
    159          	printk("\nSPI flash ID : %06X\n",ret);
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x.... 0x....      ADR.W    R0,?_6
   \   0000000C   0x.... 0x....      BL       printk
    160          
    161          	return NO_DISPLAY;
   \   00000010   0x20C9             MOVS     R0,#+201
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          INT16U dbg_sflash_dispMap(void)
    165          {
   \                     dbg_sflash_dispMap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    166          	printk("\n*** SFlash Memory Map ***\n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_7
   \   00000006   0x.... 0x....      BL       printk
    167          	printk("PROJECT_BASE           :%05X (%04X)\n", PROJECT_BASE,           sizeof(Prjcode_t));  
   \   0000000A   0x221C             MOVS     R2,#+28
   \   0000000C   0xF44F 0x0150      MOV      R1,#+13631488
   \   00000010   0x.... 0x....      ADR.W    R0,?_8
   \   00000014   0x.... 0x....      BL       printk
    168          	printk("SYSTEM_BASE            :%05X (%04X)\n", SYSTEM_BASE,			sizeof(SysControl_t));  
   \   00000018   0x22C9             MOVS     R2,#+201
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable38_2  ;; 0xd01000
   \   0000001E   0x.... 0x....      ADR.W    R0,?_9
   \   00000022   0x.... 0x....      BL       printk
    169          	//printk("TABLE_PARAM_SAVE_BASE  :%05X (%04X)\n", TABLE_PARAM_SAVE_BASE,  sizeof(table_nv_t));  
    170          	//printk("DSP_DB_SAVE_BASE       :%05X (%04X)\n", DSP_DB_SAVE_BASE,       sizeof(total_table_t));  
    171          	//printk("DSP_PARAM_SAVE_BASE    :%05X (%04X)\n", DSP_PARAM_SAVE_BASE,    sizeof(dsp_t));  
    172          	//printk("RPT_DOWNLINK_BASE      :%05X (%04X)\n", RPT_DOWNLINK_BASE,      sizeof(RfControl_t));  
    173          	//printk("RPT_UPLINK_BASE        :%05X (%04X)\n", RPT_UPLINK_BASE,        sizeof(RfControl_t));  
    174          	//printk("SELF_CONDITION_BASE    :%05X (%04X)\n", SELF_CONDITION_BASE,    sizeof(Self_Condition_t));  
    175          	//printk("MODEM_CONTROL_SAVE_BASE:%05X (%04X)\n", MODEM_CONTROL_SAVE_BASE,sizeof(ModemRfcontrol_t));  
    176          
    177          	return NO_DISPLAY;
   \   00000026   0x20C9             MOVS     R0,#+201
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    178          }
    179          
    180          

   \                                 In section .text, align 2, keep-with-next
    181          INT16U dbg_sflash_smd(void)
    182          {
   \                     dbg_sflash_smd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    183          	int address;
    184          	
    185          	if(CLI_GetArgCnt() < 1) return INV_PRM;
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??dbg_sflash_smd_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD02             POP      {R1,PC}
    186          
    187          	address = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_smd_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
    188          
    189          	nv_sflash_md(address);
   \   00000018   0x.... 0x....      BL       nv_sflash_md
    190          
    191          	return NO_DISPLAY;
   \   0000001C   0x20C9             MOVS     R0,#+201
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    192          }
    193          

   \                                 In section .text, align 2, keep-with-next
    194          INT16U dbg_sflash_modify(void)
    195          {
   \                     dbg_sflash_modify: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    196          	int address;
    197          	INT8U data;
    198          	
    199          	if ( CLI_GetArgCnt() < 2 ) return INV_PRM;
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD201             BCS.N    ??dbg_sflash_modify_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    200          
    201          	address = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_modify_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
   \   00000018   0x4604             MOV      R4,R0
    202          	data = comparison_num((char*)P_ARG(2));
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       Argument
   \   00000020   0x.... 0x....      BL       comparison_num
   \   00000024   0x4605             MOV      R5,R0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable38_3  ;; 0xfffff0
   \   0000002A   0xEA00 0x0604      AND      R6,R0,R4
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x4630             MOV      R0,R6
    203          
    204          	nv_sflash_md_1(address&0xFFFFF0,1);
   \   00000032   0x.... 0x....      BL       nv_sflash_md_1
    205          
    206          	nv_modify(address,data);
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0xB2C9             UXTB     R1,R1
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       nv_modify
    207          
    208          	nv_sflash_md_1(address&0xFFFFF0,1);
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       nv_sflash_md_1
    209          
    210          	return NO_DISPLAY;
   \   00000048   0x20C9             MOVS     R0,#+201
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    211          }
    212          

   \                                 In section .text, align 2, keep-with-next
    213          INT16U dbg_sflash_flush(void)
    214          {
   \                     dbg_sflash_flush: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    215          	int address,pagebase;
    216          
    217          	if ( CLI_GetArgCnt() < 1 ) return INV_PRM;	// 중요한 액션이므로 안전 장치...
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??dbg_sflash_flush_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD10             POP      {R4,PC}
    218          
    219          	address = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_flush_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
   \   00000018   0x4604             MOV      R4,R0
    220          
    221          	pagebase = (address / SPI_FLASH_PAGE) * SPI_FLASH_PAGE;
    222          	
    223          	nv_sflash_md(address);
   \   0000001A   0x.... 0x....      BL       nv_sflash_md
    224          	
    225          	printk("\nErasing.. sector\n");
   \   0000001E   0x.... 0x....      ADR.W    R0,?_10
   \   00000022   0x.... 0x....      BL       printk
    226          
    227          	SPI_FLASH_PageErase(pagebase);		// 1Kbytes
   \   00000026   0x12E0             ASRS     R0,R4,#+11
   \   00000028   0xEB04 0x5010      ADD      R0,R4,R0, LSR #+20
   \   0000002C   0x1300             ASRS     R0,R0,#+12
   \   0000002E   0x0300             LSLS     R0,R0,#+12
   \   00000030   0x.... 0x....      BL       SPI_FLASH_PageErase
    228          
    229          	nv_sflash_md(address);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       nv_sflash_md
    230          
    231              return NO_DISPLAY;
   \   0000003A   0x20C9             MOVS     R0,#+201
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          INT16U dbg_sflash_flush_all(void)
    235          {
   \                     dbg_sflash_flush_all: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    236          	int i;
    237          
    238          	printk("\nErasing.. MCU Area\n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_11
   \   00000006   0x.... 0x....      BL       printk
    239          	
    240          #ifdef FLASH_AT45DB642D
    241          	for(i=0; i<4; i++)
    242          	{
    243          		printk("%d\r",i);
    244          		SPI_FLASH_PageErase(0x600000+(i*SPI_FLASH_SECTOR));		// 256*4 Kbytes
    245          	}
    246          #else
    247          	for(i=0; i<16; i++)
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xE009             B.N      ??dbg_sflash_flush_all_0
    248          	{
    249          		printk("%d\r",i);
   \                     ??dbg_sflash_flush_all_1: (+1)
   \   0000000E   0x4621             MOV      R1,R4
   \   00000010   0x....             ADR.N    R0,??DataTable37  ;; "%d\r"
   \   00000012   0x.... 0x....      BL       printk
    250          		SPI_FLASH_BlockErase(0x600000+(i*SPI_FLASH_BLOCK)); // 64*16 Kbyte
   \   00000016   0x0420             LSLS     R0,R4,#+16
   \   00000018   0xF500 0x00C0      ADD      R0,R0,#+6291456
   \   0000001C   0x.... 0x....      BL       SPI_FLASH_BlockErase
    251          	}
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \                     ??dbg_sflash_flush_all_0: (+1)
   \   00000022   0x2C10             CMP      R4,#+16
   \   00000024   0xDBF3             BLT.N    ??dbg_sflash_flush_all_1
    252          #endif		
    253          	printk("Done.\n");
   \   00000026   0x.... 0x....      ADR.W    R0,?_13
   \   0000002A   0x.... 0x....      BL       printk
    254          
    255              return NO_DISPLAY;
   \   0000002E   0x20C9             MOVS     R0,#+201
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    256          }
    257          

   \                                 In section .text, align 2, keep-with-next
    258          INT16U dbg_sflash_flash_chip(void)
    259          {
   \                     dbg_sflash_flash_chip: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    260          //	int i;
    261          
    262          	printk("\nChip Erasing..(C7H) \n");
   \   00000002   0x.... 0x....      ADR.W    R0,?_14
   \   00000006   0x.... 0x....      BL       printk
    263          	
    264          	SPI_FLASH_ChipErase(); 
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_ChipErase
    265          
    266          	printk("Done.\n");
   \   0000000E   0x.... 0x....      ADR.W    R0,?_13
   \   00000012   0x.... 0x....      BL       printk
    267          
    268          	return NO_DISPLAY;
   \   00000016   0x20C9             MOVS     R0,#+201
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    269          }
    270          
    271          

   \                                 In section .text, align 2, keep-with-next
    272          INT16U dbg_sflash_write(void)
    273          {
   \                     dbg_sflash_write: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    274          	int address,data;
    275          
    276          	if ( CLI_GetArgCnt() < 2 ) return INV_PRM;	
   \   00000004   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD201             BCS.N    ??dbg_sflash_write_0
   \   0000000C   0x20CA             MOVS     R0,#+202
   \   0000000E   0xBD16             POP      {R1,R2,R4,PC}
    277          
    278          	address = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_write_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       Argument
   \   00000016   0x.... 0x....      BL       comparison_num
   \   0000001A   0x4604             MOV      R4,R0
    279          	data = comparison_num((char*)P_ARG(2));
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       Argument
   \   00000022   0x.... 0x....      BL       comparison_num
   \   00000026   0x9000             STR      R0,[SP, #+0]
    280          
    281          	SPI_FLASH_Member_Write( (INT8U *)&data, address, 1 );
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x4621             MOV      R1,R4
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x.... 0x....      BL       SPI_FLASH_Member_Write
    282          
    283          	return NO_DISPLAY;
   \   00000032   0x20C9             MOVS     R0,#+201
   \   00000034   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    284          
    285          }
    286          

   \                                 In section .text, align 2, keep-with-next
    287          INT16U dbg_sflash_read(void)
    288          {
   \                     dbg_sflash_read: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    289          	int address;
    290          	INT8U data;
    291          
    292          	if ( CLI_GetArgCnt() < 1 ) return INV_PRM;	
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??dbg_sflash_read_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD02             POP      {R1,PC}
    293          
    294          	address = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_read_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
    295          	
    296          	SPI_FLASH_BufferRead( (INT8U *)&data, address, 1);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       SPI_FLASH_BufferRead
    297          
    298          	printd("\nSPI Flash(AT45DB642D) Read 1Byte : %X \n",data);
   \   00000022   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000026   0x.... 0x....      ADR.W    R0,?_15
   \   0000002A   0x.... 0x....      BL       printd
    299          
    300          	return NO_DISPLAY;
   \   0000002E   0x20C9             MOVS     R0,#+201
   \   00000030   0xBD02             POP      {R1,PC}          ;; return
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          INT16U dbg_sflash_select(void)
    304          {
   \                     dbg_sflash_select: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    305          	int sel;
    306          	
    307          	if ( CLI_GetArgCnt() < 1 ) return INV_PRM;	
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??dbg_sflash_select_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD02             POP      {R1,PC}
    308          
    309          	sel = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_select_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
    310          
    311          	if     (sel==0) 
    312          	{
    313          		//SPI_FLASH_CS_MCU();
    314          	}
    315          
    316          	printd("\nSPI Flash Control Select : %s(%d) \n", sel?"FPGA":"MCU", sel);
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??dbg_sflash_select_1
   \   0000001C   0x.... 0x....      ADR.W    R1,?_17
   \   00000020   0xE000             B.N      ??dbg_sflash_select_2
   \                     ??dbg_sflash_select_1: (+1)
   \   00000022   0x....             ADR.N    R1,??DataTable38  ;; "MCU"
   \                     ??dbg_sflash_select_2: (+1)
   \   00000024   0x4602             MOV      R2,R0
   \   00000026   0x.... 0x....      ADR.W    R0,?_16
   \   0000002A   0x.... 0x....      BL       printd
    317          
    318          	return NO_DISPLAY;
   \   0000002E   0x20C9             MOVS     R0,#+201
   \   00000030   0xBD02             POP      {R1,PC}          ;; return
    319          }
    320          

   \                                 In section .text, align 2, keep-with-next
    321          INT16U dbg_inittest_select(void)
    322          {
    323          
    324          //	if ( CLI_GetArgCnt() < 1 ) return INV_PRM;	
    325          
    326          //	sel = comparison_num((char*)P_ARG(1));
    327          //	SPI_FLASH_CS_MCU();
    328          //	SYS_Control_Init();
    329          #ifdef FLASH_AT45DB642D
    330          	SPI_FLASH_BinPageSize();
    331          #endif
    332          
    333          	return NO_DISPLAY;
   \                     dbg_inittest_select: (+1)
   \   00000000   0x20C9             MOVS     R0,#+201
   \   00000002   0x4770             BX       LR               ;; return
    334          }
    335          

   \                                 In section .text, align 2, keep-with-next
    336          INT16U dbg_sflash_crc(void)
    337          {
   \                     dbg_sflash_crc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    338          	int sel_add, filelen;
    339          	INT16U ramCRC;
    340          	
    341          	if(CLI_GetArgCnt() < 2) return INV_PRM;
   \   00000002   0x.... 0x....      BL       CLI_GetArgCnt
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD201             BCS.N    ??dbg_sflash_crc_0
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0xBD10             POP      {R4,PC}
    342          
    343          	sel_add = comparison_num((char*)P_ARG(1));
   \                     ??dbg_sflash_crc_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       Argument
   \   00000014   0x.... 0x....      BL       comparison_num
   \   00000018   0x4604             MOV      R4,R0
    344          	filelen = comparison_num((char*)P_ARG(2));
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       Argument
   \   00000020   0x.... 0x....      BL       comparison_num
    345          
    346          	if(sel_add==0)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD109             BNE.N    ??dbg_sflash_crc_1
    347          	{
    348          		ramCRC = GetFlashAreaCRC(DOWNLOAD_SECTOR,filelen);
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0xF44F 0x0060      MOV      R0,#+14680064
   \   0000002E   0x.... 0x....      BL       GetFlashAreaCRC
    349          		printk("\nCheck wrote flash fileCRC(MCU): [%04X]\n",(INT16U)ramCRC);
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x.... 0x....      ADR.W    R0,?_19
   \   00000038   0x.... 0x....      BL       printk
    350          	}
    351          
    352          	return NO_DISPLAY;
   \                     ??dbg_sflash_crc_1: (+1)
   \   0000003C   0x20C9             MOVS     R0,#+201
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    353          }
    354          
    355          
    356          /**********************************************************************************************************
    357          *                                      GetFlashAreaCRC
    358          *
    359          * 설명        : 플레쉬 메모리에 저장된 데이터를 읽어와 CRC를 계산한다.
    360          * 전달인자    : faddr - 읽어올 데이터의 시작 주소
    361          *				size  - 읽어올 데이터 사이즈 
    362          * 리턴값      : CRC 값 
    363          **********************************************************************************************************/

   \                                 In section .bss, align 4
    364          static char getCRCBuf[SPI_FLASH_PAGE];
   \                     getCRCBuf:
   \   00000000                      DS8 4096

   \                                 In section .text, align 2, keep-with-next
    365          INT16U GetFlashAreaCRC(int faddr, int size)
    366          {
   \                     GetFlashAreaCRC: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    367          	INT16U ramCRC=0;
   \   00000006   0x2500             MOVS     R5,#+0
    368          	int i, quot, remain;
    369          
    370          	quot = size / SPI_FLASH_PAGE;
   \   00000008   0x12C8             ASRS     R0,R1,#+11
   \   0000000A   0xEB01 0x5010      ADD      R0,R1,R0, LSR #+20
   \   0000000E   0x1306             ASRS     R6,R0,#+12
    371          	remain  = size % SPI_FLASH_PAGE;
   \   00000010   0xEBA1 0x3706      SUB      R7,R1,R6, LSL #+12
    372          
    373          	for(i=0; i<quot; i++)
   \   00000014   0x46A8             MOV      R8,R5
   \   00000016   0x.... 0x....      LDR.W    R9,??DataTable38_4
   \   0000001A   0xE00F             B.N      ??GetFlashAreaCRC_0
    374          	{
    375          		SPI_FLASH_BufferRead((u8 *)getCRCBuf, faddr+(i*SPI_FLASH_PAGE), SPI_FLASH_PAGE);
   \                     ??GetFlashAreaCRC_1: (+1)
   \   0000001C   0xF44F 0x5280      MOV      R2,#+4096
   \   00000020   0xEB04 0x3108      ADD      R1,R4,R8, LSL #+12
   \   00000024   0x4648             MOV      R0,R9
   \   00000026   0x.... 0x....      BL       SPI_FLASH_BufferRead
    376          		ramCRC = GenerateCRC((INT8U*)getCRCBuf, SPI_FLASH_PAGE, ramCRC);
   \   0000002A   0x462A             MOV      R2,R5
   \   0000002C   0xF44F 0x5180      MOV      R1,#+4096
   \   00000030   0x4648             MOV      R0,R9
   \   00000032   0x.... 0x....      BL       GenerateCRC
   \   00000036   0x4605             MOV      R5,R0
    377          	}
   \   00000038   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??GetFlashAreaCRC_0: (+1)
   \   0000003C   0x45B0             CMP      R8,R6
   \   0000003E   0xDBED             BLT.N    ??GetFlashAreaCRC_1
    378          
    379          	if(remain){
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD00C             BEQ.N    ??GetFlashAreaCRC_2
    380          		SPI_FLASH_BufferRead((u8 *)getCRCBuf, faddr+(i*SPI_FLASH_PAGE), SPI_FLASH_PAGE);
   \   00000044   0xF44F 0x5280      MOV      R2,#+4096
   \   00000048   0xEB04 0x3108      ADD      R1,R4,R8, LSL #+12
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       SPI_FLASH_BufferRead
    381          		ramCRC = GenerateCRC((INT8U*)getCRCBuf, remain, ramCRC);
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0x4639             MOV      R1,R7
   \   00000056   0x4648             MOV      R0,R9
   \   00000058   0x.... 0x....      BL       GenerateCRC
   \   0000005C   0x4605             MOV      R5,R0
    382          	}
    383          	
    384          	return ramCRC;
   \                     ??GetFlashAreaCRC_2: (+1)
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    385          }
    386          
    387          
    388          /**********************************************************************************************************
    389          *                                      nv_ldstr
    390          *
    391          * 설명        : 플레쉬 메모리에 데이터를 쓰거나 읽어오는 함수. SPI_FLASH_LoadSave 함수의 하위 함수.		
    392          * 전달인자    : fbase - 메모리의 시작 번지 
    393          *               pdata - 데이터 버퍼
    394          *               sz    - 데이터 사이즈 
    395          *               rw    - 'read' 'write'
    396          * 리턴값      : 에러값 
    397          **********************************************************************************************************/
    398          //Non-volatile (비 휘 발 성) memory write or readout.

   \                                 In section .text, align 2, keep-with-next
    399          static int nv_ldstr(int fbase, void *pdata, int sz, int rw)
    400          {
   \                     nv_ldstr: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4615             MOV      R5,R2
    401          	INT16U ramCRC,getflashCRC,rdflashCRC;
    402          
    403          	// WRITE 동작 
    404          	if(rw == SAVE){
   \   0000000C   0x12E8             ASRS     R0,R5,#+11
   \   0000000E   0xEB05 0x5010      ADD      R0,R5,R0, LSR #+20
   \   00000012   0x1306             ASRS     R6,R0,#+12
   \   00000014   0xF3C5 0x070B      UBFX     R7,R5,#+0,#+12
   \   00000018   0xF640 0x78FE      MOVW     R8,#+4094
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD143             BNE.N    ??nv_ldstr_0
    405          		// 쓰고자 하는 데이터에 대한 CRC를 계산
    406          		ramCRC = GenerateCRC((INT8U*)pdata, sz, 0);
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4648             MOV      R0,R9
   \   00000026   0x.... 0x....      BL       GenerateCRC
   \   0000002A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    407          		//printk("\n--W--> ramCRC: 0x%04X\n",ramCRC);
    408          		// 데이터를 플레쉬에 저장 
    409          		SPI_FLASH_Member_Write((u8 *)pdata, fbase, sz);//write data
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x4602             MOV      R2,R0
   \   00000032   0xB292             UXTH     R2,R2
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x4648             MOV      R0,R9
   \   00000038   0x.... 0x....      BL       SPI_FLASH_Member_Write
    410          		// Page의 마지막 2Byte 위치에 CRC 저장.
    411          		SPI_FLASH_Member_Write((u8 *)&ramCRC, fbase + (SPI_FLASH_PAGE * nEXTBLKSZ(sz) - sizeof(ramCRC)), sizeof(ramCRC));//write crc
   \   0000003C   0x4547             CMP      R7,R8
   \   0000003E   0xDA01             BGE.N    ??nv_ldstr_1
   \   00000040   0x1C70             ADDS     R0,R6,#+1
   \   00000042   0xE000             B.N      ??nv_ldstr_2
   \                     ??nv_ldstr_1: (+1)
   \   00000044   0x1CB0             ADDS     R0,R6,#+2
   \                     ??nv_ldstr_2: (+1)
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0xEB04 0x3000      ADD      R0,R4,R0, LSL #+12
   \   0000004C   0x1E81             SUBS     R1,R0,#+2
   \   0000004E   0xF10D 0x0002      ADD      R0,SP,#+2
   \   00000052   0x.... 0x....      BL       SPI_FLASH_Member_Write
    412          		// 저장한 CRC를 읽어온다 
    413          		SPI_FLASH_BufferRead((u8 *)&rdflashCRC, fbase + (SPI_FLASH_PAGE * nEXTBLKSZ(sz) - sizeof(rdflashCRC)), sizeof(rdflashCRC));//read crc
   \   00000056   0x4547             CMP      R7,R8
   \   00000058   0xDA01             BGE.N    ??nv_ldstr_3
   \   0000005A   0x1C70             ADDS     R0,R6,#+1
   \   0000005C   0xE000             B.N      ??nv_ldstr_4
   \                     ??nv_ldstr_3: (+1)
   \   0000005E   0x1CB0             ADDS     R0,R6,#+2
   \                     ??nv_ldstr_4: (+1)
   \   00000060   0x2202             MOVS     R2,#+2
   \   00000062   0xEB04 0x3000      ADD      R0,R4,R0, LSL #+12
   \   00000066   0x1E81             SUBS     R1,R0,#+2
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x.... 0x....      BL       SPI_FLASH_BufferRead
    414          		//printk("--W--> rdflashCRC: 0x%04X\n",rdflashCRC);
    415          		// 저장한 데이터에 대한 CRC를 계산 
    416          		getflashCRC = GetFlashAreaCRC(fbase, sz);
   \   0000006E   0x4629             MOV      R1,R5
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       GetFlashAreaCRC
   \   00000076   0x4682             MOV      R10,R0
    417          		//printk("--W--> getflashCRC: 0x%04X\n",getflashCRC);
    418          		// ramCRC와 계산된 CRC를 비교   
    419          		if(ramCRC != getflashCRC){
   \   00000078   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \   0000007C   0x4551             CMP      R1,R10
   \   0000007E   0xD007             BEQ.N    ??nv_ldstr_5
    420          			printk("-> ramCRC:%X, getflashCRC:%X \n", ramCRC, getflashCRC);
   \   00000080   0x4652             MOV      R2,R10
   \   00000082   0x.... 0x....      ADR.W    R0,?_20
   \   00000086   0x.... 0x....      BL       printk
    421          			return -1;
   \   0000008A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000008E   0xE02E             B.N      ??nv_ldstr_6
    422          		}
    423          		// ramCRC와 플레쉬에 저장한 CRC를 비교
    424          		if(ramCRC != rdflashCRC){
   \                     ??nv_ldstr_5: (+1)
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   00000096   0x4290             CMP      R0,R2
   \   00000098   0xD028             BEQ.N    ??nv_ldstr_7
    425          			printk("-> ramCRC:%X, rdflashCRC:%X \n", ramCRC, rdflashCRC);
   \   0000009A   0x.... 0x....      ADR.W    R0,?_21
   \   0000009E   0x.... 0x....      BL       printk
    426          			return -2;
   \   000000A2   0xF06F 0x0001      MVN      R0,#+1
   \   000000A6   0xE022             B.N      ??nv_ldstr_6
    427          		}
    428                  
    429          	}
    430          	// READ 동작 
    431          	else{
    432          		// 저장한 데이터에 대한 CRC를 계산 
    433          		getflashCRC = GetFlashAreaCRC(fbase, sz);
   \                     ??nv_ldstr_0: (+1)
   \   000000A8   0x4629             MOV      R1,R5
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       GetFlashAreaCRC
   \   000000B0   0x4682             MOV      R10,R0
    434          		//printk("\n--R--> getflashCRC: 0x%04X\n",getflashCRC);
    435          		// 저장한 CRC를 읽어온다 
    436          		SPI_FLASH_BufferRead((u8 *)&rdflashCRC, fbase + (SPI_FLASH_PAGE * nEXTBLKSZ(sz) - sizeof(rdflashCRC)), sizeof(rdflashCRC));//read crc
   \   000000B2   0x4547             CMP      R7,R8
   \   000000B4   0xDA01             BGE.N    ??nv_ldstr_8
   \   000000B6   0x1C70             ADDS     R0,R6,#+1
   \   000000B8   0xE000             B.N      ??nv_ldstr_9
   \                     ??nv_ldstr_8: (+1)
   \   000000BA   0x1CB0             ADDS     R0,R6,#+2
   \                     ??nv_ldstr_9: (+1)
   \   000000BC   0x2202             MOVS     R2,#+2
   \   000000BE   0xEB04 0x3000      ADD      R0,R4,R0, LSL #+12
   \   000000C2   0x1E81             SUBS     R1,R0,#+2
   \   000000C4   0x4668             MOV      R0,SP
   \   000000C6   0x.... 0x....      BL       SPI_FLASH_BufferRead
    437          		//printk("--R--> rdflashCRC: 0x%04X\n",rdflashCRC);
    438          		// 계산된 CRC와 저장한 CRC를 비교	
    439          		if(getflashCRC != rdflashCRC){
   \   000000CA   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   000000CE   0x4592             CMP      R10,R2
   \   000000D0   0xD007             BEQ.N    ??nv_ldstr_10
    440          			printk("-> getflashCRC:%X, rdflashCRC:%X \n", getflashCRC, rdflashCRC);
   \   000000D2   0x4651             MOV      R1,R10
   \   000000D4   0x.... 0x....      ADR.W    R0,?_22
   \   000000D8   0x.... 0x....      BL       printk
    441          			return -2;
   \   000000DC   0xF06F 0x0001      MVN      R0,#+1
   \   000000E0   0xE005             B.N      ??nv_ldstr_6
    442          		}
    443          		// 플레쉬에 저장된 데이터를 읽어 온다 
    444          		SPI_FLASH_BufferRead((u8 *)pdata, fbase, sz);
   \                     ??nv_ldstr_10: (+1)
   \   000000E2   0x462A             MOV      R2,R5
   \   000000E4   0x4621             MOV      R1,R4
   \   000000E6   0x4648             MOV      R0,R9
   \   000000E8   0x.... 0x....      BL       SPI_FLASH_BufferRead
    445          	}
    446          
    447          	return 0;
   \                     ??nv_ldstr_7: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \                     ??nv_ldstr_6: (+1)
   \   000000EE   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    448          }
    449          
    450          
    451          /**********************************************************************************************************
    452          *                                      SPI_FLASH_LoadSave
    453          *
    454          * 설명        : 플레쉬 메모리에 구조체 데이터를 쓰거나 읽어 오는 함수. 구조체 사이즈 만큼 쓰거나 읽는다  
    455          * 전달인자    : itemNum - 구조체 영역에 해당하는 넘버
    456          *               rw      - 'SAVE' or 'NO_SAVE'
    457          * 리턴값      : 에러값 
    458          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    459          int SPI_FLASH_LoadSave(int itemNum, int rw)
    460          {
   \                     SPI_FLASH_LoadSave: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    461          	int ret = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    462          	//INT8U back_amp_onoff[2];
    463          
    464          	switch(itemNum){
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD002             BEQ.N    ??SPI_FLASH_LoadSave_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD015             BEQ.N    ??SPI_FLASH_LoadSave_1
   \   00000010   0xE01C             B.N      ??SPI_FLASH_LoadSave_2
    465          		case PROJECT_SAVE:
    466          			// 부트로더와의 연관 관계로 인해 PROJECT_BASE에 대해서는 CRC 체크를 하지 않는다  
    467          			if(rw == SAVE)
   \                     ??SPI_FLASH_LoadSave_0: (+1)
   \   00000012   0x....             LDR.N    R7,??DataTable38_5
   \   00000014   0x2D01             CMP      R5,#+1
   \   00000016   0xD10A             BNE.N    ??SPI_FLASH_LoadSave_3
    468          			{
    469          				SPI_FLASH_PageErase(PROJECT_BASE);
   \   00000018   0xF44F 0x0050      MOV      R0,#+13631488
   \   0000001C   0x.... 0x....      BL       SPI_FLASH_PageErase
    470          				SPI_FLASH_BufferWrite((INT8U *)&tPrjcode.project_code[0], PROJECT_BASE, sizeof(Prjcode_t));
   \   00000020   0x221C             MOVS     R2,#+28
   \   00000022   0xF44F 0x0150      MOV      R1,#+13631488
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       SPI_FLASH_BufferWrite
   \   0000002C   0xE00F             B.N      ??SPI_FLASH_LoadSave_4
    471          			}
    472          			else
    473          			{
    474          				SPI_FLASH_BufferRead((INT8U *)&tPrjcode.project_code[0], PROJECT_BASE, sizeof(Prjcode_t));
   \                     ??SPI_FLASH_LoadSave_3: (+1)
   \   0000002E   0x221C             MOVS     R2,#+28
   \   00000030   0xF44F 0x0150      MOV      R1,#+13631488
   \   00000034   0x4638             MOV      R0,R7
   \   00000036   0x.... 0x....      BL       SPI_FLASH_BufferRead
   \   0000003A   0xE008             B.N      ??SPI_FLASH_LoadSave_4
    475          			}
    476          			break;
    477          			
    478          		case SYSTEM_SAVE:
    479          			ret = nv_ldstr(SYSTEM_BASE, (void *)&SysSet.Sys_firstboot, sizeof(SysControl_t), rw);
   \                     ??SPI_FLASH_LoadSave_1: (+1)
   \   0000003C   0x462B             MOV      R3,R5
   \   0000003E   0x22C9             MOVS     R2,#+201
   \   00000040   0x....             LDR.N    R1,??DataTable38_6
   \   00000042   0x....             LDR.N    R0,??DataTable38_2  ;; 0xd01000
   \   00000044   0x.... 0x....      BL       nv_ldstr
   \   00000048   0x4606             MOV      R6,R0
    480          			break;
   \   0000004A   0xE000             B.N      ??SPI_FLASH_LoadSave_4
    481                  
    482          		default:
    483          			ret = 100;
   \                     ??SPI_FLASH_LoadSave_2: (+1)
   \   0000004C   0x2664             MOVS     R6,#+100
    484          			break;		
    485          	}
    486          
    487          	if(ret){
   \                     ??SPI_FLASH_LoadSave_4: (+1)
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD00C             BEQ.N    ??SPI_FLASH_LoadSave_5
    488          		printk("--> NV mem [%s] errorcode %d item:%d\n",rw?"Write":"Read",ret,itemNum);
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD002             BEQ.N    ??SPI_FLASH_LoadSave_6
   \   00000056   0x.... 0x....      ADR.W    R1,?_24
   \   0000005A   0xE001             B.N      ??SPI_FLASH_LoadSave_7
   \                     ??SPI_FLASH_LoadSave_6: (+1)
   \   0000005C   0x.... 0x....      ADR.W    R1,?_25
   \                     ??SPI_FLASH_LoadSave_7: (+1)
   \   00000060   0x4623             MOV      R3,R4
   \   00000062   0x4632             MOV      R2,R6
   \   00000064   0x.... 0x....      ADR.W    R0,?_23
   \   00000068   0x.... 0x....      BL       printk
    489          	}
    490          
    491          	
    492          	return ret;
   \                     ??SPI_FLASH_LoadSave_5: (+1)
   \   0000006C   0x4630             MOV      R0,R6
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    493          	
    494          }
    495          
    496          /**********************************************************************************************************
    497          *                                      SPI_FLASH_Member_Write
    498          *
    499          * 설명        : 데이터를 쓰고자 하는 주소 위치에 해당하는 Page를 자동으로 계산하여 해당 Sector만 데이터를 업데이트한다 	
    500          * 전달인자    : pBuffer        - 저장할 데이터 
    501          *				flashWaddr     - 저장할 구조체의 시작 주소 
    502          *				NumByteToWrite - 저장할 데이터 사이즈 	
    503          * 리턴값      : 없음 
    504          **********************************************************************************************************/

   \                                 In section .bss, align 4
    505          static INT8U pDumpBuff[SPI_FLASH_PAGE];
   \                     pDumpBuff:
   \   00000000                      DS8 4096
    506          

   \                                 In section .text, align 2, keep-with-next
    507          void SPI_FLASH_Member_Write(u8* pBuffer, u32 flashWaddr, u16 NumByteToWrite)
    508          {
   \                     SPI_FLASH_Member_Write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4617             MOV      R7,R2
    509          	//INT8U err;
    510          	int CurPageAddr,inPgWsz,inPgWoffset,reMainWsz,WrittenSz;
    511          
    512          	if(BSP_SaveSem == NULL)
   \   0000000A   0x....             LDR.N    R5,??DataTable38_1
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??SPI_FLASH_Member_Write_0
    513          	{
    514          		printk("%s err\n",__func__);
   \   00000012   0x.... 0x....      ADR.W    R1,`SPI_FLASH_Member_Write::__func__`
   \   00000016   0x.... 0x....      ADR.W    R0,?_26
   \   0000001A   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   0000001E   0x.... 0x....      B.W      printk
    515          		return;
    516          	}
    517          	if(xSemaphoreTake(BSP_SaveSem, ( portTickType ) 10 )  == pdTRUE)
   \                     ??SPI_FLASH_Member_Write_0: (+1)
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x220A             MOVS     R2,#+10
   \   00000026   0x4619             MOV      R1,R3
   \   00000028   0x.... 0x....      BL       xQueueGenericReceive
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD158             BNE.N    ??SPI_FLASH_Member_Write_1
    518          	{
    519          	
    520          		CurPageAddr = flashWaddr & ~(SPI_FLASH_PAGE-1);			// 처음 시도될 Sector의 base주소.
   \   00000030   0xEA4F 0x3618      LSR      R6,R8,#+12
   \   00000034   0x0336             LSLS     R6,R6,#+12
    521          		inPgWoffset = flashWaddr % SPI_FLASH_PAGE; 				// Sector옵셋사이즈 즉변경시킬 시작포인트 .
   \   00000036   0xF3C8 0x0A0B      UBFX     R10,R8,#+0,#+12
    522          
    523          		if( NumByteToWrite >= (SPI_FLASH_PAGE - inPgWoffset) )
   \   0000003A   0xF5CA 0x5080      RSB      R0,R10,#+4096
   \   0000003E   0x46B8             MOV      R8,R7
   \   00000040   0x4287             CMP      R7,R0
   \   00000042   0xDD00             BLE.N    ??SPI_FLASH_Member_Write_2
   \   00000044   0x4680             MOV      R8,R0
    524          			inPgWsz = SPI_FLASH_PAGE - inPgWoffset;
    525          		else
    526          			inPgWsz = NumByteToWrite;
    527          			
    528          	/*-----------------------------------------------------------------------------------------------------*/	
    529          		SPI_FLASH_BufferRead(pDumpBuff, CurPageAddr ,SPI_FLASH_PAGE);			// 첫번쩨 블럭에 대한 처리
   \                     ??SPI_FLASH_Member_Write_2: (+1)
   \   00000046   0x.... 0x....      LDR.W    R9,??DataTable38_7
   \   0000004A   0xF44F 0x5280      MOV      R2,#+4096
   \   0000004E   0x4631             MOV      R1,R6
   \   00000050   0x4648             MOV      R0,R9
   \   00000052   0x.... 0x....      BL       SPI_FLASH_BufferRead
    530          
    531          		if (memcmp((char *)((int)pDumpBuff + inPgWoffset), pBuffer, inPgWsz )){ // 다르냐??
   \   00000056   0x44CA             ADD      R10,R10,R9
   \   00000058   0x4642             MOV      R2,R8
   \   0000005A   0x4621             MOV      R1,R4
   \   0000005C   0x4650             MOV      R0,R10
   \   0000005E   0x.... 0x....      BL       memcmp
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD00D             BEQ.N    ??SPI_FLASH_Member_Write_3
    532          			memcpy((char *)((int)pDumpBuff + inPgWoffset), pBuffer, inPgWsz );	// 데이터 변경.
   \   00000066   0x4642             MOV      R2,R8
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0x4650             MOV      R0,R10
   \   0000006C   0x.... 0x....      BL       __aeabi_memcpy
    533          			SPI_FLASH_PageErase(CurPageAddr);
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x.... 0x....      BL       SPI_FLASH_PageErase
    534          			SPI_FLASH_BufferWrite(pDumpBuff, CurPageAddr, SPI_FLASH_PAGE);		// 데이터 쓰기.
   \   00000076   0xF44F 0x5280      MOV      R2,#+4096
   \   0000007A   0x4631             MOV      R1,R6
   \   0000007C   0x4648             MOV      R0,R9
   \   0000007E   0x.... 0x....      BL       SPI_FLASH_BufferWrite
    535          		}
    536          	/*-----------------------------------------------------------------------------------------------------*/	
    537          
    538          		reMainWsz = NumByteToWrite - inPgWsz;							// 총 써야할 데이터의 갯수 중 이미 쓴 데이터의 갯수를 구한다.
   \                     ??SPI_FLASH_Member_Write_3: (+1)
   \   00000082   0xEBA7 0x0708      SUB      R7,R7,R8
    539          
    540          		WrittenSz = inPgWsz;
   \   00000086   0xE01C             B.N      ??SPI_FLASH_Member_Write_4
    541          
    542          		while(1)
    543          		{	
    544          			CurPageAddr += SPI_FLASH_PAGE; 						// 다음Sector로 주소 이동. 
    545          
    546          			if( reMainWsz == 0 ){
    547          				printk("Write Complete..\n");
    548          				break;
    549          			}															// 두블럭 이상 지웠다 써야 할 정도의 큰 데이터 관리 							 
    550          			else if( reMainWsz >= SPI_FLASH_PAGE ){				// 다음Sector에서 해결될 경우.
    551          																			
    552          				inPgWsz = SPI_FLASH_PAGE;
    553          				
    554          	/*-----------------------------------------------------------------------------------------------------*/	
    555          				SPI_FLASH_BufferRead(pDumpBuff, CurPageAddr, SPI_FLASH_PAGE);
   \                     ??SPI_FLASH_Member_Write_5: (+1)
   \   00000088   0x.... 0x....      BL       SPI_FLASH_BufferRead
    556          
    557          				if (memcmp((char *)pDumpBuff, (char *)((int)pBuffer+WrittenSz), inPgWsz)){	// 다르냐??
   \   0000008C   0xF44F 0x5280      MOV      R2,#+4096
   \   00000090   0x4651             MOV      R1,R10
   \   00000092   0x4648             MOV      R0,R9
   \   00000094   0x.... 0x....      BL       memcmp
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD00E             BEQ.N    ??SPI_FLASH_Member_Write_6
    558          					memcpy((char *)pDumpBuff, (char *)((int)pBuffer+WrittenSz), inPgWsz);	// 데이터 변경.
   \   0000009C   0xF44F 0x5280      MOV      R2,#+4096
   \   000000A0   0x4651             MOV      R1,R10
   \   000000A2   0x4648             MOV      R0,R9
   \   000000A4   0x.... 0x....      BL       __aeabi_memcpy
    559          					SPI_FLASH_PageErase(CurPageAddr);
   \   000000A8   0x4630             MOV      R0,R6
   \   000000AA   0x.... 0x....      BL       SPI_FLASH_PageErase
    560          					SPI_FLASH_BufferWrite((u8 *)pDumpBuff, CurPageAddr, SPI_FLASH_PAGE); 	// 데이터 쓰기.
   \   000000AE   0xF44F 0x5280      MOV      R2,#+4096
   \   000000B2   0x4631             MOV      R1,R6
   \   000000B4   0x4648             MOV      R0,R9
   \   000000B6   0x.... 0x....      BL       SPI_FLASH_BufferWrite
    561          				}
    562          	/*-----------------------------------------------------------------------------------------------------*/	
    563          
    564          				WrittenSz += inPgWsz;
   \                     ??SPI_FLASH_Member_Write_6: (+1)
   \   000000BA   0xF508 0x5880      ADD      R8,R8,#+4096
    565          				reMainWsz -= SPI_FLASH_PAGE;
   \   000000BE   0xF5A7 0x5780      SUB      R7,R7,#+4096
    566          			}
   \                     ??SPI_FLASH_Member_Write_4: (+1)
   \   000000C2   0xF506 0x5680      ADD      R6,R6,#+4096
   \   000000C6   0x2F00             CMP      R7,#+0
   \   000000C8   0xD10D             BNE.N    ??SPI_FLASH_Member_Write_7
   \   000000CA   0x.... 0x....      ADR.W    R0,?_27
   \   000000CE   0x.... 0x....      BL       printk
    567          			else{														// Sector보다 작으므로 이곳에서는 단순히 Sector를 새로 쓴다.
    568          				
    569          				inPgWsz = reMainWsz;
    570          				
    571          	/*-----------------------------------------------------------------------------------------------------*/				
    572          				SPI_FLASH_BufferRead(pDumpBuff, CurPageAddr, SPI_FLASH_PAGE);
    573          
    574          				if (memcmp((char *)pDumpBuff, (char *)((int)pBuffer+WrittenSz) ,inPgWsz)){	// 다르냐??
    575          					memcpy((char *)pDumpBuff, (char *)((int)pBuffer+WrittenSz) ,inPgWsz);	// 데이터 변경.
    576          					SPI_FLASH_PageErase(CurPageAddr);
    577          					SPI_FLASH_BufferWrite((u8 *)pDumpBuff, CurPageAddr, SPI_FLASH_PAGE); 	// 데이터 쓰기.
    578          				}
    579          	/*-----------------------------------------------------------------------------------------------------*/	
    580          
    581          				WrittenSz += inPgWsz;
    582          				reMainWsz -= inPgWsz;
    583          			}
    584          		}
    585          		
    586          		xSemaphoreGive(BSP_SaveSem);
   \   000000D2   0x2300             MOVS     R3,#+0
   \   000000D4   0x461A             MOV      R2,R3
   \   000000D6   0x4611             MOV      R1,R2
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000DE   0x.... 0x....      B.W      xQueueGenericSend
    587          	}
    588          }
   \                     ??SPI_FLASH_Member_Write_1: (+1)
   \   000000E2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??SPI_FLASH_Member_Write_7: (+1)
   \   000000E6   0xEB08 0x0A04      ADD      R10,R8,R4
   \   000000EA   0xF5B7 0x5F80      CMP      R7,#+4096
   \   000000EE   0xF44F 0x5280      MOV      R2,#+4096
   \   000000F2   0x4631             MOV      R1,R6
   \   000000F4   0x4648             MOV      R0,R9
   \   000000F6   0xDAC7             BGE.N    ??SPI_FLASH_Member_Write_5
   \   000000F8   0x.... 0x....      BL       SPI_FLASH_BufferRead
   \   000000FC   0x463A             MOV      R2,R7
   \   000000FE   0x4651             MOV      R1,R10
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x.... 0x....      BL       memcmp
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD00D             BEQ.N    ??SPI_FLASH_Member_Write_8
   \   0000010A   0x463A             MOV      R2,R7
   \   0000010C   0x4651             MOV      R1,R10
   \   0000010E   0x4648             MOV      R0,R9
   \   00000110   0x.... 0x....      BL       __aeabi_memcpy
   \   00000114   0x4630             MOV      R0,R6
   \   00000116   0x.... 0x....      BL       SPI_FLASH_PageErase
   \   0000011A   0xF44F 0x5280      MOV      R2,#+4096
   \   0000011E   0x4631             MOV      R1,R6
   \   00000120   0x4648             MOV      R0,R9
   \   00000122   0x.... 0x....      BL       SPI_FLASH_BufferWrite
   \                     ??SPI_FLASH_Member_Write_8: (+1)
   \   00000126   0x44B8             ADD      R8,R7,R8
   \   00000128   0x2700             MOVS     R7,#+0
   \   0000012A   0xE7CA             B.N      ??SPI_FLASH_Member_Write_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x25 0x63          DC8      0x25, 0x63, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x25 0x64          DC8      "%d\r"
   \              0x0D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x4D 0x43          DC8      "MCU"
   \              0x55 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x........         DC32     BSP_SaveSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x00D01000         DC32     0xd01000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x00FFFFF0         DC32     0xfffff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \   00000000   0x........         DC32     getCRCBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \   00000000   0x........         DC32     tPrjcode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \   00000000   0x........         DC32     SysSet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \   00000000   0x........         DC32     pDumpBuff

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_1:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x63          DC8 "%c"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_3:
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x25 0x64          DC8 "%d\015"
   \              0x0D 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x4D 0x43          DC8 "MCU"
   \              0x55 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x0A 0x0A          DC8 "\012\012[%05X]ORG:%02X ==> %02X\012"
   \              0x5B 0x25    
   \              0x30 0x35    
   \              0x58 0x5D    
   \              0x4F 0x52    
   \              0x47 0x3A    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x20 0x3D    
   \              0x3D 0x3E    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x58 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0A 0x25          DC8 "\012%05X : "
   \              0x30 0x35    
   \              0x58 0x20    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x0A 0x53          DC8 "\012SPI flash ID : %06X\012"
   \              0x50 0x49    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x49    
   \              0x44 0x20    
   \              0x3A 0x20    
   \              0x25 0x30    
   \              0x36 0x58    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x0A 0x2A          DC8 "\012*** SFlash Memory Map ***\012"
   \              0x2A 0x2A    
   \              0x20 0x53    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x20    
   \              0x4D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x20 0x4D    
   \              0x61 0x70    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x50 0x52          DC8 "PROJECT_BASE           :%05X (%04X)\012"
   \              0x4F 0x4A    
   \              0x45 0x43    
   \              0x54 0x5F    
   \              0x42 0x41    
   \              0x53 0x45    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x25 0x30    
   \              0x35 0x58    
   \              0x20 0x28    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x29 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x53 0x59          DC8 "SYSTEM_BASE            :%05X (%04X)\012"
   \              0x53 0x54    
   \              0x45 0x4D    
   \              0x5F 0x42    
   \              0x41 0x53    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x25 0x30    
   \              0x35 0x58    
   \              0x20 0x28    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x29 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x0A 0x45          DC8 "\012Erasing.. sector\012"
   \              0x72 0x61    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x2E 0x2E    
   \              0x20 0x73    
   \              0x65 0x63    
   \              0x74 0x6F    
   \              0x72 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x0A 0x45          DC8 "\012Erasing.. MCU Area\012"
   \              0x72 0x61    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x2E 0x2E    
   \              0x20 0x4D    
   \              0x43 0x55    
   \              0x20 0x41    
   \              0x72 0x65    
   \              0x61 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x44 0x6F          DC8 "Done.\012"
   \              0x6E 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x0A 0x43          DC8 "\012Chip Erasing..(C7H) \012"
   \              0x68 0x69    
   \              0x70 0x20    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x69 0x6E    
   \              0x67 0x2E    
   \              0x2E 0x28    
   \              0x43 0x37    
   \              0x48 0x29    
   \              0x20 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x0A 0x53          DC8 "\012SPI Flash(AT45DB642D) Read 1Byte : %X \012"
   \              0x50 0x49    
   \              0x20 0x46    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x28 0x41    
   \              0x54 0x34    
   \              0x35 0x44    
   \              0x42 0x36    
   \              0x34 0x32    
   \              0x44 0x29    
   \              0x20 0x52    
   \              0x65 0x61    
   \              0x64 0x20    
   \              0x31 0x42    
   \              0x79 0x74    
   \              0x65 0x20    
   \              0x3A 0x20    
   \              0x25 0x58    
   \              0x20 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x0A 0x53          DC8 "\012SPI Flash Control Select : %s(%d) \012"
   \              0x50 0x49    
   \              0x20 0x46    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x43    
   \              0x6F 0x6E    
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x20 0x53    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x28 0x25    
   \              0x64 0x29    
   \              0x20 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x46 0x50          DC8 "FPGA"
   \              0x47 0x41    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x0A 0x43          DC8 "\012Check wrote flash fileCRC(MCU): [%04X]\012"
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x77    
   \              0x72 0x6F    
   \              0x74 0x65    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x66    
   \              0x69 0x6C    
   \              0x65 0x43    
   \              0x52 0x43    
   \              0x28 0x4D    
   \              0x43 0x55    
   \              0x29 0x3A    
   \              0x20 0x5B    
   \              0x25 0x30    
   \              0x34 0x58    
   \              0x5D 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \   00000000   0x2D 0x3E          DC8 "-> ramCRC:%X, getflashCRC:%X \012"
   \              0x20 0x72    
   \              0x61 0x6D    
   \              0x43 0x52    
   \              0x43 0x3A    
   \              0x25 0x58    
   \              0x2C 0x20    
   \              0x67 0x65    
   \              0x74 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x43 0x52    
   \              0x43 0x3A    
   \              0x25 0x58    
   \              0x20 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x2D 0x3E          DC8 "-> ramCRC:%X, rdflashCRC:%X \012"
   \              0x20 0x72    
   \              0x61 0x6D    
   \              0x43 0x52    
   \              0x43 0x3A    
   \              0x25 0x58    
   \              0x2C 0x20    
   \              0x72 0x64    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x43    
   \              0x52 0x43    
   \              0x3A 0x25    
   \              0x58 0x20    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x2D 0x3E          DC8 "-> getflashCRC:%X, rdflashCRC:%X \012"
   \              0x20 0x67    
   \              0x65 0x74    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x43    
   \              0x52 0x43    
   \              0x3A 0x25    
   \              0x58 0x2C    
   \              0x20 0x72    
   \              0x64 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x43 0x52    
   \              0x43 0x3A    
   \              0x25 0x58    
   \              0x20 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x2D 0x2D          DC8 "--> NV mem [%s] errorcode %d item:%d\012"
   \              0x3E 0x20    
   \              0x4E 0x56    
   \              0x20 0x6D    
   \              0x65 0x6D    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x63    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x25 0x64    
   \              0x20 0x69    
   \              0x74 0x65    
   \              0x6D 0x3A    
   \              0x25 0x64    
   \              0x0A 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \   00000000   0x57 0x72          DC8 "Write"
   \              0x69 0x74    
   \              0x65 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \   00000000   0x52 0x65          DC8 "Read"
   \              0x61 0x64    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \   00000000   0x25 0x73          DC8 "%s err\012"
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \   00000000   0x57 0x72          DC8 "Write Complete..\012"
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x43 0x6F    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x74 0x65    
   \              0x2E 0x2E    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
    589          
    590          
    591          
    592          /**********************************************************************************************************
    593          *                                      ExcelParam_LoadSave 
    594          *
    595          * 설명        : Excel 다운로드시 Excel의 데이터를 내부 Flash의 특정 번지에 기록해 넣는다.
    596          * 전달인자    : pdata  - 저장할 데이터 
    597          *               sz     - 저장할 데이터의 크기 
    598          *               rw     - 'SAVE' or 'NO_SAVE'
    599          * 리턴값      : 에러값 
    600          **********************************************************************************************************/
    601          #if 0
    602          int ExcelParam_LoadSave(char *pdata, int dataSz, int rw)
    603          {
    604          #if OS_CRITICAL_METHOD == 3                    
    605          	OS_CPU_SR  cpu_sr;
    606          #endif
    607          
    608          	INT32U i,pageSz;
    609          	INT16U ramCRC,getflashCRC,rdflashCRC;
    610          	INT16U databuf;
    611          		
    612          	// WRITE 동작 
    613          	if(rw == SAVE){
    614          
    615          		printk("\nExcel Parameter Save to IntFlash\n");
    616          		printk("--W--> IntFlashAddr: 0x%08X\n",EXCEL_SAVE_BASE);
    617          		// 내부 Flash 페이지를 얼마나 삭제할지 pageSz를 계산 
    618          		pageSz = nINTBLKSZ(dataSz);
    619          		
    620          		printk("--W--> dataSz: 0x%04X\n",dataSz);
    621          		printk("--W--> pageSz: 0x%04X\n",pageSz);
    622          		
    623          		// 쓰고자 하는 데이터에 대한 CRC를 계산 (Excel에서 내려온 데이터)
    624          		ramCRC = GenerateCRC((char*)pdata, dataSz, 0);
    625          		printk("--W--> ramCRC: 0x%04X\n",ramCRC);
    626          
    627          /*-----------------------------------------------------------------------------------------------------*/	
    628          		OSSchedLock();
    629          		portENTER_CRITICAL();
    630          		
    631          		// 내부 Flash 메모리에 Write하기 위해 Lock을 해제	
    632          		FLASH_Unlock();	
    633          		
    634          		// 내부 Flash 메모리를 삭제
    635          		for(i=0;i<pageSz;i++){
    636          			//printd("Erasing CODE PAGE 0x%08X\n",EXCEL_SAVE_BASE + (i*CODE_MEM_PAGESZ));
    637          			FLASH_ErasePage(EXCEL_SAVE_BASE + (i*CODE_MEM_PAGESZ));
    638          		}
    639          		
    640          		// 내부 Flash 메모리에 2Byte단위로 데이터 Write
    641          		//printd("\nWrite data to IntFlash\n");
    642          		for(i=0;i<dataSz;i+=2){
    643          			
    644          			databuf = (*(pdata+1) << 8) + *pdata;
    645          			FLASH_ProgramHalfWord(EXCEL_SAVE_BASE + i, databuf);
    646          			
    647          			//printd("ADDR: 0x%08X, DATA: %04X %04X\n",EXCEL_SAVE_BASE + i, *pdata, *(pdata+1));
    648          			
    649          			pdata += 2;
    650          		}
    651          		
    652          		// 위에서 계산한 CRC값을 저장 
    653          		FLASH_ProgramHalfWord(EXCEL_SAVE_BASE + (CODE_MEM_PAGESZ * nINTBLKSZ(dataSz) - sizeof(ramCRC)), ramCRC);
    654          		//printd("CRC ADDR: 0x%08X, CRC: 0x%04X\n",EXCEL_SAVE_BASE + (CODE_MEM_PAGESZ * nINTBLKSZ(dataSz) - sizeof(ramCRC)), ramCRC);
    655          
    656          		portEXIT_CRITICAL();
    657          		OSSchedUnlock();
    658          /*-----------------------------------------------------------------------------------------------------*/	
    659          
    660          		// 내부 Flash 메모리에서 데이터를 읽어 옴 
    661          		//printk("\nRead data from IntFlash\n");
    662          		//for(i=0;i<dataSz;i++){
    663          			//printk("%04X ",*(char *)(EXCEL_SAVE_BASE + i));
    664          			//if((i+1)%20==0) printk("\n");
    665          		//}
    666          		//printk("\n");
    667          		// 내부 Flash에 저장된 CRC를 읽어 옴 
    668          		rdflashCRC = *(INT32U *)(EXCEL_SAVE_BASE + (CODE_MEM_PAGESZ * nINTBLKSZ(dataSz) - sizeof(ramCRC)));
    669          		printk("--W--> rdflashCRC: 0x%04X\n",rdflashCRC);
    670          		
    671          		// 내부 Flash에 저장된 데이터에 대한 CRC 계산 
    672          		getflashCRC = GenerateCRC((char *)EXCEL_SAVE_BASE, dataSz, 0);
    673          		printk("--W--> getflashCRC: 0x%04X\n\n",getflashCRC);
    674          
    675          		// ramCRC와 계산된 CRC를 비교   
    676          		if(ramCRC != getflashCRC){
    677          			return -1;
    678          		}
    679          		// ramCRC와 플레쉬에 저장한 CRC를 비교
    680          		if(ramCRC != rdflashCRC){
    681          			return -2;
    682          		}
    683          	}
    684          	// Read 동작 
    685          	else{
    686          		printk("\nExcel Parameter Read from IntFlash\n");
    687          		printk("--R--> IntFlashAddr: 0x%08X\n",EXCEL_SAVE_BASE);
    688          
    689          		// 내부 Flash에 저장된 데이터에 대한 CRC 계산 
    690          		getflashCRC = GenerateCRC((char *)EXCEL_SAVE_BASE, dataSz, 0);
    691          		printk("--R--> getflashCRC: 0x%04X\n",getflashCRC);
    692          
    693          		// 내부 Flash에 저장된 CRC를 읽어 옴 
    694          		rdflashCRC = *(INT32U *)(EXCEL_SAVE_BASE + (CODE_MEM_PAGESZ * nINTBLKSZ(dataSz) - sizeof(ramCRC)));
    695          		printk("--R--> rdflashCRC: 0x%04X\n\n",rdflashCRC);
    696          
    697          		// getflashCRC와 플레쉬에 저장한 CRC를 비교
    698          		if(getflashCRC != rdflashCRC){
    699          			return -2;
    700          		}
    701          		else
    702          			pdata = (char *)EXCEL_SAVE_BASE;
    703          	}
    704          
    705          	return 0;
    706          }
    707          #endif
    708          
    709          
    710          
    711          
    712          
    713          /*
    714          ********************* (C) COPYRIGHT 2011 XNIL ***************END OF FILE*****************************
    715          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   GetFlashAreaCRC
        32   -> GenerateCRC
        32   -> SPI_FLASH_BufferRead
      24   SPI_FLASH_LoadSave
        24   -> SPI_FLASH_BufferRead
        24   -> SPI_FLASH_BufferWrite
        24   -> SPI_FLASH_PageErase
        24   -> nv_ldstr
        24   -> printk
      32   SPI_FLASH_Member_Write
        32   -> SPI_FLASH_BufferRead
        32   -> SPI_FLASH_BufferWrite
        32   -> SPI_FLASH_PageErase
        32   -> __aeabi_memcpy
        32   -> memcmp
         0   -> printk
        32   -> printk
        32   -> xQueueGenericReceive
         0   -> xQueueGenericSend
       0   dbg_inittest_select
       8   dbg_sflash_crc
         8   -> Argument
         8   -> CLI_GetArgCnt
         8   -> GetFlashAreaCRC
         8   -> comparison_num
         8   -> printk
       8   dbg_sflash_dispMap
         8   -> printk
       8   dbg_sflash_flash_chip
         8   -> SPI_FLASH_ChipErase
         8   -> printk
       8   dbg_sflash_flush
         8   -> Argument
         8   -> CLI_GetArgCnt
         8   -> SPI_FLASH_PageErase
         8   -> comparison_num
         8   -> nv_sflash_md
         8   -> printk
       8   dbg_sflash_flush_all
         8   -> SPI_FLASH_BlockErase
         8   -> printk
      16   dbg_sflash_modify
        16   -> Argument
        16   -> CLI_GetArgCnt
        16   -> comparison_num
        16   -> nv_modify
        16   -> nv_sflash_md_1
       8   dbg_sflash_read
         8   -> Argument
         8   -> CLI_GetArgCnt
         8   -> SPI_FLASH_BufferRead
         8   -> comparison_num
         8   -> printd
       8   dbg_sflash_read_id
         8   -> SPI_FLASH_ReadID
         8   -> printk
       8   dbg_sflash_select
         8   -> Argument
         8   -> CLI_GetArgCnt
         8   -> comparison_num
         8   -> printd
       8   dbg_sflash_smd
         8   -> Argument
         8   -> CLI_GetArgCnt
         8   -> comparison_num
         8   -> nv_sflash_md
      16   dbg_sflash_write
        16   -> Argument
        16   -> CLI_GetArgCnt
        16   -> SPI_FLASH_Member_Write
        16   -> comparison_num
      40   nv_ldstr
        40   -> GenerateCRC
        40   -> GetFlashAreaCRC
        40   -> SPI_FLASH_BufferRead
        40   -> SPI_FLASH_Member_Write
        40   -> printk
      16   nv_modify
        16   -> SPI_FLASH_BufferRead
        16   -> SPI_FLASH_Member_Write
        16   -> printk
      48   nv_sflash_md
        48   -> SPI_FLASH_BufferRead
        48   -> printk
      48   nv_sflash_md_1
        48   -> SPI_FLASH_BufferRead
        48   -> printk
       8   nvxSemaphore_init
         8   -> xQueueCreateMutex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
      28  ?_0
       2  ?_1
      20  ?_10
      24  ?_11
       4  ?_12
       8  ?_13
      24  ?_14
      44  ?_15
      40  ?_16
       8  ?_17
       4  ?_18
      44  ?_19
       4  ?_2
      32  ?_20
      32  ?_21
      36  ?_22
      40  ?_23
       8  ?_24
       8  ?_25
       8  ?_26
      20  ?_27
       2  ?_3
      12  ?_4
       8  ?_5
      24  ?_6
      28  ?_7
      40  ?_8
      40  ?_9
     100  GetFlashAreaCRC
     112  SPI_FLASH_LoadSave
     300  SPI_FLASH_Member_Write
       4  dbg_inittest_select
      64  dbg_sflash_crc
      42  dbg_sflash_dispMap
      26  dbg_sflash_flash_chip
      62  dbg_sflash_flush
      50  dbg_sflash_flush_all
      76  dbg_sflash_modify
      50  dbg_sflash_read
      20  dbg_sflash_read_id
      50  dbg_sflash_select
      32  dbg_sflash_smd
      54  dbg_sflash_write
    4096  getCRCBuf
     242  nv_ldstr
      44  nv_modify
     176  nv_sflash_md
     180  nv_sflash_md_1
      16  nvxSemaphore_init
    4096  pDumpBuff
      24  -- Other

 
 8 192 bytes in section .bss
    16 bytes in section .rodata
 2 348 bytes in section .text
 
 2 348 bytes of CODE  memory
    16 bytes of CONST memory
 8 192 bytes of DATA  memory

Errors: none
Warnings: none
