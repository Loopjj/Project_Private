###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       18/Dec/2023  17:37:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\diskio.c
#    Command line =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\diskio.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -lC
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List
#        --diag_suppress Pa050 -o
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Full.h" -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\ -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\cpu\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Drv\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\App\fat\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\bsp\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Dev\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_HOST_Library\Core\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\USB\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\portable\IAR\ARM_CM3\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Util\Third_Party\FreeRTOS_v7.6.0\include\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\OsConfig\usbConf\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\
#        -I
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\..\Libraries\FAT_FS\drivers\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\List\diskio.lst
#    Object file  =  
#        E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Project\Debug\Obj\diskio.o
#
###############################################################################

E:\LOOP\SCRDPF\OBD\freeRTOS_STM32F2xx_Modem_CC_Large\Libraries\FAT_FS\diskio.c
      1          /*-----------------------------------------------------------------------*/
      2          /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2013        */
      3          /*-----------------------------------------------------------------------*/
      4          /* If a working storage control module is available, it should be        */
      5          /* attached to the FatFs via a glue function rather than modifying it.   */
      6          /* This is an example of glue functions to attach various exsisting      */
      7          /* storage control module to the FatFs module with a defined API.        */
      8          /*-----------------------------------------------------------------------*/
      9          #include "includes.h"
     10          #include "diskio.h"		/* FatFs lower layer API */
     11          #include "ff.h"
     12          
     13          /* Not USB in use */
     14          /* Define it in defines.h project file if you want to use USB */
     15          #ifndef FATFS_USE_USB
     16          	#define FATFS_USE_USB				1
     17          #endif
     18          
     19          /* Set in defines.h file if you want it */
     20          #ifndef TM_FATFS_CUSTOM_FATTIME
     21          	#define TM_FATFS_CUSTOM_FATTIME		0
     22          #endif
     23          
     24          /* Defined in defines.h */
     25          /* We are using FATFS with USB */
     26          #if FATFS_USE_USB == 1
     27          	/* If SDIO is not defined, set to 2, to disable SD card */
     28          	/* You can set FATFS_USE_SDIO in defines.h file */
     29          	/* This is for error fixes */
     30          	#ifndef FATFS_USE_SDIO
     31          		#define FATFS_USE_SDIO			1
     32          	#endif
     33          #else
     34          	/* If USB is not used, set default settings back */
     35          	/* By default, SDIO is used */
     36          	#ifndef FATFS_USE_SDIO
     37          		#define FATFS_USE_SDIO			1
     38          	#endif
     39          #endif
     40          
     41          #if FATFS_USE_USB == 1
     42          	#include "fatfs_usb.h"
     43          #endif 	/* FATFS_USE_USB */
     44          
     45          /* Include SD card files if is enabled */
     46          #if FATFS_USE_SDIO == 1
     47          	#include "fatfs_sd_sdio.h"
     48          #elif FATFS_USE_SDIO == 0
     49          	#include "fatfs_spi.h"
     50          #endif
     51          
     52          
     53          /* Definitions of physical drive number for each media */
     54          #define ATA		0
     55          #define USB		1
     56          
     57          /*-----------------------------------------------------------------------*/
     58          /* Inidialize a Drive                                                    */
     59          /*-----------------------------------------------------------------------*/
     60          

   \                                 In section .text, align 2, keep-with-next
     61          DSTATUS disk_initialize (
     62          	BYTE pdrv				/* Physical drive nmuber (0..) */
     63          )
     64          {
   \                     disk_initialize: (+1)
   \   00000000   0x4601             MOV      R1,R0
     65          	DSTATUS status = STA_NOINIT;
   \   00000002   0x2001             MOVS     R0,#+1
     66          	switch (pdrv) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??disk_initialize_0
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD002             BEQ.N    ??disk_initialize_1
   \   0000000C   0x4770             BX       LR
     67          		case ATA:	/* SD CARD */
     68          			#if FATFS_USE_SDIO == 1
     69          				status = TM_FATFS_SD_SDIO_disk_initialize();	/* SDIO communication */
   \                     ??disk_initialize_0: (+1)
   \   0000000E   0x.... 0x....      B.W      TM_FATFS_SD_SDIO_disk_initialize
     70          			#elif FATFS_USE_SDIO == 0
     71          				status = TM_FATFS_SD_disk_initialize();			  /* SPI communication */
     72          			#endif
     73          			break;
     74          		case USB:	/* USB storage */
     75          			#if FATFS_USE_USB == 1
     76          				status = TM_FATFS_USB_disk_initialize();			/* USB */
   \                     ??disk_initialize_1: (+1)
   \   00000012   0x.... 0x....      B.W      TM_FATFS_USB_disk_initialize
     77          			#endif
     78          			break;
     79          		default:
     80          			status = STA_NOINIT;
     81          	}
     82          	
     83          	return status;
     84          }
     85          
     86          
     87          
     88          /*-----------------------------------------------------------------------*/
     89          /* Get Disk Status                                                       */
     90          /*-----------------------------------------------------------------------*/
     91          

   \                                 In section .text, align 2, keep-with-next
     92          DSTATUS disk_status (
     93          	BYTE pdrv		/* Physical drive nmuber (0..) */
     94          )
     95          {
   \                     disk_status: (+1)
   \   00000000   0x4601             MOV      R1,R0
     96          
     97          	DSTATUS status = STA_NOINIT;
   \   00000002   0x2001             MOVS     R0,#+1
     98          	
     99          	switch (pdrv) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??disk_status_0
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD002             BEQ.N    ??disk_status_1
   \   0000000C   0x4770             BX       LR
    100          		case ATA:	/* SD CARD */
    101          			#if FATFS_USE_SDIO == 1
    102          				status = TM_FATFS_SD_SDIO_disk_status();	  /* SDIO communication */
   \                     ??disk_status_0: (+1)
   \   0000000E   0x.... 0x....      B.W      TM_FATFS_SD_SDIO_disk_status
    103          			#elif FATFS_USE_SDIO == 0
    104          				status = TM_FATFS_SD_disk_status();		      /* SPI communication */
    105          			#endif
    106          			break;
    107          		case USB:	/* USB storage */
    108          			#if FATFS_USE_USB == 1
    109          				status = TM_FATFS_USB_disk_status();				/* USB */
   \                     ??disk_status_1: (+1)
   \   00000012   0x.... 0x....      B.W      TM_FATFS_USB_disk_status
    110          			#endif
    111          			break;
    112          		default:
    113          			status = STA_NOINIT;
    114          	}
    115          	
    116          	return status;
    117          }
    118          
    119          
    120          
    121          /*-----------------------------------------------------------------------*/
    122          /* Read Sector(s)                                                        */
    123          /*-----------------------------------------------------------------------*/
    124          

   \                                 In section .text, align 2, keep-with-next
    125          DRESULT disk_read (
    126          	BYTE pdrv,		/* Physical drive nmuber (0..) */
    127          	BYTE *buff,		/* Data buffer to store read data */
    128          	DWORD sector,	/* Sector address (LBA) */
    129          	UINT count		/* Number of sectors to read (1..128) */
    130          )
    131          {
   \                     disk_read: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461A             MOV      R2,R3
    132          	DRESULT status = RES_PARERR;
   \   0000000A   0x2004             MOVS     R0,#+4
    133          	switch (pdrv) {
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD002             BEQ.N    ??disk_read_0
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD004             BEQ.N    ??disk_read_1
   \   00000014   0xE007             B.N      ??disk_read_2
    134          		case ATA:	/* SD CARD */
    135          			#if FATFS_USE_SDIO == 1
    136          				status = TM_FATFS_SD_SDIO_disk_read(buff, sector, count);	/* SDIO communication */
   \                     ??disk_read_0: (+1)
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xBC30             POP      {R4,R5}
   \   0000001A   0x.... 0x....      B.W      TM_FATFS_SD_SDIO_disk_read
    137          			#elif FATFS_USE_SDIO == 0
    138          				//status = TM_FATFS_SD_disk_read(buff, sector, count);		/* SPI communication */
    139          			#endif
    140          			break;
    141          		case USB:	/* USB storage */
    142          			#if FATFS_USE_USB == 1
    143          				status = TM_FATFS_USB_disk_read(buff, sector, count);			/* USB */
   \                     ??disk_read_1: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xBC30             POP      {R4,R5}
   \   00000022   0x.... 0x....      B.W      TM_FATFS_USB_disk_read
    144          			#endif
    145          			break;
    146          		default:
    147          			status = RES_PARERR;
    148          	}
    149          	
    150          	return status;
   \                     ??disk_read_2: (+1)
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
    151          }
    152          
    153          
    154          
    155          /*-----------------------------------------------------------------------*/
    156          /* Write Sector(s)                                                       */
    157          /*-----------------------------------------------------------------------*/
    158          
    159          #if _USE_WRITE

   \                                 In section .text, align 2, keep-with-next
    160          DRESULT disk_write (
    161          	BYTE pdrv,			/* Physical drive nmuber (0..) */
    162          	const BYTE *buff,	/* Data to be written */
    163          	DWORD sector,		/* Sector address (LBA) */
    164          	UINT count			/* Number of sectors to write (1..128) */
    165          )
    166          {
   \                     disk_write: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461A             MOV      R2,R3
    167          	DRESULT status = RES_PARERR;
   \   0000000A   0x2004             MOVS     R0,#+4
    168          	if (!count) {
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD00C             BEQ.N    ??disk_write_0
    169          		return RES_PARERR;		/* Check parameter */
    170          	}
    171          	
    172          	switch (pdrv) {
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD002             BEQ.N    ??disk_write_1
   \   00000014   0x2D01             CMP      R5,#+1
   \   00000016   0xD004             BEQ.N    ??disk_write_2
   \   00000018   0xE007             B.N      ??disk_write_0
    173          		case ATA:	/* SD CARD */
    174          			#if FATFS_USE_SDIO == 1
    175          				status = TM_FATFS_SD_SDIO_disk_write((BYTE *)buff, sector, count);	/* SDIO communication */
   \                     ??disk_write_1: (+1)
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xBC30             POP      {R4,R5}
   \   0000001E   0x.... 0x....      B.W      TM_FATFS_SD_SDIO_disk_write
    176          			#elif FATFS_USE_SDIO == 0
    177          				//status = TM_FATFS_SD_disk_write(buff, sector, count);				/* SPI communication */
    178          			#endif
    179          			break;
    180          		case USB:	/* USB storage */
    181          			#if FATFS_USE_USB == 1
    182          				status = TM_FATFS_USB_disk_write(buff, sector, count);					/* USB */
   \                     ??disk_write_2: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x.... 0x....      B.W      TM_FATFS_USB_disk_write
    183          			#endif
    184          			break;
    185          		default:
    186          			status = RES_PARERR;
    187          	}
    188          	
    189          	return status;
   \                     ??disk_write_0: (+1)
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
    190          }
    191          #endif
    192          
    193          
    194          /*-----------------------------------------------------------------------*/
    195          /* Miscellaneous Functions                                               */
    196          /*-----------------------------------------------------------------------*/
    197          
    198          #if _USE_IOCTL

   \                                 In section .text, align 2, keep-with-next
    199          DRESULT disk_ioctl (
    200          	BYTE pdrv,		/* Physical drive nmuber (0..) */
    201          	BYTE cmd,		/* Control code */
    202          	void *buff		/* Buffer to send/receive control data */
    203          )
    204          {
   \                     disk_ioctl: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x4611             MOV      R1,R2
    205          	DRESULT status = RES_PARERR;
   \   00000008   0x2004             MOVS     R0,#+4
    206          	switch (pdrv) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD002             BEQ.N    ??disk_ioctl_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??disk_ioctl_1
   \   00000012   0xE007             B.N      ??disk_ioctl_2
    207          		case ATA:	/* SD CARD */
    208          			#if FATFS_USE_SDIO == 1
    209          				status = TM_FATFS_SD_SDIO_disk_ioctl(cmd, buff);					/* SDIO communication */
   \                     ??disk_ioctl_0: (+1)
   \   00000014   0x4618             MOV      R0,R3
   \   00000016   0xBC14             POP      {R2,R4}
   \   00000018   0x.... 0x....      B.W      TM_FATFS_SD_SDIO_disk_ioctl
    210          			#elif FATFS_USE_SDIO == 0
    211          				//status = TM_FATFS_SD_disk_ioctl(cmd, buff);							/* SPI communication */
    212          			#endif
    213          			break;
    214          		case USB:	/* USB storage */
    215          			#if FATFS_USE_USB == 1
    216          				status = TM_FATFS_USB_disk_ioctl(cmd, buff);						/* USB */
   \                     ??disk_ioctl_1: (+1)
   \   0000001C   0x4618             MOV      R0,R3
   \   0000001E   0xBC14             POP      {R2,R4}
   \   00000020   0x.... 0x....      B.W      TM_FATFS_USB_disk_ioctl
    217          			#endif
    218          			break;
    219          		default:
    220          			status = RES_PARERR;
    221          	}
    222          	return status;
   \                     ??disk_ioctl_2: (+1)
   \   00000024   0xBC12             POP      {R1,R4}
   \   00000026   0x4770             BX       LR               ;; return
    223          }
    224          #endif
    225          
    226          /*-----------------------------------------------------------------------*/
    227          /* User Provided Timer Function for FatFs module                         */
    228          /*-----------------------------------------------------------------------*/
    229          /* This is a real time clock service to be called from                   */
    230          /* FatFs module. Any valid time must be returned even if                 */
    231          /* the system does not support a real time clock.                        */
    232          /* This is not required in read-only configuration.                      */
    233          

   \                                 In section .text, align 2, keep-with-next
    234          __weak DWORD get_fattime(void) {
    235            sysinfo_t *s = &_sysinfo 	;
    236            
    237          	/* Returns current time packed into a DWORD variable */
    238          	return 	((DWORD)(s->tm_ptr.tm_year-1900) << 25)
    239          				| ((DWORD)s->tm_ptr.tm_mon << 21)
    240          				| ((DWORD)s->tm_ptr.tm_mday << 16)
    241          				| ((DWORD)s->tm_ptr.tm_hour << 11)
    242          				| ((DWORD)s->tm_ptr.tm_min << 5)
    243          				| ((DWORD)s->tm_ptr.tm_sec >> 1);
   \                     get_fattime: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable0
   \   00000002   0x6B01             LDR      R1,[R0, #+48]
   \   00000004   0xF2A1 0x716C      SUBW     R1,R1,#+1900
   \   00000008   0x6AC2             LDR      R2,[R0, #+44]
   \   0000000A   0x0552             LSLS     R2,R2,#+21
   \   0000000C   0xEA42 0x6141      ORR      R1,R2,R1, LSL #+25
   \   00000010   0x6A82             LDR      R2,[R0, #+40]
   \   00000012   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000016   0x6A42             LDR      R2,[R0, #+36]
   \   00000018   0xEA41 0x21C2      ORR      R1,R1,R2, LSL #+11
   \   0000001C   0x6A02             LDR      R2,[R0, #+32]
   \   0000001E   0xEA41 0x1142      ORR      R1,R1,R2, LSL #+5
   \   00000022   0x69C0             LDR      R0,[R0, #+28]
   \   00000024   0xEA41 0x0050      ORR      R0,R1,R0, LSR #+1
   \   00000028   0x4770             BX       LR               ;; return
    244          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     _sysinfo
    245          
    246          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   disk_initialize
         0   -> TM_FATFS_SD_SDIO_disk_initialize
         0   -> TM_FATFS_USB_disk_initialize
       8   disk_ioctl
         0   -> TM_FATFS_SD_SDIO_disk_ioctl
         0   -> TM_FATFS_USB_disk_ioctl
       8   disk_read
         0   -> TM_FATFS_SD_SDIO_disk_read
         0   -> TM_FATFS_USB_disk_read
       0   disk_status
         0   -> TM_FATFS_SD_SDIO_disk_status
         0   -> TM_FATFS_USB_disk_status
       8   disk_write
         0   -> TM_FATFS_SD_SDIO_disk_write
         0   -> TM_FATFS_USB_disk_write
       0   get_fattime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      22  disk_initialize
      40  disk_ioctl
      42  disk_read
      22  disk_status
      46  disk_write
      42  get_fattime

 
 218 bytes in section .text
 
 218 bytes of CODE memory

Errors: none
Warnings: none
